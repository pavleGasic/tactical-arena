shadow$provide.module$node_modules$pixi_DOT_js$lib$scene$graphics$shared$utils$buildContextBatches = function(global, require, module, exports) {
  function addShapePathToGeometryData(shapePath, style, isStroke, batches, geometryData) {
    const {vertices, uvs, indices} = geometryData;
    shapePath.shapePrimitives.forEach(({shape, transform:matrix, holes}) => {
      const indexOffset = indices.length, vertOffset = vertices.length / 2;
      var points = [];
      const build = shapeBuilders[shape.type];
      let topology = "triangle-list";
      build.build(shape, points);
      matrix && transformVertices.transformVertices(points, matrix);
      if (isStroke) {
        holes = shape.closePath ?? !0, style.pixelLine ? (buildPixelLine.buildPixelLine(points, holes, vertices, indices), topology = "line-list") : buildLine.buildLine(points, style, !1, holes, vertices, indices);
      } else {
        if (holes) {
          const holeIndices = [], otherPoints = points.slice();
          getHoleArrays(holes).forEach(holePoints => {
            holeIndices.push(otherPoints.length / 2);
            otherPoints.push(...holePoints);
          });
          triangulateWithHoles.triangulateWithHoles(otherPoints, holeIndices, vertices, 2, vertOffset, indices, indexOffset);
        } else {
          build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);
        }
      }
      holes = uvs.length / 2;
      points = style.texture;
      points !== Texture.Texture.WHITE ? (shape = generateTextureFillMatrix.generateTextureMatrix(tempTextureMatrix, style, shape, matrix), buildUvs.buildUvs(vertices, 2, vertOffset, uvs, holes, 2, vertices.length / 2 - vertOffset, shape)) : buildUvs.buildSimpleUvs(uvs, holes, 2, vertices.length / 2 - vertOffset);
      shape = PoolGroup.BigPool.get(BatchableGraphics.BatchableGraphics);
      shape.indexOffset = indexOffset;
      shape.indexSize = indices.length - indexOffset;
      shape.attributeOffset = vertOffset;
      shape.attributeSize = vertices.length / 2 - vertOffset;
      shape.baseColor = style.color;
      shape.alpha = style.alpha;
      shape.texture = points;
      shape.geometryData = geometryData;
      shape.topology = topology;
      batches.push(shape);
    });
  }
  function getHoleArrays(holePrimitives) {
    const holeArrays = [];
    for (let k = 0; k < holePrimitives.length; k++) {
      const holePrimitive = holePrimitives[k].shape, holePoints = [];
      shapeBuilders[holePrimitive.type].build(holePrimitive, holePoints);
      holeArrays.push(holePoints);
    }
    return holeArrays;
  }
  global = require("module$node_modules$pixi_DOT_js$lib$extensions$Extensions");
  module = require("module$node_modules$pixi_DOT_js$lib$maths$matrix$Matrix");
  var Rectangle = require("module$node_modules$pixi_DOT_js$lib$maths$shapes$Rectangle"), buildUvs = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$geometry$utils$buildUvs"), transformVertices = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$geometry$utils$transformVertices"), Texture = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$texture$Texture"), PoolGroup = require("module$node_modules$pixi_DOT_js$lib$utils$pool$PoolGroup"), 
  BatchableGraphics = require("module$node_modules$pixi_DOT_js$lib$scene$graphics$shared$BatchableGraphics"), buildCircle = require("module$node_modules$pixi_DOT_js$lib$scene$graphics$shared$buildCommands$buildCircle"), buildLine = require("module$node_modules$pixi_DOT_js$lib$scene$graphics$shared$buildCommands$buildLine"), buildPixelLine = require("module$node_modules$pixi_DOT_js$lib$scene$graphics$shared$buildCommands$buildPixelLine"), buildPolygon = require("module$node_modules$pixi_DOT_js$lib$scene$graphics$shared$buildCommands$buildPolygon"), 
  buildRectangle = require("module$node_modules$pixi_DOT_js$lib$scene$graphics$shared$buildCommands$buildRectangle"), buildTriangle = require("module$node_modules$pixi_DOT_js$lib$scene$graphics$shared$buildCommands$buildTriangle"), generateTextureFillMatrix = require("module$node_modules$pixi_DOT_js$lib$scene$graphics$shared$utils$generateTextureFillMatrix"), triangulateWithHoles = require("module$node_modules$pixi_DOT_js$lib$scene$graphics$shared$utils$triangulateWithHoles");
  "use strict";
  const shapeBuilders = {};
  global.extensions.handleByMap(global.ExtensionType.ShapeBuilder, shapeBuilders);
  global.extensions.add(buildRectangle.buildRectangle, buildPolygon.buildPolygon, buildTriangle.buildTriangle, buildCircle.buildCircle, buildCircle.buildEllipse, buildCircle.buildRoundedRectangle);
  const tempRect = new Rectangle.Rectangle(), tempTextureMatrix = new module.Matrix();
  exports.buildContextBatches = function(context, gpuContext) {
    const {geometryData, batches} = gpuContext;
    batches.length = 0;
    geometryData.indices.length = 0;
    geometryData.vertices.length = 0;
    geometryData.uvs.length = 0;
    for (gpuContext = 0; gpuContext < context.instructions.length; gpuContext++) {
      var instruction = context.instructions[gpuContext];
      if ("texture" === instruction.action) {
        var data = instruction.data;
        const {vertices, uvs, indices} = geometryData;
        var indexOffset = indices.length, vertOffset = vertices.length / 2, points = [];
        const build = shapeBuilders.rectangle, rect = tempRect;
        instruction = data.image;
        rect.x = data.dx;
        rect.y = data.dy;
        rect.width = data.dw;
        rect.height = data.dh;
        const matrix = data.transform;
        build.build(rect, points);
        matrix && transformVertices.transformVertices(points, matrix);
        build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);
        points = instruction.uvs;
        uvs.push(points.x0, points.y0, points.x1, points.y1, points.x3, points.y3, points.x2, points.y2);
        points = PoolGroup.BigPool.get(BatchableGraphics.BatchableGraphics);
        points.indexOffset = indexOffset;
        points.indexSize = indices.length - indexOffset;
        points.attributeOffset = vertOffset;
        points.attributeSize = vertices.length / 2 - vertOffset;
        points.baseColor = data.style;
        points.alpha = data.alpha;
        points.texture = instruction;
        points.geometryData = geometryData;
        batches.push(points);
      } else if ("fill" === instruction.action || "stroke" === instruction.action) {
        data = "stroke" === instruction.action, indexOffset = instruction.data.path.shapePath, vertOffset = instruction.data.style, instruction = instruction.data.hole, data && instruction && addShapePathToGeometryData(instruction.shapePath, vertOffset, !0, batches, geometryData), instruction && (indexOffset.shapePrimitives[indexOffset.shapePrimitives.length - 1].holes = instruction.shapePath.shapePrimitives), addShapePathToGeometryData(indexOffset, vertOffset, data, batches, geometryData);
      }
    }
  };
  exports.shapeBuilders = shapeBuilders;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$scene$graphics$shared$utils$buildContextBatches.js.map
