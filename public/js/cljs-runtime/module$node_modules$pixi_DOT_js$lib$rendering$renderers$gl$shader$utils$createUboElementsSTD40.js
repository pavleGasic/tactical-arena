shadow$provide.module$node_modules$pixi_DOT_js$lib$rendering$renderers$gl$shader$utils$createUboElementsSTD40 = function(global, require, module, exports) {
  const WGSL_TO_STD40_SIZE = {f32:4, i32:4, "vec2\x3cf32\x3e":8, "vec3\x3cf32\x3e":12, "vec4\x3cf32\x3e":16, "vec2\x3ci32\x3e":8, "vec3\x3ci32\x3e":12, "vec4\x3ci32\x3e":16, "mat2x2\x3cf32\x3e":32, "mat3x3\x3cf32\x3e":48, "mat4x4\x3cf32\x3e":64};
  exports.WGSL_TO_STD40_SIZE = WGSL_TO_STD40_SIZE;
  exports.createUboElementsSTD40 = function(uniformData) {
    uniformData = uniformData.map(data => ({data, offset:0, size:0}));
    let size = 0, offset = 0;
    for (let i = 0; i < uniformData.length; i++) {
      const uboElement = uniformData[i];
      size = WGSL_TO_STD40_SIZE[uboElement.data.type];
      if (!size) {
        throw Error(`Unknown type ${uboElement.data.type}`);
      }
      1 < uboElement.data.size && (size = Math.max(size, 16) * uboElement.data.size);
      const boundary = 12 === size ? 16 : size;
      uboElement.size = size;
      const curOffset = offset % 16;
      offset = 0 < curOffset && 16 - curOffset < boundary ? offset + (16 - curOffset) % 16 : offset + (size - curOffset % size) % size;
      uboElement.offset = offset;
      offset += size;
    }
    offset = 16 * Math.ceil(offset / 16);
    return {uboElements:uniformData, size:offset};
  };
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$rendering$renderers$gl$shader$utils$createUboElementsSTD40.js.map
