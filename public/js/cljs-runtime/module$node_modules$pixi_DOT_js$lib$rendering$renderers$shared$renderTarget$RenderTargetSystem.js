shadow$provide.module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$renderTarget$RenderTargetSystem = function(global, require, module, exports) {
  var Matrix = require("module$node_modules$pixi_DOT_js$lib$maths$matrix$Matrix"), Rectangle = require("module$node_modules$pixi_DOT_js$lib$maths$shapes$Rectangle"), _const = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$gl$const"), calculateProjection = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$gpu$renderTarget$calculateProjection"), SystemRunner = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$system$SystemRunner"), CanvasSource = 
  require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$texture$sources$CanvasSource"), TextureSource = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$texture$sources$TextureSource"), Texture = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$texture$Texture"), getCanvasTexture = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$texture$utils$getCanvasTexture"), isRenderingToScreen = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$renderTarget$isRenderingToScreen"), 
  RenderTarget = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$renderTarget$RenderTarget");
  "use strict";
  class RenderTargetSystem {
    constructor(renderer) {
      this.rootViewPort = new Rectangle.Rectangle();
      this.viewport = new Rectangle.Rectangle();
      this.onRenderTargetChange = new SystemRunner.SystemRunner("onRenderTargetChange");
      this.projectionMatrix = new Matrix.Matrix();
      this.defaultClearColor = [0, 0, 0, 0];
      this._renderSurfaceToRenderTargetHash = new Map();
      this._gpuRenderTargetHash = Object.create(null);
      this._renderTargetStack = [];
      this._renderer = renderer;
      renderer.renderableGC.addManagedHash(this, "_gpuRenderTargetHash");
    }
    finishRenderPass() {
      this.adaptor.finishRenderPass(this.renderTarget);
    }
    renderStart({target, clear, clearColor, frame}) {
      this._renderTargetStack.length = 0;
      this.push(target, clear, clearColor, frame);
      this.rootViewPort.copyFrom(this.viewport);
      this.rootRenderTarget = this.renderTarget;
      this.renderingToScreen = isRenderingToScreen.isRenderingToScreen(this.rootRenderTarget);
      this.adaptor.prerender?.(this.rootRenderTarget);
    }
    postrender() {
      this.adaptor.postrender?.(this.rootRenderTarget);
    }
    bind(renderSurface, clear = !0, clearColor, frame) {
      const renderTarget = this.getRenderTarget(renderSurface), didChange = this.renderTarget !== renderTarget;
      this.renderTarget = renderTarget;
      this.renderSurface = renderSurface;
      var gpuRenderTarget = this.getGpuRenderTarget(renderTarget);
      if (renderTarget.pixelWidth !== gpuRenderTarget.width || renderTarget.pixelHeight !== gpuRenderTarget.height) {
        this.adaptor.resizeGpuRenderTarget(renderTarget), gpuRenderTarget.width = renderTarget.pixelWidth, gpuRenderTarget.height = renderTarget.pixelHeight;
      }
      gpuRenderTarget = renderTarget.colorTexture;
      const viewport = this.viewport, pixelWidth = gpuRenderTarget.pixelWidth, pixelHeight = gpuRenderTarget.pixelHeight;
      !frame && renderSurface instanceof Texture.Texture && (frame = renderSurface.frame);
      frame ? (renderSurface = gpuRenderTarget._resolution, viewport.x = frame.x * renderSurface + 0.5 | 0, viewport.y = frame.y * renderSurface + 0.5 | 0, viewport.width = frame.width * renderSurface + 0.5 | 0, viewport.height = frame.height * renderSurface + 0.5 | 0) : (viewport.x = 0, viewport.y = 0, viewport.width = pixelWidth, viewport.height = pixelHeight);
      calculateProjection.calculateProjection(this.projectionMatrix, 0, 0, viewport.width / gpuRenderTarget.resolution, viewport.height / gpuRenderTarget.resolution, !renderTarget.isRoot);
      this.adaptor.startRenderPass(renderTarget, clear, clearColor, viewport);
      didChange && this.onRenderTargetChange.emit(renderTarget);
      return renderTarget;
    }
    clear(target, clear = _const.CLEAR.ALL, clearColor) {
      clear && (target && (target = this.getRenderTarget(target)), this.adaptor.clear(target || this.renderTarget, clear, clearColor, this.viewport));
    }
    contextChange() {
      this._gpuRenderTargetHash = Object.create(null);
    }
    push(renderSurface, clear = _const.CLEAR.ALL, clearColor, frame) {
      renderSurface = this.bind(renderSurface, clear, clearColor, frame);
      this._renderTargetStack.push({renderTarget:renderSurface, frame});
      return renderSurface;
    }
    pop() {
      this._renderTargetStack.pop();
      const currentRenderTargetData = this._renderTargetStack[this._renderTargetStack.length - 1];
      this.bind(currentRenderTargetData.renderTarget, !1, null, currentRenderTargetData.frame);
    }
    getRenderTarget(renderSurface) {
      renderSurface.isTexture && (renderSurface = renderSurface.source);
      return this._renderSurfaceToRenderTargetHash.get(renderSurface) ?? this._initRenderTarget(renderSurface);
    }
    copyToTexture(sourceRenderSurfaceTexture, destinationTexture, originSrc, size, originDest) {
      0 > originSrc.x && (size.width += originSrc.x, originDest.x -= originSrc.x, originSrc.x = 0);
      0 > originSrc.y && (size.height += originSrc.y, originDest.y -= originSrc.y, originSrc.y = 0);
      const {pixelWidth, pixelHeight} = sourceRenderSurfaceTexture;
      size.width = Math.min(size.width, pixelWidth - originSrc.x);
      size.height = Math.min(size.height, pixelHeight - originSrc.y);
      return this.adaptor.copyToTexture(sourceRenderSurfaceTexture, destinationTexture, originSrc, size, originDest);
    }
    ensureDepthStencil() {
      this.renderTarget.stencil || (this.renderTarget.stencil = !0, this.adaptor.startRenderPass(this.renderTarget, !1, null, this.viewport));
    }
    destroy() {
      this._renderer = null;
      this._renderSurfaceToRenderTargetHash.forEach((renderTarget, key) => {
        renderTarget !== key && renderTarget.destroy();
      });
      this._renderSurfaceToRenderTargetHash.clear();
      this._gpuRenderTargetHash = Object.create(null);
    }
    _initRenderTarget(renderSurface) {
      let renderTarget = null;
      CanvasSource.CanvasSource.test(renderSurface) && (renderSurface = getCanvasTexture.getCanvasTexture(renderSurface).source);
      renderSurface instanceof RenderTarget.RenderTarget ? renderTarget = renderSurface : renderSurface instanceof TextureSource.TextureSource && (renderTarget = new RenderTarget.RenderTarget({colorTextures:[renderSurface]}), CanvasSource.CanvasSource.test(renderSurface.source.resource) && (renderTarget.isRoot = !0), renderSurface.once("destroy", () => {
        renderTarget.destroy();
        this._renderSurfaceToRenderTargetHash.delete(renderSurface);
        const gpuRenderTarget = this._gpuRenderTargetHash[renderTarget.uid];
        gpuRenderTarget && (this._gpuRenderTargetHash[renderTarget.uid] = null, this.adaptor.destroyGpuRenderTarget(gpuRenderTarget));
      }));
      this._renderSurfaceToRenderTargetHash.set(renderSurface, renderTarget);
      return renderTarget;
    }
    getGpuRenderTarget(renderTarget) {
      return this._gpuRenderTargetHash[renderTarget.uid] || (this._gpuRenderTargetHash[renderTarget.uid] = this.adaptor.initGpuRenderTarget(renderTarget));
    }
    resetState() {
      this.renderSurface = this.renderTarget = null;
    }
  }
  exports.RenderTargetSystem = RenderTargetSystem;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$renderTarget$RenderTargetSystem.js.map
