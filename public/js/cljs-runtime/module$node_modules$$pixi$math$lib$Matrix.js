shadow$provide.module$node_modules$$pixi$math$lib$Matrix = function(global, require, module, exports) {
  var _const = require("module$node_modules$$pixi$math$lib$const"), Point = require("module$node_modules$$pixi$math$lib$Point");
  class Matrix {
    constructor(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0) {
      this.array = null;
      this.a = a;
      this.b = b;
      this.c = c;
      this.d = d;
      this.tx = tx;
      this.ty = ty;
    }
    fromArray(array) {
      this.a = array[0];
      this.b = array[1];
      this.c = array[3];
      this.d = array[4];
      this.tx = array[2];
      this.ty = array[5];
    }
    set(a, b, c, d, tx, ty) {
      return this.a = a, this.b = b, this.c = c, this.d = d, this.tx = tx, this.ty = ty, this;
    }
    toArray(transpose, out) {
      this.array || (this.array = new Float32Array(9));
      out = out || this.array;
      return transpose ? (out[0] = this.a, out[1] = this.b, out[2] = 0, out[3] = this.c, out[4] = this.d, out[5] = 0, out[6] = this.tx, out[7] = this.ty, out[8] = 1) : (out[0] = this.a, out[1] = this.c, out[2] = this.tx, out[3] = this.b, out[4] = this.d, out[5] = this.ty, out[6] = 0, out[7] = 0, out[8] = 1), out;
    }
    apply(pos, newPos) {
      newPos = newPos || new Point.Point();
      const x = pos.x;
      pos = pos.y;
      return newPos.x = this.a * x + this.c * pos + this.tx, newPos.y = this.b * x + this.d * pos + this.ty, newPos;
    }
    applyInverse(pos, newPos) {
      newPos = newPos || new Point.Point();
      const id = 1 / (this.a * this.d + this.c * -this.b), x = pos.x;
      pos = pos.y;
      return newPos.x = this.d * id * x + -this.c * id * pos + (this.ty * this.c - this.tx * this.d) * id, newPos.y = this.a * id * pos + -this.b * id * x + (-this.ty * this.a + this.tx * this.b) * id, newPos;
    }
    translate(x, y) {
      return this.tx += x, this.ty += y, this;
    }
    scale(x, y) {
      return this.a *= x, this.d *= y, this.c *= x, this.b *= y, this.tx *= x, this.ty *= y, this;
    }
    rotate(angle) {
      const cos = Math.cos(angle);
      angle = Math.sin(angle);
      const a1 = this.a, c1 = this.c, tx1 = this.tx;
      return this.a = a1 * cos - this.b * angle, this.b = a1 * angle + this.b * cos, this.c = c1 * cos - this.d * angle, this.d = c1 * angle + this.d * cos, this.tx = tx1 * cos - this.ty * angle, this.ty = tx1 * angle + this.ty * cos, this;
    }
    append(matrix) {
      const a1 = this.a, b1 = this.b, c1 = this.c, d1 = this.d;
      return this.a = matrix.a * a1 + matrix.b * c1, this.b = matrix.a * b1 + matrix.b * d1, this.c = matrix.c * a1 + matrix.d * c1, this.d = matrix.c * b1 + matrix.d * d1, this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx, this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty, this;
    }
    setTransform(x, y, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY) {
      return this.a = Math.cos(rotation + skewY) * scaleX, this.b = Math.sin(rotation + skewY) * scaleX, this.c = -Math.sin(rotation - skewX) * scaleY, this.d = Math.cos(rotation - skewX) * scaleY, this.tx = x - (pivotX * this.a + pivotY * this.c), this.ty = y - (pivotX * this.b + pivotY * this.d), this;
    }
    prepend(matrix) {
      const tx1 = this.tx;
      if (1 !== matrix.a || 0 !== matrix.b || 0 !== matrix.c || 1 !== matrix.d) {
        const a1 = this.a, c1 = this.c;
        this.a = a1 * matrix.a + this.b * matrix.c;
        this.b = a1 * matrix.b + this.b * matrix.d;
        this.c = c1 * matrix.a + this.d * matrix.c;
        this.d = c1 * matrix.b + this.d * matrix.d;
      }
      return this.tx = tx1 * matrix.a + this.ty * matrix.c + matrix.tx, this.ty = tx1 * matrix.b + this.ty * matrix.d + matrix.ty, this;
    }
    decompose(transform) {
      const a = this.a, b = this.b, c = this.c, d = this.d, pivot = transform.pivot, skewX = -Math.atan2(-c, d), skewY = Math.atan2(b, a), delta = Math.abs(skewX + skewY);
      return 1e-5 > delta || 1e-5 > Math.abs(_const.PI_2 - delta) ? (transform.rotation = skewY, transform.skew.x = transform.skew.y = 0) : (transform.rotation = 0, transform.skew.x = skewX, transform.skew.y = skewY), transform.scale.x = Math.sqrt(a * a + b * b), transform.scale.y = Math.sqrt(c * c + d * d), transform.position.x = this.tx + (pivot.x * a + pivot.y * c), transform.position.y = this.ty + (pivot.x * b + pivot.y * d), transform;
    }
    invert() {
      const a1 = this.a, b1 = this.b, c1 = this.c, d1 = this.d, tx1 = this.tx, n = a1 * d1 - b1 * c1;
      return this.a = d1 / n, this.b = -b1 / n, this.c = -c1 / n, this.d = a1 / n, this.tx = (c1 * this.ty - d1 * tx1) / n, this.ty = -(a1 * this.ty - b1 * tx1) / n, this;
    }
    identity() {
      return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.tx = 0, this.ty = 0, this;
    }
    clone() {
      const matrix = new Matrix();
      return matrix.a = this.a, matrix.b = this.b, matrix.c = this.c, matrix.d = this.d, matrix.tx = this.tx, matrix.ty = this.ty, matrix;
    }
    copyTo(matrix) {
      return matrix.a = this.a, matrix.b = this.b, matrix.c = this.c, matrix.d = this.d, matrix.tx = this.tx, matrix.ty = this.ty, matrix;
    }
    copyFrom(matrix) {
      return this.a = matrix.a, this.b = matrix.b, this.c = matrix.c, this.d = matrix.d, this.tx = matrix.tx, this.ty = matrix.ty, this;
    }
    static get IDENTITY() {
      return new Matrix();
    }
    static get TEMP_MATRIX() {
      return new Matrix();
    }
  }
  Matrix.prototype.toString = function() {
    return `[@pixi/math:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;
  };
  exports.Matrix = Matrix;
};

//# sourceMappingURL=module$node_modules$$pixi$math$lib$Matrix.js.map
