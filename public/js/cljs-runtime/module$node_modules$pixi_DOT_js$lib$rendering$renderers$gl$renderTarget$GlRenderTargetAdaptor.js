shadow$provide.module$node_modules$pixi_DOT_js$lib$rendering$renderers$gl$renderTarget$GlRenderTargetAdaptor = function(global, require, module, exports) {
  var Rectangle = require("module$node_modules$pixi_DOT_js$lib$maths$shapes$Rectangle"), warn = require("module$node_modules$pixi_DOT_js$lib$utils$logging$warn"), CanvasSource = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$texture$sources$CanvasSource"), _const = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$gl$const"), GlRenderTarget = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$gl$GlRenderTarget");
  "use strict";
  class GlRenderTargetAdaptor {
    constructor() {
      this._clearColorCache = [0, 0, 0, 0];
      this._viewPortCache = new Rectangle.Rectangle();
    }
    init(renderer, renderTargetSystem) {
      this._renderer = renderer;
      this._renderTargetSystem = renderTargetSystem;
      renderer.runners.contextChange.add(this);
    }
    contextChange() {
      this._clearColorCache = [0, 0, 0, 0];
      this._viewPortCache = new Rectangle.Rectangle();
    }
    copyToTexture(sourceRenderSurfaceTexture, destinationTexture, originSrc, size, originDest) {
      const renderer = this._renderer, glRenderTarget = this._renderTargetSystem.getGpuRenderTarget(sourceRenderSurfaceTexture), gl = renderer.gl;
      this.finishRenderPass(sourceRenderSurfaceTexture);
      gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.resolveTargetFramebuffer);
      renderer.texture.bind(destinationTexture, 0);
      gl.copyTexSubImage2D(gl.TEXTURE_2D, 0, originDest.x, originDest.y, originSrc.x, originSrc.y, size.width, size.height);
      return destinationTexture;
    }
    startRenderPass(renderTarget, clear = !0, clearColor, viewport) {
      var source = renderTarget.colorTexture;
      const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);
      let viewPortY = viewport.y;
      renderTarget.isRoot && (viewPortY = source.pixelHeight - viewport.height);
      renderTarget.colorTextures.forEach(texture => {
        this._renderer.texture.unbind(texture);
      });
      source = this._renderer.gl;
      source.bindFramebuffer(source.FRAMEBUFFER, gpuRenderTarget.framebuffer);
      const viewPortCache = this._viewPortCache;
      if (viewPortCache.x !== viewport.x || viewPortCache.y !== viewPortY || viewPortCache.width !== viewport.width || viewPortCache.height !== viewport.height) {
        viewPortCache.x = viewport.x, viewPortCache.y = viewPortY, viewPortCache.width = viewport.width, viewPortCache.height = viewport.height, source.viewport(viewport.x, viewPortY, viewport.width, viewport.height);
      }
      gpuRenderTarget.depthStencilRenderBuffer || !renderTarget.stencil && !renderTarget.depth || this._initStencil(gpuRenderTarget);
      this.clear(renderTarget, clear, clearColor);
    }
    finishRenderPass(renderTarget) {
      renderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);
      if (renderTarget.msaa) {
        var gl = this._renderer.gl;
        gl.bindFramebuffer(gl.FRAMEBUFFER, renderTarget.resolveTargetFramebuffer);
        gl.bindFramebuffer(gl.READ_FRAMEBUFFER, renderTarget.framebuffer);
        gl.blitFramebuffer(0, 0, renderTarget.width, renderTarget.height, 0, 0, renderTarget.width, renderTarget.height, gl.COLOR_BUFFER_BIT, gl.NEAREST);
        gl.bindFramebuffer(gl.FRAMEBUFFER, renderTarget.framebuffer);
      }
    }
    initGpuRenderTarget(renderTarget) {
      const gl = this._renderer.gl, glRenderTarget = new GlRenderTarget.GlRenderTarget();
      if (CanvasSource.CanvasSource.test(renderTarget.colorTexture.resource)) {
        return this._renderer.context.ensureCanvasSize(renderTarget.colorTexture.resource), glRenderTarget.framebuffer = null, glRenderTarget;
      }
      this._initColor(renderTarget, glRenderTarget);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      return glRenderTarget;
    }
    destroyGpuRenderTarget(gpuRenderTarget) {
      const gl = this._renderer.gl;
      gpuRenderTarget.framebuffer && (gl.deleteFramebuffer(gpuRenderTarget.framebuffer), gpuRenderTarget.framebuffer = null);
      gpuRenderTarget.resolveTargetFramebuffer && (gl.deleteFramebuffer(gpuRenderTarget.resolveTargetFramebuffer), gpuRenderTarget.resolveTargetFramebuffer = null);
      gpuRenderTarget.depthStencilRenderBuffer && (gl.deleteRenderbuffer(gpuRenderTarget.depthStencilRenderBuffer), gpuRenderTarget.depthStencilRenderBuffer = null);
      gpuRenderTarget.msaaRenderBuffer.forEach(renderBuffer => {
        gl.deleteRenderbuffer(renderBuffer);
      });
      gpuRenderTarget.msaaRenderBuffer = null;
    }
    clear(_renderTarget, clear, clearColor) {
      if (clear) {
        var renderTargetSystem = this._renderTargetSystem;
        "boolean" === typeof clear && (clear = clear ? _const.CLEAR.ALL : _const.CLEAR.NONE);
        _renderTarget = this._renderer.gl;
        clear & _const.CLEAR.COLOR && (clearColor ?? (clearColor = renderTargetSystem.defaultClearColor), renderTargetSystem = this._clearColorCache, renderTargetSystem[0] !== clearColor[0] || renderTargetSystem[1] !== clearColor[1] || renderTargetSystem[2] !== clearColor[2] || renderTargetSystem[3] !== clearColor[3]) && (renderTargetSystem[0] = clearColor[0], renderTargetSystem[1] = clearColor[1], renderTargetSystem[2] = clearColor[2], renderTargetSystem[3] = clearColor[3], _renderTarget.clearColor(clearColor[0], 
        clearColor[1], clearColor[2], clearColor[3]));
        _renderTarget.clear(clear);
      }
    }
    resizeGpuRenderTarget(renderTarget) {
      if (!renderTarget.isRoot) {
        var glRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);
        this._resizeColor(renderTarget, glRenderTarget);
        (renderTarget.stencil || renderTarget.depth) && this._resizeStencil(glRenderTarget);
      }
    }
    _initColor(renderTarget, glRenderTarget) {
      const renderer = this._renderer, gl = renderer.gl;
      var resolveTargetFramebuffer = gl.createFramebuffer();
      glRenderTarget.resolveTargetFramebuffer = resolveTargetFramebuffer;
      gl.bindFramebuffer(gl.FRAMEBUFFER, resolveTargetFramebuffer);
      glRenderTarget.width = renderTarget.colorTexture.source.pixelWidth;
      glRenderTarget.height = renderTarget.colorTexture.source.pixelHeight;
      renderTarget.colorTextures.forEach((colorTexture, i) => {
        colorTexture = colorTexture.source;
        colorTexture.antialias && (renderer.context.supports.msaa ? glRenderTarget.msaa = !0 : warn.warn("[RenderTexture] Antialiasing on textures is not supported in WebGL1"));
        renderer.texture.bindSource(colorTexture, 0);
        colorTexture = renderer.texture.getGlSource(colorTexture).texture;
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, 3553, colorTexture, 0);
      });
      glRenderTarget.msaa ? (resolveTargetFramebuffer = gl.createFramebuffer(), glRenderTarget.framebuffer = resolveTargetFramebuffer, gl.bindFramebuffer(gl.FRAMEBUFFER, resolveTargetFramebuffer), renderTarget.colorTextures.forEach((_, i) => {
        _ = gl.createRenderbuffer();
        glRenderTarget.msaaRenderBuffer[i] = _;
      })) : glRenderTarget.framebuffer = resolveTargetFramebuffer;
      this._resizeColor(renderTarget, glRenderTarget);
    }
    _resizeColor(renderTarget, glRenderTarget) {
      const source = renderTarget.colorTexture.source;
      glRenderTarget.width = source.pixelWidth;
      glRenderTarget.height = source.pixelHeight;
      renderTarget.colorTextures.forEach((colorTexture, i) => {
        0 !== i && colorTexture.source.resize(source.width, source.height, source._resolution);
      });
      if (glRenderTarget.msaa) {
        const renderer = this._renderer, gl = renderer.gl;
        gl.bindFramebuffer(gl.FRAMEBUFFER, glRenderTarget.framebuffer);
        renderTarget.colorTextures.forEach((colorTexture, i) => {
          colorTexture = colorTexture.source;
          renderer.texture.bindSource(colorTexture, 0);
          const glInternalFormat = renderer.texture.getGlSource(colorTexture).internalFormat, msaaRenderBuffer = glRenderTarget.msaaRenderBuffer[i];
          gl.bindRenderbuffer(gl.RENDERBUFFER, msaaRenderBuffer);
          gl.renderbufferStorageMultisample(gl.RENDERBUFFER, 4, glInternalFormat, colorTexture.pixelWidth, colorTexture.pixelHeight);
          gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.RENDERBUFFER, msaaRenderBuffer);
        });
      }
    }
    _initStencil(glRenderTarget) {
      if (null !== glRenderTarget.framebuffer) {
        var gl = this._renderer.gl, depthStencilRenderBuffer = gl.createRenderbuffer();
        glRenderTarget.depthStencilRenderBuffer = depthStencilRenderBuffer;
        gl.bindRenderbuffer(gl.RENDERBUFFER, depthStencilRenderBuffer);
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, depthStencilRenderBuffer);
        this._resizeStencil(glRenderTarget);
      }
    }
    _resizeStencil(glRenderTarget) {
      const gl = this._renderer.gl;
      gl.bindRenderbuffer(gl.RENDERBUFFER, glRenderTarget.depthStencilRenderBuffer);
      glRenderTarget.msaa ? gl.renderbufferStorageMultisample(gl.RENDERBUFFER, 4, gl.DEPTH24_STENCIL8, glRenderTarget.width, glRenderTarget.height) : gl.renderbufferStorage(gl.RENDERBUFFER, 2 === this._renderer.context.webGLVersion ? gl.DEPTH24_STENCIL8 : gl.DEPTH_STENCIL, glRenderTarget.width, glRenderTarget.height);
    }
    prerender(renderTarget) {
      renderTarget = renderTarget.colorTexture.resource;
      this._renderer.context.multiView && CanvasSource.CanvasSource.test(renderTarget) && this._renderer.context.ensureCanvasSize(renderTarget);
    }
    postrender(renderTarget) {
      if (this._renderer.context.multiView && CanvasSource.CanvasSource.test(renderTarget.colorTexture.resource)) {
        const contextCanvas = this._renderer.context.canvas;
        renderTarget = renderTarget.colorTexture;
        renderTarget.context2D.drawImage(contextCanvas, 0, renderTarget.pixelHeight - contextCanvas.height);
      }
    }
  }
  exports.GlRenderTargetAdaptor = GlRenderTargetAdaptor;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$rendering$renderers$gl$renderTarget$GlRenderTargetAdaptor.js.map
