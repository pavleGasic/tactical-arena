{
"version":3,
"file":"module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$shader$utils$uniformParsers.js",
"lineCount":8,
"mappings":"AAAAA,cAAA,CAAA,0FAAA,GAA+G,QAAQ,CAACC,MAAD,EAAQC,OAAR,EAAgBC,MAAhB,EAAuBC,OAAvB,CAAgC;AAoHvJA,SAAQC,CAAAA,cAAR,GAhHuBA,CAErB,CACEC,KAAM,mBADR,EAEEC,KAAOC,IAADD,IAEe,IAAK,EAFpBA,KACUC,IAAKC,CAAAA,KACNC,CAAAA,CAJjB,EAMEC,IAAM,4dANR;AAkBEC,UAAU,gGAlBZ,CAFqBP,EAyBrB,CACEC,KAAM,iBADR,EAEEC,KAAOC,IAADD,IAAwB,iBAAxBA,KAAUC,IAAKF,CAAAA,IAAfC,IAAqD,CAArDA,KAAuCC,IAAKK,CAAAA,IAA5CN,IAA+E,IAAK,EAApFA,KAA0DC,IAAKC,CAAAA,KAAMK,CAAAA,KAF7E,EAGEH,IAAM,+MAHR,EAUEC,QAAU,gbAVZ,CAzBqBP;AAgDrB,GACEC,KAAM,iBADR,EAEEC,KAAOC,IAADD,IAAwB,iBAAxBA,KAAUC,IAAKF,CAAAA,IAAfC,IAAqD,CAArDA,KAAuCC,IAAKK,CAAAA,IAA5CN,IAA2E,IAAK,EAAhFA,KAA0DC,IAAKC,CAAAA,KAAMM,CAAAA,CAF7E,EAGEJ,IAAM,sHAHR,EAQEC,QAAU,2RARZ,CAhDqBP;AAmErB,GACEC,KAAM,iBADR,EAEEC,KAAOC,IAADD,IAAwB,iBAAxBA,KAAUC,IAAKF,CAAAA,IAAfC,IAAqD,CAArDA,KAAuCC,IAAKK,CAAAA,IAA5CN,IAA6E,IAAK,EAAlFA,KAA0DC,IAAKC,CAAAA,KAAMO,CAAAA,GAF7E,EAGEL,IAAM,mNAHR,EAUEC,QAAU,4bAVZ,CAnEqBP;AA0FrB,GACEC,KAAM,iBADR,EAEEC,KAAOC,IAADD,IAAwB,iBAAxBA,KAAUC,IAAKF,CAAAA,IAAfC,IAAqD,CAArDA,KAAuCC,IAAKK,CAAAA,IAA5CN,IAA6E,IAAK,EAAlFA,KAA0DC,IAAKC,CAAAA,KAAMO,CAAAA,GAF7E,EAGEL,IAAM,uKAHR,EASEC,QAAU,mXATZ,CA1FqBP,CAgHvB;AApHuJ,CAAvJ;;",
"sources":["node_modules/pixi_DOT_js/lib/rendering/renderers/shared/shader/utils/uniformParsers.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$shader$utils$uniformParsers\"] = function(global,require,module,exports) {\n'use strict';\n\n\"use strict\";\nconst uniformParsers = [\n  // uploading pixi matrix object to mat3\n  {\n    type: \"mat3x3<f32>\",\n    test: (data) => {\n      const value = data.value;\n      return value.a !== void 0;\n    },\n    ubo: `\n            var matrix = uv[name].toArray(true);\n            data[offset] = matrix[0];\n            data[offset + 1] = matrix[1];\n            data[offset + 2] = matrix[2];\n            data[offset + 4] = matrix[3];\n            data[offset + 5] = matrix[4];\n            data[offset + 6] = matrix[5];\n            data[offset + 8] = matrix[6];\n            data[offset + 9] = matrix[7];\n            data[offset + 10] = matrix[8];\n        `,\n    uniform: `\n            gl.uniformMatrix3fv(ud[name].location, false, uv[name].toArray(true));\n        `\n  },\n  // uploading a pixi rectangle as a vec4\n  {\n    type: \"vec4<f32>\",\n    test: (data) => data.type === \"vec4<f32>\" && data.size === 1 && data.value.width !== void 0,\n    ubo: `\n            v = uv[name];\n            data[offset] = v.x;\n            data[offset + 1] = v.y;\n            data[offset + 2] = v.width;\n            data[offset + 3] = v.height;\n        `,\n    uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height) {\n                cv[0] = v.x;\n                cv[1] = v.y;\n                cv[2] = v.width;\n                cv[3] = v.height;\n                gl.uniform4f(ud[name].location, v.x, v.y, v.width, v.height);\n            }\n        `\n  },\n  // uploading a pixi point as a vec2\n  {\n    type: \"vec2<f32>\",\n    test: (data) => data.type === \"vec2<f32>\" && data.size === 1 && data.value.x !== void 0,\n    ubo: `\n            v = uv[name];\n            data[offset] = v.x;\n            data[offset + 1] = v.y;\n        `,\n    uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.x || cv[1] !== v.y) {\n                cv[0] = v.x;\n                cv[1] = v.y;\n                gl.uniform2f(ud[name].location, v.x, v.y);\n            }\n        `\n  },\n  // uploading a pixi color as a vec4\n  {\n    type: \"vec4<f32>\",\n    test: (data) => data.type === \"vec4<f32>\" && data.size === 1 && data.value.red !== void 0,\n    ubo: `\n            v = uv[name];\n            data[offset] = v.red;\n            data[offset + 1] = v.green;\n            data[offset + 2] = v.blue;\n            data[offset + 3] = v.alpha;\n        `,\n    uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha) {\n                cv[0] = v.red;\n                cv[1] = v.green;\n                cv[2] = v.blue;\n                cv[3] = v.alpha;\n                gl.uniform4f(ud[name].location, v.red, v.green, v.blue, v.alpha);\n            }\n        `\n  },\n  // uploading a pixi color as a vec3\n  {\n    type: \"vec3<f32>\",\n    test: (data) => data.type === \"vec3<f32>\" && data.size === 1 && data.value.red !== void 0,\n    ubo: `\n            v = uv[name];\n            data[offset] = v.red;\n            data[offset + 1] = v.green;\n            data[offset + 2] = v.blue;\n        `,\n    uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue) {\n                cv[0] = v.red;\n                cv[1] = v.green;\n                cv[2] = v.blue;\n                gl.uniform3f(ud[name].location, v.red, v.green, v.blue);\n            }\n        `\n  }\n];\n\nexports.uniformParsers = uniformParsers;\n//# sourceMappingURL=uniformParsers.js.map\n\n};"],
"names":["shadow$provide","global","require","module","exports","uniformParsers","type","test","data","value","a","ubo","uniform","size","width","x","red"]
}
