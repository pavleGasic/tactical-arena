shadow$provide.module$node_modules$$pixi$assets$lib$loader$parsers$loadWebFont = function(global, require, module, exports) {
  function getFontFamilyName(url) {
    var ext = core.utils.path.extname(url);
    ext = core.utils.path.basename(url, ext).replace(/(-|_)/g, " ").toLowerCase().split(" ").map(word => word.charAt(0).toUpperCase() + word.slice(1));
    url = 0 < ext.length;
    for (var token of ext) {
      if (!token.match(CSS_IDENT_TOKEN_REGEX)) {
        url = !1;
        break;
      }
    }
    token = ext.join(" ");
    return url || (token = `"${token.replace(/[\\"]/g, "\\$\x26")}"`), token;
  }
  function encodeURIWhenNeeded(uri) {
    return validURICharactersRegex.test(uri) ? uri : encodeURI(uri);
  }
  var core = require("module$node_modules$$pixi$core$lib$index"), checkDataUrl = require("module$node_modules$$pixi$assets$lib$utils$checkDataUrl"), checkExtension = require("module$node_modules$$pixi$assets$lib$utils$checkExtension");
  global = require("module$node_modules$$pixi$assets$lib$loader$parsers$LoaderParser");
  const validWeights = "normal bold 100 200 300 400 500 600 700 800 900".split(" "), validFontExtensions = [".ttf", ".otf", ".woff", ".woff2"], validFontMIMEs = ["font/ttf", "font/otf", "font/woff", "font/woff2"], CSS_IDENT_TOKEN_REGEX = /^(--|-?[A-Z_])[0-9A-Z_-]*$/i, validURICharactersRegex = /^[0-9A-Za-z%:/?#\[\]@!\$&'()\*\+,;=\-._~]*$/;
  global = {extension:{type:core.ExtensionType.LoadParser, priority:global.LoaderParserPriority.Low}, name:"loadWebFont", test(url) {
    return checkDataUrl.checkDataUrl(url, validFontMIMEs) || checkExtension.checkExtension(url, validFontExtensions);
  }, async load(url, options) {
    const fonts = core.settings.ADAPTER.getFontFaceSet();
    if (fonts) {
      const fontFaces = [], name = options.data?.family ?? getFontFamilyName(url), weights = options.data?.weights?.filter(weight => validWeights.includes(weight)) ?? ["normal"];
      options = options.data ?? {};
      for (let i = 0; i < weights.length; i++) {
        var weight = weights[i];
        weight = new FontFace(name, `url(${encodeURIWhenNeeded(url)})`, {...options, weight});
        await weight.load();
        fonts.add(weight);
        fontFaces.push(weight);
      }
      return 1 === fontFaces.length ? fontFaces[0] : fontFaces;
    }
    return console.warn("[loadWebFont] FontFace API is not supported. Skipping loading font"), null;
  }, unload(font) {
    (Array.isArray(font) ? font : [font]).forEach(t => core.settings.ADAPTER.getFontFaceSet().delete(t));
  }};
  core.extensions.add(global);
  exports.getFontFamilyName = getFontFamilyName;
  exports.loadWebFont = global;
};

//# sourceMappingURL=module$node_modules$$pixi$assets$lib$loader$parsers$loadWebFont.js.map
