shadow$provide.module$node_modules$pixi_DOT_js$lib$scene$graphics$shared$svg$parseSVGPath = function(global, require, module, exports) {
  var parse = require("module$node_modules$parse_svg_path$index"), warn = require("module$node_modules$pixi_DOT_js$lib$utils$logging$warn");
  "use strict";
  exports.parseSVGPath = function(svgPath, path) {
    svgPath = parse(svgPath);
    const subpaths = [];
    let currentSubPath = null, lastX = 0, lastY = 0;
    for (let i = 0; i < svgPath.length; i++) {
      var command = svgPath[i];
      const type = command[0];
      switch(type) {
        case "M":
          lastX = command[1];
          lastY = command[2];
          path.moveTo(lastX, lastY);
          break;
        case "m":
          lastX += command[1];
          lastY += command[2];
          path.moveTo(lastX, lastY);
          break;
        case "H":
          lastX = command[1];
          path.lineTo(lastX, lastY);
          break;
        case "h":
          lastX += command[1];
          path.lineTo(lastX, lastY);
          break;
        case "V":
          lastY = command[1];
          path.lineTo(lastX, lastY);
          break;
        case "v":
          lastY += command[1];
          path.lineTo(lastX, lastY);
          break;
        case "L":
          lastX = command[1];
          lastY = command[2];
          path.lineTo(lastX, lastY);
          break;
        case "l":
          lastX += command[1];
          lastY += command[2];
          path.lineTo(lastX, lastY);
          break;
        case "C":
          lastX = command[5];
          lastY = command[6];
          path.bezierCurveTo(command[1], command[2], command[3], command[4], lastX, lastY);
          break;
        case "c":
          path.bezierCurveTo(lastX + command[1], lastY + command[2], lastX + command[3], lastY + command[4], lastX + command[5], lastY + command[6]);
          lastX += command[5];
          lastY += command[6];
          break;
        case "S":
          lastX = command[3];
          lastY = command[4];
          path.bezierCurveToShort(command[1], command[2], lastX, lastY);
          break;
        case "s":
          path.bezierCurveToShort(lastX + command[1], lastY + command[2], lastX + command[3], lastY + command[4]);
          lastX += command[3];
          lastY += command[4];
          break;
        case "Q":
          lastX = command[3];
          lastY = command[4];
          path.quadraticCurveTo(command[1], command[2], lastX, lastY);
          break;
        case "q":
          path.quadraticCurveTo(lastX + command[1], lastY + command[2], lastX + command[3], lastY + command[4]);
          lastX += command[3];
          lastY += command[4];
          break;
        case "T":
          lastX = command[1];
          lastY = command[2];
          path.quadraticCurveToShort(lastX, lastY);
          break;
        case "t":
          lastX += command[1];
          lastY += command[2];
          path.quadraticCurveToShort(lastX, lastY);
          break;
        case "A":
          lastX = command[6];
          lastY = command[7];
          path.arcToSvg(command[1], command[2], command[3], command[4], command[5], lastX, lastY);
          break;
        case "a":
          lastX += command[6];
          lastY += command[7];
          path.arcToSvg(command[1], command[2], command[3], command[4], command[5], lastX, lastY);
          break;
        case "Z":
        case "z":
          path.closePath();
          0 < subpaths.length && ((currentSubPath = subpaths.pop()) ? (lastX = currentSubPath.startX, lastY = currentSubPath.startY) : lastY = lastX = 0);
          currentSubPath = null;
          break;
        default:
          warn.warn(`Unknown SVG path command: ${type}`);
      }
      "Z" !== type && "z" !== type && null === currentSubPath && (currentSubPath = {startX:lastX, startY:lastY}, subpaths.push(currentSubPath));
    }
    return path;
  };
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$scene$graphics$shared$svg$parseSVGPath.js.map
