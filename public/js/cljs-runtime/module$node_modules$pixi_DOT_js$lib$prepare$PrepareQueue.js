shadow$provide.module$node_modules$pixi_DOT_js$lib$prepare$PrepareQueue = function(global, require, module, exports) {
  var TextureSource = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$texture$sources$TextureSource"), Texture = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$texture$Texture"), Container = require("module$node_modules$pixi_DOT_js$lib$scene$container$Container"), Graphics = require("module$node_modules$pixi_DOT_js$lib$scene$graphics$shared$Graphics"), GraphicsContext = require("module$node_modules$pixi_DOT_js$lib$scene$graphics$shared$GraphicsContext"), 
  Mesh = require("module$node_modules$pixi_DOT_js$lib$scene$mesh$shared$Mesh"), Sprite = require("module$node_modules$pixi_DOT_js$lib$scene$sprite$Sprite"), AnimatedSprite = require("module$node_modules$pixi_DOT_js$lib$scene$sprite_animated$AnimatedSprite"), TilingSprite = require("module$node_modules$pixi_DOT_js$lib$scene$sprite_tiling$TilingSprite"), Text = require("module$node_modules$pixi_DOT_js$lib$scene$text$Text");
  global = require("module$node_modules$pixi_DOT_js$lib$prepare$PrepareBase");
  "use strict";
  class PrepareQueue extends global.PrepareBase {
    resolveQueueItem(source, queue) {
      source instanceof Container.Container ? this.resolveContainerQueueItem(source, queue) : source instanceof TextureSource.TextureSource || source instanceof Texture.Texture ? queue.push(source.source) : source instanceof GraphicsContext.GraphicsContext && queue.push(source);
      return null;
    }
    resolveContainerQueueItem(container, queue) {
      container instanceof Sprite.Sprite || container instanceof TilingSprite.TilingSprite || container instanceof Mesh.Mesh ? queue.push(container.texture.source) : container instanceof Text.Text ? queue.push(container) : container instanceof Graphics.Graphics ? queue.push(container.context) : container instanceof AnimatedSprite.AnimatedSprite && container.textures.forEach(textureOrFrame => {
        textureOrFrame.source ? queue.push(textureOrFrame.source) : queue.push(textureOrFrame.texture.source);
      });
    }
    resolveGraphicsContextQueueItem(graphicsContext) {
      this.renderer.graphicsContext.getGpuContext(graphicsContext);
      ({instructions:graphicsContext} = graphicsContext);
      for (var instruction of graphicsContext) {
        if ("texture" === instruction.action) {
          return {image:instruction} = instruction.data, instruction.source;
        }
        if ("fill" === instruction.action) {
          return {texture:instruction} = instruction.data.style, instruction.source;
        }
      }
      return null;
    }
  }
  exports.PrepareQueue = PrepareQueue;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$prepare$PrepareQueue.js.map
