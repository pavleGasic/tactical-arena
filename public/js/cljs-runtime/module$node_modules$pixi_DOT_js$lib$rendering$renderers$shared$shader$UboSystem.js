shadow$provide.module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$shader$UboSystem = function(global, require, module, exports) {
  var unsafeEvalSupported = require("module$node_modules$pixi_DOT_js$lib$utils$browser$unsafeEvalSupported"), Buffer = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$buffer$Buffer"), _const = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$buffer$const");
  "use strict";
  class UboSystem {
    constructor(adaptor) {
      this._syncFunctionHash = Object.create(null);
      this._adaptor = adaptor;
      this._systemCheck();
    }
    _systemCheck() {
      if (!unsafeEvalSupported.unsafeEvalSupported()) {
        throw Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.");
      }
    }
    ensureUniformGroup(uniformGroup) {
      const uniformData = this.getUniformGroupData(uniformGroup);
      uniformGroup.buffer || (uniformGroup.buffer = new Buffer.Buffer({data:new Float32Array(uniformData.layout.size / 4), usage:_const.BufferUsage.UNIFORM | _const.BufferUsage.COPY_DST}));
    }
    getUniformGroupData(uniformGroup) {
      return this._syncFunctionHash[uniformGroup._signature] || this._initUniformGroup(uniformGroup);
    }
    _initUniformGroup(uniformGroup) {
      const uniformGroupSignature = uniformGroup._signature;
      var uniformData = this._syncFunctionHash[uniformGroupSignature];
      if (!uniformData) {
        uniformData = Object.keys(uniformGroup.uniformStructures).map(i => uniformGroup.uniformStructures[i]);
        uniformData = this._adaptor.createUboElements(uniformData);
        const syncFunction = this._generateUboSync(uniformData.uboElements);
        uniformData = this._syncFunctionHash[uniformGroupSignature] = {layout:uniformData, syncFunction};
      }
      return this._syncFunctionHash[uniformGroupSignature];
    }
    _generateUboSync(uboElements) {
      return this._adaptor.generateUboSync(uboElements);
    }
    syncUniformGroup(uniformGroup, data, offset) {
      const uniformGroupData = this.getUniformGroupData(uniformGroup);
      uniformGroup.buffer || (uniformGroup.buffer = new Buffer.Buffer({data:new Float32Array(uniformGroupData.layout.size / 4), usage:_const.BufferUsage.UNIFORM | _const.BufferUsage.COPY_DST}));
      let dataInt32 = null;
      data || (data = uniformGroup.buffer.data, dataInt32 = uniformGroup.buffer.dataInt32);
      offset || (offset = 0);
      uniformGroupData.syncFunction(uniformGroup.uniforms, data, dataInt32, offset);
      return !0;
    }
    updateUniformGroup(uniformGroup) {
      if (uniformGroup.isStatic && !uniformGroup._dirtyId) {
        return !1;
      }
      uniformGroup._dirtyId = 0;
      const synced = this.syncUniformGroup(uniformGroup);
      uniformGroup.buffer.update();
      return synced;
    }
    destroy() {
      this._syncFunctionHash = null;
    }
  }
  exports.UboSystem = UboSystem;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$shader$UboSystem.js.map
