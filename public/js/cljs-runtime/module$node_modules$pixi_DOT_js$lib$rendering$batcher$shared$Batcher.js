shadow$provide.module$node_modules$pixi_DOT_js$lib$rendering$batcher$shared$Batcher = function(global, require, module, exports) {
  var uid = require("module$node_modules$pixi_DOT_js$lib$utils$data$uid"), ViewableBuffer = require("module$node_modules$pixi_DOT_js$lib$utils$data$ViewableBuffer"), fastCopy = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$buffer$utils$fastCopy"), getAdjustedBlendModeBlend = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$state$getAdjustedBlendModeBlend"), maxRecommendedTextures = require("module$node_modules$pixi_DOT_js$lib$rendering$batcher$gl$utils$maxRecommendedTextures"), 
  BatchTextureArray = require("module$node_modules$pixi_DOT_js$lib$rendering$batcher$shared$BatchTextureArray");
  "use strict";
  class Batch {
    constructor() {
      this.renderPipeId = "batch";
      this.action = "startBatch";
      this.size = this.start = 0;
      this.textures = new BatchTextureArray.BatchTextureArray();
      this.blendMode = "normal";
      this.topology = "triangle-strip";
      this.canBundle = !0;
    }
    destroy() {
      this.batcher = this.bindGroup = this.gpuBindGroup = this.textures = null;
    }
  }
  const batchPool = [];
  let batchPoolIndex = 0, BATCH_TICK = 0;
  const node_modules$pixi_DOT_js$lib$rendering$batcher$shared$Batcher$classdecl$var8 = class {
    constructor(options = {}) {
      this.uid = uid.uid("batcher");
      this.dirty = !0;
      this.batchIndex = 0;
      this.batches = [];
      this._elements = [];
      node_modules$pixi_DOT_js$lib$rendering$batcher$shared$Batcher$classdecl$var8.defaultOptions.maxTextures = node_modules$pixi_DOT_js$lib$rendering$batcher$shared$Batcher$classdecl$var8.defaultOptions.maxTextures ?? maxRecommendedTextures.getMaxTexturesPerBatch();
      options = {...node_modules$pixi_DOT_js$lib$rendering$batcher$shared$Batcher$classdecl$var8.defaultOptions, ...options};
      const {maxTextures, attributesInitialSize, indicesInitialSize} = options;
      this.attributeBuffer = new ViewableBuffer.ViewableBuffer(4 * attributesInitialSize);
      this.indexBuffer = new Uint16Array(indicesInitialSize);
      this.maxTextures = maxTextures;
    }
    begin() {
      this.attributeSize = this.indexSize = this.elementStart = this.elementSize = 0;
      for (let i = 0; i < this.batchIndex; i++) {
        var batch = this.batches[i];
        batchPool[batchPoolIndex++] = batch;
      }
      this._batchIndexSize = this._batchIndexStart = this.batchIndex = 0;
      this.dirty = !0;
    }
    add(batchableObject) {
      this._elements[this.elementSize++] = batchableObject;
      batchableObject._indexStart = this.indexSize;
      batchableObject._attributeStart = this.attributeSize;
      batchableObject._batcher = this;
      this.indexSize += batchableObject.indexSize;
      this.attributeSize += batchableObject.attributeSize * this.vertexSize;
    }
    checkAndUpdateTexture(batchableObject, texture) {
      const textureId = batchableObject._batch.textures.ids[texture._source.uid];
      if (!textureId && 0 !== textureId) {
        return !1;
      }
      batchableObject._textureId = textureId;
      batchableObject.texture = texture;
      return !0;
    }
    updateElement(batchableObject) {
      this.dirty = !0;
      const attributeBuffer = this.attributeBuffer;
      batchableObject.packAsQuad ? this.packQuadAttributes(batchableObject, attributeBuffer.float32View, attributeBuffer.uint32View, batchableObject._attributeStart, batchableObject._textureId) : this.packAttributes(batchableObject, attributeBuffer.float32View, attributeBuffer.uint32View, batchableObject._attributeStart, batchableObject._textureId);
    }
    break(instructionSet) {
      const elements = this._elements;
      if (elements[this.elementStart]) {
        var batch = 0 < batchPoolIndex ? batchPool[--batchPoolIndex] : new Batch(), textureBatch = batch.textures;
        textureBatch.clear();
        var firstElement = elements[this.elementStart], blendMode = getAdjustedBlendModeBlend.getAdjustedBlendModeBlend(firstElement.blendMode, firstElement.texture._source);
        firstElement = firstElement.topology;
        4 * this.attributeSize > this.attributeBuffer.size && this._resizeAttributeBuffer(4 * this.attributeSize);
        this.indexSize > this.indexBuffer.length && this._resizeIndexBuffer(this.indexSize);
        var f32 = this.attributeBuffer.float32View, u32 = this.attributeBuffer.uint32View, indexBuffer = this.indexBuffer, size = this._batchIndexSize, start = this._batchIndexStart, action = "startBatch", maxTextures = this.maxTextures;
        for (let i = this.elementStart; i < this.elementSize; ++i) {
          const element = elements[i];
          elements[i] = null;
          const source = element.texture._source, adjustedBlendMode = getAdjustedBlendModeBlend.getAdjustedBlendModeBlend(element.blendMode, source), breakRequired = blendMode !== adjustedBlendMode || firstElement !== element.topology;
          if (source._batchTick !== BATCH_TICK || breakRequired) {
            source._batchTick = BATCH_TICK;
            if (textureBatch.count >= maxTextures || breakRequired) {
              this._finishBatch(batch, start, size - start, textureBatch, blendMode, firstElement, instructionSet, action), action = "renderBatch", start = size, blendMode = adjustedBlendMode, firstElement = element.topology, batch = 0 < batchPoolIndex ? batchPool[--batchPoolIndex] : new Batch(), textureBatch = batch.textures, textureBatch.clear(), ++BATCH_TICK;
            }
            element._textureId = source._textureBindLocation = textureBatch.count;
            textureBatch.ids[source.uid] = textureBatch.count;
            textureBatch.textures[textureBatch.count++] = source;
            element._batch = batch;
            size += element.indexSize;
            element.packAsQuad ? (this.packQuadAttributes(element, f32, u32, element._attributeStart, element._textureId), this.packQuadIndex(indexBuffer, element._indexStart, element._attributeStart / this.vertexSize)) : (this.packAttributes(element, f32, u32, element._attributeStart, element._textureId), this.packIndex(element, indexBuffer, element._indexStart, element._attributeStart / this.vertexSize));
          } else {
            element._textureId = source._textureBindLocation, size += element.indexSize, element.packAsQuad ? (this.packQuadAttributes(element, f32, u32, element._attributeStart, element._textureId), this.packQuadIndex(indexBuffer, element._indexStart, element._attributeStart / this.vertexSize)) : (this.packAttributes(element, f32, u32, element._attributeStart, element._textureId), this.packIndex(element, indexBuffer, element._indexStart, element._attributeStart / this.vertexSize)), element._batch = 
            batch;
          }
        }
        0 < textureBatch.count && (this._finishBatch(batch, start, size - start, textureBatch, blendMode, firstElement, instructionSet, action), start = size, ++BATCH_TICK);
        this.elementStart = this.elementSize;
        this._batchIndexStart = start;
        this._batchIndexSize = size;
      }
    }
    _finishBatch(batch, indexStart, indexSize, textureBatch, blendMode, topology, instructionSet, action) {
      batch.gpuBindGroup = null;
      batch.bindGroup = null;
      batch.action = action;
      batch.batcher = this;
      batch.textures = textureBatch;
      batch.blendMode = blendMode;
      batch.topology = topology;
      batch.start = indexStart;
      batch.size = indexSize;
      ++BATCH_TICK;
      this.batches[this.batchIndex++] = batch;
      instructionSet.add(batch);
    }
    finish(instructionSet) {
      this.break(instructionSet);
    }
    ensureAttributeBuffer(size) {
      4 * size <= this.attributeBuffer.size || this._resizeAttributeBuffer(4 * size);
    }
    ensureIndexBuffer(size) {
      size <= this.indexBuffer.length || this._resizeIndexBuffer(size);
    }
    _resizeAttributeBuffer(size) {
      size = new ViewableBuffer.ViewableBuffer(Math.max(size, 2 * this.attributeBuffer.size));
      fastCopy.fastCopy(this.attributeBuffer.rawBinaryData, size.rawBinaryData);
      this.attributeBuffer = size;
    }
    _resizeIndexBuffer(size) {
      const indexBuffer = this.indexBuffer;
      size = Math.max(size, 1.5 * indexBuffer.length);
      size += size % 2;
      size = 65535 < size ? new Uint32Array(size) : new Uint16Array(size);
      if (size.BYTES_PER_ELEMENT !== indexBuffer.BYTES_PER_ELEMENT) {
        for (let i = 0; i < indexBuffer.length; i++) {
          size[i] = indexBuffer[i];
        }
      } else {
        fastCopy.fastCopy(indexBuffer.buffer, size.buffer);
      }
      this.indexBuffer = size;
    }
    packQuadIndex(indexBuffer, index, indicesOffset) {
      indexBuffer[index] = indicesOffset + 0;
      indexBuffer[index + 1] = indicesOffset + 1;
      indexBuffer[index + 2] = indicesOffset + 2;
      indexBuffer[index + 3] = indicesOffset + 0;
      indexBuffer[index + 4] = indicesOffset + 2;
      indexBuffer[index + 5] = indicesOffset + 3;
    }
    packIndex(element, indexBuffer, index, indicesOffset) {
      const indices = element.indices, size = element.indexSize, indexOffset = element.indexOffset;
      element = element.attributeOffset;
      for (let i = 0; i < size; i++) {
        indexBuffer[index++] = indicesOffset + indices[i + indexOffset] - element;
      }
    }
    destroy() {
      for (let i = 0; i < this.batches.length; i++) {
        var batch = this.batches[i];
        batchPool[batchPoolIndex++] = batch;
      }
      this.batches = null;
      for (batch = 0; batch < this._elements.length; batch++) {
        this._elements[batch]._batch = null;
      }
      this.indexBuffer = this._elements = null;
      this.attributeBuffer.destroy();
      this.attributeBuffer = null;
    }
  };
  global = node_modules$pixi_DOT_js$lib$rendering$batcher$shared$Batcher$classdecl$var8;
  global.defaultOptions = {maxTextures:null, attributesInitialSize:4, indicesInitialSize:6};
  exports.Batch = Batch;
  exports.Batcher = global;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$rendering$batcher$shared$Batcher.js.map
