shadow$provide.module$node_modules$$pixi$core$lib$Renderer = function(global, require, module, exports) {
  var constants = require("module$node_modules$$pixi$constants$lib$index");
  global = require("module$node_modules$$pixi$extensions$lib$index");
  var math = require("module$node_modules$$pixi$math$lib$index"), settings = require("module$node_modules$$pixi$settings$lib$index"), utils = require("module$node_modules$$pixi$utils$lib$index"), UniformGroup = require("module$node_modules$$pixi$core$lib$shader$UniformGroup");
  require = require("module$node_modules$$pixi$core$lib$system$SystemManager");
  const node_modules$$pixi$core$lib$Renderer$classdecl$var9 = class extends require.SystemManager {
    constructor(options) {
      super();
      this.type = constants.RENDERER_TYPE.WEBGL;
      options = Object.assign({}, settings.settings.RENDER_OPTIONS, options);
      this.gl = null;
      this.CONTEXT_UID = 0;
      this.globalUniforms = new UniformGroup.UniformGroup({projectionMatrix:new math.Matrix()}, !0);
      this.setup({runners:"init destroy contextChange resolutionChange reset update postrender prerender resize".split(" "), systems:node_modules$$pixi$core$lib$Renderer$classdecl$var9.__systems, priority:"_view textureGenerator background _plugin startup context state texture buffer geometry framebuffer transformFeedback mask scissor stencil projection textureGC filter renderTexture batch objectRenderer _multisample".split(" ")});
      "useContextAlpha" in options && (utils.deprecation("7.0.0", "options.useContextAlpha is deprecated, use options.premultipliedAlpha and options.backgroundAlpha instead"), options.premultipliedAlpha = options.useContextAlpha && "notMultiplied" !== options.useContextAlpha, options.backgroundAlpha = !1 === options.useContextAlpha ? 1 : options.backgroundAlpha);
      this._plugin.rendererPlugins = node_modules$$pixi$core$lib$Renderer$classdecl$var9.__plugins;
      this.options = options;
      this.startup.run(this.options);
    }
    static test(options) {
      return options?.forceCanvas ? !1 : utils.isWebGLSupported();
    }
    render(displayObject, options) {
      this.objectRenderer.render(displayObject, options);
    }
    resize(desiredScreenWidth, desiredScreenHeight) {
      this._view.resizeView(desiredScreenWidth, desiredScreenHeight);
    }
    reset() {
      return this.runners.reset.emit(), this;
    }
    clear() {
      this.renderTexture.bind();
      this.renderTexture.clear();
    }
    destroy(removeView = !1) {
      this.runners.destroy.items.reverse();
      this.emitWithCustomOptions(this.runners.destroy, {_view:removeView});
      super.destroy();
    }
    get plugins() {
      return this._plugin.plugins;
    }
    get multisample() {
      return this._multisample.multisample;
    }
    get width() {
      return this._view.element.width;
    }
    get height() {
      return this._view.element.height;
    }
    get resolution() {
      return this._view.resolution;
    }
    set resolution(value) {
      this._view.resolution = value;
      this.runners.resolutionChange.emit(value);
    }
    get autoDensity() {
      return this._view.autoDensity;
    }
    get view() {
      return this._view.element;
    }
    get screen() {
      return this._view.screen;
    }
    get lastObjectRendered() {
      return this.objectRenderer.lastObjectRendered;
    }
    get renderingToScreen() {
      return this.objectRenderer.renderingToScreen;
    }
    get rendererLogId() {
      return `WebGL ${this.context.webGLVersion}`;
    }
    get clearBeforeRender() {
      return utils.deprecation("7.0.0", "renderer.clearBeforeRender has been deprecated, please use renderer.background.clearBeforeRender instead."), this.background.clearBeforeRender;
    }
    get useContextAlpha() {
      return utils.deprecation("7.0.0", "renderer.useContextAlpha has been deprecated, please use renderer.context.premultipliedAlpha instead."), this.context.useContextAlpha;
    }
    get preserveDrawingBuffer() {
      return utils.deprecation("7.0.0", "renderer.preserveDrawingBuffer has been deprecated, we cannot truly know this unless pixi created the context"), this.context.preserveDrawingBuffer;
    }
    get backgroundColor() {
      return utils.deprecation("7.0.0", "renderer.backgroundColor has been deprecated, use renderer.background.color instead."), this.background.color;
    }
    set backgroundColor(value) {
      utils.deprecation("7.0.0", "renderer.backgroundColor has been deprecated, use renderer.background.color instead.");
      this.background.color = value;
    }
    get backgroundAlpha() {
      return utils.deprecation("7.0.0", "renderer.backgroundAlpha has been deprecated, use renderer.background.alpha instead."), this.background.alpha;
    }
    set backgroundAlpha(value) {
      utils.deprecation("7.0.0", "renderer.backgroundAlpha has been deprecated, use renderer.background.alpha instead.");
      this.background.alpha = value;
    }
    get powerPreference() {
      return utils.deprecation("7.0.0", "renderer.powerPreference has been deprecated, we can only know this if pixi creates the context"), this.context.powerPreference;
    }
    generateTexture(displayObject, options) {
      return this.textureGenerator.generateTexture(displayObject, options);
    }
  };
  require = node_modules$$pixi$core$lib$Renderer$classdecl$var9;
  require.extension = {type:global.ExtensionType.Renderer, priority:1};
  require.__plugins = {};
  require.__systems = {};
  global.extensions.handleByMap(global.ExtensionType.RendererPlugin, require.__plugins);
  global.extensions.handleByMap(global.ExtensionType.RendererSystem, require.__systems);
  global.extensions.add(require);
  exports.Renderer = require;
};

//# sourceMappingURL=module$node_modules$$pixi$core$lib$Renderer.js.map
