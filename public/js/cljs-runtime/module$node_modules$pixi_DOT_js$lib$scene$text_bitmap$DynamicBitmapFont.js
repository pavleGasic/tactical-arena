shadow$provide.module$node_modules$pixi_DOT_js$lib$scene$text_bitmap$DynamicBitmapFont = function(global, require, module, exports) {
  var Color = require("module$node_modules$pixi_DOT_js$lib$color$Color"), Rectangle = require("module$node_modules$pixi_DOT_js$lib$maths$shapes$Rectangle"), CanvasPool = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$texture$CanvasPool"), ImageSource = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$texture$sources$ImageSource"), Texture = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$texture$Texture"), deprecation = require("module$node_modules$pixi_DOT_js$lib$utils$logging$deprecation"), 
  CanvasTextMetrics = require("module$node_modules$pixi_DOT_js$lib$scene$text$canvas$CanvasTextMetrics"), fontStringFromTextStyle = require("module$node_modules$pixi_DOT_js$lib$scene$text$canvas$utils$fontStringFromTextStyle"), getCanvasFillStyle = require("module$node_modules$pixi_DOT_js$lib$scene$text$canvas$utils$getCanvasFillStyle");
  global = require("module$node_modules$pixi_DOT_js$lib$scene$text$TextStyle");
  module = require("module$node_modules$pixi_DOT_js$lib$scene$text_bitmap$AbstractBitmapFont");
  var resolveCharacters = require("module$node_modules$pixi_DOT_js$lib$scene$text_bitmap$utils$resolveCharacters");
  "use strict";
  const node_modules$pixi_DOT_js$lib$scene$text_bitmap$DynamicBitmapFont$classdecl$var18 = class extends module.AbstractBitmapFont {
    constructor(options) {
      super();
      this.resolution = 1;
      this.pages = [];
      this._padding = 0;
      this._measureCache = Object.create(null);
      this._currentChars = [];
      this._currentY = this._currentX = 0;
      this._currentPageIndex = -1;
      this._skipKerning = !1;
      options = {...node_modules$pixi_DOT_js$lib$scene$text_bitmap$DynamicBitmapFont$classdecl$var18.defaultOptions, ...options};
      this._textureSize = options.textureSize;
      this._mipmap = options.mipmap;
      const style = options.style.clone();
      options.overrideFill && (style._fill.color = 16777215, style._fill.alpha = 1, style._fill.texture = Texture.Texture.WHITE, style._fill.fill = null);
      this.applyFillAsTint = options.overrideFill;
      const requestedFontSize = style.fontSize;
      style.fontSize = this.baseMeasurementFontSize;
      const font = fontStringFromTextStyle.fontStringFromTextStyle(style);
      options.overrideSize ? style._stroke && (style._stroke.width *= this.baseRenderedFontSize / requestedFontSize) : style.fontSize = this.baseRenderedFontSize = requestedFontSize;
      this._style = style;
      this._skipKerning = options.skipKerning ?? !1;
      this.resolution = options.resolution ?? 1;
      this._padding = options.padding ?? 4;
      this.fontMetrics = CanvasTextMetrics.CanvasTextMetrics.measureFont(font);
      this.lineHeight = style.lineHeight || this.fontMetrics.fontSize || style.fontSize;
    }
    ensureCharacters(chars) {
      chars = resolveCharacters.resolveCharacters(chars).filter(char => !this._currentChars.includes(char)).filter((char, index, self) => self.indexOf(char) === index);
      if (chars.length) {
        this._currentChars = [...this._currentChars, ...chars];
        var pageData = -1 === this._currentPageIndex ? this._nextPage() : this.pages[this._currentPageIndex];
        var {canvas, context} = pageData.canvasAndContext, textureSource = pageData.texture.source;
        pageData = this._style;
        var currentX = this._currentX, currentY = this._currentY, fontScale = this.baseRenderedFontSize / this.baseMeasurementFontSize, padding = this._padding * fontScale, maxCharHeight = 0, skipTexture = !1, maxTextureWidth = canvas.width / this.resolution, maxTextureHeight = canvas.height / this.resolution;
        for (let i = 0; i < chars.length; i++) {
          const char = chars[i];
          var metrics = CanvasTextMetrics.CanvasTextMetrics.measureText(char, pageData, canvas, !1);
          metrics.lineHeight = metrics.height;
          var width = metrics.width * fontScale;
          const paddedWidth = Math.ceil(("italic" === pageData.fontStyle ? 2 : 1) * width) + 2 * padding;
          var paddedHeight = metrics.height * fontScale + 2 * padding;
          skipTexture = !1;
          "\n" !== char && "\r" !== char && "\t" !== char && " " !== char && (skipTexture = !0, maxCharHeight = Math.ceil(Math.max(paddedHeight, maxCharHeight)));
          currentX + paddedWidth > maxTextureWidth && (currentY += maxCharHeight, maxCharHeight = paddedHeight, currentX = 0, currentY + maxCharHeight > maxTextureHeight && (textureSource.update(), textureSource = this._nextPage(), canvas = textureSource.canvasAndContext.canvas, context = textureSource.canvasAndContext.context, textureSource = textureSource.texture.source, currentY = 0));
          width = width / fontScale - (pageData.dropShadow?.distance ?? 0) - (pageData._stroke?.width ?? 0);
          this.chars[char] = {id:char.codePointAt(0), xOffset:-this._padding, yOffset:-this._padding, xAdvance:width, kerning:{}};
          skipTexture && (this._drawGlyph(context, metrics, currentX + padding, currentY + padding, fontScale, pageData), skipTexture = textureSource.width * fontScale, metrics = textureSource.height * fontScale, paddedHeight = new Rectangle.Rectangle(currentX / skipTexture * textureSource.width, currentY / metrics * textureSource.height, paddedWidth / skipTexture * textureSource.width, paddedHeight / metrics * textureSource.height), this.chars[char].texture = new Texture.Texture({source:textureSource, 
          frame:paddedHeight}), currentX += Math.ceil(paddedWidth));
        }
        textureSource.update();
        this._currentX = currentX;
        this._currentY = currentY;
        this._skipKerning && this._applyKerning(chars, context);
      }
    }
    get pageTextures() {
      deprecation.deprecation(deprecation.v8_0_0, "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.");
      return this.pages;
    }
    _applyKerning(newChars, context) {
      const measureCache = this._measureCache;
      for (let i = 0; i < newChars.length; i++) {
        const first = newChars[i];
        for (let j = 0; j < this._currentChars.length; j++) {
          const second = this._currentChars[j];
          let c1 = measureCache[first];
          c1 || (c1 = measureCache[first] = context.measureText(first).width);
          let c2 = measureCache[second];
          c2 || (c2 = measureCache[second] = context.measureText(second).width);
          var total = context.measureText(first + second).width;
          (total -= c1 + c2) && (this.chars[first].kerning[second] = total);
          total = context.measureText(first + second).width;
          (total -= c1 + c2) && (this.chars[second].kerning[first] = total);
        }
      }
    }
    _nextPage() {
      this._currentPageIndex++;
      var textureResolution = this.resolution, canvasAndContext = CanvasPool.CanvasPool.getOptimalCanvasAndContext(this._textureSize, this._textureSize, textureResolution);
      this._setupContext(canvasAndContext.context, this._style, textureResolution);
      textureResolution = new Texture.Texture({source:new ImageSource.ImageSource({resource:canvasAndContext.canvas, resolution:this.baseRenderedFontSize / this.baseMeasurementFontSize * textureResolution, alphaMode:"premultiply-alpha-on-upload", autoGenerateMipmaps:this._mipmap})});
      canvasAndContext = {canvasAndContext, texture:textureResolution};
      return this.pages[this._currentPageIndex] = canvasAndContext;
    }
    _setupContext(context, style, resolution) {
      style.fontSize = this.baseRenderedFontSize;
      context.scale(resolution, resolution);
      context.font = fontStringFromTextStyle.fontStringFromTextStyle(style);
      style.fontSize = this.baseMeasurementFontSize;
      context.textBaseline = style.textBaseline;
      var stroke = style._stroke, strokeThickness = stroke?.width ?? 0;
      stroke && (context.lineWidth = strokeThickness, context.lineJoin = stroke.join, context.miterLimit = stroke.miterLimit, context.strokeStyle = getCanvasFillStyle.getCanvasFillStyle(stroke, context));
      style._fill && (context.fillStyle = getCanvasFillStyle.getCanvasFillStyle(style._fill, context));
      style.dropShadow ? (style = style.dropShadow, stroke = Color.Color.shared.setValue(style.color).toArray(), strokeThickness = style.blur * resolution, resolution *= style.distance, context.shadowColor = `rgba(${255 * stroke[0]},${255 * stroke[1]},${255 * stroke[2]},${style.alpha})`, context.shadowBlur = strokeThickness, context.shadowOffsetX = Math.cos(style.angle) * resolution, context.shadowOffsetY = Math.sin(style.angle) * resolution) : (context.shadowColor = "black", context.shadowBlur = 
      0, context.shadowOffsetX = 0, context.shadowOffsetY = 0);
    }
    _drawGlyph(context, metrics, x, y, fontScale, style) {
      const char = metrics.text, strokeThickness = (style._stroke?.width ?? 0) * fontScale;
      x += strokeThickness / 2;
      y -= strokeThickness / 2;
      const descent = metrics.fontProperties.descent * fontScale;
      metrics = metrics.lineHeight * fontScale;
      style.stroke && strokeThickness && context.strokeText(char, x, y + metrics - descent);
      style._fill && context.fillText(char, x, y + metrics - descent);
    }
    destroy() {
      super.destroy();
      for (let i = 0; i < this.pages.length; i++) {
        const {canvasAndContext, texture} = this.pages[i];
        CanvasPool.CanvasPool.returnCanvasAndContext(canvasAndContext);
        texture.destroy(!0);
      }
      this.pages = null;
    }
  };
  require = node_modules$pixi_DOT_js$lib$scene$text_bitmap$DynamicBitmapFont$classdecl$var18;
  require.defaultOptions = {textureSize:512, style:new global.TextStyle(), mipmap:!0};
  exports.DynamicBitmapFont = require;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$scene$text_bitmap$DynamicBitmapFont.js.map
