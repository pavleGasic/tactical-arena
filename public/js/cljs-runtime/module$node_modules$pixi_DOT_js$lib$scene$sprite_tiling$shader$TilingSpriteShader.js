shadow$provide.module$node_modules$pixi_DOT_js$lib$scene$sprite_tiling$shader$TilingSpriteShader = function(global, require, module, exports) {
  var Matrix = require("module$node_modules$pixi_DOT_js$lib$maths$matrix$Matrix"), compileHighShaderToProgram = require("module$node_modules$pixi_DOT_js$lib$rendering$high_shader$compileHighShaderToProgram"), localUniformBit = require("module$node_modules$pixi_DOT_js$lib$rendering$high_shader$shader_bits$localUniformBit"), roundPixelsBit = require("module$node_modules$pixi_DOT_js$lib$rendering$high_shader$shader_bits$roundPixelsBit");
  global = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$shader$Shader");
  var UniformGroup = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$shader$UniformGroup"), Texture = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$texture$Texture"), tilingBit = require("module$node_modules$pixi_DOT_js$lib$scene$sprite_tiling$shader$tilingBit");
  "use strict";
  let gpuProgram, glProgram;
  class TilingSpriteShader extends global.Shader {
    constructor() {
      gpuProgram ?? (gpuProgram = compileHighShaderToProgram.compileHighShaderGpuProgram({name:"tiling-sprite-shader", bits:[localUniformBit.localUniformBit, tilingBit.tilingBit, roundPixelsBit.roundPixelsBit]}));
      glProgram ?? (glProgram = compileHighShaderToProgram.compileHighShaderGlProgram({name:"tiling-sprite-shader", bits:[localUniformBit.localUniformBitGl, tilingBit.tilingBitGl, roundPixelsBit.roundPixelsBitGl]}));
      const tilingUniforms = new UniformGroup.UniformGroup({uMapCoord:{value:new Matrix.Matrix(), type:"mat3x3\x3cf32\x3e"}, uClampFrame:{value:new Float32Array([0, 0, 1, 1]), type:"vec4\x3cf32\x3e"}, uClampOffset:{value:new Float32Array([0, 0]), type:"vec2\x3cf32\x3e"}, uTextureTransform:{value:new Matrix.Matrix(), type:"mat3x3\x3cf32\x3e"}, uSizeAnchor:{value:new Float32Array([100, 100, 0.5, 0.5]), type:"vec4\x3cf32\x3e"}});
      super({glProgram, gpuProgram, resources:{localUniforms:new UniformGroup.UniformGroup({uTransformMatrix:{value:new Matrix.Matrix(), type:"mat3x3\x3cf32\x3e"}, uColor:{value:new Float32Array([1, 1, 1, 1]), type:"vec4\x3cf32\x3e"}, uRound:{value:0, type:"f32"}}), tilingUniforms, uTexture:Texture.Texture.EMPTY.source, uSampler:Texture.Texture.EMPTY.source.style}});
    }
    updateUniforms(width, height, matrix, anchorX, anchorY, texture) {
      const tilingUniforms = this.resources.tilingUniforms, textureWidth = texture.width, textureHeight = texture.height, textureMatrix = texture.textureMatrix, uTextureTransform = tilingUniforms.uniforms.uTextureTransform;
      uTextureTransform.set(matrix.a * textureWidth / width, matrix.b * textureWidth / height, matrix.c * textureHeight / width, matrix.d * textureHeight / height, matrix.tx / width, matrix.ty / height);
      uTextureTransform.invert();
      tilingUniforms.uniforms.uMapCoord = textureMatrix.mapCoord;
      tilingUniforms.uniforms.uClampFrame = textureMatrix.uClampFrame;
      tilingUniforms.uniforms.uClampOffset = textureMatrix.uClampOffset;
      tilingUniforms.uniforms.uTextureTransform = uTextureTransform;
      tilingUniforms.uniforms.uSizeAnchor[0] = width;
      tilingUniforms.uniforms.uSizeAnchor[1] = height;
      tilingUniforms.uniforms.uSizeAnchor[2] = anchorX;
      tilingUniforms.uniforms.uSizeAnchor[3] = anchorY;
      texture && (this.resources.uTexture = texture.source, this.resources.uSampler = texture.source.style);
    }
  }
  exports.TilingSpriteShader = TilingSpriteShader;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$scene$sprite_tiling$shader$TilingSpriteShader.js.map
