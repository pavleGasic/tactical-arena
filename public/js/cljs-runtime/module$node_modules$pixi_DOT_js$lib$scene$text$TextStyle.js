shadow$provide.module$node_modules$pixi_DOT_js$lib$scene$text$TextStyle = function(global, require, module, exports) {
  function convertV7Tov8Style(style) {
    if ("boolean" === typeof style.dropShadow && style.dropShadow) {
      var defaults = TextStyle.defaultDropShadow;
      style.dropShadow = {alpha:style.dropShadowAlpha ?? defaults.alpha, angle:style.dropShadowAngle ?? defaults.angle, blur:style.dropShadowBlur ?? defaults.blur, color:style.dropShadowColor ?? defaults.color, distance:style.dropShadowDistance ?? defaults.distance};
    }
    if (void 0 !== style.strokeThickness) {
      deprecation.deprecation(deprecation.v8_0_0, "strokeThickness is now a part of stroke");
      defaults = style.stroke;
      let obj = {};
      if (Color.Color.isColorLike(defaults)) {
        obj.color = defaults;
      } else if (defaults instanceof FillGradient.FillGradient || defaults instanceof FillPattern.FillPattern) {
        obj.fill = defaults;
      } else if (Object.hasOwnProperty.call(defaults, "color") || Object.hasOwnProperty.call(defaults, "fill")) {
        obj = defaults;
      } else {
        throw Error("Invalid stroke value.");
      }
      style.stroke = {...obj, width:style.strokeThickness};
    }
    if (Array.isArray(style.fillGradientStops)) {
      deprecation.deprecation(deprecation.v8_0_0, "gradient fill is now a fill pattern: `new FillGradient(...)`");
      let fontSize;
      null == style.fontSize ? style.fontSize = TextStyle.defaultTextStyle.fontSize : fontSize = "string" === typeof style.fontSize ? parseInt(style.fontSize, 10) : style.fontSize;
      const gradientFill = new FillGradient.FillGradient({start:{x:0, y:0}, end:{x:0, y:1.7 * (fontSize || 0)}}), fills = style.fillGradientStops.map(color => Color.Color.shared.setValue(color).toNumber());
      fills.forEach((number, index) => {
        gradientFill.addColorStop(index / (fills.length - 1), number);
      });
      style.fill = {fill:gradientFill};
    }
  }
  global = require("module$node_modules$eventemitter3$index");
  var Color = require("module$node_modules$pixi_DOT_js$lib$color$Color"), deprecation = require("module$node_modules$pixi_DOT_js$lib$utils$logging$deprecation"), FillGradient = require("module$node_modules$pixi_DOT_js$lib$scene$graphics$shared$fill$FillGradient"), FillPattern = require("module$node_modules$pixi_DOT_js$lib$scene$graphics$shared$fill$FillPattern"), GraphicsContext = require("module$node_modules$pixi_DOT_js$lib$scene$graphics$shared$GraphicsContext"), convertFillInputToFillStyle = require("module$node_modules$pixi_DOT_js$lib$scene$graphics$shared$utils$convertFillInputToFillStyle"), 
  generateTextStyleKey = require("module$node_modules$pixi_DOT_js$lib$scene$text$utils$generateTextStyleKey");
  "use strict";
  const node_modules$pixi_DOT_js$lib$scene$text$TextStyle$classdecl$var16 = class extends global {
    constructor(style = {}) {
      super();
      convertV7Tov8Style(style);
      style = {...node_modules$pixi_DOT_js$lib$scene$text$TextStyle$classdecl$var16.defaultTextStyle, ...style};
      for (const key in style) {
        this[key] = style[key];
      }
      this.update();
    }
    get align() {
      return this._align;
    }
    set align(value) {
      this._align = value;
      this.update();
    }
    get breakWords() {
      return this._breakWords;
    }
    set breakWords(value) {
      this._breakWords = value;
      this.update();
    }
    get dropShadow() {
      return this._dropShadow;
    }
    set dropShadow(value) {
      this._dropShadow = null !== value && "object" === typeof value ? this._createProxy({...node_modules$pixi_DOT_js$lib$scene$text$TextStyle$classdecl$var16.defaultDropShadow, ...value}) : value ? this._createProxy({...node_modules$pixi_DOT_js$lib$scene$text$TextStyle$classdecl$var16.defaultDropShadow}) : null;
      this.update();
    }
    get fontFamily() {
      return this._fontFamily;
    }
    set fontFamily(value) {
      this._fontFamily = value;
      this.update();
    }
    get fontSize() {
      return this._fontSize;
    }
    set fontSize(value) {
      this._fontSize = "string" === typeof value ? parseInt(value, 10) : value;
      this.update();
    }
    get fontStyle() {
      return this._fontStyle;
    }
    set fontStyle(value) {
      this._fontStyle = value.toLowerCase();
      this.update();
    }
    get fontVariant() {
      return this._fontVariant;
    }
    set fontVariant(value) {
      this._fontVariant = value;
      this.update();
    }
    get fontWeight() {
      return this._fontWeight;
    }
    set fontWeight(value) {
      this._fontWeight = value;
      this.update();
    }
    get leading() {
      return this._leading;
    }
    set leading(value) {
      this._leading = value;
      this.update();
    }
    get letterSpacing() {
      return this._letterSpacing;
    }
    set letterSpacing(value) {
      this._letterSpacing = value;
      this.update();
    }
    get lineHeight() {
      return this._lineHeight;
    }
    set lineHeight(value) {
      this._lineHeight = value;
      this.update();
    }
    get padding() {
      return this._padding;
    }
    set padding(value) {
      this._padding = value;
      this.update();
    }
    get trim() {
      return this._trim;
    }
    set trim(value) {
      this._trim = value;
      this.update();
    }
    get textBaseline() {
      return this._textBaseline;
    }
    set textBaseline(value) {
      this._textBaseline = value;
      this.update();
    }
    get whiteSpace() {
      return this._whiteSpace;
    }
    set whiteSpace(value) {
      this._whiteSpace = value;
      this.update();
    }
    get wordWrap() {
      return this._wordWrap;
    }
    set wordWrap(value) {
      this._wordWrap = value;
      this.update();
    }
    get wordWrapWidth() {
      return this._wordWrapWidth;
    }
    set wordWrapWidth(value) {
      this._wordWrapWidth = value;
      this.update();
    }
    get fill() {
      return this._originalFill;
    }
    set fill(value) {
      value !== this._originalFill && (this._originalFill = value, this._isFillStyle(value) && (this._originalFill = this._createProxy({...GraphicsContext.GraphicsContext.defaultFillStyle, ...value}, () => {
        this._fill = convertFillInputToFillStyle.toFillStyle({...this._originalFill}, GraphicsContext.GraphicsContext.defaultFillStyle);
      })), this._fill = convertFillInputToFillStyle.toFillStyle(0 === value ? "black" : value, GraphicsContext.GraphicsContext.defaultFillStyle), this.update());
    }
    get stroke() {
      return this._originalStroke;
    }
    set stroke(value) {
      value !== this._originalStroke && (this._originalStroke = value, this._isFillStyle(value) && (this._originalStroke = this._createProxy({...GraphicsContext.GraphicsContext.defaultStrokeStyle, ...value}, () => {
        this._stroke = convertFillInputToFillStyle.toStrokeStyle({...this._originalStroke}, GraphicsContext.GraphicsContext.defaultStrokeStyle);
      })), this._stroke = convertFillInputToFillStyle.toStrokeStyle(value, GraphicsContext.GraphicsContext.defaultStrokeStyle), this.update());
    }
    _generateKey() {
      return this._styleKey = generateTextStyleKey.generateTextStyleKey(this);
    }
    update() {
      this._styleKey = null;
      this.emit("update", this);
    }
    reset() {
      const defaultStyle = node_modules$pixi_DOT_js$lib$scene$text$TextStyle$classdecl$var16.defaultTextStyle;
      for (const key in defaultStyle) {
        this[key] = defaultStyle[key];
      }
    }
    get styleKey() {
      return this._styleKey || this._generateKey();
    }
    clone() {
      return new node_modules$pixi_DOT_js$lib$scene$text$TextStyle$classdecl$var16({align:this.align, breakWords:this.breakWords, dropShadow:this._dropShadow ? {...this._dropShadow} : null, fill:this._fill, fontFamily:this.fontFamily, fontSize:this.fontSize, fontStyle:this.fontStyle, fontVariant:this.fontVariant, fontWeight:this.fontWeight, leading:this.leading, letterSpacing:this.letterSpacing, lineHeight:this.lineHeight, padding:this.padding, stroke:this._stroke, textBaseline:this.textBaseline, 
      whiteSpace:this.whiteSpace, wordWrap:this.wordWrap, wordWrapWidth:this.wordWrapWidth});
    }
    destroy(options = !1) {
      this.removeAllListeners();
      if ("boolean" === typeof options ? options : options?.texture) {
        options = "boolean" === typeof options ? options : options?.textureSource, this._fill?.texture && this._fill.texture.destroy(options), this._originalFill?.texture && this._originalFill.texture.destroy(options), this._stroke?.texture && this._stroke.texture.destroy(options), this._originalStroke?.texture && this._originalStroke.texture.destroy(options);
      }
      this._originalFill = this._originalStroke = this.dropShadow = this._stroke = this._fill = null;
    }
    _createProxy(value, cb) {
      return new Proxy(value, {set:(target, property, newValue) => {
        target[property] = newValue;
        cb?.(property, newValue);
        this.update();
        return !0;
      }});
    }
    _isFillStyle(value) {
      return null !== (value ?? null) && !(Color.Color.isColorLike(value) || value instanceof FillGradient.FillGradient || value instanceof FillPattern.FillPattern);
    }
  };
  require = node_modules$pixi_DOT_js$lib$scene$text$TextStyle$classdecl$var16;
  require.defaultDropShadow = {alpha:1, angle:Math.PI / 6, blur:0, color:"black", distance:5};
  require.defaultTextStyle = {align:"left", breakWords:!1, dropShadow:null, fill:"black", fontFamily:"Arial", fontSize:26, fontStyle:"normal", fontVariant:"normal", fontWeight:"normal", leading:0, letterSpacing:0, lineHeight:0, padding:0, stroke:null, textBaseline:"alphabetic", trim:!1, whiteSpace:"pre", wordWrap:!1, wordWrapWidth:100};
  let TextStyle = require;
  exports.TextStyle = TextStyle;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$scene$text$TextStyle.js.map
