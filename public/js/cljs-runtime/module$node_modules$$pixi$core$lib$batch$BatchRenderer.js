shadow$provide.module$node_modules$$pixi$core$lib$batch$BatchRenderer = function(global, require, module, exports) {
  var color = require("module$node_modules$$pixi$color$lib$index"), constants = require("module$node_modules$$pixi$constants$lib$index");
  global = require("module$node_modules$$pixi$extensions$lib$index");
  var settings = require("module$node_modules$$pixi$settings$lib$index"), utils = require("module$node_modules$$pixi$utils$lib$index"), ViewableBuffer = require("module$node_modules$$pixi$core$lib$geometry$ViewableBuffer"), checkMaxIfStatementsInShader = require("module$node_modules$$pixi$core$lib$shader$utils$checkMaxIfStatementsInShader"), State = require("module$node_modules$$pixi$core$lib$state$State"), BaseTexture = require("module$node_modules$$pixi$core$lib$textures$BaseTexture"), BatchDrawCall = 
  require("module$node_modules$$pixi$core$lib$batch$BatchDrawCall"), BatchGeometry = require("module$node_modules$$pixi$core$lib$batch$BatchGeometry"), BatchShaderGenerator = require("module$node_modules$$pixi$core$lib$batch$BatchShaderGenerator"), BatchTextureArray = require("module$node_modules$$pixi$core$lib$batch$BatchTextureArray"), canUploadSameBuffer = require("module$node_modules$$pixi$core$lib$batch$canUploadSameBuffer"), maxRecommendedTextures = require("module$node_modules$$pixi$core$lib$batch$maxRecommendedTextures");
  module = require("module$node_modules$$pixi$core$lib$batch$ObjectRenderer");
  var texture$1 = require("module$node_modules$$pixi$core$lib$batch$texture_frag"), texture = require("module$node_modules$$pixi$core$lib$batch$texture_vert");
  const node_modules$$pixi$core$lib$batch$BatchRenderer$classdecl$var3 = class extends module.ObjectRenderer {
    constructor(renderer) {
      super(renderer);
      this.setShaderGenerator();
      this.geometryClass = BatchGeometry.BatchGeometry;
      this.vertexSize = 6;
      this.state = State.State.for2d();
      this.size = 4 * node_modules$$pixi$core$lib$batch$BatchRenderer$classdecl$var3.defaultBatchSize;
      this._indexCount = this._vertexCount = 0;
      this._bufferedElements = [];
      this._bufferedTextures = [];
      this._bufferSize = 0;
      this._shader = null;
      this._packedGeometries = [];
      this._packedGeometryPoolSize = 2;
      this._flushId = 0;
      this._aBuffers = {};
      this._iBuffers = {};
      this.maxTextures = 1;
      this.renderer.on("prerender", this.onPrerender, this);
      renderer.runners.contextChange.add(this);
      this._iIndex = this._aIndex = this._dcIndex = 0;
      this._indexBuffer = this._attributeBuffer = null;
      this._tempBoundTextures = [];
    }
    static get defaultMaxTextures() {
      return this._defaultMaxTextures = this._defaultMaxTextures ?? maxRecommendedTextures.maxRecommendedTextures(32), this._defaultMaxTextures;
    }
    static set defaultMaxTextures(value) {
      this._defaultMaxTextures = value;
    }
    static get canUploadSameBuffer() {
      return this._canUploadSameBuffer = this._canUploadSameBuffer ?? canUploadSameBuffer.canUploadSameBuffer(), this._canUploadSameBuffer;
    }
    static set canUploadSameBuffer(value) {
      this._canUploadSameBuffer = value;
    }
    get MAX_TEXTURES() {
      return utils.deprecation("7.1.0", "BatchRenderer#MAX_TEXTURES renamed to BatchRenderer#maxTextures"), this.maxTextures;
    }
    static get defaultVertexSrc() {
      return texture.default;
    }
    static get defaultFragmentTemplate() {
      return texture$1.default;
    }
    setShaderGenerator({vertex = node_modules$$pixi$core$lib$batch$BatchRenderer$classdecl$var3.defaultVertexSrc, fragment = node_modules$$pixi$core$lib$batch$BatchRenderer$classdecl$var3.defaultFragmentTemplate} = {}) {
      this.shaderGenerator = new BatchShaderGenerator.BatchShaderGenerator(vertex, fragment);
    }
    contextChange() {
      var gl = this.renderer.gl;
      settings.settings.PREFER_ENV === constants.ENV.WEBGL_LEGACY ? this.maxTextures = 1 : (this.maxTextures = Math.min(gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS), node_modules$$pixi$core$lib$batch$BatchRenderer$classdecl$var3.defaultMaxTextures), this.maxTextures = checkMaxIfStatementsInShader.checkMaxIfStatementsInShader(this.maxTextures, gl));
      this._shader = this.shaderGenerator.generateShader(this.maxTextures);
      for (gl = 0; gl < this._packedGeometryPoolSize; gl++) {
        this._packedGeometries[gl] = new this.geometryClass();
      }
      this.initFlushBuffers();
    }
    initFlushBuffers() {
      const {_drawCallPool, _textureArrayPool} = node_modules$$pixi$core$lib$batch$BatchRenderer$classdecl$var3;
      var MAX_SPRITES = this.size / 4;
      const MAX_TA = Math.floor(MAX_SPRITES / this.maxTextures) + 1;
      for (; _drawCallPool.length < MAX_SPRITES;) {
        _drawCallPool.push(new BatchDrawCall.BatchDrawCall());
      }
      for (; _textureArrayPool.length < MAX_TA;) {
        _textureArrayPool.push(new BatchTextureArray.BatchTextureArray());
      }
      for (MAX_SPRITES = 0; MAX_SPRITES < this.maxTextures; MAX_SPRITES++) {
        this._tempBoundTextures[MAX_SPRITES] = null;
      }
    }
    onPrerender() {
      this._flushId = 0;
    }
    render(element) {
      element._texture.valid && (this._vertexCount + element.vertexData.length / 2 > this.size && this.flush(), this._vertexCount += element.vertexData.length / 2, this._indexCount += element.indices.length, this._bufferedTextures[this._bufferSize] = element._texture.baseTexture, this._bufferedElements[this._bufferSize++] = element);
    }
    buildTexturesAndDrawCalls() {
      const {_bufferedTextures:textures, maxTextures} = this;
      var textureArrays = node_modules$$pixi$core$lib$batch$BatchRenderer$classdecl$var3._textureArrayPool;
      const batch = this.renderer.batch, boundTextures = this._tempBoundTextures, touch = this.renderer.textureGC.count;
      let TICK = ++BaseTexture.BaseTexture._globalBatch, countTexArrays = 0, texArray = textureArrays[0], start = 0;
      batch.copyBoundTextures(boundTextures, maxTextures);
      for (let i = 0; i < this._bufferSize; ++i) {
        const tex = textures[i];
        textures[i] = null;
        tex._batchEnabled !== TICK && (texArray.count >= maxTextures && (batch.boundArray(texArray, boundTextures, TICK, maxTextures), this.buildDrawCalls(texArray, start, i), start = i, texArray = textureArrays[++countTexArrays], ++TICK), tex._batchEnabled = TICK, tex.touched = touch, texArray.elements[texArray.count++] = tex);
      }
      0 < texArray.count && (batch.boundArray(texArray, boundTextures, TICK, maxTextures), this.buildDrawCalls(texArray, start, this._bufferSize), ++countTexArrays, ++TICK);
      for (textureArrays = 0; textureArrays < boundTextures.length; textureArrays++) {
        boundTextures[textureArrays] = null;
      }
      BaseTexture.BaseTexture._globalBatch = TICK;
    }
    buildDrawCalls(texArray, start, finish) {
      const {_bufferedElements:elements, _attributeBuffer, _indexBuffer, vertexSize} = this, drawCalls = node_modules$$pixi$core$lib$batch$BatchRenderer$classdecl$var3._drawCallPool;
      let dcIndex = this._dcIndex, aIndex = this._aIndex, iIndex = this._iIndex, drawCall = drawCalls[dcIndex];
      drawCall.start = this._iIndex;
      drawCall.texArray = texArray;
      for (let i = start; i < finish; ++i) {
        const sprite = elements[i], spriteBlendMode = utils.premultiplyBlendMode[sprite._texture.baseTexture.alphaMode ? 1 : 0][sprite.blendMode];
        elements[i] = null;
        start < i && drawCall.blend !== spriteBlendMode && (drawCall.size = iIndex - drawCall.start, start = i, drawCall = drawCalls[++dcIndex], drawCall.texArray = texArray, drawCall.start = iIndex);
        this.packInterleavedGeometry(sprite, _attributeBuffer, _indexBuffer, aIndex, iIndex);
        aIndex += sprite.vertexData.length / 2 * vertexSize;
        iIndex += sprite.indices.length;
        drawCall.blend = spriteBlendMode;
      }
      start < finish && (drawCall.size = iIndex - drawCall.start, ++dcIndex);
      this._dcIndex = dcIndex;
      this._aIndex = aIndex;
      this._iIndex = iIndex;
    }
    bindAndClearTexArray(texArray) {
      const textureSystem = this.renderer.texture;
      for (let j = 0; j < texArray.count; j++) {
        textureSystem.bind(texArray.elements[j], texArray.ids[j]), texArray.elements[j] = null;
      }
      texArray.count = 0;
    }
    updateGeometry() {
      const {_packedGeometries:packedGeometries, _attributeBuffer:attributeBuffer, _indexBuffer:indexBuffer} = this;
      node_modules$$pixi$core$lib$batch$BatchRenderer$classdecl$var3.canUploadSameBuffer ? (packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData), packedGeometries[this._flushId]._indexBuffer.update(indexBuffer), this.renderer.geometry.updateBuffers()) : (this._packedGeometryPoolSize <= this._flushId && (this._packedGeometryPoolSize++, packedGeometries[this._flushId] = new this.geometryClass()), packedGeometries[this._flushId]._buffer.update(attributeBuffer.rawBinaryData), 
      packedGeometries[this._flushId]._indexBuffer.update(indexBuffer), this.renderer.geometry.bind(packedGeometries[this._flushId]), this.renderer.geometry.updateBuffers(), this._flushId++);
    }
    drawBatches() {
      const dcCount = this._dcIndex, {gl, state:stateSystem} = this.renderer, drawCalls = node_modules$$pixi$core$lib$batch$BatchRenderer$classdecl$var3._drawCallPool;
      let curTexArray = null;
      for (let i = 0; i < dcCount; i++) {
        const {texArray, type, size, start, blend} = drawCalls[i];
        curTexArray !== texArray && (curTexArray = texArray, this.bindAndClearTexArray(texArray));
        this.state.blendMode = blend;
        stateSystem.set(this.state);
        gl.drawElements(type, size, gl.UNSIGNED_SHORT, 2 * start);
      }
    }
    flush() {
      0 !== this._vertexCount && (this._attributeBuffer = this.getAttributeBuffer(this._vertexCount), this._indexBuffer = this.getIndexBuffer(this._indexCount), this._aIndex = 0, this._iIndex = 0, this._dcIndex = 0, this.buildTexturesAndDrawCalls(), this.updateGeometry(), this.drawBatches(), this._bufferSize = 0, this._vertexCount = 0, this._indexCount = 0);
    }
    start() {
      this.renderer.state.set(this.state);
      this.renderer.texture.ensureSamplerType(this.maxTextures);
      this.renderer.shader.bind(this._shader);
      node_modules$$pixi$core$lib$batch$BatchRenderer$classdecl$var3.canUploadSameBuffer && this.renderer.geometry.bind(this._packedGeometries[this._flushId]);
    }
    stop() {
      this.flush();
    }
    destroy() {
      for (let i = 0; i < this._packedGeometryPoolSize; i++) {
        this._packedGeometries[i] && this._packedGeometries[i].destroy();
      }
      this.renderer.off("prerender", this.onPrerender, this);
      this._indexBuffer = this._attributeBuffer = this._packedGeometries = this._iBuffers = this._aBuffers = null;
      this._shader && (this._shader.destroy(), this._shader = null);
      super.destroy();
    }
    getAttributeBuffer(size) {
      var roundedP2 = utils.nextPow2(Math.ceil(size / 8));
      size = utils.log2(roundedP2);
      roundedP2 *= 8;
      this._aBuffers.length <= size && (this._iBuffers.length = size + 1);
      size = this._aBuffers[roundedP2];
      return size || (this._aBuffers[roundedP2] = size = new ViewableBuffer.ViewableBuffer(roundedP2 * this.vertexSize * 4)), size;
    }
    getIndexBuffer(size) {
      size = utils.nextPow2(Math.ceil(size / 12));
      const roundedSizeIndex = utils.log2(size);
      this._iBuffers.length <= roundedSizeIndex && (this._iBuffers.length = roundedSizeIndex + 1);
      let buffer = this._iBuffers[roundedSizeIndex];
      return buffer || (this._iBuffers[roundedSizeIndex] = buffer = new Uint16Array(12 * size)), buffer;
    }
    packInterleavedGeometry(element, attributeBuffer, indexBuffer, aIndex, iIndex) {
      const {uint32View, float32View} = attributeBuffer;
      attributeBuffer = aIndex / this.vertexSize;
      const uvs = element.uvs, indicies = element.indices, vertexData = element.vertexData, textureId = element._texture.baseTexture._batchLocation;
      var alpha = Math.min(element.worldAlpha, 1);
      element = color.Color.shared.setValue(element._tintRGB).toPremultiplied(alpha, 0 < element._texture.baseTexture.alphaMode);
      for (alpha = 0; alpha < vertexData.length; alpha += 2) {
        float32View[aIndex++] = vertexData[alpha], float32View[aIndex++] = vertexData[alpha + 1], float32View[aIndex++] = uvs[alpha], float32View[aIndex++] = uvs[alpha + 1], uint32View[aIndex++] = element, float32View[aIndex++] = textureId;
      }
      for (aIndex = 0; aIndex < indicies.length; aIndex++) {
        indexBuffer[iIndex++] = attributeBuffer + indicies[aIndex];
      }
    }
  };
  require = node_modules$$pixi$core$lib$batch$BatchRenderer$classdecl$var3;
  require.defaultBatchSize = 4096;
  require.extension = {name:"batch", type:global.ExtensionType.RendererPlugin};
  require._drawCallPool = [];
  require._textureArrayPool = [];
  global.extensions.add(require);
  exports.BatchRenderer = require;
};

//# sourceMappingURL=module$node_modules$$pixi$core$lib$batch$BatchRenderer.js.map
