shadow$provide.module$node_modules$pixi_DOT_js$lib$scene$text_bitmap$BitmapFontManager = function(global, require, module, exports) {
  var Cache = require("module$node_modules$pixi_DOT_js$lib$assets$cache$Cache"), deprecation = require("module$node_modules$pixi_DOT_js$lib$utils$logging$deprecation"), warn = require("module$node_modules$pixi_DOT_js$lib$utils$logging$warn"), TextStyle = require("module$node_modules$pixi_DOT_js$lib$scene$text$TextStyle"), DynamicBitmapFont = require("module$node_modules$pixi_DOT_js$lib$scene$text_bitmap$DynamicBitmapFont"), getBitmapTextLayout = require("module$node_modules$pixi_DOT_js$lib$scene$text_bitmap$utils$getBitmapTextLayout"), 
  resolveCharacters = require("module$node_modules$pixi_DOT_js$lib$scene$text_bitmap$utils$resolveCharacters");
  "use strict";
  let fontCount = 0;
  class BitmapFontManagerClass {
    constructor() {
      this.ALPHA = [["a", "z"], ["A", "Z"], " "];
      this.NUMERIC = [["0", "9"]];
      this.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "];
      this.ASCII = [[" ", "~"]];
      this.defaultOptions = {chars:this.ALPHANUMERIC, resolution:1, padding:4, skipKerning:!1};
    }
    getFont(text, style) {
      let fontFamilyKey = `${style.fontFamily}-bitmap`;
      var overrideFill = !0;
      if (style._fill.fill && !style._stroke) {
        fontFamilyKey += style._fill.fill.styleKey, overrideFill = !1;
      } else if (style._stroke || style.dropShadow) {
        overrideFill = style.styleKey, overrideFill = overrideFill.substring(0, overrideFill.lastIndexOf("-")), fontFamilyKey = `${overrideFill}-bitmap`, overrideFill = !1;
      }
      Cache.Cache.has(fontFamilyKey) || (style = new DynamicBitmapFont.DynamicBitmapFont({style, overrideFill, overrideSize:!0, ...this.defaultOptions}), fontCount++, 50 < fontCount && warn.warn("BitmapText", `You have dynamically created ${fontCount} bitmap fonts, this can be inefficient. Try pre installing your font styles using \`BitmapFont.install({name:"style1", style})\``), style.once("destroy", () => {
        fontCount--;
        Cache.Cache.remove(fontFamilyKey);
      }), Cache.Cache.set(fontFamilyKey, style));
      style = Cache.Cache.get(fontFamilyKey);
      style.ensureCharacters?.(text);
      return style;
    }
    getLayout(text, style, trimEnd = !0) {
      const bitmapFont = this.getFont(text, style);
      return getBitmapTextLayout.getBitmapTextLayout([...text], style, bitmapFont, trimEnd);
    }
    measureText(text, style, trimEnd = !0) {
      return this.getLayout(text, style, trimEnd);
    }
    install(...args) {
      var options = args[0];
      "string" === typeof options && (options = {name:options, style:args[1], chars:args[2]?.chars, resolution:args[2]?.resolution, padding:args[2]?.padding, skipKerning:args[2]?.skipKerning}, deprecation.deprecation(deprecation.v8_0_0, "BitmapFontManager.install(name, style, options) is deprecated, use BitmapFontManager.install({name, style, ...options})"));
      const name = options?.name;
      if (!name) {
        throw Error("[BitmapFontManager] Property `name` is required.");
      }
      options = {...this.defaultOptions, ...options};
      args = options.style;
      args = args instanceof TextStyle.TextStyle ? args : new TextStyle.TextStyle(args);
      args = new DynamicBitmapFont.DynamicBitmapFont({style:args, overrideFill:null !== args._fill.fill && void 0 !== args._fill.fill, skipKerning:options.skipKerning, padding:options.padding, resolution:options.resolution, overrideSize:!1});
      options = resolveCharacters.resolveCharacters(options.chars);
      args.ensureCharacters(options.join(""));
      Cache.Cache.set(`${name}-bitmap`, args);
      args.once("destroy", () => Cache.Cache.remove(`${name}-bitmap`));
      return args;
    }
    uninstall(name) {
      (name = Cache.Cache.get(`${name}-bitmap`)) && name.destroy();
    }
  }
  global = new BitmapFontManagerClass();
  exports.BitmapFontManager = global;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$scene$text_bitmap$BitmapFontManager.js.map
