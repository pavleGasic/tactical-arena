shadow$provide.module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$texture$RenderableGCSystem = function(global, require, module, exports) {
  global = require("module$node_modules$pixi_DOT_js$lib$extensions$Extensions");
  var clean = require("module$node_modules$pixi_DOT_js$lib$utils$data$clean");
  "use strict";
  let renderableGCTick = 0;
  const node_modules$pixi_DOT_js$lib$rendering$renderers$shared$texture$RenderableGCSystem$classdecl$var27 = class {
    constructor(renderer) {
      this._managedRenderables = [];
      this._managedHashes = [];
      this._managedArrays = [];
      this._renderer = renderer;
    }
    init(options) {
      options = {...node_modules$pixi_DOT_js$lib$rendering$renderers$shared$texture$RenderableGCSystem$classdecl$var27.defaultOptions, ...options};
      this.maxUnusedTime = options.renderableGCMaxUnusedTime;
      this._frequency = options.renderableGCFrequency;
      this.enabled = options.renderableGCActive;
    }
    get enabled() {
      return !!this._handler;
    }
    set enabled(value) {
      this.enabled !== value && (value ? (this._handler = this._renderer.scheduler.repeat(() => this.run(), this._frequency, !1), this._hashHandler = this._renderer.scheduler.repeat(() => {
        for (const hash of this._managedHashes) {
          hash.context[hash.hash] = clean.cleanHash(hash.context[hash.hash]);
        }
      }, this._frequency), this._arrayHandler = this._renderer.scheduler.repeat(() => {
        for (const array of this._managedArrays) {
          clean.cleanArray(array.context[array.hash]);
        }
      }, this._frequency)) : (this._renderer.scheduler.cancel(this._handler), this._renderer.scheduler.cancel(this._hashHandler), this._renderer.scheduler.cancel(this._arrayHandler)));
    }
    addManagedHash(context, hash) {
      this._managedHashes.push({context, hash});
    }
    addManagedArray(context, hash) {
      this._managedArrays.push({context, hash});
    }
    prerender({container}) {
      this._now = performance.now();
      container.renderGroup.gcTick = renderableGCTick++;
      this._updateInstructionGCTick(container.renderGroup, container.renderGroup.gcTick);
    }
    addRenderable(renderable) {
      this.enabled && (-1 === renderable._lastUsed && (this._managedRenderables.push(renderable), renderable.once("destroyed", this._removeRenderable, this)), renderable._lastUsed = this._now);
    }
    run() {
      const now = this._now, managedRenderables = this._managedRenderables, renderPipes = this._renderer.renderPipes;
      let offset = 0;
      for (let i = 0; i < managedRenderables.length; i++) {
        const renderable = managedRenderables[i];
        if (null === renderable) {
          offset++;
          continue;
        }
        const renderGroup = renderable.renderGroup ?? renderable.parentRenderGroup;
        (renderGroup?.gcTick ?? 0) === (renderGroup?.instructionSet?.gcTick ?? -1) && (renderable._lastUsed = now);
        if (now - renderable._lastUsed > this.maxUnusedTime) {
          if (!renderable.destroyed) {
            const rp = renderPipes;
            renderGroup && (renderGroup.structureDidChange = !0);
            rp[renderable.renderPipeId].destroyRenderable(renderable);
          }
          renderable._lastUsed = -1;
          offset++;
          renderable.off("destroyed", this._removeRenderable, this);
        } else {
          managedRenderables[i - offset] = renderable;
        }
      }
      managedRenderables.length -= offset;
    }
    destroy() {
      this.enabled = !1;
      this._renderer = null;
      this._managedRenderables.length = 0;
      this._managedHashes.length = 0;
      this._managedArrays.length = 0;
    }
    _removeRenderable(renderable) {
      const index = this._managedRenderables.indexOf(renderable);
      0 <= index && (renderable.off("destroyed", this._removeRenderable, this), this._managedRenderables[index] = null);
    }
    _updateInstructionGCTick(renderGroup, gcTick) {
      renderGroup.instructionSet.gcTick = gcTick;
      for (const child of renderGroup.renderGroupChildren) {
        this._updateInstructionGCTick(child, gcTick);
      }
    }
  };
  require = node_modules$pixi_DOT_js$lib$rendering$renderers$shared$texture$RenderableGCSystem$classdecl$var27;
  require.extension = {type:[global.ExtensionType.WebGLSystem, global.ExtensionType.WebGPUSystem], name:"renderableGC", priority:0};
  require.defaultOptions = {renderableGCActive:!0, renderableGCMaxUnusedTime:6e4, renderableGCFrequency:3e4};
  exports.RenderableGCSystem = require;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$texture$RenderableGCSystem.js.map
