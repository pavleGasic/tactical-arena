shadow$provide.module$node_modules$pixi_DOT_js$lib$scene$text$canvas$CanvasTextSystem = function(global, require, module, exports) {
  var Color = require("module$node_modules$pixi_DOT_js$lib$color$Color");
  global = require("module$node_modules$pixi_DOT_js$lib$extensions$Extensions");
  var pow2 = require("module$node_modules$pixi_DOT_js$lib$maths$misc$pow2"), CanvasPool = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$texture$CanvasPool"), TexturePool = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$texture$TexturePool"), getCanvasBoundingBox = require("module$node_modules$pixi_DOT_js$lib$utils$canvas$getCanvasBoundingBox"), deprecation = require("module$node_modules$pixi_DOT_js$lib$utils$logging$deprecation"), TextStyle = require("module$node_modules$pixi_DOT_js$lib$scene$text$TextStyle"), 
  getPo2TextureFromSource = require("module$node_modules$pixi_DOT_js$lib$scene$text$utils$getPo2TextureFromSource"), CanvasTextMetrics = require("module$node_modules$pixi_DOT_js$lib$scene$text$canvas$CanvasTextMetrics"), fontStringFromTextStyle = require("module$node_modules$pixi_DOT_js$lib$scene$text$canvas$utils$fontStringFromTextStyle"), getCanvasFillStyle = require("module$node_modules$pixi_DOT_js$lib$scene$text$canvas$utils$getCanvasFillStyle");
  "use strict";
  class CanvasTextSystem {
    constructor(_renderer) {
      this._activeTextures = {};
      this._renderer = _renderer;
    }
    getTextureSize(text, resolution, style) {
      const measured = CanvasTextMetrics.CanvasTextMetrics.measureText(text || " ", style);
      text = Math.ceil(Math.ceil(Math.max(1, measured.width) + 2 * style.padding) * resolution);
      resolution = Math.ceil(Math.ceil(Math.max(1, measured.height) + 2 * style.padding) * resolution);
      text = Math.ceil(text - 1e-6);
      resolution = Math.ceil(resolution - 1e-6);
      text = pow2.nextPow2(text);
      resolution = pow2.nextPow2(resolution);
      return {width:text, height:resolution};
    }
    getTexture(options, resolution, style, _textKey) {
      "string" === typeof options && (deprecation.deprecation("8.0.0", "CanvasTextSystem.getTexture: Use object TextOptions instead of separate arguments"), options = {text:options, style, resolution});
      options.style instanceof TextStyle.TextStyle || (options.style = new TextStyle.TextStyle(options.style));
      const {texture, canvasAndContext} = this.createTextureAndCanvas(options);
      this._renderer.texture.initSource(texture._source);
      CanvasPool.CanvasPool.returnCanvasAndContext(canvasAndContext);
      return texture;
    }
    createTextureAndCanvas(options) {
      const {text, style} = options;
      options = options.resolution ?? this._renderer.resolution;
      var measured = CanvasTextMetrics.CanvasTextMetrics.measureText(text || " ", style), width = Math.ceil(Math.ceil(Math.max(1, measured.width) + 2 * style.padding) * options);
      const height = Math.ceil(Math.ceil(Math.max(1, measured.height) + 2 * style.padding) * options);
      measured = CanvasPool.CanvasPool.getOptimalCanvasAndContext(width, height);
      const {canvas} = measured;
      this.renderTextToCanvas(text, style, options, measured);
      width = getPo2TextureFromSource.getPo2TextureFromSource(canvas, width, height, options);
      style.trim && (options = getCanvasBoundingBox.getCanvasBoundingBox(canvas, options), width.frame.copyFrom(options), width.updateUvs());
      return {texture:width, canvasAndContext:measured};
    }
    getManagedTexture(text) {
      text._resolution = text._autoResolution ? this._renderer.resolution : text.resolution;
      const textKey = text._getKey();
      if (this._activeTextures[textKey]) {
        return this._increaseReferenceCount(textKey), this._activeTextures[textKey].texture;
      }
      const {texture, canvasAndContext} = this.createTextureAndCanvas(text);
      this._activeTextures[textKey] = {canvasAndContext, texture, usageCount:1};
      return texture;
    }
    _increaseReferenceCount(textKey) {
      this._activeTextures[textKey].usageCount++;
    }
    returnTexture(texture) {
      const source = texture.source;
      source.resource = null;
      source.uploadMethodId = "unknown";
      source.alphaMode = "no-premultiply-alpha";
      TexturePool.TexturePool.returnTexture(texture);
    }
    decreaseReferenceCount(textKey) {
      const activeTexture = this._activeTextures[textKey];
      activeTexture.usageCount--;
      0 === activeTexture.usageCount && (CanvasPool.CanvasPool.returnCanvasAndContext(activeTexture.canvasAndContext), this.returnTexture(activeTexture.texture), this._activeTextures[textKey] = null);
    }
    getReferenceCount(textKey) {
      return this._activeTextures[textKey].usageCount;
    }
    renderTextToCanvas(text, style, resolution, canvasAndContext) {
      const {canvas, context} = canvasAndContext;
      var font = fontStringFromTextStyle.fontStringFromTextStyle(style);
      text = CanvasTextMetrics.CanvasTextMetrics.measureText(text || " ", style);
      const lines = text.lines, lineHeight = text.lineHeight, lineWidths = text.lineWidths, maxLineWidth = text.maxLineWidth, fontProperties = text.fontProperties, height = canvas.height;
      context.resetTransform();
      context.scale(resolution, resolution);
      context.textBaseline = style.textBaseline;
      if (style._stroke?.width) {
        var strokeStyle = style._stroke;
        context.lineWidth = strokeStyle.width;
        context.miterLimit = strokeStyle.miterLimit;
        context.lineJoin = strokeStyle.join;
        context.lineCap = strokeStyle.cap;
      }
      context.font = font;
      var linePositionY;
      font = style.dropShadow ? 2 : 1;
      for (strokeStyle = 0; strokeStyle < font; ++strokeStyle) {
        const dsOffsetText = (linePositionY = style.dropShadow && 0 === strokeStyle) ? Math.ceil(Math.max(1, height) + 2 * style.padding) : 0;
        var linePositionX = dsOffsetText * resolution;
        if (linePositionY) {
          context.fillStyle = "black";
          context.strokeStyle = "black";
          linePositionY = style.dropShadow;
          var dropShadowAlpha = linePositionY.alpha;
          context.shadowColor = Color.Color.shared.setValue(linePositionY.color).setAlpha(dropShadowAlpha).toRgbaString();
          dropShadowAlpha = linePositionY.distance * resolution;
          context.shadowBlur = linePositionY.blur * resolution;
          context.shadowOffsetX = Math.cos(linePositionY.angle) * dropShadowAlpha;
          context.shadowOffsetY = Math.sin(linePositionY.angle) * dropShadowAlpha + linePositionX;
        } else {
          context.fillStyle = style._fill ? getCanvasFillStyle.getCanvasFillStyle(style._fill, context, text) : null, style._stroke?.width && (context.strokeStyle = getCanvasFillStyle.getCanvasFillStyle(style._stroke, context, text, style._stroke.width * style._stroke.alignment)), context.shadowColor = "black";
        }
        dropShadowAlpha = (lineHeight - fontProperties.fontSize) / 2;
        0 > lineHeight - fontProperties.fontSize && (dropShadowAlpha = 0);
        const strokeWidth = style._stroke?.width ?? 0;
        for (let i2 = 0; i2 < lines.length; i2++) {
          linePositionX = strokeWidth / 2, linePositionY = strokeWidth / 2 + i2 * lineHeight + fontProperties.ascent + dropShadowAlpha, "right" === style.align ? linePositionX += maxLineWidth - lineWidths[i2] : "center" === style.align && (linePositionX += (maxLineWidth - lineWidths[i2]) / 2), style._stroke?.width && this._drawLetterSpacing(lines[i2], style, canvasAndContext, linePositionX + style.padding, linePositionY + style.padding - dsOffsetText, !0), void 0 !== style._fill && this._drawLetterSpacing(lines[i2], 
          style, canvasAndContext, linePositionX + style.padding, linePositionY + style.padding - dsOffsetText);
        }
      }
    }
    _drawLetterSpacing(text, style, canvasAndContext, x, y, isStroke = !1) {
      ({context:canvasAndContext} = canvasAndContext);
      style = style.letterSpacing;
      var useExperimentalLetterSpacing = !1;
      CanvasTextMetrics.CanvasTextMetrics.experimentalLetterSpacingSupported && (CanvasTextMetrics.CanvasTextMetrics.experimentalLetterSpacing ? (canvasAndContext.letterSpacing = `${style}px`, canvasAndContext.textLetterSpacing = `${style}px`, useExperimentalLetterSpacing = !0) : (canvasAndContext.letterSpacing = "0px", canvasAndContext.textLetterSpacing = "0px"));
      if (0 === style || useExperimentalLetterSpacing) {
        isStroke ? canvasAndContext.strokeText(text, x, y) : canvasAndContext.fillText(text, x, y);
      } else {
        useExperimentalLetterSpacing = CanvasTextMetrics.CanvasTextMetrics.graphemeSegmenter(text);
        text = canvasAndContext.measureText(text).width;
        for (let i = 0; i < useExperimentalLetterSpacing.length; ++i) {
          var currentWidth = useExperimentalLetterSpacing[i];
          isStroke ? canvasAndContext.strokeText(currentWidth, x, y) : canvasAndContext.fillText(currentWidth, x, y);
          currentWidth = "";
          for (let j = i + 1; j < useExperimentalLetterSpacing.length; ++j) {
            currentWidth += useExperimentalLetterSpacing[j];
          }
          currentWidth = canvasAndContext.measureText(currentWidth).width;
          x += text - currentWidth + style;
          text = currentWidth;
        }
      }
    }
    destroy() {
      this._activeTextures = null;
    }
  }
  CanvasTextSystem.extension = {type:[global.ExtensionType.WebGLSystem, global.ExtensionType.WebGPUSystem, global.ExtensionType.CanvasSystem], name:"canvasText"};
  exports.CanvasTextSystem = CanvasTextSystem;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$scene$text$canvas$CanvasTextSystem.js.map
