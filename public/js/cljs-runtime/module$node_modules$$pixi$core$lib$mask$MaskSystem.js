shadow$provide.module$node_modules$$pixi$core$lib$mask$MaskSystem = function(global, require, module, exports) {
  var constants = require("module$node_modules$$pixi$constants$lib$index");
  global = require("module$node_modules$$pixi$extensions$lib$index");
  var SpriteMaskFilter = require("module$node_modules$$pixi$core$lib$filters$spriteMask$SpriteMaskFilter"), MaskData = require("module$node_modules$$pixi$core$lib$mask$MaskData");
  class MaskSystem {
    constructor(renderer) {
      this.renderer = renderer;
      this.enableScissor = !0;
      this.alphaMaskPool = [];
      this.maskDataPool = [];
      this.maskStack = [];
      this.alphaMaskIndex = 0;
    }
    setMaskStack(maskStack) {
      this.maskStack = maskStack;
      this.renderer.scissor.setMaskStack(maskStack);
      this.renderer.stencil.setMaskStack(maskStack);
    }
    push(target, maskDataOrTarget) {
      var maskData = maskDataOrTarget;
      maskData.isMaskData || (maskData = this.maskDataPool.pop() || new MaskData.MaskData(), maskData.pooled = !0, maskData.maskObject = maskDataOrTarget);
      maskDataOrTarget = 0 !== this.maskStack.length ? this.maskStack[this.maskStack.length - 1] : null;
      if (maskData.copyCountersOrReset(maskDataOrTarget), maskData._colorMask = maskDataOrTarget ? maskDataOrTarget._colorMask : 15, maskData.autoDetect && this.detect(maskData), maskData._target = target, maskData.type !== constants.MASK_TYPES.SPRITE && this.maskStack.push(maskData), maskData.enabled) {
        switch(maskData.type) {
          case constants.MASK_TYPES.SCISSOR:
            this.renderer.scissor.push(maskData);
            break;
          case constants.MASK_TYPES.STENCIL:
            this.renderer.stencil.push(maskData);
            break;
          case constants.MASK_TYPES.SPRITE:
            maskData.copyCountersOrReset(null);
            this.pushSpriteMask(maskData);
            break;
          case constants.MASK_TYPES.COLOR:
            this.pushColorMask(maskData);
        }
      }
      maskData.type === constants.MASK_TYPES.SPRITE && this.maskStack.push(maskData);
    }
    pop(target) {
      const maskData = this.maskStack.pop();
      if (maskData && maskData._target === target) {
        if (maskData.enabled) {
          switch(maskData.type) {
            case constants.MASK_TYPES.SCISSOR:
              this.renderer.scissor.pop(maskData);
              break;
            case constants.MASK_TYPES.STENCIL:
              this.renderer.stencil.pop(maskData.maskObject);
              break;
            case constants.MASK_TYPES.SPRITE:
              this.popSpriteMask(maskData);
              break;
            case constants.MASK_TYPES.COLOR:
              this.popColorMask(maskData);
          }
        }
        if (maskData.reset(), maskData.pooled && this.maskDataPool.push(maskData), 0 !== this.maskStack.length) {
          target = this.maskStack[this.maskStack.length - 1], target.type === constants.MASK_TYPES.SPRITE && target._filters && (target._filters[0].maskSprite = target.maskObject);
        }
      }
    }
    detect(maskData) {
      const maskObject = maskData.maskObject;
      maskObject ? maskObject.isSprite ? maskData.type = constants.MASK_TYPES.SPRITE : this.enableScissor && this.renderer.scissor.testScissor(maskData) ? maskData.type = constants.MASK_TYPES.SCISSOR : maskData.type = constants.MASK_TYPES.STENCIL : maskData.type = constants.MASK_TYPES.COLOR;
    }
    pushSpriteMask(maskData) {
      const {maskObject} = maskData, target = maskData._target;
      let alphaMaskFilter = maskData._filters;
      alphaMaskFilter || (alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex], alphaMaskFilter || (alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex] = [new SpriteMaskFilter.SpriteMaskFilter()]));
      alphaMaskFilter[0].resolution = maskData.resolution;
      alphaMaskFilter[0].multisample = maskData.multisample;
      alphaMaskFilter[0].maskSprite = maskObject;
      const stashFilterArea = target.filterArea;
      target.filterArea = maskObject.getBounds(!0);
      this.renderer.filter.push(target, alphaMaskFilter);
      target.filterArea = stashFilterArea;
      maskData._filters || this.alphaMaskIndex++;
    }
    popSpriteMask(maskData) {
      this.renderer.filter.pop();
      maskData._filters ? maskData._filters[0].maskSprite = null : (this.alphaMaskIndex--, this.alphaMaskPool[this.alphaMaskIndex][0].maskSprite = null);
    }
    pushColorMask(maskData) {
      const currColorMask = maskData._colorMask;
      maskData = maskData._colorMask = currColorMask & maskData.colorMask;
      maskData !== currColorMask && this.renderer.gl.colorMask(0 !== (maskData & 1), 0 !== (maskData & 2), 0 !== (maskData & 4), 0 !== (maskData & 8));
    }
    popColorMask(maskData) {
      const nextColorMask = 0 < this.maskStack.length ? this.maskStack[this.maskStack.length - 1]._colorMask : 15;
      nextColorMask !== maskData._colorMask && this.renderer.gl.colorMask(0 !== (nextColorMask & 1), 0 !== (nextColorMask & 2), 0 !== (nextColorMask & 4), 0 !== (nextColorMask & 8));
    }
    destroy() {
      this.renderer = null;
    }
  }
  MaskSystem.extension = {type:global.ExtensionType.RendererSystem, name:"mask"};
  global.extensions.add(MaskSystem);
  exports.MaskSystem = MaskSystem;
};

//# sourceMappingURL=module$node_modules$$pixi$core$lib$mask$MaskSystem.js.map
