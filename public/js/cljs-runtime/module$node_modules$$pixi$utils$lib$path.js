shadow$provide.module$node_modules$$pixi$utils$lib$path = function(global, require, module, exports) {
  function assertPath(path2) {
    if ("string" != typeof path2) {
      throw new TypeError(`Path must be a string. Received ${JSON.stringify(path2)}`);
    }
  }
  function removeUrlParams(url) {
    return url.split("?")[0].split("#")[0];
  }
  var settings = require("module$node_modules$$pixi$settings$lib$index");
  const path = {toPosix(path2) {
    return path2.replace(new RegExp("\\".replace(/[.*+?^${}()|[\]\\]/g, "\\$\x26"), "g"), "/");
  }, isUrl(path2) {
    return /^https?:/.test(this.toPosix(path2));
  }, isDataUrl(path2) {
    return /^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(path2);
  }, isBlobUrl(path2) {
    return path2.startsWith("blob:");
  }, hasProtocol(path2) {
    return /^[^/:]+:/.test(this.toPosix(path2));
  }, getProtocol(path2) {
    assertPath(path2);
    path2 = this.toPosix(path2);
    const matchFile = /^file:\/\/\//.exec(path2);
    return matchFile ? matchFile[0] : (path2 = /^[^/:]+:\/{0,2}/.exec(path2)) ? path2[0] : "";
  }, toAbsolute(url, customBaseUrl, customRootUrl) {
    if (assertPath(url), this.isDataUrl(url) || this.isBlobUrl(url)) {
      return url;
    }
    customBaseUrl = removeUrlParams(this.toPosix(customBaseUrl ?? settings.settings.ADAPTER.getBaseUrl()));
    customRootUrl = removeUrlParams(this.toPosix(customRootUrl ?? this.rootname(customBaseUrl)));
    return url = this.toPosix(url), url.startsWith("/") ? path.join(customRootUrl, url.slice(1)) : this.isAbsolute(url) ? url : this.join(customBaseUrl, url);
  }, normalize(path2$jscomp$0) {
    if (assertPath(path2$jscomp$0), 0 === path2$jscomp$0.length) {
      return ".";
    }
    if (this.isDataUrl(path2$jscomp$0) || this.isBlobUrl(path2$jscomp$0)) {
      return path2$jscomp$0;
    }
    path2$jscomp$0 = this.toPosix(path2$jscomp$0);
    let protocol = "";
    const isAbsolute = path2$jscomp$0.startsWith("/");
    this.hasProtocol(path2$jscomp$0) && (protocol = this.rootname(path2$jscomp$0), path2$jscomp$0 = path2$jscomp$0.slice(protocol.length));
    const trailingSeparator = path2$jscomp$0.endsWith("/");
    var path2 = path2$jscomp$0;
    let res = "", lastSegmentLength = 0;
    var lastSlash = -1;
    let dots = 0, code = -1;
    for (let i = 0; i <= path2.length; ++i) {
      if (i < path2.length) {
        code = path2.charCodeAt(i);
      } else {
        if (47 === code) {
          break;
        }
        code = 47;
      }
      if (47 === code) {
        if (lastSlash !== i - 1 && 1 !== dots) {
          if (lastSlash !== i - 1 && 2 === dots) {
            if (2 > res.length || 2 !== lastSegmentLength || 46 !== res.charCodeAt(res.length - 1) || 46 !== res.charCodeAt(res.length - 2)) {
              if (2 < res.length) {
                if (lastSlash = res.lastIndexOf("/"), lastSlash !== res.length - 1) {
                  -1 === lastSlash ? (res = "", lastSegmentLength = 0) : (res = res.slice(0, lastSlash), lastSegmentLength = res.length - 1 - res.lastIndexOf("/"));
                  lastSlash = i;
                  dots = 0;
                  continue;
                }
              } else if (2 === res.length || 1 === res.length) {
                res = "";
                lastSegmentLength = 0;
                lastSlash = i;
                dots = 0;
                continue;
              }
            }
          } else {
            0 < res.length ? res += `/${path2.slice(lastSlash + 1, i)}` : res = path2.slice(lastSlash + 1, i), lastSegmentLength = i - lastSlash - 1;
          }
        }
        lastSlash = i;
        dots = 0;
      } else {
        46 === code && -1 !== dots ? ++dots : dots = -1;
      }
    }
    return path2$jscomp$0 = res, 0 < path2$jscomp$0.length && trailingSeparator && (path2$jscomp$0 += "/"), isAbsolute ? `/${path2$jscomp$0}` : protocol + path2$jscomp$0;
  }, isAbsolute(path2) {
    return assertPath(path2), path2 = this.toPosix(path2), this.hasProtocol(path2) ? !0 : path2.startsWith("/");
  }, join(...segments) {
    if (0 === segments.length) {
      return ".";
    }
    let joined;
    for (let i = 0; i < segments.length; ++i) {
      const arg = segments[i];
      if (assertPath(arg), 0 < arg.length) {
        void 0 === joined ? joined = arg : this.joinExtensions.includes(this.extname(segments[i - 1] ?? "").toLowerCase()) ? joined += `/../${arg}` : joined += `/${arg}`;
      }
    }
    return void 0 === joined ? "." : this.normalize(joined);
  }, dirname(path2) {
    if (assertPath(path2), 0 === path2.length) {
      return ".";
    }
    path2 = this.toPosix(path2);
    let code = path2.charCodeAt(0);
    const hasRoot = 47 === code;
    let end = -1, matchedSlash = !0;
    const proto = this.getProtocol(path2), origpath = path2;
    path2 = path2.slice(proto.length);
    for (let i = path2.length - 1; 1 <= i; --i) {
      if (code = path2.charCodeAt(i), 47 === code) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
        matchedSlash = !1;
      }
    }
    return -1 === end ? hasRoot ? "/" : this.isUrl(origpath) ? proto + path2 : proto : hasRoot && 1 === end ? "//" : proto + path2.slice(0, end);
  }, rootname(path2) {
    assertPath(path2);
    path2 = this.toPosix(path2);
    let root = "";
    if (path2.startsWith("/") ? root = "/" : root = this.getProtocol(path2), this.isUrl(path2)) {
      const index = path2.indexOf("/", root.length);
      -1 !== index ? root = path2.slice(0, index) : root = path2;
      root.endsWith("/") || (root += "/");
    }
    return root;
  }, basename(path2, ext) {
    assertPath(path2);
    ext && assertPath(ext);
    path2 = removeUrlParams(this.toPosix(path2));
    let start = 0, end = -1, matchedSlash = !0, i;
    if (void 0 !== ext && 0 < ext.length && ext.length <= path2.length) {
      if (ext.length === path2.length && ext === path2) {
        return "";
      }
      let extIdx = ext.length - 1, firstNonSlashEnd = -1;
      for (i = path2.length - 1; 0 <= i; --i) {
        const code = path2.charCodeAt(i);
        if (47 === code) {
          if (!matchedSlash) {
            start = i + 1;
            break;
          }
        } else {
          -1 === firstNonSlashEnd && (matchedSlash = !1, firstNonSlashEnd = i + 1), 0 <= extIdx && (code === ext.charCodeAt(extIdx) ? -1 === --extIdx && (end = i) : (extIdx = -1, end = firstNonSlashEnd));
        }
      }
      return start === end ? end = firstNonSlashEnd : -1 === end && (end = path2.length), path2.slice(start, end);
    }
    for (i = path2.length - 1; 0 <= i; --i) {
      if (47 === path2.charCodeAt(i)) {
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else {
        -1 === end && (matchedSlash = !1, end = i + 1);
      }
    }
    return -1 === end ? "" : path2.slice(start, end);
  }, extname(path2) {
    assertPath(path2);
    path2 = removeUrlParams(this.toPosix(path2));
    let startDot = -1, startPart = 0, end = -1, matchedSlash = !0, preDotState = 0;
    for (let i = path2.length - 1; 0 <= i; --i) {
      const code = path2.charCodeAt(i);
      if (47 === code) {
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
      } else {
        -1 === end && (matchedSlash = !1, end = i + 1), 46 === code ? -1 === startDot ? startDot = i : 1 !== preDotState && (preDotState = 1) : -1 !== startDot && (preDotState = -1);
      }
    }
    return -1 === startDot || -1 === end || 0 === preDotState || 1 === preDotState && startDot === end - 1 && startDot === startPart + 1 ? "" : path2.slice(startDot, end);
  }, parse(path2) {
    assertPath(path2);
    const ret = {root:"", dir:"", base:"", ext:"", name:""};
    if (0 === path2.length) {
      return ret;
    }
    path2 = removeUrlParams(this.toPosix(path2));
    let code = path2.charCodeAt(0);
    const isAbsolute = this.isAbsolute(path2);
    let start;
    ret.root = this.rootname(path2);
    isAbsolute || this.hasProtocol(path2) ? start = 1 : start = 0;
    let startDot = -1, startPart = 0, end = -1, matchedSlash = !0, i = path2.length - 1, preDotState = 0;
    for (; i >= start; --i) {
      if (code = path2.charCodeAt(i), 47 === code) {
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
      } else {
        -1 === end && (matchedSlash = !1, end = i + 1), 46 === code ? -1 === startDot ? startDot = i : 1 !== preDotState && (preDotState = 1) : -1 !== startDot && (preDotState = -1);
      }
    }
    return -1 === startDot || -1 === end || 0 === preDotState || 1 === preDotState && startDot === end - 1 && startDot === startPart + 1 ? -1 !== end && (0 === startPart && isAbsolute ? ret.base = ret.name = path2.slice(1, end) : ret.base = ret.name = path2.slice(startPart, end)) : (0 === startPart && isAbsolute ? (ret.name = path2.slice(1, startDot), ret.base = path2.slice(1, end)) : (ret.name = path2.slice(startPart, startDot), ret.base = path2.slice(startPart, end)), ret.ext = path2.slice(startDot, 
    end)), ret.dir = this.dirname(path2), ret;
  }, sep:"/", delimiter:":", joinExtensions:[".html"]};
  exports.path = path;
};

//# sourceMappingURL=module$node_modules$$pixi$utils$lib$path.js.map
