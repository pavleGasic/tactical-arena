shadow$provide.module$node_modules$pixi_DOT_js$lib$scene$text_bitmap$BitmapText = function(global, require, module, exports) {
  var warn = require("module$node_modules$pixi_DOT_js$lib$utils$logging$warn"), AbstractText = require("module$node_modules$pixi_DOT_js$lib$scene$text$AbstractText"), TextStyle = require("module$node_modules$pixi_DOT_js$lib$scene$text$TextStyle"), BitmapFontManager = require("module$node_modules$pixi_DOT_js$lib$scene$text_bitmap$BitmapFontManager");
  "use strict";
  class BitmapText extends AbstractText.AbstractText {
    constructor(...args) {
      var _a;
      args = AbstractText.ensureTextOptions(args, "BitmapText");
      args.style ?? (args.style = args.style || {});
      (_a = args.style).fill ?? (_a.fill = 16777215);
      super(args, TextStyle.TextStyle);
      this.renderPipeId = "bitmapText";
    }
    updateBounds() {
      const bounds = this._bounds, anchor = this._anchor;
      var bitmapMeasurement = BitmapFontManager.BitmapFontManager.measureText(this.text, this._style), scale = bitmapMeasurement.scale;
      const offset = bitmapMeasurement.offsetY * scale;
      let width = bitmapMeasurement.width * scale;
      bitmapMeasurement = bitmapMeasurement.height * scale;
      if (scale = this._style._stroke) {
        width += scale.width, bitmapMeasurement += scale.width;
      }
      bounds.minX = -anchor._x * width;
      bounds.maxX = bounds.minX + width;
      bounds.minY = -anchor._y * (bitmapMeasurement + offset);
      bounds.maxY = bounds.minY + bitmapMeasurement;
    }
    set resolution(value) {
      null !== value && warn.warn("[BitmapText] dynamically updating the resolution is not supported. Resolution should be managed by the BitmapFont.");
    }
    get resolution() {
      return this._resolution;
    }
  }
  exports.BitmapText = BitmapText;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$scene$text_bitmap$BitmapText.js.map
