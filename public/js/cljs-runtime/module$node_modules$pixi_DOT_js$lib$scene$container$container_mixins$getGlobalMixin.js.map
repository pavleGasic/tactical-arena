{
"version":3,
"file":"module$node_modules$pixi_DOT_js$lib$scene$container$container_mixins$getGlobalMixin.js",
"lineCount":39,
"mappings":"AAAAA,cAAA,CAAA,mFAAA,GAAwG,QAAQ,CAACC,MAAD,EAAQC,OAAR,EAAgBC,MAAhB,EAAuBC,OAAvB,CAAgC;AAQhJC,UAASA,QAAO,CAACC,KAAD,CAAQ;AACtB,aAASA,KAAT,GAAiB,GAAjB,KAAyB,EAAzB,KAAgCA,KAAhC,GAAwC,KAAxC,KAAkDA,KAAlD,IAA2D,EAA3D,GAAgE,GAAhE;AADsB;AALxB,MAAIC,kBAAkBL,OAAA,CAAQ,4EAAR,CAAtB,EACIM,sBAAsBN,OAAA,CAAQ,sFAAR,CAD1B,EAEIO,iBAAiBP,OAAA,CAAQ,0EAAR,CAFrB;AAIA,cAAA;AAmGAE,SAAQC,CAAAA,OAAR,GAAkBA,OAAlB;AACAD,SAAQM,CAAAA,cAAR,GAhGuBA,CAcrBC,cAAc,CAACC,UAAD,CAAa;AACzB,QAAIA,UAAJ;AACE,aAAI,IAAKC,CAAAA,WAAT,GACS,IAAKA,CAAAA,WAAYC,CAAAA,UAD1B,GAGI,IAAKC,CAAAA,iBAAT,GACS,IAAKA,CAAAA,iBAAkBD,CAAAA,UADhC,GAC6C,IAAKE,CAAAA,KADlD,GAGO,IAAKA,CAAAA,KANZ;AADF;AASIA,cAAAA,GAAQ,IAAKA,CAAAA,KAAbA;AACJ,QAAIC,UAAU,IAAKC,CAAAA,MAAnB;AACA,SAAA,EAAOD,OAAP,CAAA;AACED,gBACA,IADSC,OAAQD,CAAAA,KACjB,EAAAC,OAAA,GAAUA,OAAQC,CAAAA,MAAlB;AAFF;AAIA,WAAOF,UAAP;AAhByB,GAdNN,EAkDrBS,kBAAkB,CAACC,MAAD,EAASR,UAAT,CAAqB;AACrC,QAAIA,UAAJ;AACE,aAAOQ,MAAOC,CAAAA,QAAP,CAAgB,IAAKC,CAAAA,cAArB,CAAP;AADF;AAGA,QAAKC,CAAAA,oBAAL,EAAA;AACMC,cAAAA,GAAkBjB,eAAgBkB,CAAAA,wBAAhB,CAAyC,IAAzC,EAA+CjB,mBAAoBkB,CAAAA,UAAWC,CAAAA,GAA/B,EAAqCC,CAAAA,QAArC,EAA/C,CAAlBJ;AACNJ,UAAOS,CAAAA,UAAP,CAAkB,IAAKC,CAAAA,cAAvB,EAAuCN,UAAvC,CAAA;AACAhB,uBAAoBkB,CAAAA,UAAWK,CAAAA,MAA/B,CAAsCP,UAAtC,CAAA;AACA,WAAOJ,MAAP;AARqC,GAlDlBV,EAyErBsB,aAAa,CAACpB,UAAD,CAAa;AACxB,QAAIA,UAAJ;AACE,aAAI,IAAKC,CAAAA,WAAT,GACSR,OAAA,CAAQ,IAAKQ,CAAAA,WAAYoB,CAAAA,UAAzB,CADT,GAGI,IAAKlB,CAAAA,iBAAT,GACSV,OAAA,CACLI,cAAeA,CAAAA,cAAf,CAA8B,IAAKyB,CAAAA,UAAnC,EAA+C,IAAKnB,CAAAA,iBAAkBkB,CAAAA,UAAtE,CADK,CADT,GAKO,IAAKE,CAAAA,IARZ;AADF;AAWI7B,cAAAA,GAAQ,IAAK4B,CAAAA,UAAb5B;AACJ,QAAIY,SAAS,IAAKA,CAAAA,MAAlB;AACA,SAAA,EAAOA,MAAP,CAAA;AACEZ,gBACA,GADQG,cAAeA,CAAAA,cAAf,CAA8BH,UAA9B,EAAqCY,MAAOgB,CAAAA,UAA5C,CACR,EAAAhB,MAAA,GAASA,MAAOA,CAAAA,MAAhB;AAFF;AAIA,WAAOb,OAAA,CAAQC,UAAR,CAAP;AAlBwB,GAzELI,CAgGvB;AA3GgJ,CAAhJ;;",
"sources":["node_modules/pixi_DOT_js/lib/scene/container/container-mixins/getGlobalMixin.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$pixi_DOT_js$lib$scene$container$container_mixins$getGlobalMixin\"] = function(global,require,module,exports) {\n'use strict';\n\nvar getGlobalBounds = require('../bounds/getGlobalBounds.js');\nvar matrixAndBoundsPool = require('../bounds/utils/matrixAndBoundsPool.js');\nvar multiplyColors = require('../utils/multiplyColors.js');\n\n\"use strict\";\nfunction bgr2rgb(color) {\n  return ((color & 255) << 16) + (color & 65280) + (color >> 16 & 255);\n}\nconst getGlobalMixin = {\n  /**\n   * Returns the global (compound) alpha of the container within the scene.\n   * @param skipUpdate - Performance optimization flag:\n   *   - If false (default): Recalculates the entire alpha chain through parents for accuracy\n   *   - If true: Uses cached worldAlpha from the last render pass for better performance\n   * @returns The resulting alpha value (between 0 and 1)\n   * @example\n   * // Accurate but slower - recalculates entire alpha chain\n   * const preciseAlpha = container.getGlobalAlpha();\n   *\n   * // Faster but may be outdated - uses cached alpha\n   * const cachedAlpha = container.getGlobalAlpha(true);\n   */\n  getGlobalAlpha(skipUpdate) {\n    if (skipUpdate) {\n      if (this.renderGroup) {\n        return this.renderGroup.worldAlpha;\n      }\n      if (this.parentRenderGroup) {\n        return this.parentRenderGroup.worldAlpha * this.alpha;\n      }\n      return this.alpha;\n    }\n    let alpha = this.alpha;\n    let current = this.parent;\n    while (current) {\n      alpha *= current.alpha;\n      current = current.parent;\n    }\n    return alpha;\n  },\n  /**\n   * Returns the global transform matrix of the container within the scene.\n   * @param matrix - Optional matrix to store the result. If not provided, a new Matrix will be created.\n   * @param skipUpdate - Performance optimization flag:\n   *   - If false (default): Recalculates the entire transform chain for accuracy\n   *   - If true: Uses cached worldTransform from the last render pass for better performance\n   * @returns The resulting transformation matrix (either the input matrix or a new one)\n   * @example\n   * // Accurate but slower - recalculates entire transform chain\n   * const preciseTransform = container.getGlobalTransform();\n   *\n   * // Faster but may be outdated - uses cached transform\n   * const cachedTransform = container.getGlobalTransform(undefined, true);\n   *\n   * // Reuse existing matrix\n   * const existingMatrix = new Matrix();\n   * container.getGlobalTransform(existingMatrix);\n   */\n  getGlobalTransform(matrix, skipUpdate) {\n    if (skipUpdate) {\n      return matrix.copyFrom(this.worldTransform);\n    }\n    this.updateLocalTransform();\n    const parentTransform = getGlobalBounds.updateTransformBackwards(this, matrixAndBoundsPool.matrixPool.get().identity());\n    matrix.appendFrom(this.localTransform, parentTransform);\n    matrixAndBoundsPool.matrixPool.return(parentTransform);\n    return matrix;\n  },\n  /**\n   * Returns the global (compound) tint color of the container within the scene.\n   * @param skipUpdate - Performance optimization flag:\n   *   - If false (default): Recalculates the entire tint chain through parents for accuracy\n   *   - If true: Uses cached worldColor from the last render pass for better performance\n   * @returns The resulting tint color as a 24-bit RGB number (0xRRGGBB)\n   * @example\n   * // Accurate but slower - recalculates entire tint chain\n   * const preciseTint = container.getGlobalTint();\n   *\n   * // Faster but may be outdated - uses cached tint\n   * const cachedTint = container.getGlobalTint(true);\n   */\n  getGlobalTint(skipUpdate) {\n    if (skipUpdate) {\n      if (this.renderGroup) {\n        return bgr2rgb(this.renderGroup.worldColor);\n      }\n      if (this.parentRenderGroup) {\n        return bgr2rgb(\n          multiplyColors.multiplyColors(this.localColor, this.parentRenderGroup.worldColor)\n        );\n      }\n      return this.tint;\n    }\n    let color = this.localColor;\n    let parent = this.parent;\n    while (parent) {\n      color = multiplyColors.multiplyColors(color, parent.localColor);\n      parent = parent.parent;\n    }\n    return bgr2rgb(color);\n  }\n};\n\nexports.bgr2rgb = bgr2rgb;\nexports.getGlobalMixin = getGlobalMixin;\n//# sourceMappingURL=getGlobalMixin.js.map\n\n};"],
"names":["shadow$provide","global","require","module","exports","bgr2rgb","color","getGlobalBounds","matrixAndBoundsPool","multiplyColors","getGlobalMixin","getGlobalAlpha","skipUpdate","renderGroup","worldAlpha","parentRenderGroup","alpha","current","parent","getGlobalTransform","matrix","copyFrom","worldTransform","updateLocalTransform","parentTransform","updateTransformBackwards","matrixPool","get","identity","appendFrom","localTransform","return","getGlobalTint","worldColor","localColor","tint"]
}
