shadow$provide.module$node_modules$pixi_DOT_js$lib$scene$mesh$shared$BatchableMesh = function(global, require, module, exports) {
  class BatchableMesh {
    constructor() {
      this.batcherName = "default";
      this.packAsQuad = !1;
      this.roundPixels = this.attributeOffset = this.indexOffset = 0;
      this._batch = this._batcher = null;
      this._uvUpdateId = this._textureMatrixUpdateId = -1;
    }
    get blendMode() {
      return this.renderable.groupBlendMode;
    }
    get topology() {
      return this._topology || this.geometry.topology;
    }
    set topology(value) {
      this._topology = value;
    }
    reset() {
      this.geometry = this._batch = this._batcher = this.texture = this.renderable = null;
      this._textureMatrixUpdateId = this._uvUpdateId = -1;
    }
    setTexture(value) {
      this.texture !== value && (this.texture = value, this._textureMatrixUpdateId = -1);
    }
    get uvs() {
      const uvBuffer = this.geometry.getBuffer("aUV"), uvs = uvBuffer.data;
      let transformedUvs = uvs;
      const textureMatrix = this.texture.textureMatrix;
      if (!textureMatrix.isSimple && (transformedUvs = this._transformedUvs, this._textureMatrixUpdateId !== textureMatrix._updateID || this._uvUpdateId !== uvBuffer._updateID)) {
        if (!transformedUvs || transformedUvs.length < uvs.length) {
          transformedUvs = this._transformedUvs = new Float32Array(uvs.length);
        }
        this._textureMatrixUpdateId = textureMatrix._updateID;
        this._uvUpdateId = uvBuffer._updateID;
        textureMatrix.multiplyUvs(uvs, transformedUvs);
      }
      return transformedUvs;
    }
    get positions() {
      return this.geometry.positions;
    }
    get indices() {
      return this.geometry.indices;
    }
    get color() {
      return this.renderable.groupColorAlpha;
    }
    get groupTransform() {
      return this.renderable.groupTransform;
    }
    get attributeSize() {
      return this.geometry.positions.length / 2;
    }
    get indexSize() {
      return this.geometry.indices.length;
    }
  }
  exports.BatchableMesh = BatchableMesh;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$scene$mesh$shared$BatchableMesh.js.map
