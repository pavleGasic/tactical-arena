shadow$provide.module$node_modules$$pixi$mixin_cache_as_bitmap$lib$index = function(global, require, module, exports) {
  var core = require("module$node_modules$$pixi$core$lib$index");
  global = require("module$node_modules$$pixi$display$lib$index");
  var sprite = require("module$node_modules$$pixi$sprite$lib$index");
  const _tempMatrix = new core.Matrix();
  global.DisplayObject.prototype._cacheAsBitmap = !1;
  global.DisplayObject.prototype._cacheData = null;
  global.DisplayObject.prototype._cacheAsBitmapResolution = null;
  global.DisplayObject.prototype._cacheAsBitmapMultisample = null;
  class CacheData {
    constructor() {
      this.sprite = this.originalContainsPoint = this.originalFilterArea = this.originalMask = this.originalDestroy = this.originalUpdateTransform = this.originalGetLocalBounds = this.originalCalculateBounds = this.originalRenderCanvas = this.originalRender = this.textureCacheId = null;
    }
  }
  Object.defineProperties(global.DisplayObject.prototype, {cacheAsBitmapResolution:{get() {
    return this._cacheAsBitmapResolution;
  }, set(resolution) {
    resolution !== this._cacheAsBitmapResolution && (this._cacheAsBitmapResolution = resolution, this.cacheAsBitmap && (this.cacheAsBitmap = !1, this.cacheAsBitmap = !0));
  }}, cacheAsBitmapMultisample:{get() {
    return this._cacheAsBitmapMultisample;
  }, set(multisample) {
    multisample !== this._cacheAsBitmapMultisample && (this._cacheAsBitmapMultisample = multisample, this.cacheAsBitmap && (this.cacheAsBitmap = !1, this.cacheAsBitmap = !0));
  }}, cacheAsBitmap:{get() {
    return this._cacheAsBitmap;
  }, set(value) {
    if (this._cacheAsBitmap !== value) {
      this._cacheAsBitmap = value;
      var data;
      value ? (this._cacheData || (this._cacheData = new CacheData()), data = this._cacheData, data.originalRender = this.render, data.originalRenderCanvas = this.renderCanvas, data.originalUpdateTransform = this.updateTransform, data.originalCalculateBounds = this.calculateBounds, data.originalGetLocalBounds = this.getLocalBounds, data.originalDestroy = this.destroy, data.originalContainsPoint = this.containsPoint, data.originalMask = this._mask, data.originalFilterArea = this.filterArea, this.render = 
      this._renderCached, this.renderCanvas = this._renderCachedCanvas, this.destroy = this._cacheAsBitmapDestroy) : (data = this._cacheData, data.sprite && this._destroyCachedDisplayObject(), this.render = data.originalRender, this.renderCanvas = data.originalRenderCanvas, this.calculateBounds = data.originalCalculateBounds, this.getLocalBounds = data.originalGetLocalBounds, this.destroy = data.originalDestroy, this.updateTransform = data.originalUpdateTransform, this.containsPoint = data.originalContainsPoint, 
      this._mask = data.originalMask, this.filterArea = data.originalFilterArea);
    }
  }}});
  global.DisplayObject.prototype._renderCached = function(renderer) {
    !this.visible || 0 >= this.worldAlpha || !this.renderable || (this._initCachedDisplayObject(renderer), this._cacheData.sprite.transform._worldID = this.transform._worldID, this._cacheData.sprite.worldAlpha = this.worldAlpha, this._cacheData.sprite._render(renderer));
  };
  global.DisplayObject.prototype._initCachedDisplayObject = function(renderer) {
    if (!this._cacheData?.sprite) {
      var cacheAlpha = this.alpha;
      this.alpha = 1;
      renderer.batch.flush();
      var bounds = this.getLocalBounds(new core.Rectangle(), !0);
      this.filters?.length && bounds.pad(this.filters[0].padding);
      var resolution = this.cacheAsBitmapResolution || renderer.resolution;
      bounds.ceil(resolution);
      bounds.width = Math.max(bounds.width, 1 / resolution);
      bounds.height = Math.max(bounds.height, 1 / resolution);
      var cachedRenderTexture = renderer.renderTexture.current, cachedSourceFrame = renderer.renderTexture.sourceFrame.clone(), cachedDestinationFrame = renderer.renderTexture.destinationFrame.clone(), cachedProjectionTransform = renderer.projection.transform;
      resolution = core.RenderTexture.create({width:bounds.width, height:bounds.height, resolution, multisample:this.cacheAsBitmapMultisample ?? renderer.multisample});
      var textureCacheId = `cacheAsBitmap_${core.utils.uid()}`;
      this._cacheData.textureCacheId = textureCacheId;
      core.BaseTexture.addToCache(resolution.baseTexture, textureCacheId);
      core.Texture.addToCache(resolution, textureCacheId);
      textureCacheId = this.transform.localTransform.copyTo(_tempMatrix).invert().translate(-bounds.x, -bounds.y);
      this.render = this._cacheData.originalRender;
      renderer.render(this, {renderTexture:resolution, clear:!0, transform:textureCacheId, skipUpdateTransform:!1});
      renderer.framebuffer.blit();
      renderer.projection.transform = cachedProjectionTransform;
      renderer.renderTexture.bind(cachedRenderTexture, cachedSourceFrame, cachedDestinationFrame);
      this.render = this._renderCached;
      this.updateTransform = this.displayObjectUpdateTransform;
      this.calculateBounds = this._calculateCachedBounds;
      this.getLocalBounds = this._getCachedLocalBounds;
      this.filterArea = this._mask = null;
      this.alpha = cacheAlpha;
      renderer = new sprite.Sprite(resolution);
      renderer.transform.worldTransform = this.transform.worldTransform;
      renderer.anchor.x = -(bounds.x / bounds.width);
      renderer.anchor.y = -(bounds.y / bounds.height);
      renderer.alpha = cacheAlpha;
      renderer._bounds = this._bounds;
      this._cacheData.sprite = renderer;
      this.transform._parentID = -1;
      this.parent ? this.updateTransform() : (this.enableTempParent(), this.updateTransform(), this.disableTempParent(null));
      this.containsPoint = renderer.containsPoint.bind(renderer);
    }
  };
  global.DisplayObject.prototype._renderCachedCanvas = function(renderer) {
    !this.visible || 0 >= this.worldAlpha || !this.renderable || (this._initCachedDisplayObjectCanvas(renderer), this._cacheData.sprite.worldAlpha = this.worldAlpha, this._cacheData.sprite._renderCanvas(renderer));
  };
  global.DisplayObject.prototype._initCachedDisplayObjectCanvas = function(renderer) {
    if (!this._cacheData?.sprite) {
      var bounds = this.getLocalBounds(new core.Rectangle(), !0), cacheAlpha = this.alpha;
      this.alpha = 1;
      var cachedRenderTarget = renderer.canvasContext.activeContext, cachedProjectionTransform = renderer._projTransform, resolution = this.cacheAsBitmapResolution || renderer.resolution;
      bounds.ceil(resolution);
      bounds.width = Math.max(bounds.width, 1 / resolution);
      bounds.height = Math.max(bounds.height, 1 / resolution);
      resolution = core.RenderTexture.create({width:bounds.width, height:bounds.height, resolution});
      var textureCacheId = `cacheAsBitmap_${core.utils.uid()}`;
      this._cacheData.textureCacheId = textureCacheId;
      core.BaseTexture.addToCache(resolution.baseTexture, textureCacheId);
      core.Texture.addToCache(resolution, textureCacheId);
      this.transform.localTransform.copyTo(_tempMatrix);
      _tempMatrix.invert();
      _tempMatrix.tx -= bounds.x;
      _tempMatrix.ty -= bounds.y;
      this.renderCanvas = this._cacheData.originalRenderCanvas;
      renderer.render(this, {renderTexture:resolution, clear:!0, transform:_tempMatrix, skipUpdateTransform:!1});
      renderer.canvasContext.activeContext = cachedRenderTarget;
      renderer._projTransform = cachedProjectionTransform;
      this.renderCanvas = this._renderCachedCanvas;
      this.updateTransform = this.displayObjectUpdateTransform;
      this.calculateBounds = this._calculateCachedBounds;
      this.getLocalBounds = this._getCachedLocalBounds;
      this.filterArea = this._mask = null;
      this.alpha = cacheAlpha;
      cachedRenderTarget = new sprite.Sprite(resolution);
      cachedRenderTarget.transform.worldTransform = this.transform.worldTransform;
      cachedRenderTarget.anchor.x = -(bounds.x / bounds.width);
      cachedRenderTarget.anchor.y = -(bounds.y / bounds.height);
      cachedRenderTarget.alpha = cacheAlpha;
      cachedRenderTarget._bounds = this._bounds;
      this._cacheData.sprite = cachedRenderTarget;
      this.transform._parentID = -1;
      this.parent ? this.updateTransform() : (this.parent = renderer._tempDisplayObjectParent, this.updateTransform(), this.parent = null);
      this.containsPoint = cachedRenderTarget.containsPoint.bind(cachedRenderTarget);
    }
  };
  global.DisplayObject.prototype._calculateCachedBounds = function() {
    this._bounds.clear();
    this._cacheData.sprite.transform._worldID = this.transform._worldID;
    this._cacheData.sprite._calculateBounds();
    this._bounds.updateID = this._boundsID;
  };
  global.DisplayObject.prototype._getCachedLocalBounds = function() {
    return this._cacheData.sprite.getLocalBounds(null);
  };
  global.DisplayObject.prototype._destroyCachedDisplayObject = function() {
    this._cacheData.sprite._texture.destroy(!0);
    this._cacheData.sprite = null;
    core.BaseTexture.removeFromCache(this._cacheData.textureCacheId);
    core.Texture.removeFromCache(this._cacheData.textureCacheId);
    this._cacheData.textureCacheId = null;
  };
  global.DisplayObject.prototype._cacheAsBitmapDestroy = function(options) {
    this.cacheAsBitmap = !1;
    this.destroy(options);
  };
  exports.CacheData = CacheData;
};

//# sourceMappingURL=module$node_modules$$pixi$mixin_cache_as_bitmap$lib$index.js.map
