shadow$provide.module$node_modules$$pixi$core$lib$context$ContextSystem = function(global, require, module, exports) {
  var constants = require("module$node_modules$$pixi$constants$lib$index");
  global = require("module$node_modules$$pixi$extensions$lib$index");
  var settings = require("module$node_modules$$pixi$settings$lib$index");
  let CONTEXT_UID_COUNTER = 0;
  class ContextSystem {
    constructor(renderer) {
      this.renderer = renderer;
      this.webGLVersion = 1;
      this.extensions = {};
      this.supports = {uint32Indices:!1};
      this.handleContextLost = this.handleContextLost.bind(this);
      this.handleContextRestored = this.handleContextRestored.bind(this);
    }
    get isLost() {
      return !this.gl || this.gl.isContextLost();
    }
    contextChange(gl) {
      this.gl = gl;
      this.renderer.gl = gl;
      this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER++;
    }
    init(options) {
      if (options.context) {
        this.initFromContext(options.context);
      } else {
        const alpha = 1 > this.renderer.background.alpha, premultipliedAlpha = options.premultipliedAlpha;
        this.preserveDrawingBuffer = options.preserveDrawingBuffer;
        this.useContextAlpha = options.useContextAlpha;
        this.powerPreference = options.powerPreference;
        this.initFromOptions({alpha, premultipliedAlpha, antialias:options.antialias, stencil:!0, preserveDrawingBuffer:options.preserveDrawingBuffer, powerPreference:options.powerPreference});
      }
    }
    initFromContext(gl) {
      this.gl = gl;
      this.validateContext(gl);
      this.renderer.gl = gl;
      this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER++;
      this.renderer.runners.contextChange.emit(gl);
      gl = this.renderer.view;
      void 0 !== gl.addEventListener && (gl.addEventListener("webglcontextlost", this.handleContextLost, !1), gl.addEventListener("webglcontextrestored", this.handleContextRestored, !1));
    }
    initFromOptions(options) {
      options = this.createContext(this.renderer.view, options);
      this.initFromContext(options);
    }
    createContext(canvas, options) {
      let gl;
      if (settings.settings.PREFER_ENV >= constants.ENV.WEBGL2 && (gl = canvas.getContext("webgl2", options)), gl) {
        this.webGLVersion = 2;
      } else if (this.webGLVersion = 1, gl = canvas.getContext("webgl", options) || canvas.getContext("experimental-webgl", options), !gl) {
        throw Error("This browser does not support WebGL. Try using the canvas renderer");
      }
      return this.gl = gl, this.getExtensions(), this.gl;
    }
    getExtensions() {
      const {gl} = this, common = {loseContext:gl.getExtension("WEBGL_lose_context"), anisotropicFiltering:gl.getExtension("EXT_texture_filter_anisotropic"), floatTextureLinear:gl.getExtension("OES_texture_float_linear"), s3tc:gl.getExtension("WEBGL_compressed_texture_s3tc"), s3tc_sRGB:gl.getExtension("WEBGL_compressed_texture_s3tc_srgb"), etc:gl.getExtension("WEBGL_compressed_texture_etc"), etc1:gl.getExtension("WEBGL_compressed_texture_etc1"), pvrtc:gl.getExtension("WEBGL_compressed_texture_pvrtc") || 
      gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"), atc:gl.getExtension("WEBGL_compressed_texture_atc"), astc:gl.getExtension("WEBGL_compressed_texture_astc"), bptc:gl.getExtension("EXT_texture_compression_bptc")};
      1 === this.webGLVersion ? Object.assign(this.extensions, common, {drawBuffers:gl.getExtension("WEBGL_draw_buffers"), depthTexture:gl.getExtension("WEBGL_depth_texture"), vertexArrayObject:gl.getExtension("OES_vertex_array_object") || gl.getExtension("MOZ_OES_vertex_array_object") || gl.getExtension("WEBKIT_OES_vertex_array_object"), uint32ElementIndex:gl.getExtension("OES_element_index_uint"), floatTexture:gl.getExtension("OES_texture_float"), floatTextureLinear:gl.getExtension("OES_texture_float_linear"), 
      textureHalfFloat:gl.getExtension("OES_texture_half_float"), textureHalfFloatLinear:gl.getExtension("OES_texture_half_float_linear")}) : 2 === this.webGLVersion && Object.assign(this.extensions, common, {colorBufferFloat:gl.getExtension("EXT_color_buffer_float")});
    }
    handleContextLost(event) {
      event.preventDefault();
      setTimeout(() => {
        this.gl.isContextLost() && this.extensions.loseContext && this.extensions.loseContext.restoreContext();
      }, 0);
    }
    handleContextRestored() {
      this.renderer.runners.contextChange.emit(this.gl);
    }
    destroy() {
      const view = this.renderer.view;
      this.renderer = null;
      void 0 !== view.removeEventListener && (view.removeEventListener("webglcontextlost", this.handleContextLost), view.removeEventListener("webglcontextrestored", this.handleContextRestored));
      this.gl.useProgram(null);
      this.extensions.loseContext && this.extensions.loseContext.loseContext();
    }
    postrender() {
      this.renderer.objectRenderer.renderingToScreen && this.gl.flush();
    }
    validateContext(gl) {
      const attributes = gl.getContextAttributes(), isWebGl2 = "WebGL2RenderingContext" in globalThis && gl instanceof globalThis.WebGL2RenderingContext;
      isWebGl2 && (this.webGLVersion = 2);
      attributes && !attributes.stencil && console.warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
      gl = isWebGl2 || !!gl.getExtension("OES_element_index_uint");
      (this.supports.uint32Indices = gl) || console.warn("Provided WebGL context does not support 32 index buffer, complex graphics may not render correctly");
    }
  }
  ContextSystem.defaultOptions = {context:null, antialias:!1, premultipliedAlpha:!0, preserveDrawingBuffer:!1, powerPreference:"default"};
  ContextSystem.extension = {type:global.ExtensionType.RendererSystem, name:"context"};
  global.extensions.add(ContextSystem);
  exports.ContextSystem = ContextSystem;
};

//# sourceMappingURL=module$node_modules$$pixi$core$lib$context$ContextSystem.js.map
