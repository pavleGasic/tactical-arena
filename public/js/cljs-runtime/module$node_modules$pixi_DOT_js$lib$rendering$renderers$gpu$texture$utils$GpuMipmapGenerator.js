shadow$provide.module$node_modules$pixi_DOT_js$lib$rendering$renderers$gpu$texture$utils$GpuMipmapGenerator = function(global, require, module, exports) {
  class GpuMipmapGenerator {
    constructor(device) {
      this.device = device;
      this.sampler = device.createSampler({minFilter:"linear"});
      this.pipelines = {};
    }
    _getMipmapPipeline(format) {
      let pipeline = this.pipelines[format];
      pipeline || (this.mipmapShaderModule || (this.mipmapShaderModule = this.device.createShaderModule({code:"\n                        var\x3cprivate\x3e pos : array\x3cvec2\x3cf32\x3e, 3\x3e \x3d array\x3cvec2\x3cf32\x3e, 3\x3e(\n                        vec2\x3cf32\x3e(-1.0, -1.0), vec2\x3cf32\x3e(-1.0, 3.0), vec2\x3cf32\x3e(3.0, -1.0));\n\n                        struct VertexOutput {\n                        @builtin(position) position : vec4\x3cf32\x3e,\n                        @location(0) texCoord : vec2\x3cf32\x3e,\n                        };\n\n                        @vertex\n                        fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -\x3e VertexOutput {\n                        var output : VertexOutput;\n                        output.texCoord \x3d pos[vertexIndex] * vec2\x3cf32\x3e(0.5, -0.5) + vec2\x3cf32\x3e(0.5);\n                        output.position \x3d vec4\x3cf32\x3e(pos[vertexIndex], 0.0, 1.0);\n                        return output;\n                        }\n\n                        @group(0) @binding(0) var imgSampler : sampler;\n                        @group(0) @binding(1) var img : texture_2d\x3cf32\x3e;\n\n                        @fragment\n                        fn fragmentMain(@location(0) texCoord : vec2\x3cf32\x3e) -\x3e @location(0) vec4\x3cf32\x3e {\n                        return textureSample(img, imgSampler, texCoord);\n                        }\n                    "})), 
      pipeline = this.device.createRenderPipeline({layout:"auto", vertex:{module:this.mipmapShaderModule, entryPoint:"vertexMain"}, fragment:{module:this.mipmapShaderModule, entryPoint:"fragmentMain", targets:[{format}]}}), this.pipelines[format] = pipeline);
      return pipeline;
    }
    generateMipmap(texture) {
      var pipeline = this._getMipmapPipeline(texture.format);
      if ("3d" === texture.dimension || "1d" === texture.dimension) {
        throw Error("Generating mipmaps for non-2d textures is currently unsupported!");
      }
      let mipTexture = texture;
      var arrayLayerCount = texture.depthOrArrayLayers || 1;
      const renderToSource = texture.usage & GPUTextureUsage.RENDER_ATTACHMENT;
      renderToSource || (mipTexture = this.device.createTexture({size:{width:Math.ceil(texture.width / 2), height:Math.ceil(texture.height / 2), depthOrArrayLayers:arrayLayerCount}, format:texture.format, usage:GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT, mipLevelCount:texture.mipLevelCount - 1}));
      const commandEncoder = this.device.createCommandEncoder({}), bindGroupLayout = pipeline.getBindGroupLayout(0);
      for (let arrayLayer = 0; arrayLayer < arrayLayerCount; ++arrayLayer) {
        var srcView = texture.createView({baseMipLevel:0, mipLevelCount:1, dimension:"2d", baseArrayLayer:arrayLayer, arrayLayerCount:1});
        let dstMipLevel = renderToSource ? 1 : 0;
        for (let i = 1; i < texture.mipLevelCount; ++i) {
          const dstView = mipTexture.createView({baseMipLevel:dstMipLevel++, mipLevelCount:1, dimension:"2d", baseArrayLayer:arrayLayer, arrayLayerCount:1}), passEncoder = commandEncoder.beginRenderPass({colorAttachments:[{view:dstView, storeOp:"store", loadOp:"clear", clearValue:{r:0, g:0, b:0, a:0}}]});
          srcView = this.device.createBindGroup({layout:bindGroupLayout, entries:[{binding:0, resource:this.sampler}, {binding:1, resource:srcView}]});
          passEncoder.setPipeline(pipeline);
          passEncoder.setBindGroup(0, srcView);
          passEncoder.draw(3, 1, 0, 0);
          passEncoder.end();
          srcView = dstView;
        }
      }
      if (!renderToSource) {
        for (pipeline = {width:Math.ceil(texture.width / 2), height:Math.ceil(texture.height / 2), depthOrArrayLayers:arrayLayerCount}, arrayLayerCount = 1; arrayLayerCount < texture.mipLevelCount; ++arrayLayerCount) {
          commandEncoder.copyTextureToTexture({texture:mipTexture, mipLevel:arrayLayerCount - 1}, {texture, mipLevel:arrayLayerCount}, pipeline), pipeline.width = Math.ceil(pipeline.width / 2), pipeline.height = Math.ceil(pipeline.height / 2);
        }
      }
      this.device.queue.submit([commandEncoder.finish()]);
      renderToSource || mipTexture.destroy();
      return texture;
    }
  }
  exports.GpuMipmapGenerator = GpuMipmapGenerator;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$rendering$renderers$gpu$texture$utils$GpuMipmapGenerator.js.map
