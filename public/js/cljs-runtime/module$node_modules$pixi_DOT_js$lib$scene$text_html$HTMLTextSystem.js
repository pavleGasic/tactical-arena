shadow$provide.module$node_modules$pixi_DOT_js$lib$scene$text_html$HTMLTextSystem = function(global, require, module, exports) {
  global = require("module$node_modules$pixi_DOT_js$lib$extensions$Extensions");
  var CanvasPool = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$texture$CanvasPool"), TexturePool = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$texture$TexturePool"), types = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$types"), isSafari = require("module$node_modules$pixi_DOT_js$lib$utils$browser$isSafari"), warn = require("module$node_modules$pixi_DOT_js$lib$utils$logging$warn"), PoolGroup = require("module$node_modules$pixi_DOT_js$lib$utils$pool$PoolGroup"), 
  getPo2TextureFromSource = require("module$node_modules$pixi_DOT_js$lib$scene$text$utils$getPo2TextureFromSource"), HTMLTextRenderData = require("module$node_modules$pixi_DOT_js$lib$scene$text_html$HTMLTextRenderData"), HTMLTextStyle = require("module$node_modules$pixi_DOT_js$lib$scene$text_html$HTMLTextStyle"), extractFontFamilies = require("module$node_modules$pixi_DOT_js$lib$scene$text_html$utils$extractFontFamilies"), getFontCss = require("module$node_modules$pixi_DOT_js$lib$scene$text_html$utils$getFontCss"), 
  getSVGUrl = require("module$node_modules$pixi_DOT_js$lib$scene$text_html$utils$getSVGUrl"), getTemporaryCanvasFromImage = require("module$node_modules$pixi_DOT_js$lib$scene$text_html$utils$getTemporaryCanvasFromImage"), loadSVGImage = require("module$node_modules$pixi_DOT_js$lib$scene$text_html$utils$loadSVGImage"), measureHtmlText = require("module$node_modules$pixi_DOT_js$lib$scene$text_html$utils$measureHtmlText");
  "use strict";
  class HTMLTextSystem {
    constructor(renderer) {
      this._activeTextures = {};
      this._renderer = renderer;
      this._createCanvas = renderer.type === types.RendererType.WEBGPU;
    }
    getTexture(options) {
      return this._buildTexturePromise(options.text, options.resolution, options.style);
    }
    getManagedTexture(text, resolution, style, textKey) {
      if (this._activeTextures[textKey]) {
        return this._increaseReferenceCount(textKey), this._activeTextures[textKey].promise;
      }
      text = this._buildTexturePromise(text, resolution, style).then(texture => this._activeTextures[textKey].texture = texture);
      this._activeTextures[textKey] = {texture:null, promise:text, usageCount:1};
      return text;
    }
    async _buildTexturePromise(text, resolution, style) {
      const htmlTextData = PoolGroup.BigPool.get(HTMLTextRenderData.HTMLTextRenderData), fontFamilies = extractFontFamilies.extractFontFamilies(text, style), fontCSS = await getFontCss.getFontCss(fontFamilies, style, HTMLTextStyle.HTMLTextStyle.defaultTextStyle), measured = measureHtmlText.measureHtmlText(text, style, fontCSS, htmlTextData), height = Math.ceil(Math.ceil(Math.max(1, measured.height) + 2 * style.padding) * resolution), image = htmlTextData.image;
      image.width = (Math.ceil(Math.ceil(Math.max(1, measured.width) + 2 * style.padding) * resolution) | 0) + 2;
      image.height = (height | 0) + 2;
      text = getSVGUrl.getSVGUrl(text, style, resolution, fontCSS, htmlTextData);
      await loadSVGImage.loadSVGImage(image, text, isSafari.isSafari() && 0 < fontFamilies.length);
      let canvasAndContext;
      this._createCanvas && (canvasAndContext = getTemporaryCanvasFromImage.getTemporaryCanvasFromImage(image, resolution));
      resolution = getPo2TextureFromSource.getPo2TextureFromSource(canvasAndContext ? canvasAndContext.canvas : image, image.width - 2, image.height - 2, resolution);
      this._createCanvas && (this._renderer.texture.initSource(resolution.source), CanvasPool.CanvasPool.returnCanvasAndContext(canvasAndContext));
      PoolGroup.BigPool.return(htmlTextData);
      return resolution;
    }
    _increaseReferenceCount(textKey) {
      this._activeTextures[textKey].usageCount++;
    }
    decreaseReferenceCount(textKey) {
      const activeTexture = this._activeTextures[textKey];
      activeTexture && (activeTexture.usageCount--, 0 === activeTexture.usageCount && (activeTexture.texture ? this._cleanUp(activeTexture) : activeTexture.promise.then(texture => {
        activeTexture.texture = texture;
        this._cleanUp(activeTexture);
      }).catch(() => {
        warn.warn("HTMLTextSystem: Failed to clean texture");
      }), this._activeTextures[textKey] = null));
    }
    _cleanUp(activeTexture) {
      TexturePool.TexturePool.returnTexture(activeTexture.texture);
      activeTexture.texture.source.resource = null;
      activeTexture.texture.source.uploadMethodId = "unknown";
    }
    getReferenceCount(textKey) {
      return this._activeTextures[textKey].usageCount;
    }
    destroy() {
      this._activeTextures = null;
    }
  }
  HTMLTextSystem.extension = {type:[global.ExtensionType.WebGLSystem, global.ExtensionType.WebGPUSystem, global.ExtensionType.CanvasSystem], name:"htmlText"};
  HTMLTextSystem.defaultFontOptions = {fontFamily:"Arial", fontStyle:"normal", fontWeight:"normal"};
  exports.HTMLTextSystem = HTMLTextSystem;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$scene$text_html$HTMLTextSystem.js.map
