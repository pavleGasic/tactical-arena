shadow$provide.module$node_modules$$xmldom$xmldom$lib$dom_parser = function(global, require, module, exports) {
  function normalizeLineEndings(input) {
    return input.replace(/\r[\n\u0085]/g, "\n").replace(/[\r\u0085\u2028]/g, "\n");
  }
  function DOMParser(options) {
    this.options = options || {locator:{}};
  }
  function buildErrorHandler(errorImpl, domBuilder, locator) {
    function build(key) {
      var fn = errorImpl[key];
      !fn && isCallback && (fn = 2 == errorImpl.length ? function(msg) {
        errorImpl(key, msg);
      } : errorImpl);
      errorHandler[key] = fn && function(msg) {
        fn("[xmldom " + key + "]\t" + msg + _locator(locator));
      } || function() {
      };
    }
    if (!errorImpl) {
      if (domBuilder instanceof DOMHandler) {
        return domBuilder;
      }
      errorImpl = domBuilder;
    }
    var errorHandler = {}, isCallback = errorImpl instanceof Function;
    locator = locator || {};
    build("warning");
    build("error");
    build("fatalError");
    return errorHandler;
  }
  function DOMHandler() {
    this.cdata = !1;
  }
  function position(locator, node) {
    node.lineNumber = locator.lineNumber;
    node.columnNumber = locator.columnNumber;
  }
  function _locator(l) {
    if (l) {
      return "\n@" + (l.systemId || "") + "#[line:" + l.lineNumber + ",col:" + l.columnNumber + "]";
    }
  }
  function _toString(chars, start, length) {
    return "string" == typeof chars ? chars.substr(start, length) : chars.length >= start + length || start ? new java.lang.String(chars, start, length) + "" : chars;
  }
  function appendElement(hander, node) {
    hander.currentElement ? hander.currentElement.appendChild(node) : hander.doc.appendChild(node);
  }
  global = require("module$node_modules$$xmldom$xmldom$lib$conventions");
  module = require("module$node_modules$$xmldom$xmldom$lib$dom");
  var entities = require("module$node_modules$$xmldom$xmldom$lib$entities");
  require = require("module$node_modules$$xmldom$xmldom$lib$sax");
  var DOMImplementation = module.DOMImplementation, NAMESPACE = global.NAMESPACE, ParseError = require.ParseError, XMLReader = require.XMLReader;
  DOMParser.prototype.parseFromString = function(source, mimeType) {
    var options = this.options, sax = new XMLReader(), domBuilder = options.domBuilder || new DOMHandler(), errorHandler = options.errorHandler, locator = options.locator, defaultNSMap = options.xmlns || {}, isHTML = /\/x?html?$/.test(mimeType);
    mimeType = isHTML ? entities.HTML_ENTITIES : entities.XML_ENTITIES;
    locator && domBuilder.setDocumentLocator(locator);
    sax.errorHandler = buildErrorHandler(errorHandler, domBuilder, locator);
    sax.domBuilder = options.domBuilder || domBuilder;
    isHTML && (defaultNSMap[""] = NAMESPACE.HTML);
    defaultNSMap.xml = defaultNSMap.xml || NAMESPACE.XML;
    options = options.normalizeLineEndings || normalizeLineEndings;
    source && "string" === typeof source ? sax.parse(options(source), defaultNSMap, mimeType) : sax.errorHandler.error("invalid doc source");
    return domBuilder.doc;
  };
  DOMHandler.prototype = {startDocument:function() {
    this.doc = (new DOMImplementation()).createDocument(null, null, null);
    this.locator && (this.doc.documentURI = this.locator.systemId);
  }, startElement:function(namespaceURI, localName, qName, attrs) {
    var doc = this.doc;
    localName = doc.createElementNS(namespaceURI, qName || localName);
    var len = attrs.length;
    appendElement(this, localName);
    this.currentElement = localName;
    this.locator && position(this.locator, localName);
    for (var i = 0; i < len; i++) {
      namespaceURI = attrs.getURI(i);
      var value = attrs.getValue(i);
      qName = attrs.getQName(i);
      namespaceURI = doc.createAttributeNS(namespaceURI, qName);
      this.locator && position(attrs.getLocator(i), namespaceURI);
      namespaceURI.value = namespaceURI.nodeValue = value;
      localName.setAttributeNode(namespaceURI);
    }
  }, endElement:function(namespaceURI, localName, qName) {
    this.currentElement = this.currentElement.parentNode;
  }, startPrefixMapping:function(prefix, uri) {
  }, endPrefixMapping:function(prefix) {
  }, processingInstruction:function(target, data) {
    target = this.doc.createProcessingInstruction(target, data);
    this.locator && position(this.locator, target);
    appendElement(this, target);
  }, ignorableWhitespace:function(ch, start, length) {
  }, characters:function(chars, start, length) {
    if (chars = _toString.apply(this, arguments)) {
      var charNode = this.cdata ? this.doc.createCDATASection(chars) : this.doc.createTextNode(chars);
      this.currentElement ? this.currentElement.appendChild(charNode) : /^\s*$/.test(chars) && this.doc.appendChild(charNode);
      this.locator && position(this.locator, charNode);
    }
  }, skippedEntity:function(name) {
  }, endDocument:function() {
    this.doc.normalize();
  }, setDocumentLocator:function(locator) {
    if (this.locator = locator) {
      locator.lineNumber = 0;
    }
  }, comment:function(chars, start, length) {
    chars = _toString.apply(this, arguments);
    var comm = this.doc.createComment(chars);
    this.locator && position(this.locator, comm);
    appendElement(this, comm);
  }, startCDATA:function() {
    this.cdata = !0;
  }, endCDATA:function() {
    this.cdata = !1;
  }, startDTD:function(name, publicId, systemId) {
    var impl = this.doc.implementation;
    impl && impl.createDocumentType && (name = impl.createDocumentType(name, publicId, systemId), this.locator && position(this.locator, name), appendElement(this, name), this.doc.doctype = name);
  }, warning:function(error) {
    console.warn("[xmldom warning]\t" + error, _locator(this.locator));
  }, error:function(error) {
    console.error("[xmldom error]\t" + error, _locator(this.locator));
  }, fatalError:function(error) {
    throw new ParseError(error, this.locator);
  }};
  "endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g, function(key) {
    DOMHandler.prototype[key] = function() {
      return null;
    };
  });
  exports.__DOMHandler = DOMHandler;
  exports.normalizeLineEndings = normalizeLineEndings;
  exports.DOMParser = DOMParser;
};

//# sourceMappingURL=module$node_modules$$xmldom$xmldom$lib$dom_parser.js.map
