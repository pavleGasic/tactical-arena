shadow$provide.module$node_modules$pixi_DOT_js$lib$rendering$renderers$gl$buffer$GlBufferSystem = function(global, require, module, exports) {
  global = require("module$node_modules$pixi_DOT_js$lib$extensions$Extensions");
  var _const = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$buffer$const"), _const$1 = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$gl$buffer$const"), GlBuffer = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$gl$buffer$GlBuffer");
  "use strict";
  class GlBufferSystem {
    constructor(renderer) {
      this._gpuBuffers = Object.create(null);
      this._boundBufferBases = Object.create(null);
      this._bindCallId = this._nextBindBaseIndex = this._minBaseLocation = 0;
      this._renderer = renderer;
      this._renderer.renderableGC.addManagedHash(this, "_gpuBuffers");
    }
    destroy() {
      this._boundBufferBases = this._gpuBuffers = this._gl = this._renderer = null;
    }
    contextChange() {
      const gl = this._gl = this._renderer.gl;
      this._gpuBuffers = Object.create(null);
      this._maxBindings = gl.MAX_UNIFORM_BUFFER_BINDINGS ? gl.getParameter(gl.MAX_UNIFORM_BUFFER_BINDINGS) : 0;
    }
    getGlBuffer(buffer) {
      return this._gpuBuffers[buffer.uid] || this.createGLBuffer(buffer);
    }
    bind(buffer) {
      const {_gl:gl} = this;
      buffer = this.getGlBuffer(buffer);
      gl.bindBuffer(buffer.type, buffer.buffer);
    }
    bindBufferBase(glBuffer, index) {
      const {_gl:gl} = this;
      this._boundBufferBases[index] !== glBuffer && (this._boundBufferBases[index] = glBuffer, glBuffer._lastBindBaseLocation = index, gl.bindBufferBase(gl.UNIFORM_BUFFER, index, glBuffer.buffer));
    }
    nextBindBase(hasTransformFeedback) {
      this._bindCallId++;
      this._minBaseLocation = 0;
      hasTransformFeedback && (this._boundBufferBases[0] = null, this._minBaseLocation = 1, 1 > this._nextBindBaseIndex && (this._nextBindBaseIndex = 1));
    }
    freeLocationForBufferBase(glBuffer) {
      var freeIndex = this.getLastBindBaseLocation(glBuffer);
      if (freeIndex >= this._minBaseLocation) {
        return glBuffer._lastBindCallId = this._bindCallId, freeIndex;
      }
      let loop = 0, nextIndex = this._nextBindBaseIndex;
      for (; 2 > loop;) {
        if (nextIndex >= this._maxBindings && (nextIndex = this._minBaseLocation, loop++), (freeIndex = this._boundBufferBases[nextIndex]) && freeIndex._lastBindCallId === this._bindCallId) {
          nextIndex++;
        } else {
          break;
        }
      }
      freeIndex = nextIndex;
      this._nextBindBaseIndex = nextIndex + 1;
      if (2 <= loop) {
        return -1;
      }
      glBuffer._lastBindCallId = this._bindCallId;
      this._boundBufferBases[freeIndex] = null;
      return freeIndex;
    }
    getLastBindBaseLocation(glBuffer) {
      const index = glBuffer._lastBindBaseLocation;
      return this._boundBufferBases[index] === glBuffer ? index : -1;
    }
    bindBufferRange(glBuffer, index, offset, size) {
      const {_gl:gl} = this;
      offset || (offset = 0);
      index || (index = 0);
      this._boundBufferBases[index] = null;
      gl.bindBufferRange(gl.UNIFORM_BUFFER, index || 0, glBuffer.buffer, 256 * offset, size || 256);
    }
    updateBuffer(buffer) {
      const {_gl:gl} = this, glBuffer = this.getGlBuffer(buffer);
      if (buffer._updateID === glBuffer.updateID) {
        return glBuffer;
      }
      glBuffer.updateID = buffer._updateID;
      gl.bindBuffer(glBuffer.type, glBuffer.buffer);
      const data = buffer.data, drawType = buffer.descriptor.usage & _const.BufferUsage.STATIC ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW;
      data ? glBuffer.byteLength >= data.byteLength ? gl.bufferSubData(glBuffer.type, 0, data, 0, buffer._updateSize / data.BYTES_PER_ELEMENT) : (glBuffer.byteLength = data.byteLength, gl.bufferData(glBuffer.type, data, drawType)) : (glBuffer.byteLength = buffer.descriptor.size, gl.bufferData(glBuffer.type, glBuffer.byteLength, drawType));
      return glBuffer;
    }
    destroyAll() {
      const gl = this._gl;
      for (const id in this._gpuBuffers) {
        gl.deleteBuffer(this._gpuBuffers[id].buffer);
      }
      this._gpuBuffers = Object.create(null);
    }
    onBufferDestroy(buffer, contextLost) {
      const glBuffer = this._gpuBuffers[buffer.uid], gl = this._gl;
      contextLost || gl.deleteBuffer(glBuffer.buffer);
      this._gpuBuffers[buffer.uid] = null;
    }
    createGLBuffer(buffer) {
      var {_gl:gl} = this;
      let type = _const$1.BUFFER_TYPE.ARRAY_BUFFER;
      buffer.descriptor.usage & _const.BufferUsage.INDEX ? type = _const$1.BUFFER_TYPE.ELEMENT_ARRAY_BUFFER : buffer.descriptor.usage & _const.BufferUsage.UNIFORM && (type = _const$1.BUFFER_TYPE.UNIFORM_BUFFER);
      gl = new GlBuffer.GlBuffer(gl.createBuffer(), type);
      this._gpuBuffers[buffer.uid] = gl;
      buffer.on("destroy", this.onBufferDestroy, this);
      return gl;
    }
    resetState() {
      this._boundBufferBases = Object.create(null);
    }
  }
  GlBufferSystem.extension = {type:[global.ExtensionType.WebGLSystem], name:"buffer"};
  exports.GlBufferSystem = GlBufferSystem;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$rendering$renderers$gl$buffer$GlBufferSystem.js.map
