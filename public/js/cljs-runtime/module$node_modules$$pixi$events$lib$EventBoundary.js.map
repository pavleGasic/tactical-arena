{
"version":3,
"file":"module$node_modules$$pixi$events$lib$EventBoundary.js",
"lineCount":362,
"mappings":"AAAAA,cAAA,CAAA,kDAAA,GAAuE,QAAQ,CAACC,MAAD,EAAQC,OAAR,EAAgBC,MAAhB,EAAuBC,OAAvB,CAAgC;AAAA,MAE3GC,OAAOH,OAAA,CAAQ,0CAAR,CAFoG,EAE7EI,cAAcJ,OAAA,CAAQ,kDAAR,CAF+D,EAElCK,sBAAsBL,OAAA,CAAQ,0DAAR,CAFY,EAEyBM,wBAAwBN,OAAA,CAAQ,4DAAR,CAFjD,EAEwFO,sBAAsBP,OAAA,CAAQ,0DAAR,CAF9G;AAAA,QAG/EQ,kBAAkB,IAAIL,IAAKM,CAAAA,KAAT,EAH6D,EAG3CC,mBAAmB,IAAIP,IAAKM,CAAAA,KAAT,EAHwB;AAI/G,OAAME,cAAN;AAIEC,eAAW,CAACC,UAAD,CAAa;AACtB,UAAKC,CAAAA,QAAL,GAAgB,IAAIX,IAAKY,CAAAA,KAAMC,CAAAA,YAAf,EAAhB;AAA+C,UAAKC,CAAAA,SAAL,GAAiB,CAAA,CAAjB;AAAqB,UAAKC,CAAAA,sBAAL,GAA8B,CAAA,CAA9B;AAAkC,UAAKC,CAAAA,YAAL,GAAoB,CACxHC,aAAc,EAD0G,CAApB;AAEnG,UAAKC,CAAAA,SAAL,GAAiC,IAAIC,GAAJ,EAAjC;AAA4C,UAAKC,CAAAA,uBAAL,GAA+B,EAA/B;AAAmC,UAAKC,CAAAA,YAAL,GAAoB,EAApB;AAAwB,UAAKC,CAAAA,mBAAL,GAA2B,CAAA,CAA3B;AAA+B,UAAKZ,CAAAA,UAAL,GAAkBA,UAAlB;AAA8B,UAAKa,CAAAA,UAAL,GAAkB,IAAKA,CAAAA,UAAWC,CAAAA,IAAhB,CAAqB,IAArB,CAAlB;AAA8C,UAAKC,CAAAA,SAAL,GAAiB,IAAKA,CAAAA,SAAUD,CAAAA,IAAf,CAAoB,IAApB,CAAjB;AAA4C,UAAKE,CAAAA,cAAL,GAAsB,IAAKA,CAAAA,cAAeF,CAAAA,IAApB,CAAyB,IAAzB,CAAtB;AAAsD,UAAKG,CAAAA,cAAL,GAAsB,IAAKA,CAAAA,cAAeH,CAAAA,IAApB,CAAyB,IAAzB,CAAtB;AAAsD,UAAKI,CAAAA,aAAL,GAAqB,IAAKA,CAAAA,aAAcJ,CAAAA,IAAnB,CAAwB,IAAxB,CAArB;AAAoD,UAAKK,CAAAA,cAAL,GAAsB,IAAKA,CAAAA,cAAeL,CAAAA,IAApB,CAAyB,IAAzB,CAAtB;AAAsD,UAAKM,CAAAA,YAAL,GAAoB,IAAKA,CAAAA,YAAaN,CAAAA,IAAlB,CAAuB,IAAvB,CAApB;AAAkD,UAAKO,CAAAA,mBAAL,GAA2B,IAAKA,CAAAA,mBAAoBP,CAAAA,IAAzB,CAA8B,IAA9B,CAA3B;AAAgE,UAAKQ,CAAAA,QAAL,GAAgB,IAAKA,CAAAA,QAASR,CAAAA,IAAd,CAAmB,IAAnB,CAAhB;AAA0C,UAAKS,CAAAA,YAAL,GAAoB,EAApB;AAAwB,UAAKC,CAAAA,eAAL,CAAqB,aAArB,EAAoC,IAAKR,CAAAA,cAAzC,CAAA;AAA0D,UAAKQ,CAAAA,eAAL,CAAqB,aAArB,EAAoC,IAAKP,CAAAA,cAAzC,CAAA;AAA0D,UAAKO,CAAAA,eAAL,CAAqB,YAArB,EAAmC,IAAKN,CAAAA,aAAxC,CAAA;AAAwD,UAAKM,CAAAA,eAAL,CAAqB,cAArB,EAAqC,IAAKN,CAAAA,aAA1C,CAAA;AAA0D,UAAKM,CAAAA,eAAL,CAAqB,aAArB,EAAoC,IAAKL,CAAAA,cAAzC,CAAA;AAA0D,UAAKK,CAAAA,eAAL,CAAqB,WAArB,EAAkC,IAAKJ,CAAAA,YAAvC,CAAA;AAAsD,UAAKI,CAAAA,eAAL,CAAqB,kBAArB,EAAyC,IAAKH,CAAAA,mBAA9C,CAAA;AAAoE,UAAKG,CAAAA,eAAL,CAAqB,OAArB,EAA8B,IAAKF,CAAAA,QAAnC,CAAA;AAH/gC;AAiBxBE,mBAAe,CAACC,IAAD,EAAOC,EAAP,CAAW;AACxB,UAAKH,CAAAA,YAAL,CAAkBE,IAAlB,CAAA,KAA4B,IAAKF,CAAAA,YAAL,CAAkBE,IAAlB,CAA5B,GAAsD,EAAtD;AAA2D,UAAKF,CAAAA,YAAL,CAAkBE,IAAlB,CAAwBE,CAAAA,IAAxB,CAA6B,CACtFD,EADsF,EAEtFE,SAAU,CAF4E,CAA7B,CAAA;AAGvD,UAAKL,CAAAA,YAAL,CAAkBE,IAAlB,CAAwBI,CAAAA,IAAxB,CAA6B,CAACC,CAAD,EAAIC,CAAJ,CAAA,IAAUD,CAAEF,CAAAA,QAAZ,GAAuBG,CAAEH,CAAAA,QAAtD,CAAA;AAJoB;AAW1BI,iBAAa,CAACC,CAAD,EAAIR,IAAJ,CAAU;AACrBQ,OAAEC,CAAAA,kBAAF,GAAuB,CAAA,CAAvB;AAA2BD,OAAEE,CAAAA,6BAAF,GAAkC,CAAA,CAAlC;AAAsC,UAAKC,CAAAA,SAAL,CAAeH,CAAf,EAAkBR,IAAlB,CAAA;AAAyB,UAAKxB,CAAAA,QAASoC,CAAAA,IAAd,CAAmBZ,IAAnB,IAA2BQ,CAAER,CAAAA,IAA7B,EAAmCQ,CAAnC,CAAA;AADrE;AAOvBK,YAAQ,CAACL,CAAD,CAAI;AACV,UAAK,IAAKjC,CAAAA,UAAV,CAAA;AAEA,YAAMuC,UAAU,IAAKhB,CAAAA,YAAL,CAAkBU,CAAER,CAAAA,IAApB,CAAhB;AACA,YAAIc,OAAJ;AACE,eAAK,IAAIC,IAAI,CAAR,EAAWC,IAAIF,OAAQG,CAAAA,MAA5B,EAAoCF,CAApC,GAAwCC,CAAxC,EAA2CD,CAAA,EAA3C;AACED,mBAAA,CAAQC,CAAR,CAAWd,CAAAA,EAAX,CAAcO,CAAd,CAAA;AADF;AADF;AAIEU,iBAAQC,CAAAA,IAAR,CAAc,kDAAiDX,CAAER,CAAAA,IAAnD,EAAd,CAAA;AAJF;AAHA;AADU;AAiBZoB,WAAO,CAACC,CAAD,EAAIC,CAAJ,CAAO;AACZxD,iBAAYyD,CAAAA,YAAaC,CAAAA,WAAzB,GAAuC,CAAA,CAAvC;AAQA,cAPkHC,CAOlH,GAPiI,IAAA,CAAtH,IAAKtC,CAAAA,mBAALc,IAA4B,IAAKrB,CAAAA,sBAAjCqB,GAA0D,sBAA1DA,GAAmF,kBAAmC,CAAA,CAC/H,IAAK1B,CAAAA,UAD0H,EAE/H,IAAKA,CAAAA,UAAWmD,CAAAA,SAF+G,EAG/HxD,eAAgByD,CAAAA,GAAhB,CAAoBN,CAApB,EAAuBC,CAAvB,CAH+H,EAI/H,IAAKhC,CAAAA,SAJ0H,EAK/H,IAAKF,CAAAA,UAL0H,CAOjI,KAAuBqC,CAAA,CAAa,CAAb,CAAvB;AATY;AAiBdd,aAAS,CAACH,CAAD,EAAIR,IAAJ,CAAU;AACjB,UAAKQ,CAAEoB,CAAAA,MAAP,CAAA;AAEA,YAAMC,eAAerB,CAAEqB,CAAAA,YAAF,EAArB;AACArB,SAAEsB,CAAAA,UAAF,GAAetB,CAAEuB,CAAAA,eAAjB;AACA,aAAK,IAAIhB,IAAI,CAAR,EAAWC,IAAIa,YAAaZ,CAAAA,MAAjBD,GAA0B,CAA1C,EAA6CD,CAA7C,GAAiDC,CAAjD,EAAoDD,CAAA,EAApD;AACE,cAAIP,CAAEwB,CAAAA,aAAF,GAAkBH,YAAA,CAAad,CAAb,CAAlB,EAAmC,IAAKkB,CAAAA,YAAL,CAAkBzB,CAAlB,EAAqBR,IAArB,CAAnC,EAA+DQ,CAAEC,CAAAA,kBAAjE,IAAuFD,CAAEE,CAAAA,6BAA7F;AACE;AADF;AADF;AAGA,YAAIF,CAAEsB,CAAAA,UAAF,GAAetB,CAAE0B,CAAAA,SAAjB,EAA4B1B,CAAEwB,CAAAA,aAA9B,GAA8CxB,CAAEoB,CAAAA,MAAhD,EAAwD,IAAKK,CAAAA,YAAL,CAAkBzB,CAAlB,EAAqBR,IAArB,CAAxD,EAAwFS,CAAFD,CAAEC,CAAAA,kBAAxF,IAAgHC,CAAFF,CAAEE,CAAAA,6BAApH,CAAoJ;AAClJF,WAAEsB,CAAAA,UAAF,GAAetB,CAAE2B,CAAAA,cAAjB;AACA,eAAK,IAAIpB,IAAIc,YAAaZ,CAAAA,MAAjBF,GAA0B,CAAnC,EAA2C,CAA3C,IAAsCA,CAAtC,KACMP,CAAEwB,CAAAA,aAAF,GAAkBH,YAAA,CAAad,CAAb,CAAlB,EAAmC,IAAKkB,CAAAA,YAAL,CAAkBzB,CAAlB,EAAqBR,IAArB,CAAnC,EAAiES,CAAFD,CAAEC,CAAAA,kBAAjE,IAAyFC,CAAFF,CAAEE,CAAAA,6BAD/F,GAA8CK,CAAA,EAA9C;;AAFkJ;AAPpJ;AADiB;AAuBnBqB,OAAG,CAAC5B,CAAD,EAAIR,IAAJ,EAAUqC,OAAA,GAAU,IAAKpD,CAAAA,uBAAzB,CAAkD;AACnD,UAAuB,CAAvB,KAAIoD,OAAQpB,CAAAA,MAAZ,CAAA;AAEAT,SAAEsB,CAAAA,UAAF,GAAetB,CAAE2B,CAAAA,cAAjB;AACMG,YAAAA,GAASC,KAAMC,CAAAA,OAAN,CAAcxC,IAAd,CAAA,GAAsBA,IAAtB,GAA6B,CAACA,IAAD,CAAtCsC;AACN,aAAK,IAAIvB,IAAIsB,OAAQpB,CAAAA,MAAZF,GAAqB,CAA9B,EAAsC,CAAtC,IAAiCA,CAAjC,EAAyCA,CAAA,EAAzC;AACEuB,cAAOG,CAAAA,OAAP,CAAgBC,KAAD,IAAW;AACxBlC,aAAEwB,CAAAA,aAAF,GAAkBK,OAAA,CAAQtB,CAAR,CAAlB;AAA8B,gBAAKkB,CAAAA,YAAL,CAAkBzB,CAAlB,EAAqBkC,KAArB,CAAA;AADN,WAA1B,CAAA;AADF;AAJA;AADmD;AAerDC,mBAAe,CAACf,MAAD,CAAS;AACtB,YAAMe,kBAAkB,CAACf,MAAD,CAAxB;AACA,WAAK,IAAIb,IAAI,CAAb,EAlHsB6B,IAkHtB,GAAgB7B,CAAhB,IAAyCa,MAAzC,KAAoD,IAAKrD,CAAAA,UAAzD,EAAqEwC,CAAA,EAArE,CAA0E;AACxE,YAAI,CAACa,MAAOiB,CAAAA,MAAZ;AACE,gBAAUC,KAAJ,CAAU,qDAAV,CAAN;AADF;AAEAH,uBAAgBzC,CAAAA,IAAhB,CAAqB0B,MAAOiB,CAAAA,MAA5B,CAAA;AAAqCjB,cAAA,GAASA,MAAOiB,CAAAA,MAAhB;AAHmC;AAK1E,aAAOF,eAAgBI,CAAAA,OAAhB,EAAA,EAA2BJ,eAAlC;AAPsB;AASxBK,wBAAoB,CAAChB,aAAD,EAAgBN,SAAhB,EAA2BuB,QAA3B,EAAqCC,MAArC,EAA6CC,OAA7C,EAAsDC,MAAA,GAAS,CAAA,CAA/D,CAAmE;AACrF,UAAIC,eAAe,CAAA,CAAnB;AACA,UAAI,IAAKC,CAAAA,iBAAL,CAAuBtB,aAAvB,CAAJ;AACE,eAAO,IAAP;AADF;AAEA,UAAI,CAA6B,SAA7B,KAACA,aAAcN,CAAAA,SAAf,IAAwD,SAAxD,KAA0CA,SAA1C,MAAuE5D,WAAYyD,CAAAA,YAAaC,CAAAA,WAAhG,GAA8G,CAAA,CAA9G,GAAmHQ,aAAcuB,CAAAA,mBAAjI,IAAwJvB,aAAcwB,CAAAA,QAA1K,CAAoL;AAClL,YAAMA,WAAWxB,aAAcwB,CAAAA,QAA/B;AACA,aAAK,IAAIzC,IAAIyC,QAASvC,CAAAA,MAAbF,GAAsB,CAA/B,EAAuC,CAAvC,IAAkCA,CAAlC,EAA0CA,CAAA,EAA1C,CAA+C;AAAA,cACvC0C,QAAQD,QAAA,CAASzC,CAAT,CAD+B;AAClB2C,YAAAA,KAAAA,GAAY,IAAKV,CAAAA,oBAAL,CACrCS,KADqC,EAErC,IAAKE,CAAAA,cAAL,CAAoBjC,SAApB,CAAA,GAAiCA,SAAjC,GAA6C+B,KAAM/B,CAAAA,SAFd,EAGrCuB,QAHqC,EAIrCC,MAJqC,EAKrCC,OALqC,EAMrCC,MANqC,IAM3BD,OAAA,CAAQnB,aAAR,EAAuBiB,QAAvB,CAN2B,CAAZS,CAQ3B,IACyB,CADzB,GACMA,KAAUzC,CAAAA,MADhB,IAC+D4B,CAAhCa,KAAA,CAAUA,KAAUzC,CAAAA,MAApB,GAA6B,CAA7B,CAAgC4B,CAAAA,MAD/D,KAGQe,YAC4M,GAD5L5B,aAAc4B,CAAAA,aAAd,EAC4L,GAA9L,CAA8L,GAAjNF,KAAUzC,CAAAA,MAAuM,IAAzL2C,YAAyL,MAAtKA,YAAA,IAAiB,IAAK3E,CAAAA,uBAAwBiB,CAAAA,IAA7B,CAAkC8B,aAAlC,CAAjB,EAAmE0B,KAAUxD,CAAAA,IAAV,CAAe8B,aAAf,CAAmG,GAAtC,CAAsC,KAAnE,IAAK9C,CAAAA,YAAa+B,CAAAA,MAAiD,KAAhC,IAAK/B,CAAAA,YAA2B,GAAZwE,KAAY,GAAAL,YAAA;AAAe,WAAA,CAJnO;AAT6C;AAFmI;AAmB9KQ,eAAAA,GAAoB,IAAKF,CAAAA,cAAL,CAAoBjC,SAApB,CAApBmC;AAAoDC,cAAAA,GAAsB9B,aAAc4B,CAAAA,aAAd,EAAtBE;AAC1D,aAAOD,SAAA,IAAqBC,QAArB,IAA4C,IAAK7E,CAAAA,uBAAwBiB,CAAAA,IAA7B,CAAkC8B,aAAlC,CAA5C,EAA8FoB,MAAA,IAAqC,CAArC,GAAU,IAAKlE,CAAAA,YAAa+B,CAAAA,MAA5B,GAAyC,IAAzC,GAAgDoC,YAAA,GAAe,IAAKnE,CAAAA,YAApB,GAAmC2E,SAAA,IAAqB,CAACV,OAAA,CAAQnB,aAAR,EAAuBiB,QAAvB,CAAtB,IAA0DC,MAAA,CAAOlB,aAAP,EAAsBiB,QAAtB,CAA1D,GAA4Fa,QAAA,GAAsB,CAAC9B,aAAD,CAAtB,GAAwC,EAApI,GAAyI,IAAjU;AAxBqF;AAwCvF+B,oBAAgB,CAAC/B,aAAD,EAAgBN,SAAhB,EAA2BuB,QAA3B,EAAqCC,MAArC,EAA6CC,OAA7C,CAAsD;AACpE,UAAI,IAAKG,CAAAA,iBAAL,CAAuBtB,aAAvB,CAAJ,IAA6CmB,OAAA,CAAQnB,aAAR,EAAuBiB,QAAvB,CAA7C;AACE,eAAO,IAAP;AADF;AAEA,UAAI,CAA6B,SAA7B,KAACjB,aAAcN,CAAAA,SAAf,IAAwD,SAAxD,KAA0CA,SAA1C,MAAuE5D,WAAYyD,CAAAA,YAAaC,CAAAA,WAAhG,GAA8G,CAAA,CAA9G,GAAmHQ,aAAcuB,CAAAA,mBAAjI,IAAwJvB,aAAcwB,CAAAA,QAA1K,CAAoL;AAClL,cAAMA,WAAWxB,aAAcwB,CAAAA,QAA/B;AACA,aAAK,IAAIzC,IAAIyC,QAASvC,CAAAA,MAAbF,GAAsB,CAA/B,EAAuC,CAAvC,IAAkCA,CAAlC,EAA0CA,CAAA,EAA1C,CAA+C;AAAA,cACvC0C,QAAQD,QAAA,CAASzC,CAAT,CAD+B;AAQ7C,eAP2B2C,KAO3B,GAPuC,IAAKK,CAAAA,gBAAL,CACrCN,KADqC,EAErC,IAAKE,CAAAA,cAAL,CAAoBjC,SAApB,CAAA,GAAiCA,SAAjC,GAA6C+B,KAAM/B,CAAAA,SAFd,EAGrCuB,QAHqC,EAIrCC,MAJqC,EAKrCC,OALqC,CAOvC,MACM,EAAmB,CAAnB,GAAAO,KAAUzC,CAAAA,MAAV,CADN,IAC+ByC,KAAA,CAAUA,KAAUzC,CAAAA,MAApB,GAA6B,CAA7B,CAAgC4B,CAAAA,MAD/D;AAIE,mBADMe,QACC,GADe5B,aAAc4B,CAAAA,aAAd,EACf,GAAoB,CAApB,GAACF,KAAUzC,CAAAA,MAAX,IAAyB2C,QAAzB,KAA2CF,KAAUxD,CAAAA,IAAV,CAAe8B,aAAf,CAA3C,EAA0E0B,KAAjF;AAJF;AAR6C;AAFmI;AAkB9KG,eAAAA,GAAoB,IAAKF,CAAAA,cAAL,CAAoBjC,SAApB,CAApBmC;AAAoDC,aAAAA,GAAsB9B,aAAc4B,CAAAA,aAAd,EAAtBE;AAC1D,aAAOD,SAAA,IAAqBX,MAAA,CAAOlB,aAAP,EAAsBiB,QAAtB,CAArB,GAAuDa,OAAA,GAAsB,CAAC9B,aAAD,CAAtB,GAAwC,EAA/F,GAAoG,IAA3G;AAtBoE;AAwBtE2B,kBAAc,CAACK,GAAD,CAAM;AAClB,aAAe,QAAf,KAAOA,GAAP,IAAmC,SAAnC,KAA2BA,GAA3B;AADkB;AAGpBV,qBAAiB,CAACW,aAAD,CAAgB;AAC/B,aAAO,EAAIA,aAAJ,IAAmCC,CAAdD,aAAcC,CAAAA,MAAnC,IAA8CD,aAAcE,CAAAA,OAA5D,IAAwEF,aAAcG,CAAAA,UAAtF,IAAgI,MAAhI,KAAoGH,aAAcvC,CAAAA,SAAlH,KAAsK,SAAtK,KAA0IuC,aAAcvC,CAAAA,SAAxJ,IAAoLuC,aAAcV,CAAAA,mBAAlM,KAAuOW,CAAdD,aAAcC,CAAAA,MAAvO,CAAP;AAD+B;AAWjC9E,cAAU,CAAC6E,aAAD,EAAgBhB,QAAhB,CAA0B;AAGlC,aAFIgB,aAAcI,CAAAA,OAElB,KAF8BJ,aAAcK,CAAAA,cAAeC,CAAAA,YAA7B,CAA0CtB,QAA1C,EAAoD7E,gBAApD,CAAA,EAAuE,CAAC6F,aAAcI,CAAAA,OAAQG,CAAAA,QAAtB,CAA+BpG,gBAAiBiD,CAAAA,CAAhD,EAAmDjD,gBAAiBkD,CAAAA,CAApE,CAEtG,KAAI2C,aAAcQ,CAAAA,KAAlB,KACQC,aADR,GACqBT,aAAcQ,CAAAA,KAAME,CAAAA,UAApB,GAAiCV,aAAcQ,CAAAA,KAAMC,CAAAA,UAArD,GAAkET,aAAcQ,CAAAA,KADrG,KAEoB,CAACC,aAAWE,CAAAA,aAAX,GAA2B3B,QAA3B,CAFrB,GAGW,CAAA,CAHX,GAKO,CAAA,CALP;AAHkC;AAgBpC3D,aAAS,CAAC2E,aAAD,EAAgBhB,QAAhB,CAA0B;AACjC,aAAmC,SAA5B,KAAAgB,aAAcvC,CAAAA,SAAd,GAAwC,CAAA,CAAxC,GAA6CuC,aAAcI,CAAAA,OAAd,GAAwB,CAAA,CAAxB,GAA6BJ,aAAcW,CAAAA,aAAd,GAA8BX,aAAcW,CAAAA,aAAd,CAA4B3B,QAA5B,CAA9B,GAAsE,CAAA,CAAvJ;AADiC;AAWnChB,gBAAY,CAACzB,CAAD,EAAIR,IAAJ,CAAU;AACpBA,UAAA,GAAOA,IAAP,IAAeQ,CAAER,CAAAA,IAAjB;AAEAQ,OAAEwB,CAAAA,aAAF,CADoB6C,KAAI7E,IAAJ6E,EACpB,CAAA,GAA8BrE,CAA9B,CAAA;AAEA,UAAKsE,CAAAA,eAAL,CAAqBtE,CAArB,EADYA,CAAEsB,CAAAA,UAAFiD,KAAiBvE,CAAEuB,CAAAA,eAAnBgD,IAAsCvE,CAAEsB,CAAAA,UAAxCiD,KAAuDvE,CAAE0B,CAAAA,SAAzD6C,GAAsE,GAAE/E,IAAF,SAAtE+E,GAAwF/E,IACpG,CAAA;AAA8BQ,OAAEsB,CAAAA,UAAF,KAAiBtB,CAAE0B,CAAAA,SAAnB,IAAgC,IAAK4C,CAAAA,eAAL,CAAqBtE,CAArB,EAAwBR,IAAxB,CAAhC;AALV;AAatBT,kBAAc,CAACyF,IAAD,CAAO;AACnB,UAAMA,IAAN,YAAsBhH,qBAAsBA,CAAAA,qBAA5C,CAAA;AAIA,YAAMwC,IAAI,IAAKyE,CAAAA,kBAAL,CAAwBD,IAAxB,CAAV;AACA,SAAI,IAAKzE,CAAAA,aAAL,CAAmBC,CAAnB,EAAsB,aAAtB,CAAA,EAAwD,OAAxD,KAAsCA,CAAE0E,CAAAA,WAA5C,IACE,IAAK3E,CAAAA,aAAL,CAAmBC,CAAnB,EAAsB,YAAtB,CADF,IAE2B,OAF3B,KAESA,CAAE0E,CAAAA,WAFX,IAEwD,KAFxD,KAEsC1E,CAAE0E,CAAAA,WAFxC,KAIE,IAAK3E,CAAAA,aAAL,CAAmBC,CAAnB,EADmC,CACb,KADAA,CAAE2E,CAAAA,MACF,GAAgB,WAAhB,GAA8B,WAApD,CAJF;AAMqB,YAAKrG,CAAAA,YAALA,CAAkBkG,IAAKI,CAAAA,SAAvBtG,CACRuG,CAAAA,oBAAb,CAAkCL,IAAKG,CAAAA,MAAvC,CAAA,GAAiD3E,CAAEqB,CAAAA,YAAF,EAAjD;AAAmE,YAAKyD,CAAAA,SAAL,CAAe9E,CAAf,CAAA;AAZnE,OAAA;AACEU,eAAQC,CAAAA,IAAR,CAAa,iEAAb,CAAA;AADF;AADmB;AAsBrB3B,kBAAc,CAACwF,IAAD,CAAO;AACnB,UAAMA,IAAN,YAAsBhH,qBAAsBA,CAAAA,qBAA5C,CAAA;AAIA,YAAKiB,CAAAA,uBAAwBgC,CAAAA,MAA7B,GAAsC,CAAtC;AAAyC,YAAK/B,CAAAA,YAAa+B,CAAAA,MAAlB,GAA2B,CAA3B;AAA8B,YAAK9B,CAAAA,mBAAL,GAA2B,CAAA,CAA3B;AACvE,YAAMqB,IAAI,IAAKyE,CAAAA,kBAAL,CAAwBD,IAAxB,CAAV;AACA,YAAK7F,CAAAA,mBAAL,GAA2B,CAAA,CAA3B;AAPmB,YAQboG,UAA4B,OAA5BA,KAAU/E,CAAE0E,CAAAA,WAAZK,IAAyD,KAAzDA,KAAuC/E,CAAE0E,CAAAA,WAR5B,EAQmDpG,eAAe,IAAKA,CAAAA,YAAL,CAAkBkG,IAAKI,CAAAA,SAAvB,CARlE,EAQqGI,YAAY,IAAKC,CAAAA,iBAAL,CAAuB3G,YAAa4G,CAAAA,WAApC,CARjH;AASnB,YAAuC,CAAvC,GAAI5G,YAAa4G,CAAAA,WAAazE,EAAAA,MAA9B,IAA4CuE,SAA5C,KAA0DhF,CAAEoB,CAAAA,MAA5D,CAAoE;AAClE,cAAuE+D,WAAW,IAAKV,CAAAA,kBAAL,CAAwBD,IAAxB,EAApD,WAAdY,KAAAZ,IAAKhF,CAAAA,IAAL4F,GAA4B,UAA5BA,GAAyC,YAAyB,EAAuCJ,SAAvC,CAAlF;AACA,cAAI,IAAKjF,CAAAA,aAAL,CAAmBoF,QAAnB,EAA6B,YAA7B,CAAA,EAA4CJ,OAA5C,IAAuD,IAAKhF,CAAAA,aAAL,CAAmBoF,QAAnB,EAA6B,UAA7B,CAAvD,EAAiG,CAACnF,CAAEqB,CAAAA,YAAF,EAAiBgE,CAAAA,QAAjB,CAA0BL,SAA1B,CAAtG,CAA4I;AAC1I,kBAAMM,aAAa,IAAKb,CAAAA,kBAAL,CAAwBD,IAAxB,EAA8B,cAA9B,EAA8CQ,SAA9C,CAAnB;AACA,iBAAKM,UAAWhE,CAAAA,UAAhB,GAA6BgE,UAAW5D,CAAAA,SAAxC,EAAmD4D,UAAWlE,CAAAA,MAA9D,IAAwE,CAACpB,CAAEqB,CAAAA,YAAF,EAAiBgE,CAAAA,QAAjB,CAA0BC,UAAWlE,CAAAA,MAArC,CAAzE,CAAA;AACEkE,wBAAW9D,CAAAA,aAA0H,GAA1G8D,UAAWlE,CAAAA,MAA+F,EAAvF,IAAKK,CAAAA,YAAL,CAAkB6D,UAAlB,CAAuF,EAAxDP,OAAwD,IAA7C,IAAKtD,CAAAA,YAAL,CAAkB6D,UAAlB,EAA8B,YAA9B,CAA6C,EAAAA,UAAWlE,CAAAA,MAAX,GAAoBkE,UAAWlE,CAAAA,MAAOiB,CAAAA,MAAtC;AADvI;AAEA,gBAAKyC,CAAAA,SAAL,CAAeQ,UAAf,CAAA;AAJ0I;AAM5I,cAAKR,CAAAA,SAAL,CAAeK,QAAf,CAAA;AARkE;AAUpE,YAAIH,SAAJ,KAAkBhF,CAAEoB,CAAAA,MAApB,CAA4B;AACgDmE,cAAAA,GAAY,IAAKC,CAAAA,iBAAL,CAAuBxF,CAAvB,EAAvD,WAAdyF,KAAAjB,IAAKhF,CAAAA,IAALiG,GAA4B,WAA5BA,GAA0C,aAA2B,CAAZF;AAC1E,cAAKxF,CAAAA,aAAL,CAAmBwF,IAAnB,EAA8B,aAA9B,CAAA;AAA8CR,iBAAA,IAAW,IAAKhF,CAAAA,aAAL,CAAmBwF,IAAnB,EAA8B,WAA9B,CAAX;AAE9C,eADIG,QACJ,GADyBV,SAAW3C,EAAAA,MACpC,EAAOqD,QAAP,IAA6BA,QAA7B,KAAoD,IAAK3H,CAAAA,UAAWsE,CAAAA,MAApE,IAA8EqD,QAA9E,KAAqG1F,CAAEoB,CAAAA,MAAvG,CAAA;AACEsE,oBAAA,GAAqBA,QAAmBrD,CAAAA,MAAxC;AADF;AAEA,cAAI,CAACqD,QAAL,IAA2BA,QAA3B,KAAkD,IAAK3H,CAAAA,UAAWsE,CAAAA,MAAlE,CAA0E;AAClEsD,oBAAAA,GAAa,IAAKH,CAAAA,iBAAL,CAAuBxF,CAAvB,EAA0B,cAA1B,CAAb2F;AACN,iBAAKA,QAAWrE,CAAAA,UAAhB,GAA6BqE,QAAWjE,CAAAA,SAAxC,EAAmDiE,QAAWvE,CAAAA,MAA9D,IAAwEuE,QAAWvE,CAAAA,MAAnF,KAA8F4D,SAA9F,IAA2GW,QAAWvE,CAAAA,MAAtH,KAAiI,IAAKrD,CAAAA,UAAWsE,CAAAA,MAAjJ,CAAA;AACEsD,sBAAWnE,CAAAA,aAA0H,GAA1GmE,QAAWvE,CAAAA,MAA+F,EAAvF,IAAKK,CAAAA,YAAL,CAAkBkE,QAAlB,CAAuF,EAAxDZ,OAAwD,IAA7C,IAAKtD,CAAAA,YAAL,CAAkBkE,QAAlB,EAA8B,YAA9B,CAA6C,EAAAA,QAAWvE,CAAAA,MAAX,GAAoBuE,QAAWvE,CAAAA,MAAOiB,CAAAA,MAAtC;AADvI;AAEA,gBAAKyC,CAAAA,SAAL,CAAea,QAAf,CAAA;AAJwE;AAM1E,cAAKb,CAAAA,SAAL,CAAeS,IAAf,CAAA;AAZ0B;AActBK,iBAAAA,GAAa,EAAbA;AAAiBC,YAAAA,GAA2B,IAAKzH,CAAAA,sBAAhCyH,IAA0D,CAAA,CAA1DA;AACvB,YAAK1H,CAAAA,SAAL,GAAiByH,SAAWlG,CAAAA,IAAX,CAAgB,aAAhB,CAAjB,GAAkD,IAAKK,CAAAA,aAAL,CAAmBC,CAAnB,EAAsB,aAAtB,CAAlD;AAAwF6F,YAAA,IAA4BD,SAAWlG,CAAAA,IAAX,CAAgB,mBAAhB,CAA5B;AAAoF,eAAlB,KAAAM,CAAE0E,CAAAA,WAAF,KAA8B,IAAKvG,CAAAA,SAAL,GAAiByH,SAAWE,CAAAA,MAAX,CAAkB,CAAlB,EAAqB,CAArB,EAAwB,WAAxB,CAAjB,GAAwD,IAAK/F,CAAAA,aAAL,CAAmBC,CAAnB,EAAsB,WAAtB,CAAxD,EAA4F6F,IAA5F,IAAwHD,SAAWlG,CAAAA,IAAX,CAAgB,iBAAhB,CAAtJ;AAA2LqF,eAAA,KAAY,IAAK5G,CAAAA,SAAL,GAAiByH,SAAWE,CAAAA,MAAX,CAAkB,CAAlB,EAAqB,CAArB,EAAwB,WAAxB,CAAjB,GAAwD,IAAK/F,CAAAA,aAAL,CAAmBC,CAAnB,EAAsB,WAAtB,CAAxD,EAA4F6F,IAA5F,IAAwHD,SAAWlG,CAAAA,IAAX,CAAgB,iBAAhB,CAAxH,EAA4J,IAAKqG,CAAAA,MAAjK,GAA0K/F,CAAEoB,CAAAA,MAAQ2E,EAAAA,MAAhM;AAA6N,SAApB,GAAAH,SAAWnF,CAAAA,MAAX,IAAyB,IAAKmB,CAAAA,GAAL,CAAS5B,CAAT,EAAY4F,SAAZ,CAAzB;AAAkD,YAAKnH,CAAAA,uBAAwBgC,CAAAA,MAA7B,GAAsC,CAAtC;AAAyC,YAAK/B,CAAAA,YAAa+B,CAAAA,MAAlB,GAA2B,CAA3B;AAA8BnC,oBAAa4G,CAAAA,WAAb,GAA2BlF,CAAEqB,CAAAA,YAAF,EAA3B;AAA6C,YAAKyD,CAAAA,SAAL,CAAe9E,CAAf,CAAA;AAjCpsB,OAAA;AACEU,eAAQC,CAAAA,IAAR,CAAa,iEAAb,CAAA;AADF;AADmB;AA0CrBzB,kBAAc,CAACsF,IAAD,CAAO;AACnB,UAAMA,IAAN,YAAsBhH,qBAAsBA,CAAAA,qBAA5C,CAAA;AADmB,YAKbc,eAAe,IAAKA,CAAAA,YAAL,CAAkBkG,IAAKI,CAAAA,SAAvB,CALF;AAKqC5E,YAAAA,GAAI,IAAKyE,CAAAA,kBAAL,CAAwBD,IAAxB,CAAJxE;AAAxD,YAA2F+E,UAA4B,OAA5BA,KAAU/E,IAAE0E,CAAAA,WAAZK,IAAyD,KAAzDA,KAAuC/E,IAAE0E,CAAAA,WAApI;AACA,YAAK3E,CAAAA,aAAL,CAAmBC,IAAnB,EAAsB,aAAtB,CAAA;AAAsC+E,eAAA,IAAW,IAAKhF,CAAAA,aAAL,CAAmBC,IAAnB,EAAsB,WAAtB,CAAX;AAAiE,eAAlB,KAAAA,IAAE0E,CAAAA,WAAF,KAA8B,IAAKqB,CAAAA,MAAnC,GAA4C/F,IAAEoB,CAAAA,MAAQ2E,EAAAA,MAAtD;AACrF,YAAMJ,aAAa,IAAKH,CAAAA,iBAAL,CAAuBxF,IAAvB,EAA0B,cAA1B,CAAnB;AACA,aAAK2F,UAAWrE,CAAAA,UAAhB,GAA6BqE,UAAWjE,CAAAA,SAAxC,EAAmDiE,UAAWvE,CAAAA,MAA9D,IAAwEuE,UAAWvE,CAAAA,MAAnF,KAA8F,IAAKrD,CAAAA,UAAWsE,CAAAA,MAA9G,CAAA;AACEsD,oBAAWnE,CAAAA,aAA0H,GAA1GmE,UAAWvE,CAAAA,MAA+F,EAAvF,IAAKK,CAAAA,YAAL,CAAkBkE,UAAlB,CAAuF,EAAxDZ,OAAwD,IAA7C,IAAKtD,CAAAA,YAAL,CAAkBkE,UAAlB,EAA8B,YAA9B,CAA6C,EAAAA,UAAWvE,CAAAA,MAAX,GAAoBuE,UAAWvE,CAAAA,MAAOiB,CAAAA,MAAtC;AADvI;AAEA/D,oBAAa4G,CAAAA,WAAb,GAA2BlF,IAAEqB,CAAAA,YAAF,EAA3B;AAA6C,YAAKyD,CAAAA,SAAL,CAAe9E,IAAf,CAAA;AAAmB,YAAK8E,CAAAA,SAAL,CAAea,UAAf,CAAA;AAThE,OAAA;AACEjF,eAAQC,CAAAA,IAAR,CAAa,iEAAb,CAAA;AADF;AADmB;AAkBrB1B,iBAAa,CAACuF,IAAD,CAAO;AAClB,UAAMA,IAAN,YAAsBhH,qBAAsBA,CAAAA,qBAA5C,CAAA;AAIA,YAAMc,eAAe,IAAKA,CAAAA,YAAL,CAAkBkG,IAAKI,CAAAA,SAAvB,CAArB;AACA,YAAItG,YAAa4G,CAAAA,WAAjB,CAA8B;AAAA,gBACtBH,UAA+B,OAA/BA,KAAUP,IAAKE,CAAAA,WAAfK,IAA+D,KAA/DA,KAA0CP,IAAKE,CAAAA,WADzB,EACgDM,YAAY,IAAKC,CAAAA,iBAAL,CAAuB3G,YAAa4G,CAAAA,WAApC,CAD5D,EAC8GC,WAAW,IAAKV,CAAAA,kBAAL,CAAwBD,IAAxB,EAA8B,YAA9B,EAA4CQ,SAA5C,CADzH;AAE5B,cAAKjF,CAAAA,aAAL,CAAmBoF,QAAnB,CAAA;AAA8BJ,iBAAA,IAAW,IAAKhF,CAAAA,aAAL,CAAmBoF,QAAnB,EAA6B,UAA7B,CAAX;AACxBG,cAAAA,GAAa,IAAKb,CAAAA,kBAAL,CAAwBD,IAAxB,EAA8B,cAA9B,EAA8CQ,SAA9C,CAAbM;AACN,eAAKA,IAAWhE,CAAAA,UAAhB,GAA6BgE,IAAW5D,CAAAA,SAAxC,EAAmD4D,IAAWlE,CAAAA,MAA9D,IAAwEkE,IAAWlE,CAAAA,MAAnF,KAA8F,IAAKrD,CAAAA,UAAWsE,CAAAA,MAA9G,CAAA;AACEiD,gBAAW9D,CAAAA,aAA0H,GAA1G8D,IAAWlE,CAAAA,MAA+F,EAAvF,IAAKK,CAAAA,YAAL,CAAkB6D,IAAlB,CAAuF,EAAxDP,OAAwD,IAA7C,IAAKtD,CAAAA,YAAL,CAAkB6D,IAAlB,EAA8B,YAA9B,CAA6C,EAAAA,IAAWlE,CAAAA,MAAX,GAAoBkE,IAAWlE,CAAAA,MAAOiB,CAAAA,MAAtC;AADvI;AAEA/D,sBAAa4G,CAAAA,WAAb,GAA2B,IAA3B;AAAiC,cAAKJ,CAAAA,SAAL,CAAeK,QAAf,CAAA;AAA0B,cAAKL,CAAAA,SAAL,CAAeQ,IAAf,CAAA;AAN/B;AAQ9B,YAAKS,CAAAA,MAAL,GAAc,IAAd;AAbA,OAAA;AACErF,eAAQC,CAAAA,IAAR,CAAa,iEAAb,CAAA;AADF;AADkB;AA0BpBxB,gBAAY,CAACqF,IAAD,CAAO;AACjB,UAAMA,IAAN,YAAsBhH,qBAAsBA,CAAAA,qBAA5C,CAAA;AADiB,YAKXwI,MAAMC,WAAYD,CAAAA,GAAZ,EALK,EAKchG,IAAI,IAAKyE,CAAAA,kBAAL,CAAwBD,IAAxB,CALlB;AAMjB,SAAI,IAAKzE,CAAAA,aAAL,CAAmBC,CAAnB,EAAsB,WAAtB,CAAA,EAAsD,OAAtD,KAAoCA,CAAE0E,CAAAA,WAA1C,IACE,IAAK3E,CAAAA,aAAL,CAAmBC,CAAnB,EAAsB,UAAtB,CADF,IAE2B,OAF3B,KAESA,CAAE0E,CAAAA,WAFX,IAEwD,KAFxD,KAEsC1E,CAAE0E,CAAAA,WAFxC,KAIE,IAAK3E,CAAAA,aAAL,CAAmBC,CAAnB,EADmC,CACb,KADAA,CAAE2E,CAAAA,MACF,GAAgB,SAAhB,GAA4B,SAAlD,CAJF;AANiB,YAYXrG,eAAe,IAAKA,CAAAA,YAAL,CAAkBkG,IAAKI,CAAAA,SAAvB,CAZJ,EAYuCsB,cAAc,IAAKjB,CAAAA,iBAAL,CAAuB3G,YAAauG,CAAAA,oBAAb,CAAkCL,IAAKG,CAAAA,MAAvC,CAAvB,CAZrD,EAabwB,cAAcD,WAbD;AAcjB,YAAIA,WAAJ,IAAmB,CAAClG,CAAEqB,CAAAA,YAAF,EAAiBgE,CAAAA,QAAjB,CAA0Ba,WAA1B,CAApB,CAA4D;AAE1D,eADI1E,WACJ,GADoB0E,WACpB,EAAO1E,WAAP,IAAwB,CAACxB,CAAEqB,CAAAA,YAAF,EAAiBgE,CAAAA,QAAjB,CAA0B7D,WAA1B,CAAzB,CAAA;AACE,aAAIxB,CAAEwB,CAAAA,aAAF,GAAkBA,WAAlB,EAAiC,IAAKC,CAAAA,YAAL,CAAkBzB,CAAlB,EAAqB,kBAArB,CAAjC,EAA6F,OAA7F,KAA2EA,CAAE0E,CAAAA,WAAjF,IACE,IAAKjD,CAAAA,YAAL,CAAkBzB,CAAlB,EAAqB,iBAArB,CADF,IAE2B,OAF3B,KAESA,CAAE0E,CAAAA,WAFX,IAEwD,KAFxD,KAEsC1E,CAAE0E,CAAAA,WAFxC,KAIE,IAAKjD,CAAAA,YAAL,CAAkBzB,CAAlB,EADmC,CACd,KADCA,CAAE2E,CAAAA,MACH,GAAgB,gBAAhB,GAAmC,gBAAxD,CAEF,EAAAnD,WAAA,GAAgBA,WAAca,CAAAA,MAA9B;AAPF;AASA,iBAAO/D,YAAauG,CAAAA,oBAAb,CAAkCL,IAAKG,CAAAA,MAAvC,CAAP;AAX0D;AAaxDwB,mBAAJ,KACQC,WAYwC,GAZ3B,IAAKZ,CAAAA,iBAAL,CAAuBxF,CAAvB,EAA0B,OAA1B,CAY2B,EAX9CoG,WAAWhF,CAAAA,MAWmC,GAX1B+E,WAW0B,EAXbC,WAAWC,CAAAA,IAWE,GAXK,IAWL,EAXW/H,YAAagI,CAAAA,cAAb,CAA4B9B,IAAKG,CAAAA,MAAjC,CAWX,KAXwDrG,YAAagI,CAAAA,cAAb,CAA4B9B,IAAKG,CAAAA,MAAjC,CAWxD,GAXmG,CAC/I4B,WAAY,CADmI,EAE/InF,OAAQgF,WAAWhF,CAAAA,MAF4H,EAG/IoF,UAAWR,GAHoI,CAWnG,GANxCS,IAMwC,GANzBnI,YAAagI,CAAAA,cAAb,CAA4B9B,IAAKG,CAAAA,MAAjC,CAMyB,EAL9C,CAAI8B,IAAarF,CAAAA,MAAb,KAAwBgF,WAAWhF,CAAAA,MAAnC,IAA4E,GAA5E,GAA6C4E,GAA7C,GAAmDS,IAAaD,CAAAA,SAAhE,GAAkF,EAAEC,IAAaF,CAAAA,UAAjG,GAA8GE,IAAaF,CAAAA,UAA3H,GAAwI,CAAxI,EAA2IE,IAAarF,CAAAA,MAAxJ,GAAiKgF,WAAWhF,CAAAA,MAA5K,EAAoLqF,IAAaD,CAAAA,SAAjM,GAA6MR,GAA7M,EAAkNI,WAAWM,CAAAA,MAA7N;AAAsOD,YAAaF,CAAAA,UAAnP,EAA0R,OAA1R,KAA+PH,WAAW1B,CAAAA,WAA9Q,IAEE,IAAK3E,CAAAA,aAAL,CAAmBqG,WAAnB,EAD4C,CACb,KADTA,WAAWzB,CAAAA,MACF,GAAgB,YAAhB,GAA+B,OAA9D,CAFF,GAI6B,OAJ7B,KAIEyB,WAAW1B,CAAAA,WAJb,IAIwC,IAAK3E,CAAAA,aAAL,CAAmBqG,WAAnB,EAA+B,KAA/B,CACM,EAA9C,IAAKrG,CAAAA,aAAL,CAAmBqG,WAAnB,EAA+B,YAA/B,CAA8C,EAAA,IAAKtB,CAAAA,SAAL,CAAesB,WAAf,CAbhD;AAeA,YAAKtB,CAAAA,SAAL,CAAe9E,CAAf,CAAA;AAzCA,OAAA;AACEU,eAAQC,CAAAA,IAAR,CAAa,iEAAb,CAAA;AADF;AADiB;AAuDnBvB,uBAAmB,CAACoF,IAAD,CAAO;AACxB,UAAMA,IAAN,YAAsBhH,qBAAsBA,CAAAA,qBAA5C,CAAA;AADwB,YAKlBc,eAAe,IAAKA,CAAAA,YAAL,CAAkBkG,IAAKI,CAAAA,SAAvB,CALG,EAKgCsB,cAAc,IAAKjB,CAAAA,iBAAL,CAAuB3G,YAAauG,CAAAA,oBAAb,CAAkCL,IAAKG,CAAAA,MAAvC,CAAvB,CAL9C,EAKsH3E,IAAI,IAAKyE,CAAAA,kBAAL,CAAwBD,IAAxB,CAL1H;AAMxB,YAAI0B,WAAJ,CAAiB;AAEf,eAAA,EAAO1E,WAAP,CAAA;AACExB,aAAEwB,CAAAA,aAAqR,GAArQA,WAAqQ,EAAtP,IAAKC,CAAAA,YAAL,CAAkBzB,CAAlB,EAAqB,kBAArB,CAAsP,EAA1L,OAAlB,KAAAA,CAAE0E,CAAAA,WAAF,GAA4B,IAAKjD,CAAAA,YAAL,CAAkBzB,CAAlB,EAAqB,iBAArB,CAA5B,IAAyF,OAAzF,KAAuEA,CAAE0E,CAAAA,WAAzE,IAAsH,KAAtH,KAAoG1E,CAAE0E,CAAAA,WAAtG,KAAgI,IAAKjD,CAAAA,YAAL,CAAkBzB,CAAlB,EAAkC,CAAb,KAAAA,CAAE2E,CAAAA,MAAF,GAAiB,gBAAjB,GAAoC,gBAAzD,CAA4E,EAAAnD,WAAA,GAAgBA,WAAca,CAAAA,MAA9B;AADzR;AAEA,iBAAO/D,YAAauG,CAAAA,oBAAb,CAAkCL,IAAKG,CAAAA,MAAvC,CAAP;AAJe;AAMjB,YAAKG,CAAAA,SAAL,CAAe9E,CAAf,CAAA;AAXA,OAAA;AACEU,eAAQC,CAAAA,IAAR,CAAa,iEAAb,CAAA;AADF;AADwB;AAkB1BtB,YAAQ,CAACmF,IAAD,CAAO;AACPA,UAAN,YAAsB/G,mBAAoBA,CAAAA,mBAA1C,IAIMkJ,IAC0B,GADb,IAAKC,CAAAA,gBAAL,CAAsBpC,IAAtB,CACa,EAAhC,IAAKzE,CAAAA,aAAL,CAAmB4G,IAAnB,CAAgC,EAAA,IAAK7B,CAAAA,SAAL,CAAe6B,IAAf,CALhC,IACEjG,OAAQC,CAAAA,IAAR,CAAa,6DAAb,CADF;AADa;AAgBfsE,qBAAiB,CAAC9C,eAAD,CAAkB;AACjC,UAAI,CAACA,eAAL;AACE,eAAO,IAAP;AADF;AAEA,UAAIX,gBAAgBW,eAAA,CAAgB,CAAhB,CAApB;AACA,WAAK,IAAI5B,IAAI,CAAb,EAAgBA,CAAhB,GAAoB4B,eAAgB1B,CAAAA,MAApC,IAA8C0B,eAAA,CAAgB5B,CAAhB,CAAmB8B,CAAAA,MAAjE,KAA4Eb,aAA5E,EAA2FjB,CAAA,EAA3F;AACEiB,qBAAA,GAAgBW,eAAA,CAAgB5B,CAAhB,CAAhB;AADF;AAEA,aAAOiB,aAAP;AANiC;AAgBnCiD,sBAAkB,CAACD,IAAD,EAAOhF,IAAP,EAAa4B,MAAb,CAAqB;AACrC,YAAMc,QAAQ,IAAK2E,CAAAA,aAAL,CAAmBrJ,qBAAsBA,CAAAA,qBAAzC,CAAd;AACA,aAAO,IAAKsJ,CAAAA,eAAL,CAAqBtC,IAArB,EAA2BtC,KAA3B,CAAA,EAAmC,IAAK6E,CAAAA,aAAL,CAAmBvC,IAAnB,EAAyBtC,KAAzB,CAAnC,EAAoE,IAAK8E,CAAAA,QAAL,CAAcxC,IAAd,EAAoBtC,KAApB,CAApE,EAAgGA,KAAM+E,CAAAA,WAAtG,GAAoHzC,IAAKyC,CAAAA,WAAzH,EAAsI/E,KAAMgF,CAAAA,aAA5I,GAA4J1C,IAA5J,EAAkKtC,KAAMd,CAAAA,MAAxK,GAAiLA,MAAjL,IAA2L,IAAKR,CAAAA,OAAL,CAAasB,KAAMjF,CAAAA,MAAO4D,CAAAA,CAA1B,EAA6BqB,KAAMjF,CAAAA,MAAO6D,CAAAA,CAA1C,CAA3L,IAA2O,IAAKpC,CAAAA,YAAL,CAAkB,CAAlB,CAA3O,EAAgR,QAAhR,IAAiQ,MAAOc,KAAxQ,KAA6R0C,KAAM1C,CAAAA,IAAnS,GAA0SA,IAA1S,GAAiT0C,KAAxT;AAFqC;AAUvC0E,oBAAgB,CAACpC,IAAD,CAAO;AACrB,YAAMtC,QAAQ,IAAK2E,CAAAA,aAAL,CAAmBpJ,mBAAoBA,CAAAA,mBAAvC,CAAd;AACA,aAAO,IAAK0J,CAAAA,aAAL,CAAmB3C,IAAnB,EAAyBtC,KAAzB,CAAA,EAAiC,IAAK6E,CAAAA,aAAL,CAAmBvC,IAAnB,EAAyBtC,KAAzB,CAAjC,EAAkE,IAAK8E,CAAAA,QAAL,CAAcxC,IAAd,EAAoBtC,KAApB,CAAlE,EAA8FA,KAAM+E,CAAAA,WAApG,GAAkHzC,IAAKyC,CAAAA,WAAvH,EAAoI/E,KAAMgF,CAAAA,aAA1I,GAA0J1C,IAA1J,EAAgKtC,KAAMd,CAAAA,MAAtK,GAA+K,IAAKR,CAAAA,OAAL,CAAasB,KAAMjF,CAAAA,MAAO4D,CAAAA,CAA1B,EAA6BqB,KAAMjF,CAAAA,MAAO6D,CAAAA,CAA1C,CAA/K,EAA6NoB,KAApO;AAFqB;AAWvBsD,qBAAiB,CAAChB,IAAD,EAAOhF,IAAP,CAAa;AAC5B,YAAM0C,QAAQ,IAAK2E,CAAAA,aAAL,CAAmBrJ,qBAAsBA,CAAAA,qBAAzC,CAAd;AACA,aAAO0E,KAAM+E,CAAAA,WAAN,GAAoBzC,IAAKyC,CAAAA,WAAzB,EAAsC/E,KAAMgF,CAAAA,aAA5C,GAA4D1C,IAAK0C,CAAAA,aAAjE,EAAgF,IAAKJ,CAAAA,eAAL,CAAqBtC,IAArB,EAA2BtC,KAA3B,CAAhF,EAAmH,IAAK6E,CAAAA,aAAL,CAAmBvC,IAAnB,EAAyBtC,KAAzB,CAAnH,EAAoJ,IAAK8E,CAAAA,QAAL,CAAcxC,IAAd,EAAoBtC,KAApB,CAApJ,EAAgLA,KAAMd,CAAAA,MAAtL,GAA+LoD,IAAKpD,CAAAA,MAApM,EAA4Mc,KAAMmE,CAAAA,IAAlN,GAAyN7B,IAAKnD,CAAAA,YAAL,EAAoB+F,CAAAA,KAApB,EAAzN,EAAsPlF,KAAM1C,CAAAA,IAA5P,GAAmQA,IAAnQ,IAA2Q0C,KAAM1C,CAAAA,IAAjR,EAAuR0C,KAA9R;AAF4B;AAe9BiF,iBAAa,CAAC3C,IAAD,EAAO6C,EAAP,CAAW;AACtBA,QAAGC,CAAAA,SAAH,GAAe9C,IAAK8C,CAAAA,SAApB;AAA+BD,QAAGE,CAAAA,MAAH,GAAY/C,IAAK+C,CAAAA,MAAjB;AAAyBF,QAAGG,CAAAA,MAAH,GAAYhD,IAAKgD,CAAAA,MAAjB;AAAyBH,QAAGI,CAAAA,MAAH,GAAYjD,IAAKiD,CAAAA,MAAjB;AAD3D;AAmBxBX,mBAAe,CAACtC,IAAD,EAAO6C,EAAP,CAAW;AACxB7C,UAAA,YAAgBhH,qBAAsBA,CAAAA,qBAAtC,IAA+D6J,EAA/D,YAA6E7J,qBAAsBA,CAAAA,qBAAnG,KAA6H6J,EAAGzC,CAAAA,SAAH,GAAeJ,IAAKI,CAAAA,SAApB,EAA+ByC,EAAGK,CAAAA,KAAlC,GAA0ClD,IAAKkD,CAAAA,KAA/C,EAAsDL,EAAGM,CAAAA,MAAzD,GAAkEnD,IAAKmD,CAAAA,MAAvE,EAA+EN,EAAGO,CAAAA,SAAlF,GAA8FpD,IAAKoD,CAAAA,SAAnG,EAA8GP,EAAG3C,CAAAA,WAAjH,GAA+HF,IAAKE,CAAAA,WAApI,EAAiJ2C,EAAGQ,CAAAA,QAApJ,GAA+JrD,IAAKqD,CAAAA,QAApK,EAA8KR,EAAGS,CAAAA,kBAAjL,GAAsMtD,IAAKsD,CAAAA,kBAA3M,EAA+NT,EAAGU,CAAAA,KAAlO,GAA0OvD,IAAKuD,CAAAA,KAA/O,EAAsPV,EAAGW,CAAAA,KAAzP,GAAiQxD,IAAKwD,CAAAA,KAAtQ,EAA6QX,EAAGY,CAAAA,KAAhR,GAAwRzD,IAAKyD,CAAAA,KAA1Z;AADwB;AAyB1BlB,iBAAa,CAACvC,IAAD,EAAO6C,EAAP,CAAW;AACtB7C,UAAA,YAAgBjH,mBAAoBA,CAAAA,mBAApC,IAA2D8J,EAA3D,YAAyE9J,mBAAoBA,CAAAA,mBAA7F,KAAqH8J,EAAGa,CAAAA,MAAH,GAAY1D,IAAK0D,CAAAA,MAAjB,EAAyBb,EAAG1C,CAAAA,MAA5B,GAAqCH,IAAKG,CAAAA,MAA1C,EAAkD0C,EAAGc,CAAAA,OAArD,GAA+D3D,IAAK2D,CAAAA,OAApE,EAA6Ed,EAAGe,CAAAA,MAAOC,CAAAA,QAAV,CAAmB7D,IAAK4D,CAAAA,MAAxB,CAA7E,EAA8Gf,EAAGiB,CAAAA,OAAjH,GAA2H9D,IAAK8D,CAAAA,OAAhI,EAAyIjB,EAAGkB,CAAAA,OAA5I,GAAsJ/D,IAAK+D,CAAAA,OAA3J,EAAoKlB,EAAGmB,CAAAA,QAASH,CAAAA,QAAZ,CAAqB7D,IAAKgE,CAAAA,QAA1B,CAApK,EAAyMnB,EAAGoB,CAAAA,MAAOJ,CAAAA,QAAV,CAAmB7D,IAAKiE,CAAAA,MAAxB,CAAzM,EAA0OpB,EAAGqB,CAAAA,QAA7O,GAAwPlE,IAAKkE,CAAAA,QAA7P,EAAuQrB,EAAGpK,CAAAA,MAAOoL,CAAAA,QAAV,CAAmB7D,IAAKvH,CAAAA,MAAxB,CAA5X;AADsB;AAcxB+J,YAAQ,CAACxC,IAAD,EAAO6C,EAAP,CAAW;AACjBA,QAAGsB,CAAAA,SAAH,GAAenE,IAAKmE,CAAAA,SAApB;AAA+BtB,QAAGuB,CAAAA,UAAH,GAAgBpE,IAAKoE,CAAAA,UAArB;AAAiCvB,QAAGb,CAAAA,SAAH,GAAeP,WAAYD,CAAAA,GAAZ,EAAf;AAAkCqB,QAAG7H,CAAAA,IAAH,GAAUgF,IAAKhF,CAAAA,IAAf;AAAqB6H,QAAGX,CAAAA,MAAH,GAAYlC,IAAKkC,CAAAA,MAAjB;AAAyBW,QAAGwB,CAAAA,IAAH,GAAUrE,IAAKqE,CAAAA,IAAf;AAAqBxB,QAAGyB,CAAAA,KAAH,GAAWtE,IAAKsE,CAAAA,KAAhB;AAAuBzB,QAAG0B,CAAAA,KAAMV,CAAAA,QAAT,CAAkB7D,IAAKuE,CAAAA,KAAvB,CAAA;AAA+B1B,QAAG2B,CAAAA,IAAKX,CAAAA,QAAR,CAAiB7D,IAAKwE,CAAAA,IAAtB,CAAA;AAD1M;AAQnB1K,gBAAY,CAAC2K,EAAD,CAAK;AACf,aAAO,IAAK5K,CAAAA,YAAaC,CAAAA,YAAlB,CAA+B2K,EAA/B,CAAA,KAAuC,IAAK5K,CAAAA,YAAaC,CAAAA,YAAlB,CAA+B2K,EAA/B,CAAvC,GAA4E,CACjFpE,qBAAsB,EAD2D,EAEjFyB,eAAgB,EAFiE,EAGjF4C,WAAY,IAHqE,CAA5E,GAIH,IAAK7K,CAAAA,YAAaC,CAAAA,YAAlB,CAA+B2K,EAA/B,CAJJ;AADe;AAcjBpC,iBAAa,CAAC/I,WAAD,CAAc;AACzB,UAAKS,CAAAA,SAAU4K,CAAAA,GAAf,CAAmBrL,WAAnB,CAAA,IAAmC,IAAKS,CAAAA,SAAU4C,CAAAA,GAAf,CAAmBrD,WAAnB,EAAgC,EAAhC,CAAnC;AACMoE,iBAAAA,GAAQ,IAAK3D,CAAAA,SAAU6K,CAAAA,GAAf,CAAmBtL,WAAnB,CAAgCuL,CAAAA,GAAhC,EAARnH,IAAiD,IAAIpE,WAAJ,CAAgB,IAAhB,CAAjDoE;AACN,aAAOA,WAAMZ,CAAAA,UAAN,GAAmBY,WAAMoH,CAAAA,IAAzB,EAA+BpH,WAAMV,CAAAA,aAArC,GAAqD,IAArD,EAA2DU,WAAMmE,CAAAA,IAAjE,GAAwE,IAAxE,EAA8EnE,WAAMd,CAAAA,MAApF,GAA6F,IAA7F,EAAmGc,WAA1G;AAHyB;AAgB3B4C,aAAS,CAAC5C,KAAD,CAAQ;AACf,UAAIA,KAAMqH,CAAAA,OAAV,KAAsB,IAAtB;AACE,cAAUjH,KAAJ,CAAU,mEAAV,CAAN;AADF;AAEA,YAAMxE,cAAcoE,KAAMpE,CAAAA,WAA1B;AACA,UAAKS,CAAAA,SAAU4K,CAAAA,GAAf,CAAmBrL,WAAnB,CAAA,IAAmC,IAAKS,CAAAA,SAAU4C,CAAAA,GAAf,CAAmBrD,WAAnB,EAAgC,EAAhC,CAAnC;AAAwE,UAAKS,CAAAA,SAAU6K,CAAAA,GAAf,CAAmBtL,WAAnB,CAAgC4B,CAAAA,IAAhC,CAAqCwC,KAArC,CAAA;AAJzD;AAYjBoC,mBAAe,CAACtE,CAAD,EAAIR,IAAJ,CAAU;AACvB,YAAMgK,YAAYxJ,CAAEwB,CAAAA,aAAciI,CAAAA,OAAhB,CAAwBjK,IAAxB,CAAlB;AACA,UAAIgK,SAAJ,IAAiBxJ,CAAEwB,CAAAA,aAAc4B,CAAAA,aAAhB,EAAjB;AACE,YAAI,IAAJ,IAAYoG,SAAZ;AACEA,mBAAUE,CAAAA,IAAwE,IAAhE1J,CAAEwB,CAAAA,aAAcmI,CAAAA,cAAhB,CAA+BnK,IAA/B,EAAqCgK,SAAU/J,CAAAA,EAA/C,EAAmD,IAAK,EAAxD,EAA2D,CAAA,CAA3D,CAAgE,EAAA+J,SAAU/J,CAAAA,EAAGmK,CAAAA,IAAb,CAAkBJ,SAAUK,CAAAA,OAA5B,EAAqC7J,CAArC,CAAA;AADpF;AAGE,eAAK,IAAIO,IAAI,CAAR,EAAWC,IAAIgJ,SAAU/I,CAAAA,MAA9B,EAAsCF,CAAtC,GAA0CC,CAA1C,IAA+C,CAACR,CAAEE,CAAAA,6BAAlD,EAAiFK,CAAA,EAAjF;AACEiJ,qBAAA,CAAUjJ,CAAV,CAAamJ,CAAAA,IAA2E,IAAnE1J,CAAEwB,CAAAA,aAAcmI,CAAAA,cAAhB,CAA+BnK,IAA/B,EAAqCgK,SAAA,CAAUjJ,CAAV,CAAad,CAAAA,EAAlD,EAAsD,IAAK,EAA3D,EAA8D,CAAA,CAA9D,CAAmE,EAAA+J,SAAA,CAAUjJ,CAAV,CAAad,CAAAA,EAAGmK,CAAAA,IAAhB,CAAqBJ,SAAA,CAAUjJ,CAAV,CAAasJ,CAAAA,OAAlC,EAA2C7J,CAA3C,CAAA;AAD1F;AAHF;AADF;AAFuB;AAnlB3B;AA6lBA5C,SAAQS,CAAAA,aAAR,GAAwBA,aAAxB;AAjmB+G,CAA/G;;",
"sources":["node_modules/@pixi/events/lib/EventBoundary.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$$pixi$events$lib$EventBoundary\"] = function(global,require,module,exports) {\n\"use strict\";\nvar core = require(\"@pixi/core\"), EventTicker = require(\"./EventTicker.js\"), FederatedMouseEvent = require(\"./FederatedMouseEvent.js\"), FederatedPointerEvent = require(\"./FederatedPointerEvent.js\"), FederatedWheelEvent = require(\"./FederatedWheelEvent.js\");\nconst PROPAGATION_LIMIT = 2048, tempHitLocation = new core.Point(), tempLocalMapping = new core.Point();\nclass EventBoundary {\n  /**\n   * @param rootTarget - The holder of the event boundary.\n   */\n  constructor(rootTarget) {\n    this.dispatch = new core.utils.EventEmitter(), this.moveOnAll = !1, this.enableGlobalMoveEvents = !0, this.mappingState = {\n      trackingData: {}\n    }, this.eventPool = /* @__PURE__ */ new Map(), this._allInteractiveElements = [], this._hitElements = [], this._isPointerMoveEvent = !1, this.rootTarget = rootTarget, this.hitPruneFn = this.hitPruneFn.bind(this), this.hitTestFn = this.hitTestFn.bind(this), this.mapPointerDown = this.mapPointerDown.bind(this), this.mapPointerMove = this.mapPointerMove.bind(this), this.mapPointerOut = this.mapPointerOut.bind(this), this.mapPointerOver = this.mapPointerOver.bind(this), this.mapPointerUp = this.mapPointerUp.bind(this), this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this), this.mapWheel = this.mapWheel.bind(this), this.mappingTable = {}, this.addEventMapping(\"pointerdown\", this.mapPointerDown), this.addEventMapping(\"pointermove\", this.mapPointerMove), this.addEventMapping(\"pointerout\", this.mapPointerOut), this.addEventMapping(\"pointerleave\", this.mapPointerOut), this.addEventMapping(\"pointerover\", this.mapPointerOver), this.addEventMapping(\"pointerup\", this.mapPointerUp), this.addEventMapping(\"pointerupoutside\", this.mapPointerUpOutside), this.addEventMapping(\"wheel\", this.mapWheel);\n  }\n  /**\n   * Adds an event mapping for the event `type` handled by `fn`.\n   *\n   * Event mappings can be used to implement additional or custom events. They take an event\n   * coming from the upstream scene (or directly from the {@link PIXI.EventSystem}) and dispatch new downstream events\n   * generally trickling down and bubbling up to {@link PIXI.EventBoundary.rootTarget this.rootTarget}.\n   *\n   * To modify the semantics of existing events, the built-in mapping methods of EventBoundary should be overridden\n   * instead.\n   * @param type - The type of upstream event to map.\n   * @param fn - The mapping method. The context of this function must be bound manually, if desired.\n   */\n  addEventMapping(type, fn) {\n    this.mappingTable[type] || (this.mappingTable[type] = []), this.mappingTable[type].push({\n      fn,\n      priority: 0\n    }), this.mappingTable[type].sort((a, b) => a.priority - b.priority);\n  }\n  /**\n   * Dispatches the given event\n   * @param e\n   * @param type\n   */\n  dispatchEvent(e, type) {\n    e.propagationStopped = !1, e.propagationImmediatelyStopped = !1, this.propagate(e, type), this.dispatch.emit(type || e.type, e);\n  }\n  /**\n   * Maps the given upstream event through the event boundary and propagates it downstream.\n   * @param e\n   */\n  mapEvent(e) {\n    if (!this.rootTarget)\n      return;\n    const mappers = this.mappingTable[e.type];\n    if (mappers)\n      for (let i = 0, j = mappers.length; i < j; i++)\n        mappers[i].fn(e);\n    else\n      console.warn(`[EventBoundary]: Event mapping not defined for ${e.type}`);\n  }\n  /**\n   * Finds the DisplayObject that is the target of a event at the given coordinates.\n   *\n   * The passed (x,y) coordinates are in the world space above this event boundary.\n   * @param x\n   * @param y\n   */\n  hitTest(x, y) {\n    EventTicker.EventsTicker.pauseUpdate = !0;\n    const fn = this._isPointerMoveEvent && this.enableGlobalMoveEvents ? \"hitTestMoveRecursive\" : \"hitTestRecursive\", invertedPath = this[fn](\n      this.rootTarget,\n      this.rootTarget.eventMode,\n      tempHitLocation.set(x, y),\n      this.hitTestFn,\n      this.hitPruneFn\n    );\n    return invertedPath && invertedPath[0];\n  }\n  /**\n   * Propagate the passed event from from {@link PIXI.EventBoundary.rootTarget this.rootTarget} to its\n   * target {@code e.target}.\n   * @param e - The event to propagate.\n   * @param type\n   */\n  propagate(e, type) {\n    if (!e.target)\n      return;\n    const composedPath = e.composedPath();\n    e.eventPhase = e.CAPTURING_PHASE;\n    for (let i = 0, j = composedPath.length - 1; i < j; i++)\n      if (e.currentTarget = composedPath[i], this.notifyTarget(e, type), e.propagationStopped || e.propagationImmediatelyStopped)\n        return;\n    if (e.eventPhase = e.AT_TARGET, e.currentTarget = e.target, this.notifyTarget(e, type), !(e.propagationStopped || e.propagationImmediatelyStopped)) {\n      e.eventPhase = e.BUBBLING_PHASE;\n      for (let i = composedPath.length - 2; i >= 0; i--)\n        if (e.currentTarget = composedPath[i], this.notifyTarget(e, type), e.propagationStopped || e.propagationImmediatelyStopped)\n          return;\n    }\n  }\n  /**\n   * Emits the event {@code e} to all interactive display objects. The event is propagated in the bubbling phase always.\n   *\n   * This is used in the `globalpointermove` event.\n   * @param e - The emitted event.\n   * @param type - The listeners to notify.\n   * @param targets - The targets to notify.\n   */\n  all(e, type, targets = this._allInteractiveElements) {\n    if (targets.length === 0)\n      return;\n    e.eventPhase = e.BUBBLING_PHASE;\n    const events = Array.isArray(type) ? type : [type];\n    for (let i = targets.length - 1; i >= 0; i--)\n      events.forEach((event) => {\n        e.currentTarget = targets[i], this.notifyTarget(e, event);\n      });\n  }\n  /**\n   * Finds the propagation path from {@link PIXI.EventBoundary.rootTarget rootTarget} to the passed\n   * {@code target}. The last element in the path is {@code target}.\n   * @param target\n   */\n  propagationPath(target) {\n    const propagationPath = [target];\n    for (let i = 0; i < PROPAGATION_LIMIT && target !== this.rootTarget; i++) {\n      if (!target.parent)\n        throw new Error(\"Cannot find propagation path to disconnected target\");\n      propagationPath.push(target.parent), target = target.parent;\n    }\n    return propagationPath.reverse(), propagationPath;\n  }\n  hitTestMoveRecursive(currentTarget, eventMode, location, testFn, pruneFn, ignore = !1) {\n    let shouldReturn = !1;\n    if (this._interactivePrune(currentTarget))\n      return null;\n    if ((currentTarget.eventMode === \"dynamic\" || eventMode === \"dynamic\") && (EventTicker.EventsTicker.pauseUpdate = !1), currentTarget.interactiveChildren && currentTarget.children) {\n      const children = currentTarget.children;\n      for (let i = children.length - 1; i >= 0; i--) {\n        const child = children[i], nestedHit = this.hitTestMoveRecursive(\n          child,\n          this._isInteractive(eventMode) ? eventMode : child.eventMode,\n          location,\n          testFn,\n          pruneFn,\n          ignore || pruneFn(currentTarget, location)\n        );\n        if (nestedHit) {\n          if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent)\n            continue;\n          const isInteractive = currentTarget.isInteractive();\n          (nestedHit.length > 0 || isInteractive) && (isInteractive && this._allInteractiveElements.push(currentTarget), nestedHit.push(currentTarget)), this._hitElements.length === 0 && (this._hitElements = nestedHit), shouldReturn = !0;\n        }\n      }\n    }\n    const isInteractiveMode = this._isInteractive(eventMode), isInteractiveTarget = currentTarget.isInteractive();\n    return isInteractiveMode && isInteractiveTarget && this._allInteractiveElements.push(currentTarget), ignore || this._hitElements.length > 0 ? null : shouldReturn ? this._hitElements : isInteractiveMode && !pruneFn(currentTarget, location) && testFn(currentTarget, location) ? isInteractiveTarget ? [currentTarget] : [] : null;\n  }\n  /**\n   * Recursive implementation for {@link PIXI.EventBoundary.hitTest hitTest}.\n   * @param currentTarget - The DisplayObject that is to be hit tested.\n   * @param eventMode - The event mode for the `currentTarget` or one of its parents.\n   * @param location - The location that is being tested for overlap.\n   * @param testFn - Callback that determines whether the target passes hit testing. This callback\n   *  can assume that `pruneFn` failed to prune the display object.\n   * @param pruneFn - Callback that determiness whether the target and all of its children\n   *  cannot pass the hit test. It is used as a preliminary optimization to prune entire subtrees\n   *  of the scene graph.\n   * @returns An array holding the hit testing target and all its ancestors in order. The first element\n   *  is the target itself and the last is {@link PIXI.EventBoundary.rootTarget rootTarget}. This is the opposite\n   *  order w.r.t. the propagation path. If no hit testing target is found, null is returned.\n   */\n  hitTestRecursive(currentTarget, eventMode, location, testFn, pruneFn) {\n    if (this._interactivePrune(currentTarget) || pruneFn(currentTarget, location))\n      return null;\n    if ((currentTarget.eventMode === \"dynamic\" || eventMode === \"dynamic\") && (EventTicker.EventsTicker.pauseUpdate = !1), currentTarget.interactiveChildren && currentTarget.children) {\n      const children = currentTarget.children;\n      for (let i = children.length - 1; i >= 0; i--) {\n        const child = children[i], nestedHit = this.hitTestRecursive(\n          child,\n          this._isInteractive(eventMode) ? eventMode : child.eventMode,\n          location,\n          testFn,\n          pruneFn\n        );\n        if (nestedHit) {\n          if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent)\n            continue;\n          const isInteractive = currentTarget.isInteractive();\n          return (nestedHit.length > 0 || isInteractive) && nestedHit.push(currentTarget), nestedHit;\n        }\n      }\n    }\n    const isInteractiveMode = this._isInteractive(eventMode), isInteractiveTarget = currentTarget.isInteractive();\n    return isInteractiveMode && testFn(currentTarget, location) ? isInteractiveTarget ? [currentTarget] : [] : null;\n  }\n  _isInteractive(int) {\n    return int === \"static\" || int === \"dynamic\";\n  }\n  _interactivePrune(displayObject) {\n    return !!(!displayObject || displayObject.isMask || !displayObject.visible || !displayObject.renderable || displayObject.eventMode === \"none\" || displayObject.eventMode === \"passive\" && !displayObject.interactiveChildren || displayObject.isMask);\n  }\n  /**\n   * Checks whether the display object or any of its children cannot pass the hit test at all.\n   *\n   * {@link PIXI.EventBoundary}'s implementation uses the {@link PIXI.DisplayObject.hitArea hitArea}\n   * and {@link PIXI.DisplayObject._mask} for pruning.\n   * @param displayObject\n   * @param location\n   */\n  hitPruneFn(displayObject, location) {\n    if (displayObject.hitArea && (displayObject.worldTransform.applyInverse(location, tempLocalMapping), !displayObject.hitArea.contains(tempLocalMapping.x, tempLocalMapping.y)))\n      return !0;\n    if (displayObject._mask) {\n      const maskObject = displayObject._mask.isMaskData ? displayObject._mask.maskObject : displayObject._mask;\n      if (maskObject && !maskObject.containsPoint?.(location))\n        return !0;\n    }\n    return !1;\n  }\n  /**\n   * Checks whether the display object passes hit testing for the given location.\n   * @param displayObject\n   * @param location\n   * @returns - Whether `displayObject` passes hit testing for `location`.\n   */\n  hitTestFn(displayObject, location) {\n    return displayObject.eventMode === \"passive\" ? !1 : displayObject.hitArea ? !0 : displayObject.containsPoint ? displayObject.containsPoint(location) : !1;\n  }\n  /**\n   * Notify all the listeners to the event's `currentTarget`.\n   *\n   * If the `currentTarget` contains the property `on<type>`, then it is called here,\n   * simulating the behavior from version 6.x and prior.\n   * @param e - The event passed to the target.\n   * @param type\n   */\n  notifyTarget(e, type) {\n    type = type ?? e.type;\n    const handlerKey = `on${type}`;\n    e.currentTarget[handlerKey]?.(e);\n    const key = e.eventPhase === e.CAPTURING_PHASE || e.eventPhase === e.AT_TARGET ? `${type}capture` : type;\n    this.notifyListeners(e, key), e.eventPhase === e.AT_TARGET && this.notifyListeners(e, type);\n  }\n  /**\n   * Maps the upstream `pointerdown` events to a downstream `pointerdown` event.\n   *\n   * `touchstart`, `rightdown`, `mousedown` events are also dispatched for specific pointer types.\n   * @param from\n   */\n  mapPointerDown(from) {\n    if (!(from instanceof FederatedPointerEvent.FederatedPointerEvent)) {\n      console.warn(\"EventBoundary cannot map a non-pointer event as a pointer event\");\n      return;\n    }\n    const e = this.createPointerEvent(from);\n    if (this.dispatchEvent(e, \"pointerdown\"), e.pointerType === \"touch\")\n      this.dispatchEvent(e, \"touchstart\");\n    else if (e.pointerType === \"mouse\" || e.pointerType === \"pen\") {\n      const isRightButton = e.button === 2;\n      this.dispatchEvent(e, isRightButton ? \"rightdown\" : \"mousedown\");\n    }\n    const trackingData = this.trackingData(from.pointerId);\n    trackingData.pressTargetsByButton[from.button] = e.composedPath(), this.freeEvent(e);\n  }\n  /**\n   * Maps the upstream `pointermove` to downstream `pointerout`, `pointerover`, and `pointermove` events, in that order.\n   *\n   * The tracking data for the specific pointer has an updated `overTarget`. `mouseout`, `mouseover`,\n   * `mousemove`, and `touchmove` events are fired as well for specific pointer types.\n   * @param from - The upstream `pointermove` event.\n   */\n  mapPointerMove(from) {\n    if (!(from instanceof FederatedPointerEvent.FederatedPointerEvent)) {\n      console.warn(\"EventBoundary cannot map a non-pointer event as a pointer event\");\n      return;\n    }\n    this._allInteractiveElements.length = 0, this._hitElements.length = 0, this._isPointerMoveEvent = !0;\n    const e = this.createPointerEvent(from);\n    this._isPointerMoveEvent = !1;\n    const isMouse = e.pointerType === \"mouse\" || e.pointerType === \"pen\", trackingData = this.trackingData(from.pointerId), outTarget = this.findMountedTarget(trackingData.overTargets);\n    if (trackingData.overTargets?.length > 0 && outTarget !== e.target) {\n      const outType = from.type === \"mousemove\" ? \"mouseout\" : \"pointerout\", outEvent = this.createPointerEvent(from, outType, outTarget);\n      if (this.dispatchEvent(outEvent, \"pointerout\"), isMouse && this.dispatchEvent(outEvent, \"mouseout\"), !e.composedPath().includes(outTarget)) {\n        const leaveEvent = this.createPointerEvent(from, \"pointerleave\", outTarget);\n        for (leaveEvent.eventPhase = leaveEvent.AT_TARGET; leaveEvent.target && !e.composedPath().includes(leaveEvent.target); )\n          leaveEvent.currentTarget = leaveEvent.target, this.notifyTarget(leaveEvent), isMouse && this.notifyTarget(leaveEvent, \"mouseleave\"), leaveEvent.target = leaveEvent.target.parent;\n        this.freeEvent(leaveEvent);\n      }\n      this.freeEvent(outEvent);\n    }\n    if (outTarget !== e.target) {\n      const overType = from.type === \"mousemove\" ? \"mouseover\" : \"pointerover\", overEvent = this.clonePointerEvent(e, overType);\n      this.dispatchEvent(overEvent, \"pointerover\"), isMouse && this.dispatchEvent(overEvent, \"mouseover\");\n      let overTargetAncestor = outTarget?.parent;\n      for (; overTargetAncestor && overTargetAncestor !== this.rootTarget.parent && overTargetAncestor !== e.target; )\n        overTargetAncestor = overTargetAncestor.parent;\n      if (!overTargetAncestor || overTargetAncestor === this.rootTarget.parent) {\n        const enterEvent = this.clonePointerEvent(e, \"pointerenter\");\n        for (enterEvent.eventPhase = enterEvent.AT_TARGET; enterEvent.target && enterEvent.target !== outTarget && enterEvent.target !== this.rootTarget.parent; )\n          enterEvent.currentTarget = enterEvent.target, this.notifyTarget(enterEvent), isMouse && this.notifyTarget(enterEvent, \"mouseenter\"), enterEvent.target = enterEvent.target.parent;\n        this.freeEvent(enterEvent);\n      }\n      this.freeEvent(overEvent);\n    }\n    const allMethods = [], allowGlobalPointerEvents = this.enableGlobalMoveEvents ?? !0;\n    this.moveOnAll ? allMethods.push(\"pointermove\") : this.dispatchEvent(e, \"pointermove\"), allowGlobalPointerEvents && allMethods.push(\"globalpointermove\"), e.pointerType === \"touch\" && (this.moveOnAll ? allMethods.splice(1, 0, \"touchmove\") : this.dispatchEvent(e, \"touchmove\"), allowGlobalPointerEvents && allMethods.push(\"globaltouchmove\")), isMouse && (this.moveOnAll ? allMethods.splice(1, 0, \"mousemove\") : this.dispatchEvent(e, \"mousemove\"), allowGlobalPointerEvents && allMethods.push(\"globalmousemove\"), this.cursor = e.target?.cursor), allMethods.length > 0 && this.all(e, allMethods), this._allInteractiveElements.length = 0, this._hitElements.length = 0, trackingData.overTargets = e.composedPath(), this.freeEvent(e);\n  }\n  /**\n   * Maps the upstream `pointerover` to downstream `pointerover` and `pointerenter` events, in that order.\n   *\n   * The tracking data for the specific pointer gets a new `overTarget`.\n   * @param from - The upstream `pointerover` event.\n   */\n  mapPointerOver(from) {\n    if (!(from instanceof FederatedPointerEvent.FederatedPointerEvent)) {\n      console.warn(\"EventBoundary cannot map a non-pointer event as a pointer event\");\n      return;\n    }\n    const trackingData = this.trackingData(from.pointerId), e = this.createPointerEvent(from), isMouse = e.pointerType === \"mouse\" || e.pointerType === \"pen\";\n    this.dispatchEvent(e, \"pointerover\"), isMouse && this.dispatchEvent(e, \"mouseover\"), e.pointerType === \"mouse\" && (this.cursor = e.target?.cursor);\n    const enterEvent = this.clonePointerEvent(e, \"pointerenter\");\n    for (enterEvent.eventPhase = enterEvent.AT_TARGET; enterEvent.target && enterEvent.target !== this.rootTarget.parent; )\n      enterEvent.currentTarget = enterEvent.target, this.notifyTarget(enterEvent), isMouse && this.notifyTarget(enterEvent, \"mouseenter\"), enterEvent.target = enterEvent.target.parent;\n    trackingData.overTargets = e.composedPath(), this.freeEvent(e), this.freeEvent(enterEvent);\n  }\n  /**\n   * Maps the upstream `pointerout` to downstream `pointerout`, `pointerleave` events, in that order.\n   *\n   * The tracking data for the specific pointer is cleared of a `overTarget`.\n   * @param from - The upstream `pointerout` event.\n   */\n  mapPointerOut(from) {\n    if (!(from instanceof FederatedPointerEvent.FederatedPointerEvent)) {\n      console.warn(\"EventBoundary cannot map a non-pointer event as a pointer event\");\n      return;\n    }\n    const trackingData = this.trackingData(from.pointerId);\n    if (trackingData.overTargets) {\n      const isMouse = from.pointerType === \"mouse\" || from.pointerType === \"pen\", outTarget = this.findMountedTarget(trackingData.overTargets), outEvent = this.createPointerEvent(from, \"pointerout\", outTarget);\n      this.dispatchEvent(outEvent), isMouse && this.dispatchEvent(outEvent, \"mouseout\");\n      const leaveEvent = this.createPointerEvent(from, \"pointerleave\", outTarget);\n      for (leaveEvent.eventPhase = leaveEvent.AT_TARGET; leaveEvent.target && leaveEvent.target !== this.rootTarget.parent; )\n        leaveEvent.currentTarget = leaveEvent.target, this.notifyTarget(leaveEvent), isMouse && this.notifyTarget(leaveEvent, \"mouseleave\"), leaveEvent.target = leaveEvent.target.parent;\n      trackingData.overTargets = null, this.freeEvent(outEvent), this.freeEvent(leaveEvent);\n    }\n    this.cursor = null;\n  }\n  /**\n   * Maps the upstream `pointerup` event to downstream `pointerup`, `pointerupoutside`,\n   * and `click`/`rightclick`/`pointertap` events, in that order.\n   *\n   * The `pointerupoutside` event bubbles from the original `pointerdown` target to the most specific\n   * ancestor of the `pointerdown` and `pointerup` targets, which is also the `click` event's target. `touchend`,\n   * `rightup`, `mouseup`, `touchendoutside`, `rightupoutside`, `mouseupoutside`, and `tap` are fired as well for\n   * specific pointer types.\n   * @param from - The upstream `pointerup` event.\n   */\n  mapPointerUp(from) {\n    if (!(from instanceof FederatedPointerEvent.FederatedPointerEvent)) {\n      console.warn(\"EventBoundary cannot map a non-pointer event as a pointer event\");\n      return;\n    }\n    const now = performance.now(), e = this.createPointerEvent(from);\n    if (this.dispatchEvent(e, \"pointerup\"), e.pointerType === \"touch\")\n      this.dispatchEvent(e, \"touchend\");\n    else if (e.pointerType === \"mouse\" || e.pointerType === \"pen\") {\n      const isRightButton = e.button === 2;\n      this.dispatchEvent(e, isRightButton ? \"rightup\" : \"mouseup\");\n    }\n    const trackingData = this.trackingData(from.pointerId), pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);\n    let clickTarget = pressTarget;\n    if (pressTarget && !e.composedPath().includes(pressTarget)) {\n      let currentTarget = pressTarget;\n      for (; currentTarget && !e.composedPath().includes(currentTarget); ) {\n        if (e.currentTarget = currentTarget, this.notifyTarget(e, \"pointerupoutside\"), e.pointerType === \"touch\")\n          this.notifyTarget(e, \"touchendoutside\");\n        else if (e.pointerType === \"mouse\" || e.pointerType === \"pen\") {\n          const isRightButton = e.button === 2;\n          this.notifyTarget(e, isRightButton ? \"rightupoutside\" : \"mouseupoutside\");\n        }\n        currentTarget = currentTarget.parent;\n      }\n      delete trackingData.pressTargetsByButton[from.button], clickTarget = currentTarget;\n    }\n    if (clickTarget) {\n      const clickEvent = this.clonePointerEvent(e, \"click\");\n      clickEvent.target = clickTarget, clickEvent.path = null, trackingData.clicksByButton[from.button] || (trackingData.clicksByButton[from.button] = {\n        clickCount: 0,\n        target: clickEvent.target,\n        timeStamp: now\n      });\n      const clickHistory = trackingData.clicksByButton[from.button];\n      if (clickHistory.target === clickEvent.target && now - clickHistory.timeStamp < 200 ? ++clickHistory.clickCount : clickHistory.clickCount = 1, clickHistory.target = clickEvent.target, clickHistory.timeStamp = now, clickEvent.detail = clickHistory.clickCount, clickEvent.pointerType === \"mouse\") {\n        const isRightButton = clickEvent.button === 2;\n        this.dispatchEvent(clickEvent, isRightButton ? \"rightclick\" : \"click\");\n      } else\n        clickEvent.pointerType === \"touch\" && this.dispatchEvent(clickEvent, \"tap\");\n      this.dispatchEvent(clickEvent, \"pointertap\"), this.freeEvent(clickEvent);\n    }\n    this.freeEvent(e);\n  }\n  /**\n   * Maps the upstream `pointerupoutside` event to a downstream `pointerupoutside` event, bubbling from the original\n   * `pointerdown` target to `rootTarget`.\n   *\n   * (The most specific ancestor of the `pointerdown` event and the `pointerup` event must the\n   * `{@link PIXI.EventBoundary}'s root because the `pointerup` event occurred outside of the boundary.)\n   *\n   * `touchendoutside`, `mouseupoutside`, and `rightupoutside` events are fired as well for specific pointer\n   * types. The tracking data for the specific pointer is cleared of a `pressTarget`.\n   * @param from - The upstream `pointerupoutside` event.\n   */\n  mapPointerUpOutside(from) {\n    if (!(from instanceof FederatedPointerEvent.FederatedPointerEvent)) {\n      console.warn(\"EventBoundary cannot map a non-pointer event as a pointer event\");\n      return;\n    }\n    const trackingData = this.trackingData(from.pointerId), pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]), e = this.createPointerEvent(from);\n    if (pressTarget) {\n      let currentTarget = pressTarget;\n      for (; currentTarget; )\n        e.currentTarget = currentTarget, this.notifyTarget(e, \"pointerupoutside\"), e.pointerType === \"touch\" ? this.notifyTarget(e, \"touchendoutside\") : (e.pointerType === \"mouse\" || e.pointerType === \"pen\") && this.notifyTarget(e, e.button === 2 ? \"rightupoutside\" : \"mouseupoutside\"), currentTarget = currentTarget.parent;\n      delete trackingData.pressTargetsByButton[from.button];\n    }\n    this.freeEvent(e);\n  }\n  /**\n   * Maps the upstream `wheel` event to a downstream `wheel` event.\n   * @param from - The upstream `wheel` event.\n   */\n  mapWheel(from) {\n    if (!(from instanceof FederatedWheelEvent.FederatedWheelEvent)) {\n      console.warn(\"EventBoundary cannot map a non-wheel event as a wheel event\");\n      return;\n    }\n    const wheelEvent = this.createWheelEvent(from);\n    this.dispatchEvent(wheelEvent), this.freeEvent(wheelEvent);\n  }\n  /**\n   * Finds the most specific event-target in the given propagation path that is still mounted in the scene graph.\n   *\n   * This is used to find the correct `pointerup` and `pointerout` target in the case that the original `pointerdown`\n   * or `pointerover` target was unmounted from the scene graph.\n   * @param propagationPath - The propagation path was valid in the past.\n   * @returns - The most specific event-target still mounted at the same location in the scene graph.\n   */\n  findMountedTarget(propagationPath) {\n    if (!propagationPath)\n      return null;\n    let currentTarget = propagationPath[0];\n    for (let i = 1; i < propagationPath.length && propagationPath[i].parent === currentTarget; i++)\n      currentTarget = propagationPath[i];\n    return currentTarget;\n  }\n  /**\n   * Creates an event whose {@code originalEvent} is {@code from}, with an optional `type` and `target` override.\n   *\n   * The event is allocated using {@link PIXI.EventBoundary#allocateEvent this.allocateEvent}.\n   * @param from - The {@code originalEvent} for the returned event.\n   * @param [type=from.type] - The type of the returned event.\n   * @param target - The target of the returned event.\n   */\n  createPointerEvent(from, type, target) {\n    const event = this.allocateEvent(FederatedPointerEvent.FederatedPointerEvent);\n    return this.copyPointerData(from, event), this.copyMouseData(from, event), this.copyData(from, event), event.nativeEvent = from.nativeEvent, event.originalEvent = from, event.target = target ?? this.hitTest(event.global.x, event.global.y) ?? this._hitElements[0], typeof type == \"string\" && (event.type = type), event;\n  }\n  /**\n   * Creates a wheel event whose {@code originalEvent} is {@code from}.\n   *\n   * The event is allocated using {@link PIXI.EventBoundary#allocateEvent this.allocateEvent}.\n   * @param from - The upstream wheel event.\n   */\n  createWheelEvent(from) {\n    const event = this.allocateEvent(FederatedWheelEvent.FederatedWheelEvent);\n    return this.copyWheelData(from, event), this.copyMouseData(from, event), this.copyData(from, event), event.nativeEvent = from.nativeEvent, event.originalEvent = from, event.target = this.hitTest(event.global.x, event.global.y), event;\n  }\n  /**\n   * Clones the event {@code from}, with an optional {@code type} override.\n   *\n   * The event is allocated using {@link PIXI.EventBoundary#allocateEvent this.allocateEvent}.\n   * @param from - The event to clone.\n   * @param [type=from.type] - The type of the returned event.\n   */\n  clonePointerEvent(from, type) {\n    const event = this.allocateEvent(FederatedPointerEvent.FederatedPointerEvent);\n    return event.nativeEvent = from.nativeEvent, event.originalEvent = from.originalEvent, this.copyPointerData(from, event), this.copyMouseData(from, event), this.copyData(from, event), event.target = from.target, event.path = from.composedPath().slice(), event.type = type ?? event.type, event;\n  }\n  /**\n   * Copies wheel {@link PIXI.FederatedWheelEvent} data from {@code from} into {@code to}.\n   *\n   * The following properties are copied:\n   * + deltaMode\n   * + deltaX\n   * + deltaY\n   * + deltaZ\n   * @param from\n   * @param to\n   */\n  copyWheelData(from, to) {\n    to.deltaMode = from.deltaMode, to.deltaX = from.deltaX, to.deltaY = from.deltaY, to.deltaZ = from.deltaZ;\n  }\n  /**\n   * Copies pointer {@link PIXI.FederatedPointerEvent} data from {@code from} into {@code to}.\n   *\n   * The following properties are copied:\n   * + pointerId\n   * + width\n   * + height\n   * + isPrimary\n   * + pointerType\n   * + pressure\n   * + tangentialPressure\n   * + tiltX\n   * + tiltY\n   * @param from\n   * @param to\n   */\n  copyPointerData(from, to) {\n    from instanceof FederatedPointerEvent.FederatedPointerEvent && to instanceof FederatedPointerEvent.FederatedPointerEvent && (to.pointerId = from.pointerId, to.width = from.width, to.height = from.height, to.isPrimary = from.isPrimary, to.pointerType = from.pointerType, to.pressure = from.pressure, to.tangentialPressure = from.tangentialPressure, to.tiltX = from.tiltX, to.tiltY = from.tiltY, to.twist = from.twist);\n  }\n  /**\n   * Copies mouse {@link PIXI.FederatedMouseEvent} data from {@code from} to {@code to}.\n   *\n   * The following properties are copied:\n   * + altKey\n   * + button\n   * + buttons\n   * + clientX\n   * + clientY\n   * + metaKey\n   * + movementX\n   * + movementY\n   * + pageX\n   * + pageY\n   * + x\n   * + y\n   * + screen\n   * + shiftKey\n   * + global\n   * @param from\n   * @param to\n   */\n  copyMouseData(from, to) {\n    from instanceof FederatedMouseEvent.FederatedMouseEvent && to instanceof FederatedMouseEvent.FederatedMouseEvent && (to.altKey = from.altKey, to.button = from.button, to.buttons = from.buttons, to.client.copyFrom(from.client), to.ctrlKey = from.ctrlKey, to.metaKey = from.metaKey, to.movement.copyFrom(from.movement), to.screen.copyFrom(from.screen), to.shiftKey = from.shiftKey, to.global.copyFrom(from.global));\n  }\n  /**\n   * Copies base {@link PIXI.FederatedEvent} data from {@code from} into {@code to}.\n   *\n   * The following properties are copied:\n   * + isTrusted\n   * + srcElement\n   * + timeStamp\n   * + type\n   * @param from - The event to copy data from.\n   * @param to - The event to copy data into.\n   */\n  copyData(from, to) {\n    to.isTrusted = from.isTrusted, to.srcElement = from.srcElement, to.timeStamp = performance.now(), to.type = from.type, to.detail = from.detail, to.view = from.view, to.which = from.which, to.layer.copyFrom(from.layer), to.page.copyFrom(from.page);\n  }\n  /**\n   * @param id - The pointer ID.\n   * @returns The tracking data stored for the given pointer. If no data exists, a blank\n   *  state will be created.\n   */\n  trackingData(id) {\n    return this.mappingState.trackingData[id] || (this.mappingState.trackingData[id] = {\n      pressTargetsByButton: {},\n      clicksByButton: {},\n      overTarget: null\n    }), this.mappingState.trackingData[id];\n  }\n  /**\n   * Allocate a specific type of event from {@link PIXI.EventBoundary#eventPool this.eventPool}.\n   *\n   * This allocation is constructor-agnostic, as long as it only takes one argument - this event\n   * boundary.\n   * @param constructor - The event's constructor.\n   */\n  allocateEvent(constructor) {\n    this.eventPool.has(constructor) || this.eventPool.set(constructor, []);\n    const event = this.eventPool.get(constructor).pop() || new constructor(this);\n    return event.eventPhase = event.NONE, event.currentTarget = null, event.path = null, event.target = null, event;\n  }\n  /**\n   * Frees the event and puts it back into the event pool.\n   *\n   * It is illegal to reuse the event until it is allocated again, using `this.allocateEvent`.\n   *\n   * It is also advised that events not allocated from {@link PIXI.EventBoundary#allocateEvent this.allocateEvent}\n   * not be freed. This is because of the possibility that the same event is freed twice, which can cause\n   * it to be allocated twice & result in overwriting.\n   * @param event - The event to be freed.\n   * @throws Error if the event is managed by another event boundary.\n   */\n  freeEvent(event) {\n    if (event.manager !== this)\n      throw new Error(\"It is illegal to free an event not managed by this EventBoundary!\");\n    const constructor = event.constructor;\n    this.eventPool.has(constructor) || this.eventPool.set(constructor, []), this.eventPool.get(constructor).push(event);\n  }\n  /**\n   * Similar to {@link PIXI.EventEmitter.emit}, except it stops if the `propagationImmediatelyStopped` flag\n   * is set on the event.\n   * @param e - The event to call each listener with.\n   * @param type - The event key.\n   */\n  notifyListeners(e, type) {\n    const listeners = e.currentTarget._events[type];\n    if (listeners && e.currentTarget.isInteractive())\n      if (\"fn\" in listeners)\n        listeners.once && e.currentTarget.removeListener(type, listeners.fn, void 0, !0), listeners.fn.call(listeners.context, e);\n      else\n        for (let i = 0, j = listeners.length; i < j && !e.propagationImmediatelyStopped; i++)\n          listeners[i].once && e.currentTarget.removeListener(type, listeners[i].fn, void 0, !0), listeners[i].fn.call(listeners[i].context, e);\n  }\n}\nexports.EventBoundary = EventBoundary;\n//# sourceMappingURL=EventBoundary.js.map\n\n};"],
"names":["shadow$provide","global","require","module","exports","core","EventTicker","FederatedMouseEvent","FederatedPointerEvent","FederatedWheelEvent","tempHitLocation","Point","tempLocalMapping","EventBoundary","constructor","rootTarget","dispatch","utils","EventEmitter","moveOnAll","enableGlobalMoveEvents","mappingState","trackingData","eventPool","Map","_allInteractiveElements","_hitElements","_isPointerMoveEvent","hitPruneFn","bind","hitTestFn","mapPointerDown","mapPointerMove","mapPointerOut","mapPointerOver","mapPointerUp","mapPointerUpOutside","mapWheel","mappingTable","addEventMapping","type","fn","push","priority","sort","a","b","dispatchEvent","e","propagationStopped","propagationImmediatelyStopped","propagate","emit","mapEvent","mappers","i","j","length","console","warn","hitTest","x","y","EventsTicker","pauseUpdate","invertedPath","eventMode","set","target","composedPath","eventPhase","CAPTURING_PHASE","currentTarget","notifyTarget","AT_TARGET","BUBBLING_PHASE","all","targets","events","Array","isArray","forEach","event","propagationPath","PROPAGATION_LIMIT","parent","Error","reverse","hitTestMoveRecursive","location","testFn","pruneFn","ignore","shouldReturn","_interactivePrune","interactiveChildren","children","child","nestedHit","_isInteractive","isInteractive","isInteractiveMode","isInteractiveTarget","hitTestRecursive","int","displayObject","isMask","visible","renderable","hitArea","worldTransform","applyInverse","contains","_mask","maskObject","isMaskData","containsPoint","handlerKey","notifyListeners","key","from","createPointerEvent","pointerType","button","pointerId","pressTargetsByButton","freeEvent","isMouse","outTarget","findMountedTarget","overTargets","outEvent","outType","includes","leaveEvent","overEvent","clonePointerEvent","overType","overTargetAncestor","enterEvent","allMethods","allowGlobalPointerEvents","splice","cursor","now","performance","pressTarget","clickTarget","clickEvent","path","clicksByButton","clickCount","timeStamp","clickHistory","detail","wheelEvent","createWheelEvent","allocateEvent","copyPointerData","copyMouseData","copyData","nativeEvent","originalEvent","copyWheelData","slice","to","deltaMode","deltaX","deltaY","deltaZ","width","height","isPrimary","pressure","tangentialPressure","tiltX","tiltY","twist","altKey","buttons","client","copyFrom","ctrlKey","metaKey","movement","screen","shiftKey","isTrusted","srcElement","view","which","layer","page","id","overTarget","has","get","pop","NONE","manager","listeners","_events","once","removeListener","call","context"]
}
