shadow$provide.module$node_modules$$pixi$mesh_extras$lib$geometry$PlaneGeometry = function(global, require, module, exports) {
  global = require("module$node_modules$$pixi$mesh$lib$index");
  class PlaneGeometry extends global.MeshGeometry {
    constructor(width = 100, height = 100, segWidth = 10, segHeight = 10) {
      super();
      this.segWidth = segWidth;
      this.segHeight = segHeight;
      this.width = width;
      this.height = height;
      this.build();
    }
    build() {
      var total = this.segWidth * this.segHeight;
      const verts = [], uvs = [], indices = [], segmentsX = this.segWidth - 1;
      var segmentsY = this.segHeight - 1, sizeX = this.width / segmentsX, sizeY = this.height / segmentsY;
      for (var i = 0; i < total; i++) {
        var x = i % this.segWidth;
        const y = i / this.segWidth | 0;
        verts.push(x * sizeX, y * sizeY);
        uvs.push(x / segmentsX, y / segmentsY);
      }
      total = segmentsX * segmentsY;
      for (segmentsY = 0; segmentsY < total; segmentsY++) {
        sizeX = segmentsY % segmentsX, sizeY = segmentsY / segmentsX | 0, i = sizeY * this.segWidth + sizeX + 1, x = (sizeY + 1) * this.segWidth + sizeX, indices.push(sizeY * this.segWidth + sizeX, i, x, i, (sizeY + 1) * this.segWidth + sizeX + 1, x);
      }
      this.buffers[0].data = new Float32Array(verts);
      this.buffers[1].data = new Float32Array(uvs);
      this.indexBuffer.data = new Uint16Array(indices);
      this.buffers[0].update();
      this.buffers[1].update();
      this.indexBuffer.update();
    }
  }
  exports.PlaneGeometry = PlaneGeometry;
};

//# sourceMappingURL=module$node_modules$$pixi$mesh_extras$lib$geometry$PlaneGeometry.js.map
