shadow$provide.module$node_modules$pixi_DOT_js$lib$filters$FilterSystem = function(global, require, module, exports) {
  global = require("module$node_modules$pixi_DOT_js$lib$extensions$Extensions");
  var Matrix = require("module$node_modules$pixi_DOT_js$lib$maths$matrix$Matrix"), Point = require("module$node_modules$pixi_DOT_js$lib$maths$point$Point"), BindGroup = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$gpu$shader$BindGroup");
  module = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$geometry$Geometry");
  var UniformGroup = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$shader$UniformGroup"), Texture = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$texture$Texture"), TexturePool = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$texture$TexturePool"), types = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$types"), Bounds = require("module$node_modules$pixi_DOT_js$lib$scene$container$bounds$Bounds"), getRenderableBounds = 
  require("module$node_modules$pixi_DOT_js$lib$scene$container$bounds$getRenderableBounds"), warn = require("module$node_modules$pixi_DOT_js$lib$utils$logging$warn");
  "use strict";
  const quadGeometry = new module.Geometry({attributes:{aPosition:{buffer:new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]), format:"float32x2", stride:8, offset:0}}, indexBuffer:new Uint32Array([0, 1, 2, 0, 2, 3])});
  class FilterSystem {
    constructor(renderer) {
      this._filterStackIndex = 0;
      this._filterStack = [];
      this._filterGlobalUniforms = new UniformGroup.UniformGroup({uInputSize:{value:new Float32Array(4), type:"vec4\x3cf32\x3e"}, uInputPixel:{value:new Float32Array(4), type:"vec4\x3cf32\x3e"}, uInputClamp:{value:new Float32Array(4), type:"vec4\x3cf32\x3e"}, uOutputFrame:{value:new Float32Array(4), type:"vec4\x3cf32\x3e"}, uGlobalFrame:{value:new Float32Array(4), type:"vec4\x3cf32\x3e"}, uOutputTexture:{value:new Float32Array(4), type:"vec4\x3cf32\x3e"}});
      this._globalFilterBindGroup = new BindGroup.BindGroup({});
      this.renderer = renderer;
    }
    get activeBackTexture() {
      return this._activeFilterData?.backTexture;
    }
    push(instruction) {
      const renderer = this.renderer;
      var filters = instruction.filterEffect.filters;
      this._filterStack[this._filterStackIndex] || (this._filterStack[this._filterStackIndex] = this._getFilterData());
      const filterData = this._filterStack[this._filterStackIndex];
      this._filterStackIndex++;
      if (0 === filters.length) {
        filterData.skip = !0;
      } else {
        var bounds = filterData.bounds;
        instruction.renderables ? getRenderableBounds.getGlobalRenderableBounds(instruction.renderables, bounds) : instruction.filterEffect.filterArea ? (bounds.clear(), bounds.addRect(instruction.filterEffect.filterArea), bounds.applyMatrix(instruction.container.worldTransform)) : instruction.container.getFastGlobalBounds(!0, bounds);
        if (instruction.container) {
          var filterFrameTransform = (instruction.container.renderGroup || instruction.container.parentRenderGroup).cacheToLocalTransform;
          filterFrameTransform && bounds.applyMatrix(filterFrameTransform);
        }
        var colorTextureSource = renderer.renderTarget.renderTarget.colorTexture.source;
        filterFrameTransform = Infinity;
        var padding = 0, antialias = !0, blendRequired = !1, enabled = !1, clipToViewport = !0;
        for (let i = 0; i < filters.length; i++) {
          const filter = filters[i];
          filterFrameTransform = Math.min(filterFrameTransform, "inherit" === filter.resolution ? colorTextureSource._resolution : filter.resolution);
          padding += filter.padding;
          "off" === filter.antialias ? antialias = !1 : "inherit" === filter.antialias && antialias && (antialias = colorTextureSource.antialias);
          filter.clipToViewport || (clipToViewport = !1);
          if (!(filter.compatibleRenderers & renderer.type)) {
            enabled = !1;
            break;
          }
          if (filter.blendRequired && !(renderer.backBuffer?.useBackBuffer ?? !0)) {
            warn.warn("Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options.");
            enabled = !1;
            break;
          }
          enabled = filter.enabled || enabled;
          blendRequired || (blendRequired = filter.blendRequired);
        }
        enabled ? (clipToViewport && (filters = renderer.renderTarget.rootViewPort, colorTextureSource = renderer.renderTarget.renderTarget.resolution, bounds.fitBounds(0, filters.width / colorTextureSource, 0, filters.height / colorTextureSource)), bounds.scale(filterFrameTransform).ceil().scale(1 / filterFrameTransform).pad(padding | 0), bounds.isPositive ? (filterData.skip = !1, filterData.bounds = bounds, filterData.blendRequired = blendRequired, filterData.container = instruction.container, 
        filterData.filterEffect = instruction.filterEffect, filterData.previousRenderSurface = renderer.renderTarget.renderSurface, filterData.inputTexture = TexturePool.TexturePool.getOptimalTexture(bounds.width, bounds.height, filterFrameTransform, antialias), renderer.renderTarget.bind(filterData.inputTexture, !0), renderer.globalUniforms.push({offset:bounds})) : filterData.skip = !0) : filterData.skip = !0;
      }
    }
    pop() {
      var renderer = this.renderer;
      this._filterStackIndex--;
      const filterData = this._filterStack[this._filterStackIndex];
      if (!filterData.skip) {
        this._activeFilterData = filterData;
        var inputTexture = filterData.inputTexture, bounds = filterData.bounds, backTexture = Texture.Texture.EMPTY;
        renderer.renderTarget.finishRenderPass();
        if (filterData.blendRequired) {
          backTexture = 0 < this._filterStackIndex ? this._filterStack[this._filterStackIndex - 1].bounds : null;
          var renderTarget = renderer.renderTarget.getRenderTarget(filterData.previousRenderSurface);
          backTexture = this.getBackTexture(renderTarget, bounds, backTexture);
        }
        filterData.backTexture = backTexture;
        renderTarget = filterData.filterEffect.filters;
        this._globalFilterBindGroup.setResource(inputTexture.source.style, 2);
        this._globalFilterBindGroup.setResource(backTexture.source, 3);
        renderer.globalUniforms.pop();
        if (1 === renderTarget.length) {
          renderTarget[0].apply(this, inputTexture, filterData.previousRenderSurface, !1), TexturePool.TexturePool.returnTexture(inputTexture);
        } else {
          renderer = filterData.inputTexture;
          bounds = TexturePool.TexturePool.getOptimalTexture(bounds.width, bounds.height, renderer.source._resolution, !1);
          for (inputTexture = 0; inputTexture < renderTarget.length - 1; ++inputTexture) {
            renderTarget[inputTexture].apply(this, renderer, bounds, !0);
            const t = renderer;
            renderer = bounds;
            bounds = t;
          }
          renderTarget[inputTexture].apply(this, renderer, filterData.previousRenderSurface, !1);
          TexturePool.TexturePool.returnTexture(renderer);
          TexturePool.TexturePool.returnTexture(bounds);
        }
        filterData.blendRequired && TexturePool.TexturePool.returnTexture(backTexture);
      }
    }
    getBackTexture(lastRenderSurface, bounds, previousBounds) {
      const backgroundResolution = lastRenderSurface.colorTexture.source._resolution, backTexture = TexturePool.TexturePool.getOptimalTexture(bounds.width, bounds.height, backgroundResolution, !1);
      let x = bounds.minX, y = bounds.minY;
      previousBounds && (x -= previousBounds.minX, y -= previousBounds.minY);
      x = Math.floor(x * backgroundResolution);
      y = Math.floor(y * backgroundResolution);
      this.renderer.renderTarget.copyToTexture(lastRenderSurface, backTexture, {x, y}, {width:Math.ceil(bounds.width * backgroundResolution), height:Math.ceil(bounds.height * backgroundResolution)}, {x:0, y:0});
      return backTexture;
    }
    applyFilter(filter, input, output, clear) {
      const renderer = this.renderer;
      var filterData = this._filterStack[this._filterStackIndex], bounds = filterData.bounds, offset = Point.Point.shared, previousRenderSurface = filterData.previousRenderSurface;
      filterData = this.renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution;
      for (var currentIndex = this._filterStackIndex - 1; 0 < currentIndex && this._filterStack[currentIndex].skip;) {
        --currentIndex;
      }
      0 < currentIndex && (filterData = this._filterStack[currentIndex].inputTexture.source._resolution);
      currentIndex = this._filterGlobalUniforms;
      var uniforms = currentIndex.uniforms;
      const outputFrame = uniforms.uOutputFrame, inputSize = uniforms.uInputSize, inputPixel = uniforms.uInputPixel, inputClamp = uniforms.uInputClamp, globalFrame = uniforms.uGlobalFrame;
      uniforms = uniforms.uOutputTexture;
      if (previousRenderSurface === output) {
        for (previousRenderSurface = this._filterStackIndex; 0 < previousRenderSurface;) {
          previousRenderSurface--;
          const filterData2 = this._filterStack[this._filterStackIndex - 1];
          if (!filterData2.skip) {
            offset.x = filterData2.bounds.minX;
            offset.y = filterData2.bounds.minY;
            break;
          }
        }
        outputFrame[0] = bounds.minX - offset.x;
        outputFrame[1] = bounds.minY - offset.y;
      } else {
        outputFrame[0] = 0, outputFrame[1] = 0;
      }
      outputFrame[2] = input.frame.width;
      outputFrame[3] = input.frame.height;
      inputSize[0] = input.source.width;
      inputSize[1] = input.source.height;
      inputSize[2] = 1 / inputSize[0];
      inputSize[3] = 1 / inputSize[1];
      inputPixel[0] = input.source.pixelWidth;
      inputPixel[1] = input.source.pixelHeight;
      inputPixel[2] = 1 / inputPixel[0];
      inputPixel[3] = 1 / inputPixel[1];
      inputClamp[0] = 0.5 * inputPixel[2];
      inputClamp[1] = 0.5 * inputPixel[3];
      inputClamp[2] = input.frame.width * inputSize[2] - 0.5 * inputPixel[2];
      inputClamp[3] = input.frame.height * inputSize[3] - 0.5 * inputPixel[3];
      bounds = this.renderer.renderTarget.rootRenderTarget.colorTexture;
      globalFrame[0] = offset.x * filterData;
      globalFrame[1] = offset.y * filterData;
      globalFrame[2] = bounds.source.width * filterData;
      globalFrame[3] = bounds.source.height * filterData;
      offset = this.renderer.renderTarget.getRenderTarget(output);
      renderer.renderTarget.bind(output, !!clear);
      output instanceof Texture.Texture ? (uniforms[0] = output.frame.width, uniforms[1] = output.frame.height) : (uniforms[0] = offset.width, uniforms[1] = offset.height);
      uniforms[2] = offset.isRoot ? -1 : 1;
      currentIndex.update();
      renderer.renderPipes.uniformBatch ? (output = renderer.renderPipes.uniformBatch.getUboResource(currentIndex), this._globalFilterBindGroup.setResource(output, 0)) : this._globalFilterBindGroup.setResource(currentIndex, 0);
      this._globalFilterBindGroup.setResource(input.source, 1);
      this._globalFilterBindGroup.setResource(input.source.style, 2);
      filter.groups[0] = this._globalFilterBindGroup;
      renderer.encoder.draw({geometry:quadGeometry, shader:filter, state:filter._state, topology:"triangle-list"});
      renderer.type === types.RendererType.WEBGL && renderer.renderTarget.finishRenderPass();
    }
    _getFilterData() {
      return {skip:!1, inputTexture:null, bounds:new Bounds.Bounds(), container:null, filterEffect:null, blendRequired:!1, previousRenderSurface:null};
    }
    calculateSpriteMatrix(outputMatrix, sprite) {
      var data = this._activeFilterData;
      outputMatrix = outputMatrix.set(data.inputTexture._source.width, 0, 0, data.inputTexture._source.height, data.bounds.minX, data.bounds.minY);
      data = sprite.worldTransform.copyTo(Matrix.Matrix.shared);
      const renderGroup = sprite.renderGroup || sprite.parentRenderGroup;
      renderGroup && renderGroup.cacheToLocalTransform && data.prepend(renderGroup.cacheToLocalTransform);
      data.invert();
      outputMatrix.prepend(data);
      outputMatrix.scale(1 / sprite.texture.frame.width, 1 / sprite.texture.frame.height);
      outputMatrix.translate(sprite.anchor.x, sprite.anchor.y);
      return outputMatrix;
    }
  }
  FilterSystem.extension = {type:[global.ExtensionType.WebGLSystem, global.ExtensionType.WebGPUSystem], name:"filter"};
  exports.FilterSystem = FilterSystem;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$filters$FilterSystem.js.map
