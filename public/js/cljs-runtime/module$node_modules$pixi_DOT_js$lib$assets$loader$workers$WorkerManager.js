shadow$provide.module$node_modules$pixi_DOT_js$lib$assets$loader$workers$WorkerManager = function(global, require, module, exports) {
  var checkImageBitmap_worker = require("module$node_modules$pixi_DOT_js$lib$_virtual$checkImageBitmap_worker"), loadImageBitmap_worker = require("module$node_modules$pixi_DOT_js$lib$_virtual$loadImageBitmap_worker");
  "use strict";
  let UUID = 0, MAX_WORKERS;
  class WorkerManagerClass {
    constructor() {
      this._initialized = !1;
      this._createdWorkers = 0;
      this._workerPool = [];
      this._queue = [];
      this._resolveHash = {};
    }
    isImageBitmapSupported() {
      return void 0 !== this._isImageBitmapSupported ? this._isImageBitmapSupported : this._isImageBitmapSupported = new Promise(resolve => {
        const {worker} = new checkImageBitmap_worker.default();
        worker.addEventListener("message", event => {
          worker.terminate();
          checkImageBitmap_worker.default.revokeObjectURL();
          resolve(event.data);
        });
      });
    }
    loadImageBitmap(src, asset) {
      return this._run("loadImageBitmap", [src, asset?.data?.alphaMode]);
    }
    async _initWorkers() {
      this._initialized || (this._initialized = !0);
    }
    _getWorker() {
      void 0 === MAX_WORKERS && (MAX_WORKERS = navigator.hardwareConcurrency || 4);
      let worker = this._workerPool.pop();
      !worker && this._createdWorkers < MAX_WORKERS && (this._createdWorkers++, worker = (new loadImageBitmap_worker.default()).worker, worker.addEventListener("message", event => {
        this._complete(event.data);
        this._returnWorker(event.target);
        this._next();
      }));
      return worker;
    }
    _returnWorker(worker) {
      this._workerPool.push(worker);
    }
    _complete(data) {
      void 0 !== data.error ? this._resolveHash[data.uuid].reject(data.error) : this._resolveHash[data.uuid].resolve(data.data);
      this._resolveHash[data.uuid] = null;
    }
    async _run(id, args) {
      await this._initWorkers();
      const promise = new Promise((resolve, reject) => {
        this._queue.push({id, arguments:args, resolve, reject});
      });
      this._next();
      return promise;
    }
    _next() {
      if (this._queue.length) {
        var worker = this._getWorker();
        if (worker) {
          var toDo = this._queue.pop(), id = toDo.id;
          this._resolveHash[UUID] = {resolve:toDo.resolve, reject:toDo.reject};
          worker.postMessage({data:toDo.arguments, uuid:UUID++, id});
        }
      }
    }
  }
  global = new WorkerManagerClass();
  exports.WorkerManager = global;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$assets$loader$workers$WorkerManager.js.map
