shadow$provide.module$node_modules$pixi_DOT_js$lib$maths$shapes$Polygon = function(global, require, module, exports) {
  var squaredDistanceToLineSegment = require("module$node_modules$pixi_DOT_js$lib$maths$misc$squaredDistanceToLineSegment"), Rectangle = require("module$node_modules$pixi_DOT_js$lib$maths$shapes$Rectangle");
  "use strict";
  class Polygon {
    constructor(...points) {
      this.type = "polygon";
      points = Array.isArray(points[0]) ? points[0] : points;
      if ("number" !== typeof points[0]) {
        const p = [];
        for (let i = 0, il = points.length; i < il; i++) {
          p.push(points[i].x, points[i].y);
        }
        points = p;
      }
      this.points = points;
      this.closePath = !0;
    }
    isClockwise() {
      let area = 0;
      const points = this.points, length = points.length;
      for (let i = 0; i < length; i += 2) {
        area += (points[(i + 2) % length] - points[i]) * (points[(i + 3) % length] + points[i + 1]);
      }
      return 0 > area;
    }
    containsPolygon(polygon) {
      var thisBounds = this.getBounds(void 0);
      const otherBounds = polygon.getBounds(void 0);
      if (!thisBounds.containsRect(otherBounds)) {
        return !1;
      }
      polygon = polygon.points;
      for (thisBounds = 0; thisBounds < polygon.length; thisBounds += 2) {
        if (!this.contains(polygon[thisBounds], polygon[thisBounds + 1])) {
          return !1;
        }
      }
      return !0;
    }
    clone() {
      var points = this.points.slice();
      points = new Polygon(points);
      points.closePath = this.closePath;
      return points;
    }
    contains(x, y) {
      let inside = !1;
      const length = this.points.length / 2;
      for (let i = 0, j = length - 1; i < length; j = i++) {
        const xi = this.points[2 * i], yi = this.points[2 * i + 1], xj = this.points[2 * j], yj = this.points[2 * j + 1];
        yi > y !== yj > y && x < (y - yi) / (yj - yi) * (xj - xi) + xi && (inside = !inside);
      }
      return inside;
    }
    strokeContains(x, y, strokeWidth, alignment = 0.5) {
      strokeWidth *= strokeWidth;
      alignment = strokeWidth * (1 - alignment);
      strokeWidth -= alignment;
      const {points} = this, iterationLength = points.length - (this.closePath ? 0 : 2);
      for (let i = 0; i < iterationLength; i += 2) {
        const x1 = points[i], y1 = points[i + 1], x2 = points[(i + 2) % points.length], y2 = points[(i + 3) % points.length];
        if (squaredDistanceToLineSegment.squaredDistanceToLineSegment(x, y, x1, y1, x2, y2) <= (0 > Math.sign((x2 - x1) * (y - y1) - (y2 - y1) * (x - x1)) ? strokeWidth : alignment)) {
          return !0;
        }
      }
      return !1;
    }
    getBounds(out) {
      out || (out = new Rectangle.Rectangle());
      const points = this.points;
      let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
      for (let i = 0, n = points.length; i < n; i += 2) {
        const x = points[i], y = points[i + 1];
        minX = x < minX ? x : minX;
        maxX = x > maxX ? x : maxX;
        minY = y < minY ? y : minY;
        maxY = y > maxY ? y : maxY;
      }
      out.x = minX;
      out.width = maxX - minX;
      out.y = minY;
      out.height = maxY - minY;
      return out;
    }
    copyFrom(polygon) {
      this.points = polygon.points.slice();
      this.closePath = polygon.closePath;
      return this;
    }
    copyTo(polygon) {
      polygon.copyFrom(this);
      return polygon;
    }
    toString() {
      return `[pixi.js/math:PolygoncloseStroke=${this.closePath}points=${this.points.reduce((pointsDesc, currentPoint) => `${pointsDesc}, ${currentPoint}`, "")}]`;
    }
    get lastX() {
      return this.points[this.points.length - 2];
    }
    get lastY() {
      return this.points[this.points.length - 1];
    }
    get x() {
      return this.points[this.points.length - 2];
    }
    get y() {
      return this.points[this.points.length - 1];
    }
  }
  exports.Polygon = Polygon;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$maths$shapes$Polygon.js.map
