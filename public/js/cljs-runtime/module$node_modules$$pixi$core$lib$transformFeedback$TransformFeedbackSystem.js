shadow$provide.module$node_modules$$pixi$core$lib$transformFeedback$TransformFeedbackSystem = function(global, require, module, exports) {
  global = require("module$node_modules$$pixi$extensions$lib$index");
  class TransformFeedbackSystem {
    constructor(renderer) {
      this.renderer = renderer;
    }
    contextChange() {
      this.gl = this.renderer.gl;
      this.CONTEXT_UID = this.renderer.CONTEXT_UID;
    }
    bind(transformFeedback) {
      const {gl, CONTEXT_UID} = this;
      transformFeedback = transformFeedback._glTransformFeedbacks[CONTEXT_UID] || this.createGLTransformFeedback(transformFeedback);
      gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, transformFeedback);
    }
    unbind() {
      const {gl} = this;
      gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);
    }
    beginTransformFeedback(drawMode, shader) {
      const {gl, renderer} = this;
      shader && renderer.shader.bind(shader);
      gl.beginTransformFeedback(drawMode);
    }
    endTransformFeedback() {
      const {gl} = this;
      gl.endTransformFeedback();
    }
    createGLTransformFeedback(tf) {
      const {gl, renderer, CONTEXT_UID} = this, glTransformFeedback = gl.createTransformFeedback();
      tf._glTransformFeedbacks[CONTEXT_UID] = glTransformFeedback;
      gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, glTransformFeedback);
      for (let i = 0; i < tf.buffers.length; i++) {
        const buffer = tf.buffers[i];
        buffer && (renderer.buffer.update(buffer), buffer._glBuffers[CONTEXT_UID].refCount++, gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, i, buffer._glBuffers[CONTEXT_UID].buffer || null));
      }
      return gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null), tf.disposeRunner.add(this), glTransformFeedback;
    }
    disposeTransformFeedback(tf, contextLost) {
      const glTF = tf._glTransformFeedbacks[this.CONTEXT_UID], gl = this.gl;
      tf.disposeRunner.remove(this);
      const bufferSystem = this.renderer.buffer;
      if (bufferSystem) {
        for (let i = 0; i < tf.buffers.length; i++) {
          const buffer = tf.buffers[i];
          if (!buffer) {
            continue;
          }
          const buf = buffer._glBuffers[this.CONTEXT_UID];
          buf && (buf.refCount--, 0 === buf.refCount && !contextLost && bufferSystem.dispose(buffer, contextLost));
        }
      }
      glTF && (contextLost || gl.deleteTransformFeedback(glTF), delete tf._glTransformFeedbacks[this.CONTEXT_UID]);
    }
    destroy() {
      this.renderer = null;
    }
  }
  TransformFeedbackSystem.extension = {type:global.ExtensionType.RendererSystem, name:"transformFeedback"};
  global.extensions.add(TransformFeedbackSystem);
  exports.TransformFeedbackSystem = TransformFeedbackSystem;
};

//# sourceMappingURL=module$node_modules$$pixi$core$lib$transformFeedback$TransformFeedbackSystem.js.map
