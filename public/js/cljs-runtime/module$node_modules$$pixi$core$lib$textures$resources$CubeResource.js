shadow$provide.module$node_modules$$pixi$core$lib$textures$resources$CubeResource = function(global, require, module, exports) {
  var constants = require("module$node_modules$$pixi$constants$lib$index");
  global = require("module$node_modules$$pixi$core$lib$textures$resources$AbstractMultiResource");
  const node_modules$$pixi$core$lib$textures$resources$CubeResource$classdecl$var10 = class extends global.AbstractMultiResource {
    constructor(source, options) {
      const {width, height, autoLoad, linkBaseTexture} = options || {};
      if (source && source.length !== node_modules$$pixi$core$lib$textures$resources$CubeResource$classdecl$var10.SIDES) {
        throw Error(`Invalid length. Got ${source.length}, expected 6`);
      }
      super(6, {width, height});
      for (let i = 0; i < node_modules$$pixi$core$lib$textures$resources$CubeResource$classdecl$var10.SIDES; i++) {
        this.items[i].target = constants.TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + i;
      }
      this.linkBaseTexture = !1 !== linkBaseTexture;
      source && this.initFromArray(source, options);
      !1 !== autoLoad && this.load();
    }
    bind(baseTexture) {
      super.bind(baseTexture);
      baseTexture.target = constants.TARGETS.TEXTURE_CUBE_MAP;
    }
    addBaseTextureAt(baseTexture, index, linkBaseTexture) {
      if (!this.items[index]) {
        throw Error(`Index ${index} is out of bounds`);
      }
      if (!this.linkBaseTexture || baseTexture.parentTextureArray || 0 < Object.keys(baseTexture._glTextures).length) {
        if (baseTexture.resource) {
          this.addResourceAt(baseTexture.resource, index);
        } else {
          throw Error("CubeResource does not support copying of renderTexture.");
        }
      } else {
        baseTexture.target = constants.TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + index, baseTexture.parentTextureArray = this.baseTexture, this.items[index] = baseTexture;
      }
      return baseTexture.valid && !this.valid && this.resize(baseTexture.realWidth, baseTexture.realHeight), this.items[index] = baseTexture, this;
    }
    upload(renderer, _baseTexture, glTexture) {
      const dirty = this.itemDirtyIds;
      for (let i = 0; i < node_modules$$pixi$core$lib$textures$resources$CubeResource$classdecl$var10.SIDES; i++) {
        const side = this.items[i];
        (dirty[i] < side.dirtyId || glTexture.dirtyId < _baseTexture.dirtyId) && (side.valid && side.resource ? (side.resource.upload(renderer, side, glTexture), dirty[i] = side.dirtyId) : -1 > dirty[i] && (renderer.gl.texImage2D(side.target, 0, glTexture.internalFormat, _baseTexture.realWidth, _baseTexture.realHeight, 0, _baseTexture.format, glTexture.type, null), dirty[i] = -1));
      }
      return !0;
    }
    static test(source) {
      return Array.isArray(source) && source.length === node_modules$$pixi$core$lib$textures$resources$CubeResource$classdecl$var10.SIDES;
    }
  };
  global = node_modules$$pixi$core$lib$textures$resources$CubeResource$classdecl$var10;
  global.SIDES = 6;
  exports.CubeResource = global;
};

//# sourceMappingURL=module$node_modules$$pixi$core$lib$textures$resources$CubeResource.js.map
