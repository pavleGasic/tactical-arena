shadow$provide.module$node_modules$pixi_DOT_js$lib$spritesheet$Spritesheet = function(global, require, module, exports) {
  var Rectangle = require("module$node_modules$pixi_DOT_js$lib$maths$shapes$Rectangle"), Texture = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$texture$Texture");
  "use strict";
  const node_modules$pixi_DOT_js$lib$spritesheet$Spritesheet$classdecl$var6 = class {
    constructor(texture, data) {
      this.linkedSheets = [];
      this._texture = texture instanceof Texture.Texture ? texture : null;
      this.textureSource = texture.source;
      this.textures = {};
      this.animations = {};
      this.data = data;
      (data = parseFloat(data.meta.scale)) ? (this.resolution = data, texture.source.resolution = this.resolution) : this.resolution = texture.source._resolution;
      this._frames = this.data.frames;
      this._frameKeys = Object.keys(this._frames);
      this._batchIndex = 0;
      this._callback = null;
    }
    parse() {
      return new Promise(resolve => {
        this._callback = resolve;
        this._batchIndex = 0;
        this._frameKeys.length <= node_modules$pixi_DOT_js$lib$spritesheet$Spritesheet$classdecl$var6.BATCH_SIZE ? (this._processFrames(0), this._processAnimations(), this._parseComplete()) : this._nextBatch();
      });
    }
    _processFrames(initialFrameIndex) {
      let frameIndex = initialFrameIndex;
      const maxFrames = node_modules$pixi_DOT_js$lib$spritesheet$Spritesheet$classdecl$var6.BATCH_SIZE;
      for (; frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length;) {
        const i = this._frameKeys[frameIndex], data = this._frames[i], rect = data.frame;
        if (rect) {
          var frame = void 0;
          let trim = null;
          frame = !1 !== data.trimmed && data.sourceSize ? data.sourceSize : data.frame;
          const orig = new Rectangle.Rectangle(0, 0, Math.floor(frame.w) / this.resolution, Math.floor(frame.h) / this.resolution);
          frame = data.rotated ? new Rectangle.Rectangle(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.h) / this.resolution, Math.floor(rect.w) / this.resolution) : new Rectangle.Rectangle(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);
          !1 !== data.trimmed && data.spriteSourceSize && (trim = new Rectangle.Rectangle(Math.floor(data.spriteSourceSize.x) / this.resolution, Math.floor(data.spriteSourceSize.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution));
          this.textures[i] = new Texture.Texture({source:this.textureSource, frame, orig, trim, rotate:data.rotated ? 2 : 0, defaultAnchor:data.anchor, defaultBorders:data.borders, label:i.toString()});
        }
        frameIndex++;
      }
    }
    _processAnimations() {
      const animations = this.data.animations || {};
      for (const animName in animations) {
        this.animations[animName] = [];
        for (let i = 0; i < animations[animName].length; i++) {
          this.animations[animName].push(this.textures[animations[animName][i]]);
        }
      }
    }
    _parseComplete() {
      const callback = this._callback;
      this._callback = null;
      this._batchIndex = 0;
      callback.call(this, this.textures);
    }
    _nextBatch() {
      this._processFrames(this._batchIndex * node_modules$pixi_DOT_js$lib$spritesheet$Spritesheet$classdecl$var6.BATCH_SIZE);
      this._batchIndex++;
      setTimeout(() => {
        this._batchIndex * node_modules$pixi_DOT_js$lib$spritesheet$Spritesheet$classdecl$var6.BATCH_SIZE < this._frameKeys.length ? this._nextBatch() : (this._processAnimations(), this._parseComplete());
      }, 0);
    }
    destroy(destroyBase = !1) {
      for (const i in this.textures) {
        this.textures[i].destroy();
      }
      this.textures = this.data = this._frameKeys = this._frames = null;
      destroyBase && (this._texture?.destroy(), this.textureSource.destroy());
      this.textureSource = this._texture = null;
      this.linkedSheets = [];
    }
  };
  global = node_modules$pixi_DOT_js$lib$spritesheet$Spritesheet$classdecl$var6;
  global.BATCH_SIZE = 1e3;
  exports.Spritesheet = global;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$spritesheet$Spritesheet.js.map
