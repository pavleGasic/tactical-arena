shadow$provide.module$node_modules$pixi_DOT_js$lib$scene$mesh_perspective$utils$compute2DProjections = function(global, require, module, exports) {
  function computeAdjugate(out, matrix) {
    const a00 = matrix[0], a01 = matrix[1], a02 = matrix[2], a10 = matrix[3], a11 = matrix[4], a12 = matrix[5], a20 = matrix[6], a21 = matrix[7];
    matrix = matrix[8];
    out[0] = a11 * matrix - a12 * a21;
    out[1] = a02 * a21 - a01 * matrix;
    out[2] = a01 * a12 - a02 * a11;
    out[3] = a12 * a20 - a10 * matrix;
    out[4] = a00 * matrix - a02 * a20;
    out[5] = a02 * a10 - a00 * a12;
    out[6] = a10 * a21 - a11 * a20;
    out[7] = a01 * a20 - a00 * a21;
    out[8] = a00 * a11 - a01 * a10;
    return out;
  }
  function multiplyMatrix3x3(out, a, b) {
    const a00 = a[0], a01 = a[1], a02 = a[2], a10 = a[3], a11 = a[4], a12 = a[5], a20 = a[6], a21 = a[7];
    a = a[8];
    const b00 = b[0], b01 = b[1], b02 = b[2], b10 = b[3], b11 = b[4], b12 = b[5], b20 = b[6], b21 = b[7];
    b = b[8];
    out[0] = b00 * a00 + b01 * a10 + b02 * a20;
    out[1] = b00 * a01 + b01 * a11 + b02 * a21;
    out[2] = b00 * a02 + b01 * a12 + b02 * a;
    out[3] = b10 * a00 + b11 * a10 + b12 * a20;
    out[4] = b10 * a01 + b11 * a11 + b12 * a21;
    out[5] = b10 * a02 + b11 * a12 + b12 * a;
    out[6] = b20 * a00 + b21 * a10 + b * a20;
    out[7] = b20 * a01 + b21 * a11 + b * a21;
    out[8] = b20 * a02 + b21 * a12 + b * a;
    return out;
  }
  function generateBasisToPointsMatrix(out, x1, y1, x2, y2, x3, y3, x4, y4) {
    const m = tempMatrix;
    m[0] = x1;
    m[1] = x2;
    m[2] = x3;
    m[3] = y1;
    m[4] = y2;
    m[5] = y3;
    m[6] = 1;
    m[7] = 1;
    m[8] = 1;
    x1 = computeAdjugate(out, m);
    tempVec2[0] = x4;
    tempVec2[1] = y4;
    tempVec2[2] = 1;
    x4 = tempVec2[0];
    y4 = tempVec2[1];
    y1 = tempVec2[2];
    tempVec[0] = x1[0] * x4 + x1[1] * y4 + x1[2] * y1;
    tempVec[1] = x1[3] * x4 + x1[4] * y4 + x1[5] * y1;
    tempVec[2] = x1[6] * x4 + x1[7] * y4 + x1[8] * y1;
    x4 = tempVec;
    out[0] = x4[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = x4[1];
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = x4[2];
    return multiplyMatrix3x3(out, out, m);
  }
  const tempMatrix = [0, 0, 0, 0, 0, 0, 0, 0, 0], tempVec = [0, 0, 0], tempVec2 = [0, 0, 0], tempSourceMatrix = [0, 0, 0, 0, 0, 0, 0, 0, 0], tempDestinationMatrix = [0, 0, 0, 0, 0, 0, 0, 0, 0];
  exports.compute2DProjection = function(out, x1s, y1s, x1d, y1d, x2s, y2s, x2d, y2d, x3s, y3s, x3d, y3d, x4s, y4s, x4d, y4d) {
    x1s = generateBasisToPointsMatrix(tempSourceMatrix, x1s, y1s, x2s, y2s, x3s, y3s, x4s, y4s);
    x1d = generateBasisToPointsMatrix(tempDestinationMatrix, x1d, y1d, x2d, y2d, x3d, y3d, x4d, y4d);
    return multiplyMatrix3x3(out, computeAdjugate(x1s, x1s), x1d);
  };
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$scene$mesh_perspective$utils$compute2DProjections.js.map
