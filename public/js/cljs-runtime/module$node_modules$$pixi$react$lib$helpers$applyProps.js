shadow$provide.module$node_modules$$pixi$react$lib$helpers$applyProps = function(global, require, module, exports) {
  function targetKeyReducer(accumulator, key) {
    return !accumulator || (key = accumulator[key], compare.isUndefined(key) || compare.isNull(key)) ? accumulator : key;
  }
  var pixi_js = require("module$node_modules$pixi_DOT_js$lib$index"), EventPropNames = require("module$node_modules$$pixi$react$lib$constants$EventPropNames"), compare = require("module$node_modules$$pixi$react$lib$helpers$compare"), diffProps = require("module$node_modules$$pixi$react$lib$helpers$diffProps"), isDiffSet = require("module$node_modules$$pixi$react$lib$helpers$isDiffSet"), isReadOnlyProperty = require("module$node_modules$$pixi$react$lib$helpers$isReadOnlyProperty"), log = require("module$node_modules$$pixi$react$lib$helpers$log");
  "use strict";
  const DEFAULTS_CONTAINERS = new Map(), PIXI_EVENT_PROP_NAME_ERROR_HAS_BEEN_SHOWN = {};
  exports.applyProps = function(instance, data) {
    const {__pixireact:instanceState = {}, ...instanceProps} = instance;
    data = isDiffSet.isDiffSet(data) ? data : diffProps.diffProps(data, instanceProps);
    ({changes:data} = data);
    let changeIndex = 0;
    for (; changeIndex < data.length;) {
      var change = data[changeIndex], hasError = !1, key = change[0], value = change[1];
      const isEvent = change[2], keys = change[3];
      change = instance;
      "draw" === key && "function" === typeof value && (instance instanceof pixi_js.Graphics ? value(instance) : (hasError = !0, log.log("warn", `The \`draw\` prop was used on a \`${instanceState.type}\` component, but it's only valid on \`graphics\` components.`)));
      if (key in EventPropNames.PixiToReactEventPropNames) {
        const typedKey = key;
        hasError = !0;
        PIXI_EVENT_PROP_NAME_ERROR_HAS_BEEN_SHOWN[key] || (PIXI_EVENT_PROP_NAME_ERROR_HAS_BEEN_SHOWN[key] = !0, log.log("warn", `Event names must be pascal case; instead of \`${key}\`, you probably want \`${EventPropNames.PixiToReactEventPropNames[typedKey]}\`.`));
      }
      if (!hasError) {
        if (keys.length && (hasError = keys.reduce(targetKeyReducer, change), !hasError || !hasError.set)) {
          const [name, ...reverseEntries] = keys.reverse();
          change = reverseEntries.reverse().reduce(targetKeyReducer, change);
          key = name;
        }
        "__defaultremove" === value && (change instanceof pixi_js.Container ? (value = DEFAULTS_CONTAINERS.get(change.constructor), value || (value = change.constructor, value = new value(), DEFAULTS_CONTAINERS.set(change.constructor, value)), value = value[key]) : value = 0);
        isEvent && instanceState ? (key = EventPropNames.ReactToPixiEventPropNames[key], value ? change[key] = value : delete change[key]) : isReadOnlyProperty.isReadOnlyProperty(change, key) || (change[key] = value);
      }
      changeIndex += 1;
    }
    return instance;
  };
};

//# sourceMappingURL=module$node_modules$$pixi$react$lib$helpers$applyProps.js.map
