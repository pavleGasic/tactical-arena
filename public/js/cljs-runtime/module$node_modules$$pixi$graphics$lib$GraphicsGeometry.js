shadow$provide.module$node_modules$$pixi$graphics$lib$GraphicsGeometry = function(global, require, module, exports) {
  var core = require("module$node_modules$$pixi$core$lib$index"), display = require("module$node_modules$$pixi$display$lib$index"), GraphicsData = require("module$node_modules$$pixi$graphics$lib$GraphicsData"), index = require("module$node_modules$$pixi$graphics$lib$utils$index"), BatchPart = require("module$node_modules$$pixi$graphics$lib$utils$BatchPart"), buildPoly = require("module$node_modules$$pixi$graphics$lib$utils$buildPoly"), buildLine = require("module$node_modules$$pixi$graphics$lib$utils$buildLine");
  const tmpPoint = new core.Point();
  global = (() => {
    const node_modules$$pixi$graphics$lib$GraphicsGeometry$classdecl$var17 = class extends core.BatchGeometry {
      constructor() {
        super();
        this.closePointEps = 1e-4;
        this.boundsPadding = 0;
        this.indicesUint16 = this.uvsFloat32 = null;
        this.batchable = !1;
        this.points = [];
        this.colors = [];
        this.uvs = [];
        this.indices = [];
        this.textureIds = [];
        this.graphicsData = [];
        this.drawCalls = [];
        this.batchDirty = -1;
        this.batches = [];
        this.dirty = 0;
        this.cacheDirty = -1;
        this.shapeIndex = this.clearDirty = 0;
        this._bounds = new display.Bounds();
        this.boundsDirty = -1;
      }
      get bounds() {
        return this.updateBatches(), this.boundsDirty !== this.dirty && (this.boundsDirty = this.dirty, this.calculateBounds()), this._bounds;
      }
      invalidate() {
        this.boundsDirty = -1;
        this.dirty++;
        this.batchDirty++;
        this.shapeIndex = 0;
        this.points.length = 0;
        this.colors.length = 0;
        this.uvs.length = 0;
        this.indices.length = 0;
        this.textureIds.length = 0;
        for (var i = 0; i < this.drawCalls.length; i++) {
          this.drawCalls[i].texArray.clear(), index.DRAW_CALL_POOL.push(this.drawCalls[i]);
        }
        this.drawCalls.length = 0;
        for (i = 0; i < this.batches.length; i++) {
          const batchPart = this.batches[i];
          batchPart.reset();
          index.BATCH_POOL.push(batchPart);
        }
        this.batches.length = 0;
      }
      clear() {
        return 0 < this.graphicsData.length && (this.invalidate(), this.clearDirty++, this.graphicsData.length = 0), this;
      }
      drawShape(shape, fillStyle = null, lineStyle = null, matrix = null) {
        shape = new GraphicsData.GraphicsData(shape, fillStyle, lineStyle, matrix);
        return this.graphicsData.push(shape), this.dirty++, this;
      }
      drawHole(shape, matrix = null) {
        if (!this.graphicsData.length) {
          return null;
        }
        shape = new GraphicsData.GraphicsData(shape, null, null, matrix);
        matrix = this.graphicsData[this.graphicsData.length - 1];
        return shape.lineStyle = matrix.lineStyle, matrix.holes.push(shape), this.dirty++, this;
      }
      destroy() {
        super.destroy();
        for (let i = 0; i < this.graphicsData.length; ++i) {
          this.graphicsData[i].destroy();
        }
        this.points.length = 0;
        this.points = null;
        this.colors.length = 0;
        this.colors = null;
        this.uvs.length = 0;
        this.uvs = null;
        this.indices.length = 0;
        this.indices = null;
        this.indexBuffer.destroy();
        this.indexBuffer = null;
        this.graphicsData.length = 0;
        this.graphicsData = null;
        this.drawCalls.length = 0;
        this.drawCalls = null;
        this.batches.length = 0;
        this._bounds = this.batches = null;
      }
      containsPoint(point) {
        const graphicsData = this.graphicsData;
        for (let i = 0; i < graphicsData.length; ++i) {
          const data = graphicsData[i];
          if (data.fillStyle.visible && data.shape && (data.matrix ? data.matrix.applyInverse(point, tmpPoint) : tmpPoint.copyFrom(point), data.shape.contains(tmpPoint.x, tmpPoint.y))) {
            let hitHole = !1;
            if (data.holes) {
              for (let i2 = 0; i2 < data.holes.length; i2++) {
                if (data.holes[i2].shape.contains(tmpPoint.x, tmpPoint.y)) {
                  hitHole = !0;
                  break;
                }
              }
            }
            if (!hitHole) {
              return !0;
            }
          }
        }
        return !1;
      }
      updateBatches() {
        if (!this.graphicsData.length) {
          this.batchable = !0;
        } else {
          if (this.validateBatching()) {
            this.cacheDirty = this.dirty;
            var uvs = this.uvs, graphicsData = this.graphicsData, batchPart = null, currentStyle = null;
            0 < this.batches.length && (batchPart = this.batches[this.batches.length - 1], currentStyle = batchPart.style);
            for (let i = this.shapeIndex; i < graphicsData.length; i++) {
              this.shapeIndex++;
              const data = graphicsData[i], fillStyle = data.fillStyle, lineStyle = data.lineStyle;
              index.FILL_COMMANDS[data.type].build(data);
              data.matrix && this.transformPoints(data.points, data.matrix);
              (fillStyle.visible || lineStyle.visible) && this.processHoles(data.holes);
              for (let j = 0; 2 > j; j++) {
                const style = 0 === j ? fillStyle : lineStyle;
                if (!style.visible) {
                  continue;
                }
                const index2 = this.indices.length, attribIndex = this.points.length / 2;
                style.texture.baseTexture.wrapMode = core.WRAP_MODES.REPEAT;
                0 === j ? this.processFill(data) : this.processLine(data);
                const size = this.points.length / 2 - attribIndex;
                0 !== size && (batchPart && !this._compareStyles(currentStyle, style) && (batchPart.end(index2, attribIndex), batchPart = null), batchPart || (batchPart = index.BATCH_POOL.pop() || new BatchPart.BatchPart(), batchPart.begin(style, index2, attribIndex), this.batches.push(batchPart), currentStyle = style), this.addUvs(this.points, uvs, style.texture, attribIndex, size, style.matrix));
              }
            }
            uvs = this.indices.length;
            graphicsData = this.points.length / 2;
            (batchPart && batchPart.end(uvs, graphicsData), 0 === this.batches.length) ? this.batchable = !0 : (batchPart = 65535 < graphicsData, this.indicesUint16 && this.indices.length === this.indicesUint16.length && batchPart === 2 < this.indicesUint16.BYTES_PER_ELEMENT ? this.indicesUint16.set(this.indices) : this.indicesUint16 = batchPart ? new Uint32Array(this.indices) : new Uint16Array(this.indices), (this.batchable = this.isBatchable()) ? this.packBatches() : this.buildDrawCalls());
          }
        }
      }
      _compareStyles(styleA, styleB) {
        return !(!styleA || !styleB || styleA.texture.baseTexture !== styleB.texture.baseTexture || styleA.color + styleA.alpha !== styleB.color + styleB.alpha || !!styleA.native != !!styleB.native);
      }
      validateBatching() {
        if (this.dirty === this.cacheDirty || !this.graphicsData.length) {
          return !1;
        }
        for (let i = 0, l = this.graphicsData.length; i < l; i++) {
          var data = this.graphicsData[i];
          const fill = data.fillStyle;
          data = data.lineStyle;
          if (fill && !fill.texture.baseTexture.valid || data && !data.texture.baseTexture.valid) {
            return !1;
          }
        }
        return !0;
      }
      packBatches() {
        this.batchDirty++;
        this.uvsFloat32 = new Float32Array(this.uvs);
        const batches = this.batches;
        for (let i = 0, l = batches.length; i < l; i++) {
          const batch = batches[i];
          for (let j = 0; j < batch.size; j++) {
            const index2 = batch.start + j;
            this.indicesUint16[index2] -= batch.attribStart;
          }
        }
      }
      isBatchable() {
        if (131070 < this.points.length) {
          return !1;
        }
        const batches = this.batches;
        for (let i = 0; i < batches.length; i++) {
          if (batches[i].style.native) {
            return !1;
          }
        }
        return this.points.length < 2 * node_modules$$pixi$graphics$lib$GraphicsGeometry$classdecl$var17.BATCHABLE_SIZE;
      }
      buildDrawCalls() {
        let TICK = ++core.BaseTexture._globalBatch;
        for (var i$jscomp$0 = 0; i$jscomp$0 < this.drawCalls.length; i$jscomp$0++) {
          this.drawCalls[i$jscomp$0].texArray.clear(), index.DRAW_CALL_POOL.push(this.drawCalls[i$jscomp$0]);
        }
        this.drawCalls.length = 0;
        i$jscomp$0 = this.colors;
        const textureIds = this.textureIds;
        let currentGroup = index.DRAW_CALL_POOL.pop();
        currentGroup || (currentGroup = new core.BatchDrawCall(), currentGroup.texArray = new core.BatchTextureArray());
        currentGroup.texArray.count = 0;
        currentGroup.start = 0;
        currentGroup.size = 0;
        currentGroup.type = core.DRAW_MODES.TRIANGLES;
        let textureCount = 0, currentTexture = null;
        let native = !1, drawMode = core.DRAW_MODES.TRIANGLES, index$1 = 0;
        this.drawCalls.push(currentGroup);
        for (let i = 0; i < this.batches.length; i++) {
          const data = this.batches[i], style = data.style;
          var textureId = style.texture.baseTexture;
          native !== !!style.native && (native = !!style.native, drawMode = native ? core.DRAW_MODES.LINES : core.DRAW_MODES.TRIANGLES, currentTexture = null, textureCount = 8, TICK++);
          currentTexture !== textureId && (currentTexture = textureId, textureId._batchEnabled !== TICK && (8 === textureCount && (TICK++, textureCount = 0, 0 < currentGroup.size && (currentGroup = index.DRAW_CALL_POOL.pop(), currentGroup || (currentGroup = new core.BatchDrawCall(), currentGroup.texArray = new core.BatchTextureArray()), this.drawCalls.push(currentGroup)), currentGroup.start = index$1, currentGroup.size = 0, currentGroup.texArray.count = 0, currentGroup.type = drawMode), textureId.touched = 
          1, textureId._batchEnabled = TICK, textureId._batchLocation = textureCount, textureId.wrapMode = core.WRAP_MODES.REPEAT, currentGroup.texArray.elements[currentGroup.texArray.count++] = textureId, textureCount++));
          currentGroup.size += data.size;
          index$1 += data.size;
          textureId = textureId._batchLocation;
          this.addColors(i$jscomp$0, style.color, style.alpha, data.attribSize, data.attribStart);
          this.addTextureIds(textureIds, textureId, data.attribSize, data.attribStart);
        }
        core.BaseTexture._globalBatch = TICK;
        this.packAttributes();
      }
      packAttributes() {
        const verts = this.points, uvs = this.uvs, colors = this.colors, textureIds = this.textureIds, glPoints = new ArrayBuffer(12 * verts.length), f32 = new Float32Array(glPoints), u32 = new Uint32Array(glPoints);
        let p = 0;
        for (let i = 0; i < verts.length / 2; i++) {
          f32[p++] = verts[2 * i], f32[p++] = verts[2 * i + 1], f32[p++] = uvs[2 * i], f32[p++] = uvs[2 * i + 1], u32[p++] = colors[i], f32[p++] = textureIds[i];
        }
        this._buffer.update(glPoints);
        this._indexBuffer.update(this.indicesUint16);
      }
      processFill(data) {
        data.holes.length ? buildPoly.buildPoly.triangulate(data, this) : index.FILL_COMMANDS[data.type].triangulate(data, this);
      }
      processLine(data) {
        buildLine.buildLine(data, this);
        for (let i = 0; i < data.holes.length; i++) {
          buildLine.buildLine(data.holes[i], this);
        }
      }
      processHoles(holes) {
        for (let i = 0; i < holes.length; i++) {
          const hole = holes[i];
          index.FILL_COMMANDS[hole.type].build(hole);
          hole.matrix && this.transformPoints(hole.points, hole.matrix);
        }
      }
      calculateBounds() {
        const bounds = this._bounds;
        bounds.clear();
        bounds.addVertexData(this.points, 0, this.points.length);
        bounds.pad(this.boundsPadding, this.boundsPadding);
      }
      transformPoints(points, matrix) {
        for (let i = 0; i < points.length / 2; i++) {
          const x = points[2 * i], y = points[2 * i + 1];
          points[2 * i] = matrix.a * x + matrix.c * y + matrix.tx;
          points[2 * i + 1] = matrix.b * x + matrix.d * y + matrix.ty;
        }
      }
      addColors(colors, color, alpha, size, offset = 0) {
        color = core.Color.shared.setValue(color).toLittleEndianNumber();
        alpha = core.Color.shared.setValue(color).toPremultiplied(alpha);
        colors.length = Math.max(colors.length, offset + size);
        for (color = 0; color < size; color++) {
          colors[offset + color] = alpha;
        }
      }
      addTextureIds(textureIds, id, size, offset = 0) {
        textureIds.length = Math.max(textureIds.length, offset + size);
        for (let i = 0; i < size; i++) {
          textureIds[offset + i] = id;
        }
      }
      addUvs(verts, uvs, texture, start, size, matrix = null) {
        let index2 = 0;
        const uvsStart = uvs.length, frame = texture.frame;
        for (; index2 < size;) {
          let x = verts[2 * (start + index2)], y = verts[2 * (start + index2) + 1];
          if (matrix) {
            const nx = matrix.a * x + matrix.c * y + matrix.tx;
            y = matrix.b * x + matrix.d * y + matrix.ty;
            x = nx;
          }
          index2++;
          uvs.push(x / frame.width, y / frame.height);
        }
        verts = texture.baseTexture;
        (frame.width < verts.width || frame.height < verts.height) && this.adjustUvs(uvs, texture, uvsStart, size);
      }
      adjustUvs(uvs, texture, start, size) {
        var baseTexture = texture.baseTexture;
        size = start + 2 * size;
        var frame = texture.frame;
        texture = frame.width / baseTexture.width;
        baseTexture = frame.height / baseTexture.height;
        let offsetX = frame.x / frame.width;
        frame = frame.y / frame.height;
        let minX = Math.floor(uvs[start] + 1e-6), minY = Math.floor(uvs[start + 1] + 1e-6);
        for (let i = start + 2; i < size; i += 2) {
          minX = Math.min(minX, Math.floor(uvs[i] + 1e-6)), minY = Math.min(minY, Math.floor(uvs[i + 1] + 1e-6));
        }
        offsetX -= minX;
        for (frame -= minY; start < size; start += 2) {
          uvs[start] = (uvs[start] + offsetX) * texture, uvs[start + 1] = (uvs[start + 1] + frame) * baseTexture;
        }
      }
    };
    return node_modules$$pixi$graphics$lib$GraphicsGeometry$classdecl$var17;
  })();
  global.BATCHABLE_SIZE = 100;
  exports.GraphicsGeometry = global;
};

//# sourceMappingURL=module$node_modules$$pixi$graphics$lib$GraphicsGeometry.js.map
