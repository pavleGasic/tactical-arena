shadow$provide.module$node_modules$pixi_DOT_js$lib$scene$graphics$shared$svg$SVGParser = function(global, require, module, exports) {
  function renderChildren(svg, session, fillStyle, strokeStyle) {
    const children = svg.children, {fillStyle:f1, strokeStyle:s1} = parseSVGStyle.parseSVGStyle(svg, session);
    f1 && fillStyle ? fillStyle = {...fillStyle, ...f1} : f1 && (fillStyle = f1);
    s1 && strokeStyle ? strokeStyle = {...strokeStyle, ...s1} : s1 && (strokeStyle = s1);
    var noStyle = !fillStyle && !strokeStyle;
    noStyle && (fillStyle = {color:0});
    let width, height;
    switch(svg.nodeName.toLowerCase()) {
      case "path":
        var x1 = svg.getAttribute("d");
        "evenodd" === svg.getAttribute("fill-rule") && warn.warn("SVG Evenodd fill rule not supported, your svg may render incorrectly");
        svg = new GraphicsPath.GraphicsPath(x1, !0);
        session.context.path(svg);
        fillStyle && session.context.fill(fillStyle);
        strokeStyle && session.context.stroke(strokeStyle);
        break;
      case "circle":
        var x = parseSVGFloatAttribute.parseSVGFloatAttribute(svg, "cx", 0);
        var y = parseSVGFloatAttribute.parseSVGFloatAttribute(svg, "cy", 0);
        svg = parseSVGFloatAttribute.parseSVGFloatAttribute(svg, "r", 0);
        session.context.ellipse(x, y, svg, svg);
        fillStyle && session.context.fill(fillStyle);
        strokeStyle && session.context.stroke(strokeStyle);
        break;
      case "rect":
        x = parseSVGFloatAttribute.parseSVGFloatAttribute(svg, "x", 0);
        y = parseSVGFloatAttribute.parseSVGFloatAttribute(svg, "y", 0);
        width = parseSVGFloatAttribute.parseSVGFloatAttribute(svg, "width", 0);
        height = parseSVGFloatAttribute.parseSVGFloatAttribute(svg, "height", 0);
        x1 = parseSVGFloatAttribute.parseSVGFloatAttribute(svg, "rx", 0);
        svg = parseSVGFloatAttribute.parseSVGFloatAttribute(svg, "ry", 0);
        x1 || svg ? session.context.roundRect(x, y, width, height, x1 || svg) : session.context.rect(x, y, width, height);
        fillStyle && session.context.fill(fillStyle);
        strokeStyle && session.context.stroke(strokeStyle);
        break;
      case "ellipse":
        x = parseSVGFloatAttribute.parseSVGFloatAttribute(svg, "cx", 0);
        y = parseSVGFloatAttribute.parseSVGFloatAttribute(svg, "cy", 0);
        x1 = parseSVGFloatAttribute.parseSVGFloatAttribute(svg, "rx", 0);
        svg = parseSVGFloatAttribute.parseSVGFloatAttribute(svg, "ry", 0);
        session.context.beginPath();
        session.context.ellipse(x, y, x1, svg);
        fillStyle && session.context.fill(fillStyle);
        strokeStyle && session.context.stroke(strokeStyle);
        break;
      case "line":
        x1 = parseSVGFloatAttribute.parseSVGFloatAttribute(svg, "x1", 0);
        x = parseSVGFloatAttribute.parseSVGFloatAttribute(svg, "y1", 0);
        y = parseSVGFloatAttribute.parseSVGFloatAttribute(svg, "x2", 0);
        svg = parseSVGFloatAttribute.parseSVGFloatAttribute(svg, "y2", 0);
        session.context.beginPath();
        session.context.moveTo(x1, x);
        session.context.lineTo(y, svg);
        strokeStyle && session.context.stroke(strokeStyle);
        break;
      case "polygon":
        svg = svg.getAttribute("points");
        svg = svg.match(/\d+/g).map(n => parseInt(n, 10));
        session.context.poly(svg, !0);
        fillStyle && session.context.fill(fillStyle);
        strokeStyle && session.context.stroke(strokeStyle);
        break;
      case "polyline":
        svg = svg.getAttribute("points");
        svg = svg.match(/\d+/g).map(n => parseInt(n, 10));
        session.context.poly(svg, !1);
        strokeStyle && session.context.stroke(strokeStyle);
        break;
      case "g":
      case "svg":
        break;
      default:
        warn.warn(`[SVG parser] <${svg.nodeName}> elements unsupported`);
    }
    noStyle && (fillStyle = null);
    for (noStyle = 0; noStyle < children.length; noStyle++) {
      renderChildren(children[noStyle], session, fillStyle, strokeStyle);
    }
  }
  var warn = require("module$node_modules$pixi_DOT_js$lib$utils$logging$warn"), GraphicsPath = require("module$node_modules$pixi_DOT_js$lib$scene$graphics$shared$path$GraphicsPath"), parseSVGDefinitions = require("module$node_modules$pixi_DOT_js$lib$scene$graphics$shared$svg$parseSVGDefinitions"), parseSVGFloatAttribute = require("module$node_modules$pixi_DOT_js$lib$scene$graphics$shared$svg$parseSVGFloatAttribute"), parseSVGStyle = require("module$node_modules$pixi_DOT_js$lib$scene$graphics$shared$svg$parseSVGStyle");
  "use strict";
  exports.SVGParser = function(svg, graphicsContext) {
    if ("string" === typeof svg) {
      var div = document.createElement("div");
      div.innerHTML = svg.trim();
      svg = div.querySelector("svg");
    }
    div = {context:graphicsContext, defs:{}, path:new GraphicsPath.GraphicsPath()};
    parseSVGDefinitions.parseSVGDefinitions(svg, div);
    const children = svg.children, {fillStyle, strokeStyle} = parseSVGStyle.parseSVGStyle(svg, div);
    for (svg = 0; svg < children.length; svg++) {
      const child = children[svg];
      "defs" !== child.nodeName.toLowerCase() && renderChildren(child, div, fillStyle, strokeStyle);
    }
    return graphicsContext;
  };
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$scene$graphics$shared$svg$SVGParser.js.map
