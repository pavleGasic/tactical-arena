{
"version":3,
"file":"module$node_modules$$pixi$ticker$lib$Ticker.js",
"lineCount":147,
"mappings":"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",
"sources":["node_modules/@pixi/ticker/lib/Ticker.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$$pixi$ticker$lib$Ticker\"] = function(global,require,module,exports) {\n\"use strict\";\nvar _const = require(\"./const.js\"), TickerListener = require(\"./TickerListener.js\");\nconst _Ticker = class _Ticker2 {\n  constructor() {\n    this.autoStart = !1, this.deltaTime = 1, this.lastTime = -1, this.speed = 1, this.started = !1, this._requestId = null, this._maxElapsedMS = 100, this._minElapsedMS = 0, this._protected = !1, this._lastFrame = -1, this._head = new TickerListener.TickerListener(null, null, 1 / 0), this.deltaMS = 1 / _Ticker2.targetFPMS, this.elapsedMS = 1 / _Ticker2.targetFPMS, this._tick = (time) => {\n      this._requestId = null, this.started && (this.update(time), this.started && this._requestId === null && this._head.next && (this._requestId = requestAnimationFrame(this._tick)));\n    };\n  }\n  /**\n   * Conditionally requests a new animation frame.\n   * If a frame has not already been requested, and if the internal\n   * emitter has listeners, a new frame is requested.\n   * @private\n   */\n  _requestIfNeeded() {\n    this._requestId === null && this._head.next && (this.lastTime = performance.now(), this._lastFrame = this.lastTime, this._requestId = requestAnimationFrame(this._tick));\n  }\n  /**\n   * Conditionally cancels a pending animation frame.\n   * @private\n   */\n  _cancelIfNeeded() {\n    this._requestId !== null && (cancelAnimationFrame(this._requestId), this._requestId = null);\n  }\n  /**\n   * Conditionally requests a new animation frame.\n   * If the ticker has been started it checks if a frame has not already\n   * been requested, and if the internal emitter has listeners. If these\n   * conditions are met, a new frame is requested. If the ticker has not\n   * been started, but autoStart is `true`, then the ticker starts now,\n   * and continues with the previous conditions to request a new frame.\n   * @private\n   */\n  _startIfPossible() {\n    this.started ? this._requestIfNeeded() : this.autoStart && this.start();\n  }\n  /**\n   * Register a handler for tick events. Calls continuously unless\n   * it is removed or the ticker is stopped.\n   * @param fn - The listener function to be added for updates\n   * @param context - The listener context\n   * @param {number} [priority=PIXI.UPDATE_PRIORITY.NORMAL] - The priority for emitting\n   * @returns This instance of a ticker\n   */\n  add(fn, context, priority = _const.UPDATE_PRIORITY.NORMAL) {\n    return this._addListener(new TickerListener.TickerListener(fn, context, priority));\n  }\n  /**\n   * Add a handler for the tick event which is only execute once.\n   * @param fn - The listener function to be added for one update\n   * @param context - The listener context\n   * @param {number} [priority=PIXI.UPDATE_PRIORITY.NORMAL] - The priority for emitting\n   * @returns This instance of a ticker\n   */\n  addOnce(fn, context, priority = _const.UPDATE_PRIORITY.NORMAL) {\n    return this._addListener(new TickerListener.TickerListener(fn, context, priority, !0));\n  }\n  /**\n   * Internally adds the event handler so that it can be sorted by priority.\n   * Priority allows certain handler (user, AnimatedSprite, Interaction) to be run\n   * before the rendering.\n   * @private\n   * @param listener - Current listener being added.\n   * @returns This instance of a ticker\n   */\n  _addListener(listener) {\n    let current = this._head.next, previous = this._head;\n    if (!current)\n      listener.connect(previous);\n    else {\n      for (; current; ) {\n        if (listener.priority > current.priority) {\n          listener.connect(previous);\n          break;\n        }\n        previous = current, current = current.next;\n      }\n      listener.previous || listener.connect(previous);\n    }\n    return this._startIfPossible(), this;\n  }\n  /**\n   * Removes any handlers matching the function and context parameters.\n   * If no handlers are left after removing, then it cancels the animation frame.\n   * @param fn - The listener function to be removed\n   * @param context - The listener context to be removed\n   * @returns This instance of a ticker\n   */\n  remove(fn, context) {\n    let listener = this._head.next;\n    for (; listener; )\n      listener.match(fn, context) ? listener = listener.destroy() : listener = listener.next;\n    return this._head.next || this._cancelIfNeeded(), this;\n  }\n  /**\n   * The number of listeners on this ticker, calculated by walking through linked list\n   * @readonly\n   * @member {number}\n   */\n  get count() {\n    if (!this._head)\n      return 0;\n    let count = 0, current = this._head;\n    for (; current = current.next; )\n      count++;\n    return count;\n  }\n  /** Starts the ticker. If the ticker has listeners a new animation frame is requested at this point. */\n  start() {\n    this.started || (this.started = !0, this._requestIfNeeded());\n  }\n  /** Stops the ticker. If the ticker has requested an animation frame it is canceled at this point. */\n  stop() {\n    this.started && (this.started = !1, this._cancelIfNeeded());\n  }\n  /** Destroy the ticker and don't use after this. Calling this method removes all references to internal events. */\n  destroy() {\n    if (!this._protected) {\n      this.stop();\n      let listener = this._head.next;\n      for (; listener; )\n        listener = listener.destroy(!0);\n      this._head.destroy(), this._head = null;\n    }\n  }\n  /**\n   * Triggers an update. An update entails setting the\n   * current {@link PIXI.Ticker#elapsedMS},\n   * the current {@link PIXI.Ticker#deltaTime},\n   * invoking all listeners with current deltaTime,\n   * and then finally setting {@link PIXI.Ticker#lastTime}\n   * with the value of currentTime that was provided.\n   * This method will be called automatically by animation\n   * frame callbacks if the ticker instance has been started\n   * and listeners are added.\n   * @param {number} [currentTime=performance.now()] - the current time of execution\n   */\n  update(currentTime = performance.now()) {\n    let elapsedMS;\n    if (currentTime > this.lastTime) {\n      if (elapsedMS = this.elapsedMS = currentTime - this.lastTime, elapsedMS > this._maxElapsedMS && (elapsedMS = this._maxElapsedMS), elapsedMS *= this.speed, this._minElapsedMS) {\n        const delta = currentTime - this._lastFrame | 0;\n        if (delta < this._minElapsedMS)\n          return;\n        this._lastFrame = currentTime - delta % this._minElapsedMS;\n      }\n      this.deltaMS = elapsedMS, this.deltaTime = this.deltaMS * _Ticker2.targetFPMS;\n      const head = this._head;\n      let listener = head.next;\n      for (; listener; )\n        listener = listener.emit(this.deltaTime);\n      head.next || this._cancelIfNeeded();\n    } else\n      this.deltaTime = this.deltaMS = this.elapsedMS = 0;\n    this.lastTime = currentTime;\n  }\n  /**\n   * The frames per second at which this ticker is running.\n   * The default is approximately 60 in most modern browsers.\n   * **Note:** This does not factor in the value of\n   * {@link PIXI.Ticker#speed}, which is specific\n   * to scaling {@link PIXI.Ticker#deltaTime}.\n   * @member {number}\n   * @readonly\n   */\n  get FPS() {\n    return 1e3 / this.elapsedMS;\n  }\n  /**\n   * Manages the maximum amount of milliseconds allowed to\n   * elapse between invoking {@link PIXI.Ticker#update}.\n   * This value is used to cap {@link PIXI.Ticker#deltaTime},\n   * but does not effect the measured value of {@link PIXI.Ticker#FPS}.\n   * When setting this property it is clamped to a value between\n   * `0` and `Ticker.targetFPMS * 1000`.\n   * @member {number}\n   * @default 10\n   */\n  get minFPS() {\n    return 1e3 / this._maxElapsedMS;\n  }\n  set minFPS(fps) {\n    const minFPS = Math.min(this.maxFPS, fps), minFPMS = Math.min(Math.max(0, minFPS) / 1e3, _Ticker2.targetFPMS);\n    this._maxElapsedMS = 1 / minFPMS;\n  }\n  /**\n   * Manages the minimum amount of milliseconds required to\n   * elapse between invoking {@link PIXI.Ticker#update}.\n   * This will effect the measured value of {@link PIXI.Ticker#FPS}.\n   * If it is set to `0`, then there is no limit; PixiJS will render as many frames as it can.\n   * Otherwise it will be at least `minFPS`\n   * @member {number}\n   * @default 0\n   */\n  get maxFPS() {\n    return this._minElapsedMS ? Math.round(1e3 / this._minElapsedMS) : 0;\n  }\n  set maxFPS(fps) {\n    if (fps === 0)\n      this._minElapsedMS = 0;\n    else {\n      const maxFPS = Math.max(this.minFPS, fps);\n      this._minElapsedMS = 1 / (maxFPS / 1e3);\n    }\n  }\n  /**\n   * The shared ticker instance used by {@link PIXI.AnimatedSprite} and by\n   * {@link PIXI.VideoResource} to update animation frames / video textures.\n   *\n   * It may also be used by {@link PIXI.Application} if created with the `sharedTicker` option property set to true.\n   *\n   * The property {@link PIXI.Ticker#autoStart} is set to `true` for this instance.\n   * Please follow the examples for usage, including how to opt-out of auto-starting the shared ticker.\n   * @example\n   * import { Ticker } from 'pixi.js';\n   *\n   * const ticker = Ticker.shared;\n   * // Set this to prevent starting this ticker when listeners are added.\n   * // By default this is true only for the PIXI.Ticker.shared instance.\n   * ticker.autoStart = false;\n   *\n   * // FYI, call this to ensure the ticker is stopped. It should be stopped\n   * // if you have not attempted to render anything yet.\n   * ticker.stop();\n   *\n   * // Call this when you are ready for a running shared ticker.\n   * ticker.start();\n   * @example\n   * import { autoDetectRenderer, Container } from 'pixi.js';\n   *\n   * // You may use the shared ticker to render...\n   * const renderer = autoDetectRenderer();\n   * const stage = new Container();\n   * document.body.appendChild(renderer.view);\n   * ticker.add((time) => renderer.render(stage));\n   *\n   * // Or you can just update it manually.\n   * ticker.autoStart = false;\n   * ticker.stop();\n   * const animate = (time) => {\n   *     ticker.update(time);\n   *     renderer.render(stage);\n   *     requestAnimationFrame(animate);\n   * };\n   * animate(performance.now());\n   * @member {PIXI.Ticker}\n   * @static\n   */\n  static get shared() {\n    if (!_Ticker2._shared) {\n      const shared = _Ticker2._shared = new _Ticker2();\n      shared.autoStart = !0, shared._protected = !0;\n    }\n    return _Ticker2._shared;\n  }\n  /**\n   * The system ticker instance used by {@link PIXI.BasePrepare} for core timing\n   * functionality that shouldn't usually need to be paused, unlike the `shared`\n   * ticker which drives visual animations and rendering which may want to be paused.\n   *\n   * The property {@link PIXI.Ticker#autoStart} is set to `true` for this instance.\n   * @member {PIXI.Ticker}\n   * @static\n   */\n  static get system() {\n    if (!_Ticker2._system) {\n      const system = _Ticker2._system = new _Ticker2();\n      system.autoStart = !0, system._protected = !0;\n    }\n    return _Ticker2._system;\n  }\n};\n_Ticker.targetFPMS = 0.06;\nlet Ticker = _Ticker;\nexports.Ticker = Ticker;\n//# sourceMappingURL=Ticker.js.map\n\n};"],
"names":["shadow$provide","global","require","module","exports","_const","TickerListener","constructor","autoStart","deltaTime","lastTime","speed","started","_requestId","_maxElapsedMS","_minElapsedMS","_protected","_lastFrame","_head","deltaMS","_Ticker2","targetFPMS","elapsedMS","_tick","time","this._tick","update","next","requestAnimationFrame","_requestIfNeeded","performance","now","_cancelIfNeeded","cancelAnimationFrame","_startIfPossible","start","add","fn","context","priority","UPDATE_PRIORITY","NORMAL","_addListener","addOnce","listener","current","previous","connect","remove","match","destroy","count","stop","currentTime","delta","head","emit","fps","Math","min","minFPMS","max","minFPS","maxFPS","round","_shared","shared","_system","system","_Ticker","Ticker"]
}
