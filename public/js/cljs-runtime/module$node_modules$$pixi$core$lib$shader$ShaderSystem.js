shadow$provide.module$node_modules$$pixi$core$lib$shader$ShaderSystem = function(global, require, module, exports) {
  global = require("module$node_modules$$pixi$extensions$lib$index");
  require("module$node_modules$$pixi$core$lib$shader$utils$index");
  var generateProgram = require("module$node_modules$$pixi$core$lib$shader$utils$generateProgram"), generateUniformBufferSync = require("module$node_modules$$pixi$core$lib$shader$utils$generateUniformBufferSync"), unsafeEvalSupported = require("module$node_modules$$pixi$core$lib$shader$utils$unsafeEvalSupported"), generateUniformsSync = require("module$node_modules$$pixi$core$lib$shader$utils$generateUniformsSync");
  let UID = 0;
  const defaultSyncData = {textureCount:0, uboCount:0};
  class ShaderSystem {
    constructor(renderer) {
      this.destroyed = !1;
      this.renderer = renderer;
      this.systemCheck();
      this.program = this.shader = this.gl = null;
      this.cache = {};
      this._uboCache = {};
      this.id = UID++;
    }
    systemCheck() {
      if (!unsafeEvalSupported.unsafeEvalSupported()) {
        throw Error("Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.");
      }
    }
    contextChange(gl) {
      this.gl = gl;
      this.reset();
    }
    bind(shader, dontSync) {
      shader.disposeRunner.add(this);
      shader.uniforms.globals = this.renderer.globalUniforms;
      const program = shader.program, glProgram = program.glPrograms[this.renderer.CONTEXT_UID] || this.generateProgram(shader);
      return this.shader = shader, this.program !== program && (this.program = program, this.gl.useProgram(glProgram.program)), dontSync || (defaultSyncData.textureCount = 0, defaultSyncData.uboCount = 0, this.syncUniformGroup(shader.uniformGroup, defaultSyncData)), glProgram;
    }
    setUniforms(uniforms) {
      const shader = this.shader.program;
      shader.syncUniforms(shader.glPrograms[this.renderer.CONTEXT_UID].uniformData, uniforms, this.renderer);
    }
    syncUniformGroup(group, syncData) {
      const glProgram = this.getGlProgram();
      group.static && group.dirtyId === glProgram.uniformDirtyGroups[group.id] || (glProgram.uniformDirtyGroups[group.id] = group.dirtyId, this.syncUniforms(group, glProgram, syncData));
    }
    syncUniforms(group, glProgram, syncData) {
      (group.syncUniforms[this.shader.program.id] || this.createSyncGroups(group))(glProgram.uniformData, group.uniforms, this.renderer, syncData);
    }
    createSyncGroups(group) {
      const id = this.getSignature(group, this.shader.program.uniformData, "u");
      return this.cache[id] || (this.cache[id] = generateUniformsSync.generateUniformsSync(group, this.shader.program.uniformData)), group.syncUniforms[this.shader.program.id] = this.cache[id], group.syncUniforms[this.shader.program.id];
    }
    syncUniformBufferGroup(group, name) {
      const glProgram = this.getGlProgram();
      if (!group.static || 0 !== group.dirtyId || !glProgram.uniformGroups[group.id]) {
        group.dirtyId = 0;
        const syncFunc = glProgram.uniformGroups[group.id] || this.createSyncBufferGroup(group, glProgram, name);
        group.buffer.update();
        syncFunc(glProgram.uniformData, group.uniforms, this.renderer, defaultSyncData, group.buffer);
      }
      this.renderer.buffer.bindBufferBase(group.buffer, glProgram.uniformBufferBindings[name]);
    }
    createSyncBufferGroup(group, glProgram, name) {
      var {gl} = this.renderer;
      this.renderer.buffer.bind(group.buffer);
      const uniformBlockIndex = this.gl.getUniformBlockIndex(glProgram.program, name);
      glProgram.uniformBufferBindings[name] = this.shader.uniformBindCount;
      gl.uniformBlockBinding(glProgram.program, uniformBlockIndex, this.shader.uniformBindCount);
      this.shader.uniformBindCount++;
      gl = this.getSignature(group, this.shader.program.uniformData, "ubo");
      name = this._uboCache[gl];
      if (name || (name = this._uboCache[gl] = generateUniformBufferSync.generateUniformBufferSync(group, this.shader.program.uniformData)), group.autoManage) {
        gl = new Float32Array(name.size / 4), group.buffer.update(gl);
      }
      return glProgram.uniformGroups[group.id] = name.syncFunc, glProgram.uniformGroups[group.id];
    }
    getSignature(group, uniformData, preFix) {
      group = group.uniforms;
      preFix = [`${preFix}-`];
      for (const i in group) {
        preFix.push(i), uniformData[i] && preFix.push(uniformData[i].type);
      }
      return preFix.join("-");
    }
    getGlProgram() {
      return this.shader ? this.shader.program.glPrograms[this.renderer.CONTEXT_UID] : null;
    }
    generateProgram(shader) {
      shader = shader.program;
      const glProgram = generateProgram.generateProgram(this.gl, shader);
      return shader.glPrograms[this.renderer.CONTEXT_UID] = glProgram, glProgram;
    }
    reset() {
      this.shader = this.program = null;
    }
    disposeShader(shader) {
      this.shader === shader && (this.shader = null);
    }
    destroy() {
      this.renderer = null;
      this.destroyed = !0;
    }
  }
  ShaderSystem.extension = {type:global.ExtensionType.RendererSystem, name:"shader"};
  global.extensions.add(ShaderSystem);
  exports.ShaderSystem = ShaderSystem;
};

//# sourceMappingURL=module$node_modules$$pixi$core$lib$shader$ShaderSystem.js.map
