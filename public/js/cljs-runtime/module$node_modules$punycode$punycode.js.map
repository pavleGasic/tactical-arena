{
"version":3,
"file":"module$node_modules$punycode$punycode.js",
"lineCount":151,
"mappings":"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",
"sources":["node_modules/punycode/punycode.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$punycode$punycode\"] = function(global,require,module,exports) {\n/*! https://mths.be/punycode v1.4.1 by @mathias */\n;(function(root) {\n\n\t/** Detect free variables */\n\tvar freeExports = typeof exports == 'object' && exports &&\n\t\t!exports.nodeType && exports;\n\tvar freeModule = typeof module == 'object' && module &&\n\t\t!module.nodeType && module;\n\tvar freeGlobal = typeof global == 'object' && global;\n\tif (\n\t\tfreeGlobal.global === freeGlobal ||\n\t\tfreeGlobal.window === freeGlobal ||\n\t\tfreeGlobal.self === freeGlobal\n\t) {\n\t\troot = freeGlobal;\n\t}\n\n\t/**\n\t * The `punycode` object.\n\t * @name punycode\n\t * @type Object\n\t */\n\tvar punycode,\n\n\t/** Highest positive signed 32-bit float value */\n\tmaxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1\n\n\t/** Bootstring parameters */\n\tbase = 36,\n\ttMin = 1,\n\ttMax = 26,\n\tskew = 38,\n\tdamp = 700,\n\tinitialBias = 72,\n\tinitialN = 128, // 0x80\n\tdelimiter = '-', // '\\x2D'\n\n\t/** Regular expressions */\n\tregexPunycode = /^xn--/,\n\tregexNonASCII = /[^\\x20-\\x7E]/, // unprintable ASCII chars + non-ASCII chars\n\tregexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g, // RFC 3490 separators\n\n\t/** Error messages */\n\terrors = {\n\t\t'overflow': 'Overflow: input needs wider integers to process',\n\t\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t\t'invalid-input': 'Invalid input'\n\t},\n\n\t/** Convenience shortcuts */\n\tbaseMinusTMin = base - tMin,\n\tfloor = Math.floor,\n\tstringFromCharCode = String.fromCharCode,\n\n\t/** Temporary variable */\n\tkey;\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/**\n\t * A generic error utility function.\n\t * @private\n\t * @param {String} type The error type.\n\t * @returns {Error} Throws a `RangeError` with the applicable error message.\n\t */\n\tfunction error(type) {\n\t\tthrow new RangeError(errors[type]);\n\t}\n\n\t/**\n\t * A generic `Array#map` utility function.\n\t * @private\n\t * @param {Array} array The array to iterate over.\n\t * @param {Function} callback The function that gets called for every array\n\t * item.\n\t * @returns {Array} A new array of values returned by the callback function.\n\t */\n\tfunction map(array, fn) {\n\t\tvar length = array.length;\n\t\tvar result = [];\n\t\twhile (length--) {\n\t\t\tresult[length] = fn(array[length]);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * A simple `Array#map`-like wrapper to work with domain name strings or email\n\t * addresses.\n\t * @private\n\t * @param {String} domain The domain name or email address.\n\t * @param {Function} callback The function that gets called for every\n\t * character.\n\t * @returns {Array} A new string of characters returned by the callback\n\t * function.\n\t */\n\tfunction mapDomain(string, fn) {\n\t\tvar parts = string.split('@');\n\t\tvar result = '';\n\t\tif (parts.length > 1) {\n\t\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t\t// the local part (i.e. everything up to `@`) intact.\n\t\t\tresult = parts[0] + '@';\n\t\t\tstring = parts[1];\n\t\t}\n\t\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\t\tstring = string.replace(regexSeparators, '\\x2E');\n\t\tvar labels = string.split('.');\n\t\tvar encoded = map(labels, fn).join('.');\n\t\treturn result + encoded;\n\t}\n\n\t/**\n\t * Creates an array containing the numeric code points of each Unicode\n\t * character in the string. While JavaScript uses UCS-2 internally,\n\t * this function will convert a pair of surrogate halves (each of which\n\t * UCS-2 exposes as separate characters) into a single code point,\n\t * matching UTF-16.\n\t * @see `punycode.ucs2.encode`\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode.ucs2\n\t * @name decode\n\t * @param {String} string The Unicode input string (UCS-2).\n\t * @returns {Array} The new array of code points.\n\t */\n\tfunction ucs2decode(string) {\n\t\tvar output = [],\n\t\t    counter = 0,\n\t\t    length = string.length,\n\t\t    value,\n\t\t    extra;\n\t\twhile (counter < length) {\n\t\t\tvalue = string.charCodeAt(counter++);\n\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t\t// high surrogate, and there is a next character\n\t\t\t\textra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\n\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t\t} else {\n\t\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\n\t\t\t\t\t// code unit is the high surrogate of a surrogate pair\n\t\t\t\t\toutput.push(value);\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toutput.push(value);\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t}\n\n\t/**\n\t * Creates a string based on an array of numeric code points.\n\t * @see `punycode.ucs2.decode`\n\t * @memberOf punycode.ucs2\n\t * @name encode\n\t * @param {Array} codePoints The array of numeric code points.\n\t * @returns {String} The new Unicode string (UCS-2).\n\t */\n\tfunction ucs2encode(array) {\n\t\treturn map(array, function(value) {\n\t\t\tvar output = '';\n\t\t\tif (value > 0xFFFF) {\n\t\t\t\tvalue -= 0x10000;\n\t\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n\t\t\t\tvalue = 0xDC00 | value & 0x3FF;\n\t\t\t}\n\t\t\toutput += stringFromCharCode(value);\n\t\t\treturn output;\n\t\t}).join('');\n\t}\n\n\t/**\n\t * Converts a basic code point into a digit/integer.\n\t * @see `digitToBasic()`\n\t * @private\n\t * @param {Number} codePoint The basic numeric code point value.\n\t * @returns {Number} The numeric value of a basic code point (for use in\n\t * representing integers) in the range `0` to `base - 1`, or `base` if\n\t * the code point does not represent a value.\n\t */\n\tfunction basicToDigit(codePoint) {\n\t\tif (codePoint - 48 < 10) {\n\t\t\treturn codePoint - 22;\n\t\t}\n\t\tif (codePoint - 65 < 26) {\n\t\t\treturn codePoint - 65;\n\t\t}\n\t\tif (codePoint - 97 < 26) {\n\t\t\treturn codePoint - 97;\n\t\t}\n\t\treturn base;\n\t}\n\n\t/**\n\t * Converts a digit/integer into a basic code point.\n\t * @see `basicToDigit()`\n\t * @private\n\t * @param {Number} digit The numeric value of a basic code point.\n\t * @returns {Number} The basic code point whose value (when used for\n\t * representing integers) is `digit`, which needs to be in the range\n\t * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n\t * used; else, the lowercase form is used. The behavior is undefined\n\t * if `flag` is non-zero and `digit` has no uppercase form.\n\t */\n\tfunction digitToBasic(digit, flag) {\n\t\t//  0..25 map to ASCII a..z or A..Z\n\t\t// 26..35 map to ASCII 0..9\n\t\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n\t}\n\n\t/**\n\t * Bias adaptation function as per section 3.4 of RFC 3492.\n\t * https://tools.ietf.org/html/rfc3492#section-3.4\n\t * @private\n\t */\n\tfunction adapt(delta, numPoints, firstTime) {\n\t\tvar k = 0;\n\t\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\t\tdelta += floor(delta / numPoints);\n\t\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\t\tdelta = floor(delta / baseMinusTMin);\n\t\t}\n\t\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n\t}\n\n\t/**\n\t * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n\t * symbols.\n\t * @memberOf punycode\n\t * @param {String} input The Punycode string of ASCII-only symbols.\n\t * @returns {String} The resulting string of Unicode symbols.\n\t */\n\tfunction decode(input) {\n\t\t// Don't use UCS-2\n\t\tvar output = [],\n\t\t    inputLength = input.length,\n\t\t    out,\n\t\t    i = 0,\n\t\t    n = initialN,\n\t\t    bias = initialBias,\n\t\t    basic,\n\t\t    j,\n\t\t    index,\n\t\t    oldi,\n\t\t    w,\n\t\t    k,\n\t\t    digit,\n\t\t    t,\n\t\t    /** Cached calculation results */\n\t\t    baseMinusT;\n\n\t\t// Handle the basic code points: let `basic` be the number of input code\n\t\t// points before the last delimiter, or `0` if there is none, then copy\n\t\t// the first basic code points to the output.\n\n\t\tbasic = input.lastIndexOf(delimiter);\n\t\tif (basic < 0) {\n\t\t\tbasic = 0;\n\t\t}\n\n\t\tfor (j = 0; j < basic; ++j) {\n\t\t\t// if it's not a basic code point\n\t\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\t\terror('not-basic');\n\t\t\t}\n\t\t\toutput.push(input.charCodeAt(j));\n\t\t}\n\n\t\t// Main decoding loop: start just after the last delimiter if any basic code\n\t\t// points were copied; start at the beginning otherwise.\n\n\t\tfor (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\n\t\t\t// `index` is the index of the next character to be consumed.\n\t\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t\t// which gets added to `i`. The overflow checking is easier\n\t\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t\t// value at the end to obtain `delta`.\n\t\t\tfor (oldi = i, w = 1, k = base; /* no condition */; k += base) {\n\n\t\t\t\tif (index >= inputLength) {\n\t\t\t\t\terror('invalid-input');\n\t\t\t\t}\n\n\t\t\t\tdigit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\ti += digit * w;\n\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n\t\t\t\tif (digit < t) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tbaseMinusT = base - t;\n\t\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tw *= baseMinusT;\n\n\t\t\t}\n\n\t\t\tout = output.length + 1;\n\t\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t\t// incrementing `n` each time, so we'll fix that now:\n\t\t\tif (floor(i / out) > maxInt - n) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tn += floor(i / out);\n\t\t\ti %= out;\n\n\t\t\t// Insert `n` at position `i` of the output\n\t\t\toutput.splice(i++, 0, n);\n\n\t\t}\n\n\t\treturn ucs2encode(output);\n\t}\n\n\t/**\n\t * Converts a string of Unicode symbols (e.g. a domain name label) to a\n\t * Punycode string of ASCII-only symbols.\n\t * @memberOf punycode\n\t * @param {String} input The string of Unicode symbols.\n\t * @returns {String} The resulting Punycode string of ASCII-only symbols.\n\t */\n\tfunction encode(input) {\n\t\tvar n,\n\t\t    delta,\n\t\t    handledCPCount,\n\t\t    basicLength,\n\t\t    bias,\n\t\t    j,\n\t\t    m,\n\t\t    q,\n\t\t    k,\n\t\t    t,\n\t\t    currentValue,\n\t\t    output = [],\n\t\t    /** `inputLength` will hold the number of code points in `input`. */\n\t\t    inputLength,\n\t\t    /** Cached calculation results */\n\t\t    handledCPCountPlusOne,\n\t\t    baseMinusT,\n\t\t    qMinusT;\n\n\t\t// Convert the input in UCS-2 to Unicode\n\t\tinput = ucs2decode(input);\n\n\t\t// Cache the length\n\t\tinputLength = input.length;\n\n\t\t// Initialize the state\n\t\tn = initialN;\n\t\tdelta = 0;\n\t\tbias = initialBias;\n\n\t\t// Handle the basic code points\n\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\tcurrentValue = input[j];\n\t\t\tif (currentValue < 0x80) {\n\t\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t\t}\n\t\t}\n\n\t\thandledCPCount = basicLength = output.length;\n\n\t\t// `handledCPCount` is the number of code points that have been handled;\n\t\t// `basicLength` is the number of basic code points.\n\n\t\t// Finish the basic string - if it is not empty - with a delimiter\n\t\tif (basicLength) {\n\t\t\toutput.push(delimiter);\n\t\t}\n\n\t\t// Main encoding loop:\n\t\twhile (handledCPCount < inputLength) {\n\n\t\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t\t// larger one:\n\t\t\tfor (m = maxInt, j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\t\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\t\tm = currentValue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t\t// but guard against overflow\n\t\t\thandledCPCountPlusOne = handledCPCount + 1;\n\t\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\t\tn = m;\n\n\t\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\n\t\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tif (currentValue == n) {\n\t\t\t\t\t// Represent delta as a generalized variable-length integer\n\t\t\t\t\tfor (q = delta, k = base; /* no condition */; k += base) {\n\t\t\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tqMinusT = q - t;\n\t\t\t\t\t\tbaseMinusT = base - t;\n\t\t\t\t\t\toutput.push(\n\t\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t\t);\n\t\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t\t}\n\n\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\t\tdelta = 0;\n\t\t\t\t\t++handledCPCount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t++delta;\n\t\t\t++n;\n\n\t\t}\n\t\treturn output.join('');\n\t}\n\n\t/**\n\t * Converts a Punycode string representing a domain name or an email address\n\t * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n\t * it doesn't matter if you call it on a string that has already been\n\t * converted to Unicode.\n\t * @memberOf punycode\n\t * @param {String} input The Punycoded domain name or email address to\n\t * convert to Unicode.\n\t * @returns {String} The Unicode representation of the given Punycode\n\t * string.\n\t */\n\tfunction toUnicode(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexPunycode.test(string)\n\t\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/**\n\t * Converts a Unicode string representing a domain name or an email address to\n\t * Punycode. Only the non-ASCII parts of the domain name will be converted,\n\t * i.e. it doesn't matter if you call it with a domain that's already in\n\t * ASCII.\n\t * @memberOf punycode\n\t * @param {String} input The domain name or email address to convert, as a\n\t * Unicode string.\n\t * @returns {String} The Punycode representation of the given domain name or\n\t * email address.\n\t */\n\tfunction toASCII(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexNonASCII.test(string)\n\t\t\t\t? 'xn--' + encode(string)\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/** Define the public API */\n\tpunycode = {\n\t\t/**\n\t\t * A string representing the current Punycode.js version number.\n\t\t * @memberOf punycode\n\t\t * @type String\n\t\t */\n\t\t'version': '1.4.1',\n\t\t/**\n\t\t * An object of methods to convert from JavaScript's internal character\n\t\t * representation (UCS-2) to Unicode code points, and back.\n\t\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t\t * @memberOf punycode\n\t\t * @type Object\n\t\t */\n\t\t'ucs2': {\n\t\t\t'decode': ucs2decode,\n\t\t\t'encode': ucs2encode\n\t\t},\n\t\t'decode': decode,\n\t\t'encode': encode,\n\t\t'toASCII': toASCII,\n\t\t'toUnicode': toUnicode\n\t};\n\n\t/** Expose `punycode` */\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t// like the following:\n\tif (\n\t\ttypeof define == 'function' &&\n\t\ttypeof define.amd == 'object' &&\n\t\tdefine.amd\n\t) {\n\t\tdefine('punycode', function() {\n\t\t\treturn punycode;\n\t\t});\n\t} else if (freeExports && freeModule) {\n\t\tif (module.exports == freeExports) {\n\t\t\t// in Node.js, io.js, or RingoJS v0.8.0+\n\t\t\tfreeModule.exports = punycode;\n\t\t} else {\n\t\t\t// in Narwhal or RingoJS v0.7.0-\n\t\t\tfor (key in punycode) {\n\t\t\t\tpunycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// in Rhino or a web browser\n\t\troot.punycode = punycode;\n\t}\n\n}(this));\n\n};"],
"names":["shadow$provide","global","require","module","exports","root","error","type","RangeError","errors","map","array","fn","length","result","mapDomain","string","parts","split","replace","regexSeparators","labels","encoded","join","ucs2decode","output","counter","value","extra","charCodeAt","push","ucs2encode","stringFromCharCode","adapt","delta","numPoints","firstTime","k","floor","damp","base","baseMinusTMin","skew","decode","input","inputLength","i","n","initialN","bias","initialBias","j","basic","lastIndexOf","delimiter","index","oldi","w","codePoint","digit","maxInt","t","tMin","tMax","baseMinusT","out","splice","encode","handledCPCount","basicLength","currentValue","m","handledCPCountPlusOne","q","qMinusT","freeExports","nodeType","freeModule","freeGlobal","window","self","regexPunycode","regexNonASCII","Math","String","fromCharCode","key","punycode","toASCII","test","toUnicode","slice","toLowerCase","define","amd","hasOwnProperty"]
}
