{
"version":3,
"file":"module$node_modules$pixi_DOT_js$lib$filters$Filter.js",
"lineCount":41,
"mappings":"AAAAA,cAAA,CAAA,kDAAA,GAAuE,QAAQ,CAACC,MAAD,EAAQC,OAAR,EAAgBC,MAAhB,EAAuBC,OAAvB,CAAgC;AAG/G,MAAIC,YAAYH,OAAA,CAAQ,6EAAR,CAAhB,EACII,aAAaJ,OAAA,CAAQ,+EAAR,CADjB;AAEIK,QAAAA,GAASL,OAAA,CAAQ,8EAAR,CAATK;AACJ,MAAIC,QAAQN,OAAA,CAAQ,4EAAR,CAAZ;AAEA,cAAA;AACgB,QAAA,8DAAA,aAAsBK,OAAOA,CAAAA,MAA7B;AAIdE,eAAW,CAACC,OAAD,CAAU;AACnBA,aAAA,GAAU,CAAE,GAAGC,2DAAQC,CAAAA,cAAb,EAA6B,GAAGF,OAAhC,CAAV;AACA,WAAA,CAAMA,OAAN,CAAA;AAEA,UAAKG,CAAAA,OAAL,GAAe,CAAA,CAAf;AAMA,UAAKC,CAAAA,MAAL,GAAcN,KAAMA,CAAAA,KAAMO,CAAAA,KAAZ,EAAd;AACA,UAAKC,CAAAA,SAAL,GAAiBN,OAAQM,CAAAA,SAAzB;AACA,UAAKC,CAAAA,OAAL,GAAeP,OAAQO,CAAAA,OAAvB;AAEE,UAAKC,CAAAA,SAAL,GAD+B,SAAjC,KAAI,MAAOR,QAAQQ,CAAAA,SAAnB,GACmBR,OAAQQ,CAAAA,SAAR,GAAoB,IAApB,GAA2B,KAD9C,GAGmBR,OAAQQ,CAAAA,SAFzB;AAIF,UAAKC,CAAAA,UAAL,GAAkBT,OAAQS,CAAAA,UAA1B;AACA,UAAKC,CAAAA,aAAL,GAAqBV,OAAQU,CAAAA,aAA7B;AACA,UAAKC,CAAAA,cAAL,GAAsBX,OAAQW,CAAAA,cAA9B;AACA,UAAKC,CAAAA,WAAL,CAAiB,UAAjB,EAA6B,CAA7B,EAAgC,CAAhC,CAAA;AArBmB;AA8BrBC,SAAK,CAACC,aAAD,EAAgBC,KAAhB,EAAuBC,MAAvB,EAA+BC,SAA/B,CAA0C;AAC7CH,mBAAcI,CAAAA,WAAd,CAA0B,IAA1B,EAAgCH,KAAhC,EAAuCC,MAAvC,EAA+CC,SAA/C,CAAA;AAD6C;AAO3C,iBAAY,EAAA;AACd,aAAO,IAAKb,CAAAA,MAAOE,CAAAA,SAAnB;AADc;AAIZ,iBAAS,CAACa,KAAD,CAAQ;AACnB,UAAKf,CAAAA,MAAOE,CAAAA,SAAZ,GAAwBa,KAAxB;AADmB;AAQdC,eAAI,CAACpB,OAAD,CAAU;AACnB,YAAM,CAAEqB,GAAF,EAAOC,EAAP,EAAW,GAAGC,IAAd,CAAA,GAAuBvB,OAA7B;AACA,UAAIwB,UAAJ,EACIC,SADJ;AAEIJ,SAAJ,KACEG,UADF,GACe5B,UAAWA,CAAAA,UAAWwB,CAAAA,IAAtB,CAA2BC,GAA3B,CADf;AAGIC,QAAJ,KACEG,SADF,GACc9B,SAAUA,CAAAA,SAAUyB,CAAAA,IAApB,CAAyBE,EAAzB,CADd;AAGA,aAAO,IAAIrB,2DAAJ,CAAY,CACjBuB,UADiB,EAEjBC,SAFiB,EAGjB,GAAGF,IAHc,CAAZ,CAAP;AAVmB;AArDP,GAAA;AAAVtB,SAAAA,GAAU,2DAAVA;AA0ENA,SAAQC,CAAAA,cAAR,GAAyB,CACvBI,UAAW,QADY,EAEvBG,WAAY,CAFW,EAGvBF,QAAS,CAHc,EAIvBC,UAAW,KAJY,EAKvBE,cAAe,CAAA,CALQ,EAMvBC,eAAgB,CAAA,CANO,CAAzB;AAUAjB,SAAQgC,CAAAA,MAAR,GAFazB,OAEb;AA7F+G,CAA/G;;",
"sources":["node_modules/pixi_DOT_js/lib/filters/Filter.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$pixi_DOT_js$lib$filters$Filter\"] = function(global,require,module,exports) {\n'use strict';\n\nvar GlProgram = require('../rendering/renderers/gl/shader/GlProgram.js');\nvar GpuProgram = require('../rendering/renderers/gpu/shader/GpuProgram.js');\nvar Shader = require('../rendering/renderers/shared/shader/Shader.js');\nvar State = require('../rendering/renderers/shared/state/State.js');\n\n\"use strict\";\nconst _Filter = class _Filter extends Shader.Shader {\n  /**\n   * @param options - The optional parameters of this filter.\n   */\n  constructor(options) {\n    options = { ..._Filter.defaultOptions, ...options };\n    super(options);\n    /** If enabled is true the filter is applied, if false it will not. */\n    this.enabled = true;\n    /**\n     * The gpu state the filter requires to render.\n     * @internal\n     * @ignore\n     */\n    this._state = State.State.for2d();\n    this.blendMode = options.blendMode;\n    this.padding = options.padding;\n    if (typeof options.antialias === \"boolean\") {\n      this.antialias = options.antialias ? \"on\" : \"off\";\n    } else {\n      this.antialias = options.antialias;\n    }\n    this.resolution = options.resolution;\n    this.blendRequired = options.blendRequired;\n    this.clipToViewport = options.clipToViewport;\n    this.addResource(\"uTexture\", 0, 1);\n  }\n  /**\n   * Applies the filter\n   * @param filterManager - The renderer to retrieve the filter from\n   * @param input - The input render target.\n   * @param output - The target to output to.\n   * @param clearMode - Should the output be cleared before rendering to it\n   */\n  apply(filterManager, input, output, clearMode) {\n    filterManager.applyFilter(this, input, output, clearMode);\n  }\n  /**\n   * Get the blend mode of the filter.\n   * @default \"normal\"\n   */\n  get blendMode() {\n    return this._state.blendMode;\n  }\n  /** Sets the blend mode of the filter. */\n  set blendMode(value) {\n    this._state.blendMode = value;\n  }\n  /**\n   * A short hand function to create a filter based of a vertex and fragment shader src.\n   * @param options\n   * @returns A shiny new PixiJS filter!\n   */\n  static from(options) {\n    const { gpu, gl, ...rest } = options;\n    let gpuProgram;\n    let glProgram;\n    if (gpu) {\n      gpuProgram = GpuProgram.GpuProgram.from(gpu);\n    }\n    if (gl) {\n      glProgram = GlProgram.GlProgram.from(gl);\n    }\n    return new _Filter({\n      gpuProgram,\n      glProgram,\n      ...rest\n    });\n  }\n};\n/**\n * The default filter settings\n * @static\n */\n_Filter.defaultOptions = {\n  blendMode: \"normal\",\n  resolution: 1,\n  padding: 0,\n  antialias: \"off\",\n  blendRequired: false,\n  clipToViewport: true\n};\nlet Filter = _Filter;\n\nexports.Filter = Filter;\n//# sourceMappingURL=Filter.js.map\n\n};"],
"names":["shadow$provide","global","require","module","exports","GlProgram","GpuProgram","Shader","State","constructor","options","_Filter","defaultOptions","enabled","_state","for2d","blendMode","padding","antialias","resolution","blendRequired","clipToViewport","addResource","apply","filterManager","input","output","clearMode","applyFilter","value","from","gpu","gl","rest","gpuProgram","glProgram","Filter"]
}
