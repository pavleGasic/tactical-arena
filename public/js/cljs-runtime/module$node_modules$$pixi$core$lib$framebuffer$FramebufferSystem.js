shadow$provide.module$node_modules$$pixi$core$lib$framebuffer$FramebufferSystem = function(global, require, module, exports) {
  var constants = require("module$node_modules$$pixi$constants$lib$index");
  global = require("module$node_modules$$pixi$extensions$lib$index");
  var math = require("module$node_modules$$pixi$math$lib$index"), settings = require("module$node_modules$$pixi$settings$lib$index"), Framebuffer = require("module$node_modules$$pixi$core$lib$framebuffer$Framebuffer"), GLFramebuffer = require("module$node_modules$$pixi$core$lib$framebuffer$GLFramebuffer");
  const tempRectangle = new math.Rectangle();
  class FramebufferSystem {
    constructor(renderer) {
      this.renderer = renderer;
      this.managedFramebuffers = [];
      this.unknownFramebuffer = new Framebuffer.Framebuffer(10, 10);
      this.msaaSamples = null;
    }
    contextChange() {
      this.disposeAll(!0);
      const gl = this.gl = this.renderer.gl;
      if (this.CONTEXT_UID = this.renderer.CONTEXT_UID, this.current = this.unknownFramebuffer, this.viewport = new math.Rectangle(), this.hasMRT = !0, this.writeDepthTexture = !0, 1 === this.renderer.context.webGLVersion) {
        let nativeDrawBuffersExtension = this.renderer.context.extensions.drawBuffers, nativeDepthTextureExtension = this.renderer.context.extensions.depthTexture;
        settings.settings.PREFER_ENV === constants.ENV.WEBGL_LEGACY && (nativeDrawBuffersExtension = null, nativeDepthTextureExtension = null);
        nativeDrawBuffersExtension ? gl.drawBuffers = activeTextures => nativeDrawBuffersExtension.drawBuffersWEBGL(activeTextures) : (this.hasMRT = !1, gl.drawBuffers = () => {
        });
        nativeDepthTextureExtension || (this.writeDepthTexture = !1);
      } else {
        this.msaaSamples = gl.getInternalformatParameter(gl.RENDERBUFFER, gl.RGBA8, gl.SAMPLES);
      }
    }
    bind(framebuffer, frame, mipLevel = 0) {
      var {gl} = this;
      if (framebuffer) {
        var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(framebuffer);
        this.current !== framebuffer && (this.current = framebuffer, gl.bindFramebuffer(gl.FRAMEBUFFER, fbo.framebuffer));
        fbo.mipLevel !== mipLevel && (framebuffer.dirtyId++, framebuffer.dirtyFormat++, fbo.mipLevel = mipLevel);
        fbo.dirtyId !== framebuffer.dirtyId && (fbo.dirtyId = framebuffer.dirtyId, fbo.dirtyFormat !== framebuffer.dirtyFormat ? (fbo.dirtyFormat = framebuffer.dirtyFormat, fbo.dirtySize = framebuffer.dirtySize, this.updateFramebuffer(framebuffer, mipLevel)) : fbo.dirtySize !== framebuffer.dirtySize && (fbo.dirtySize = framebuffer.dirtySize, this.resizeFramebuffer(framebuffer)));
        for (gl = 0; gl < framebuffer.colorTextures.length; gl++) {
          fbo = framebuffer.colorTextures[gl], this.renderer.texture.unbind(fbo.parentTextureArray || fbo);
        }
        (framebuffer.depthTexture && this.renderer.texture.unbind(framebuffer.depthTexture), frame) ? (framebuffer = frame.width >> mipLevel, gl = framebuffer / frame.width, this.setViewport(frame.x * gl, frame.y * gl, framebuffer, frame.height >> mipLevel)) : this.setViewport(0, 0, framebuffer.width >> mipLevel, framebuffer.height >> mipLevel);
      } else {
        this.current && (this.current = null, gl.bindFramebuffer(gl.FRAMEBUFFER, null)), frame ? this.setViewport(frame.x, frame.y, frame.width, frame.height) : this.setViewport(0, 0, this.renderer.width, this.renderer.height);
      }
    }
    setViewport(x, y, width, height) {
      const v = this.viewport;
      x = Math.round(x);
      y = Math.round(y);
      width = Math.round(width);
      height = Math.round(height);
      v.width === width && v.height === height && v.x === x && v.y === y || (v.x = x, v.y = y, v.width = width, v.height = height, this.gl.viewport(x, y, width, height));
    }
    get size() {
      return this.current ? {x:0, y:0, width:this.current.width, height:this.current.height} : {x:0, y:0, width:this.renderer.width, height:this.renderer.height};
    }
    clear(r, g, b, a, mask = constants.BUFFER_BITS.COLOR | constants.BUFFER_BITS.DEPTH) {
      const {gl} = this;
      gl.clearColor(r, g, b, a);
      gl.clear(mask);
    }
    initFramebuffer(framebuffer) {
      var {gl} = this;
      gl = new GLFramebuffer.GLFramebuffer(gl.createFramebuffer());
      return gl.multisample = this.detectSamples(framebuffer.multisample), framebuffer.glFramebuffers[this.CONTEXT_UID] = gl, this.managedFramebuffers.push(framebuffer), framebuffer.disposeRunner.add(this), gl;
    }
    resizeFramebuffer(framebuffer) {
      const {gl} = this, fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
      if (fbo.stencil) {
        gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.stencil);
        var stencilFormat;
        1 === this.renderer.context.webGLVersion ? stencilFormat = gl.DEPTH_STENCIL : framebuffer.depth && framebuffer.stencil ? stencilFormat = gl.DEPTH24_STENCIL8 : framebuffer.depth ? stencilFormat = gl.DEPTH_COMPONENT24 : stencilFormat = gl.STENCIL_INDEX8;
        fbo.msaaBuffer ? gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, stencilFormat, framebuffer.width, framebuffer.height) : gl.renderbufferStorage(gl.RENDERBUFFER, stencilFormat, framebuffer.width, framebuffer.height);
      }
      stencilFormat = framebuffer.colorTextures;
      let count = stencilFormat.length;
      gl.drawBuffers || (count = Math.min(count, 1));
      for (let i = 0; i < count; i++) {
        var texture = stencilFormat[i];
        texture = texture.parentTextureArray || texture;
        this.renderer.texture.bind(texture, 0);
        0 === i && fbo.msaaBuffer && (gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.msaaBuffer), gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, texture._glTextures[this.CONTEXT_UID].internalFormat, framebuffer.width, framebuffer.height));
      }
      framebuffer.depthTexture && this.writeDepthTexture && this.renderer.texture.bind(framebuffer.depthTexture, 0);
    }
    updateFramebuffer(framebuffer, mipLevel) {
      const {gl} = this, fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
      var colorTextures = framebuffer.colorTextures;
      let count = colorTextures.length;
      gl.drawBuffers || (count = Math.min(count, 1));
      1 < fbo.multisample && this.canMultisampleFramebuffer(framebuffer) ? fbo.msaaBuffer = fbo.msaaBuffer || gl.createRenderbuffer() : fbo.msaaBuffer && (gl.deleteRenderbuffer(fbo.msaaBuffer), fbo.msaaBuffer = null, fbo.blitFramebuffer && (fbo.blitFramebuffer.dispose(), fbo.blitFramebuffer = null));
      const activeTextures = [];
      for (let i = 0; i < count; i++) {
        const texture = colorTextures[i], parentTexture = texture.parentTextureArray || texture;
        this.renderer.texture.bind(parentTexture, 0);
        0 === i && fbo.msaaBuffer ? (gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.msaaBuffer), gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, parentTexture._glTextures[this.CONTEXT_UID].internalFormat, framebuffer.width, framebuffer.height), gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, fbo.msaaBuffer)) : (gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, texture.target, parentTexture._glTextures[this.CONTEXT_UID].texture, mipLevel), 
        activeTextures.push(gl.COLOR_ATTACHMENT0 + i));
      }
      if (1 < activeTextures.length && gl.drawBuffers(activeTextures), framebuffer.depthTexture && this.writeDepthTexture) {
        colorTextures = framebuffer.depthTexture, this.renderer.texture.bind(colorTextures, 0), gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, colorTextures._glTextures[this.CONTEXT_UID].texture, mipLevel);
      }
      if (!framebuffer.stencil && !framebuffer.depth || framebuffer.depthTexture && this.writeDepthTexture) {
        fbo.stencil && (gl.deleteRenderbuffer(fbo.stencil), fbo.stencil = null);
      } else {
        fbo.stencil = fbo.stencil || gl.createRenderbuffer();
        let stencilAttachment, stencilFormat;
        1 === this.renderer.context.webGLVersion ? (stencilAttachment = gl.DEPTH_STENCIL_ATTACHMENT, stencilFormat = gl.DEPTH_STENCIL) : framebuffer.depth && framebuffer.stencil ? (stencilAttachment = gl.DEPTH_STENCIL_ATTACHMENT, stencilFormat = gl.DEPTH24_STENCIL8) : framebuffer.depth ? (stencilAttachment = gl.DEPTH_ATTACHMENT, stencilFormat = gl.DEPTH_COMPONENT24) : (stencilAttachment = gl.STENCIL_ATTACHMENT, stencilFormat = gl.STENCIL_INDEX8);
        gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.stencil);
        fbo.msaaBuffer ? gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, stencilFormat, framebuffer.width, framebuffer.height) : gl.renderbufferStorage(gl.RENDERBUFFER, stencilFormat, framebuffer.width, framebuffer.height);
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, stencilAttachment, gl.RENDERBUFFER, fbo.stencil);
      }
    }
    canMultisampleFramebuffer(framebuffer) {
      return 1 !== this.renderer.context.webGLVersion && 1 >= framebuffer.colorTextures.length && !framebuffer.depthTexture;
    }
    detectSamples(samples) {
      const {msaaSamples} = this;
      let res = constants.MSAA_QUALITY.NONE;
      if (1 >= samples || null === msaaSamples) {
        return res;
      }
      for (let i = 0; i < msaaSamples.length; i++) {
        if (msaaSamples[i] <= samples) {
          res = msaaSamples[i];
          break;
        }
      }
      return 1 === res && (res = constants.MSAA_QUALITY.NONE), res;
    }
    blit(framebuffer, sourcePixels, destPixels) {
      const {current, renderer, gl, CONTEXT_UID} = this;
      if (2 === renderer.context.webGLVersion && current) {
        var fbo = current.glFramebuffers[CONTEXT_UID];
        if (fbo) {
          if (!framebuffer) {
            if (!fbo.msaaBuffer) {
              return;
            }
            var colorTexture = current.colorTextures[0];
            if (!colorTexture) {
              return;
            }
            fbo.blitFramebuffer || (fbo.blitFramebuffer = new Framebuffer.Framebuffer(current.width, current.height), fbo.blitFramebuffer.addColorTexture(0, colorTexture));
            framebuffer = fbo.blitFramebuffer;
            framebuffer.colorTextures[0] !== colorTexture && (framebuffer.colorTextures[0] = colorTexture, framebuffer.dirtyId++, framebuffer.dirtyFormat++);
            framebuffer.width === current.width && framebuffer.height === current.height || (framebuffer.width = current.width, framebuffer.height = current.height, framebuffer.dirtyId++, framebuffer.dirtySize++);
          }
          sourcePixels || (sourcePixels = tempRectangle, sourcePixels.width = current.width, sourcePixels.height = current.height);
          destPixels || (destPixels = sourcePixels);
          colorTexture = sourcePixels.width === destPixels.width && sourcePixels.height === destPixels.height;
          this.bind(framebuffer);
          gl.bindFramebuffer(gl.READ_FRAMEBUFFER, fbo.framebuffer);
          gl.blitFramebuffer(sourcePixels.left, sourcePixels.top, sourcePixels.right, sourcePixels.bottom, destPixels.left, destPixels.top, destPixels.right, destPixels.bottom, gl.COLOR_BUFFER_BIT, colorTexture ? gl.NEAREST : gl.LINEAR);
          gl.bindFramebuffer(gl.READ_FRAMEBUFFER, framebuffer.glFramebuffers[this.CONTEXT_UID].framebuffer);
        }
      }
    }
    disposeFramebuffer(framebuffer, contextLost) {
      const fbo = framebuffer.glFramebuffers[this.CONTEXT_UID], gl = this.gl;
      if (fbo) {
        delete framebuffer.glFramebuffers[this.CONTEXT_UID];
        var index = this.managedFramebuffers.indexOf(framebuffer);
        0 <= index && this.managedFramebuffers.splice(index, 1);
        framebuffer.disposeRunner.remove(this);
        contextLost || (gl.deleteFramebuffer(fbo.framebuffer), fbo.msaaBuffer && gl.deleteRenderbuffer(fbo.msaaBuffer), fbo.stencil && gl.deleteRenderbuffer(fbo.stencil));
        fbo.blitFramebuffer && this.disposeFramebuffer(fbo.blitFramebuffer, contextLost);
      }
    }
    disposeAll(contextLost) {
      const list = this.managedFramebuffers;
      this.managedFramebuffers = [];
      for (let i = 0; i < list.length; i++) {
        this.disposeFramebuffer(list[i], contextLost);
      }
    }
    forceStencil() {
      const framebuffer = this.current;
      if (framebuffer) {
        var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
        if (!(!fbo || fbo.stencil && framebuffer.stencil)) {
          framebuffer.stencil = !0;
          var w = framebuffer.width, h = framebuffer.height, gl = this.gl, stencil = fbo.stencil = gl.createRenderbuffer();
          gl.bindRenderbuffer(gl.RENDERBUFFER, stencil);
          var stencilAttachment, stencilFormat;
          1 === this.renderer.context.webGLVersion ? (stencilAttachment = gl.DEPTH_STENCIL_ATTACHMENT, stencilFormat = gl.DEPTH_STENCIL) : framebuffer.depth ? (stencilAttachment = gl.DEPTH_STENCIL_ATTACHMENT, stencilFormat = gl.DEPTH24_STENCIL8) : (stencilAttachment = gl.STENCIL_ATTACHMENT, stencilFormat = gl.STENCIL_INDEX8);
          fbo.msaaBuffer ? gl.renderbufferStorageMultisample(gl.RENDERBUFFER, fbo.multisample, stencilFormat, w, h) : gl.renderbufferStorage(gl.RENDERBUFFER, stencilFormat, w, h);
          gl.framebufferRenderbuffer(gl.FRAMEBUFFER, stencilAttachment, gl.RENDERBUFFER, stencil);
        }
      }
    }
    reset() {
      this.current = this.unknownFramebuffer;
      this.viewport = new math.Rectangle();
    }
    destroy() {
      this.renderer = null;
    }
  }
  FramebufferSystem.extension = {type:global.ExtensionType.RendererSystem, name:"framebuffer"};
  global.extensions.add(FramebufferSystem);
  exports.FramebufferSystem = FramebufferSystem;
};

//# sourceMappingURL=module$node_modules$$pixi$core$lib$framebuffer$FramebufferSystem.js.map
