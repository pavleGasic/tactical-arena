{
"version":3,
"file":"module$node_modules$pixi_DOT_js$lib$spritesheet$Spritesheet.js",
"lineCount":78,
"mappings":"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",
"sources":["node_modules/pixi_DOT_js/lib/spritesheet/Spritesheet.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$pixi_DOT_js$lib$spritesheet$Spritesheet\"] = function(global,require,module,exports) {\n'use strict';\n\nvar Rectangle = require('../maths/shapes/Rectangle.js');\nvar Texture = require('../rendering/renderers/shared/texture/Texture.js');\n\n\"use strict\";\nconst _Spritesheet = class _Spritesheet {\n  /**\n   * @param texture - Reference to the source BaseTexture object.\n   * @param {object} data - Spritesheet image data.\n   */\n  constructor(texture, data) {\n    /** For multi-packed spritesheets, this contains a reference to all the other spritesheets it depends on. */\n    this.linkedSheets = [];\n    this._texture = texture instanceof Texture.Texture ? texture : null;\n    this.textureSource = texture.source;\n    this.textures = {};\n    this.animations = {};\n    this.data = data;\n    const metaResolution = parseFloat(data.meta.scale);\n    if (metaResolution) {\n      this.resolution = metaResolution;\n      texture.source.resolution = this.resolution;\n    } else {\n      this.resolution = texture.source._resolution;\n    }\n    this._frames = this.data.frames;\n    this._frameKeys = Object.keys(this._frames);\n    this._batchIndex = 0;\n    this._callback = null;\n  }\n  /**\n   * Parser spritesheet from loaded data. This is done asynchronously\n   * to prevent creating too many Texture within a single process.\n   */\n  parse() {\n    return new Promise((resolve) => {\n      this._callback = resolve;\n      this._batchIndex = 0;\n      if (this._frameKeys.length <= _Spritesheet.BATCH_SIZE) {\n        this._processFrames(0);\n        this._processAnimations();\n        this._parseComplete();\n      } else {\n        this._nextBatch();\n      }\n    });\n  }\n  /**\n   * Process a batch of frames\n   * @param initialFrameIndex - The index of frame to start.\n   */\n  _processFrames(initialFrameIndex) {\n    let frameIndex = initialFrameIndex;\n    const maxFrames = _Spritesheet.BATCH_SIZE;\n    while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length) {\n      const i = this._frameKeys[frameIndex];\n      const data = this._frames[i];\n      const rect = data.frame;\n      if (rect) {\n        let frame = null;\n        let trim = null;\n        const sourceSize = data.trimmed !== false && data.sourceSize ? data.sourceSize : data.frame;\n        const orig = new Rectangle.Rectangle(\n          0,\n          0,\n          Math.floor(sourceSize.w) / this.resolution,\n          Math.floor(sourceSize.h) / this.resolution\n        );\n        if (data.rotated) {\n          frame = new Rectangle.Rectangle(\n            Math.floor(rect.x) / this.resolution,\n            Math.floor(rect.y) / this.resolution,\n            Math.floor(rect.h) / this.resolution,\n            Math.floor(rect.w) / this.resolution\n          );\n        } else {\n          frame = new Rectangle.Rectangle(\n            Math.floor(rect.x) / this.resolution,\n            Math.floor(rect.y) / this.resolution,\n            Math.floor(rect.w) / this.resolution,\n            Math.floor(rect.h) / this.resolution\n          );\n        }\n        if (data.trimmed !== false && data.spriteSourceSize) {\n          trim = new Rectangle.Rectangle(\n            Math.floor(data.spriteSourceSize.x) / this.resolution,\n            Math.floor(data.spriteSourceSize.y) / this.resolution,\n            Math.floor(rect.w) / this.resolution,\n            Math.floor(rect.h) / this.resolution\n          );\n        }\n        this.textures[i] = new Texture.Texture({\n          source: this.textureSource,\n          frame,\n          orig,\n          trim,\n          rotate: data.rotated ? 2 : 0,\n          defaultAnchor: data.anchor,\n          defaultBorders: data.borders,\n          label: i.toString()\n        });\n      }\n      frameIndex++;\n    }\n  }\n  /** Parse animations config. */\n  _processAnimations() {\n    const animations = this.data.animations || {};\n    for (const animName in animations) {\n      this.animations[animName] = [];\n      for (let i = 0; i < animations[animName].length; i++) {\n        const frameName = animations[animName][i];\n        this.animations[animName].push(this.textures[frameName]);\n      }\n    }\n  }\n  /** The parse has completed. */\n  _parseComplete() {\n    const callback = this._callback;\n    this._callback = null;\n    this._batchIndex = 0;\n    callback.call(this, this.textures);\n  }\n  /** Begin the next batch of textures. */\n  _nextBatch() {\n    this._processFrames(this._batchIndex * _Spritesheet.BATCH_SIZE);\n    this._batchIndex++;\n    setTimeout(() => {\n      if (this._batchIndex * _Spritesheet.BATCH_SIZE < this._frameKeys.length) {\n        this._nextBatch();\n      } else {\n        this._processAnimations();\n        this._parseComplete();\n      }\n    }, 0);\n  }\n  /**\n   * Destroy Spritesheet and don't use after this.\n   * @param {boolean} [destroyBase=false] - Whether to destroy the base texture as well\n   */\n  destroy(destroyBase = false) {\n    for (const i in this.textures) {\n      this.textures[i].destroy();\n    }\n    this._frames = null;\n    this._frameKeys = null;\n    this.data = null;\n    this.textures = null;\n    if (destroyBase) {\n      this._texture?.destroy();\n      this.textureSource.destroy();\n    }\n    this._texture = null;\n    this.textureSource = null;\n    this.linkedSheets = [];\n  }\n};\n/** The maximum number of Textures to build per process. */\n_Spritesheet.BATCH_SIZE = 1e3;\nlet Spritesheet = _Spritesheet;\n\nexports.Spritesheet = Spritesheet;\n//# sourceMappingURL=Spritesheet.js.map\n\n};"],
"names":["shadow$provide","global","require","module","exports","Rectangle","Texture","constructor","texture","data","linkedSheets","_texture","textureSource","source","textures","animations","metaResolution","parseFloat","meta","scale","resolution","_resolution","_frames","frames","_frameKeys","Object","keys","_batchIndex","_callback","parse","Promise","resolve","length","_Spritesheet","BATCH_SIZE","_processFrames","_processAnimations","_parseComplete","_nextBatch","initialFrameIndex","frameIndex","maxFrames","i","rect","frame","trim","sourceSize","trimmed","orig","Math","floor","w","h","rotated","x","y","spriteSourceSize","rotate","defaultAnchor","anchor","defaultBorders","borders","label","toString","animName","push","frameName","callback","call","setTimeout","destroy","destroyBase","Spritesheet"]
}
