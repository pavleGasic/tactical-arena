shadow$provide.module$node_modules$$pixi$display$lib$Container = function(global, require, module, exports) {
  function sortChildren(a, b) {
    return a.zIndex === b.zIndex ? a._lastSortedIndex - b._lastSortedIndex : a.zIndex - b.zIndex;
  }
  var core = require("module$node_modules$$pixi$core$lib$index");
  global = require("module$node_modules$$pixi$display$lib$DisplayObject");
  const tempMatrix = new core.Matrix(), node_modules$$pixi$display$lib$Container$classdecl$var13 = class extends global.DisplayObject {
    constructor() {
      super();
      this.children = [];
      this.sortableChildren = node_modules$$pixi$display$lib$Container$classdecl$var13.defaultSortableChildren;
      this.sortDirty = !1;
    }
    onChildrenChange(_length) {
    }
    addChild(...children) {
      if (1 < children.length) {
        for (var i = 0; i < children.length; i++) {
          this.addChild(children[i]);
        }
      } else {
        i = children[0], i.parent && i.parent.removeChild(i), i.parent = this, this.sortDirty = !0, i.transform._parentID = -1, this.children.push(i), this._boundsID++, this.onChildrenChange(this.children.length - 1), this.emit("childAdded", i, this, this.children.length - 1), i.emit("added", this);
      }
      return children[0];
    }
    addChildAt(child, index) {
      if (0 > index || index > this.children.length) {
        throw Error(`${child}addChildAt: The index ${index} supplied is out of bounds ${this.children.length}`);
      }
      return child.parent && child.parent.removeChild(child), child.parent = this, this.sortDirty = !0, child.transform._parentID = -1, this.children.splice(index, 0, child), this._boundsID++, this.onChildrenChange(index), child.emit("added", this), this.emit("childAdded", child, this, index), child;
    }
    swapChildren(child, child2) {
      if (child !== child2) {
        var index1 = this.getChildIndex(child), index2 = this.getChildIndex(child2);
        this.children[index1] = child2;
        this.children[index2] = child;
        this.onChildrenChange(index1 < index2 ? index1 : index2);
      }
    }
    getChildIndex(child) {
      child = this.children.indexOf(child);
      if (-1 === child) {
        throw Error("The supplied DisplayObject must be a child of the caller");
      }
      return child;
    }
    setChildIndex(child, index) {
      if (0 > index || index >= this.children.length) {
        throw Error(`The index ${index} supplied is out of bounds ${this.children.length}`);
      }
      const currentIndex = this.getChildIndex(child);
      core.utils.removeItems(this.children, currentIndex, 1);
      this.children.splice(index, 0, child);
      this.onChildrenChange(index);
    }
    getChildAt(index) {
      if (0 > index || index >= this.children.length) {
        throw Error(`getChildAt: Index (${index}) does not exist.`);
      }
      return this.children[index];
    }
    removeChild(...children) {
      if (1 < children.length) {
        for (var i = 0; i < children.length; i++) {
          this.removeChild(children[i]);
        }
      } else {
        i = children[0];
        const index = this.children.indexOf(i);
        if (-1 === index) {
          return null;
        }
        i.parent = null;
        i.transform._parentID = -1;
        core.utils.removeItems(this.children, index, 1);
        this._boundsID++;
        this.onChildrenChange(index);
        i.emit("removed", this);
        this.emit("childRemoved", i, this, index);
      }
      return children[0];
    }
    removeChildAt(index) {
      const child = this.getChildAt(index);
      return child.parent = null, child.transform._parentID = -1, core.utils.removeItems(this.children, index, 1), this._boundsID++, this.onChildrenChange(index), child.emit("removed", this), this.emit("childRemoved", child, this, index), child;
    }
    removeChildren(beginIndex = 0, endIndex = this.children.length) {
      var range = endIndex - beginIndex;
      if (0 < range && range <= endIndex) {
        endIndex = this.children.splice(beginIndex, range);
        for (range = 0; range < endIndex.length; ++range) {
          endIndex[range].parent = null, endIndex[range].transform && (endIndex[range].transform._parentID = -1);
        }
        this._boundsID++;
        this.onChildrenChange(beginIndex);
        for (beginIndex = 0; beginIndex < endIndex.length; ++beginIndex) {
          endIndex[beginIndex].emit("removed", this), this.emit("childRemoved", endIndex[beginIndex], this, beginIndex);
        }
        return endIndex;
      }
      if (0 === range && 0 === this.children.length) {
        return [];
      }
      throw new RangeError("removeChildren: numeric values are outside the acceptable range.");
    }
    sortChildren() {
      let sortRequired = !1;
      for (let i = 0, j = this.children.length; i < j; ++i) {
        const child = this.children[i];
        child._lastSortedIndex = i;
        !sortRequired && 0 !== child.zIndex && (sortRequired = !0);
      }
      sortRequired && 1 < this.children.length && this.children.sort(sortChildren);
      this.sortDirty = !1;
    }
    updateTransform() {
      this.sortableChildren && this.sortDirty && this.sortChildren();
      this._boundsID++;
      this.transform.updateTransform(this.parent.transform);
      this.worldAlpha = this.alpha * this.parent.worldAlpha;
      for (let i = 0, j = this.children.length; i < j; ++i) {
        const child = this.children[i];
        child.visible && child.updateTransform();
      }
    }
    calculateBounds() {
      this._bounds.clear();
      this._calculateBounds();
      for (let i = 0; i < this.children.length; i++) {
        const child = this.children[i];
        if (child.visible && child.renderable) {
          if (child.calculateBounds(), child._mask) {
            const maskObject = child._mask.isMaskData ? child._mask.maskObject : child._mask;
            maskObject ? (maskObject.calculateBounds(), this._bounds.addBoundsMask(child._bounds, maskObject._bounds)) : this._bounds.addBounds(child._bounds);
          } else {
            child.filterArea ? this._bounds.addBoundsArea(child._bounds, child.filterArea) : this._bounds.addBounds(child._bounds);
          }
        }
      }
      this._bounds.updateID = this._boundsID;
    }
    getLocalBounds(rect, skipChildrenUpdate = !1) {
      rect = super.getLocalBounds(rect);
      if (!skipChildrenUpdate) {
        for (let i = 0, j = this.children.length; i < j; ++i) {
          skipChildrenUpdate = this.children[i], skipChildrenUpdate.visible && skipChildrenUpdate.updateTransform();
        }
      }
      return rect;
    }
    _calculateBounds() {
    }
    _renderWithCulling(renderer) {
      var sourceFrame = renderer.renderTexture.sourceFrame;
      if (0 < sourceFrame.width && 0 < sourceFrame.height) {
        var bounds, transform;
        this.cullArea ? (bounds = this.cullArea, transform = this.worldTransform) : this._render !== node_modules$$pixi$display$lib$Container$classdecl$var13.prototype._render && (bounds = this.getBounds(!0));
        var projectionTransform = renderer.projection.transform;
        if (projectionTransform && (transform ? (transform = tempMatrix.copyFrom(transform), transform.prepend(projectionTransform)) : transform = projectionTransform), bounds && sourceFrame.intersects(bounds, transform)) {
          this._render(renderer);
        } else if (this.cullArea) {
          return;
        }
        for (let i = 0, j = this.children.length; i < j; ++i) {
          sourceFrame = this.children[i], bounds = sourceFrame.cullable, sourceFrame.cullable = bounds || !this.cullArea, sourceFrame.render(renderer), sourceFrame.cullable = bounds;
        }
      }
    }
    render(renderer) {
      if (this.visible && !(0 >= this.worldAlpha) && this.renderable) {
        if (this._mask || this.filters?.length) {
          this.renderAdvanced(renderer);
        } else if (this.cullable) {
          this._renderWithCulling(renderer);
        } else {
          this._render(renderer);
          for (let i = 0, j = this.children.length; i < j; ++i) {
            this.children[i].render(renderer);
          }
        }
      }
    }
    renderAdvanced(renderer) {
      const filters = this.filters, mask = this._mask;
      if (filters) {
        this._enabledFilters || (this._enabledFilters = []);
        this._enabledFilters.length = 0;
        for (var i = 0; i < filters.length; i++) {
          filters[i].enabled && this._enabledFilters.push(filters[i]);
        }
      }
      i = filters && this._enabledFilters?.length || mask && (!mask.isMaskData || mask.enabled && (mask.autoDetect || mask.type !== core.MASK_TYPES.NONE));
      if (i && renderer.batch.flush(), filters && this._enabledFilters?.length && renderer.filter.push(this, this._enabledFilters), mask && renderer.mask.push(this, this._mask), this.cullable) {
        this._renderWithCulling(renderer);
      } else {
        this._render(renderer);
        for (let i = 0, j = this.children.length; i < j; ++i) {
          this.children[i].render(renderer);
        }
      }
      i && renderer.batch.flush();
      mask && renderer.mask.pop(this);
      filters && this._enabledFilters?.length && renderer.filter.pop();
    }
    _render(_renderer) {
    }
    destroy(options) {
      super.destroy();
      this.sortDirty = !1;
      var destroyChildren = "boolean" == typeof options ? options : options?.children;
      const oldChildren = this.removeChildren(0, this.children.length);
      if (destroyChildren) {
        for (destroyChildren = 0; destroyChildren < oldChildren.length; ++destroyChildren) {
          oldChildren[destroyChildren].destroy(options);
        }
      }
    }
    get width() {
      return this.scale.x * this.getLocalBounds().width;
    }
    set width(value) {
      const width = this.getLocalBounds().width;
      0 !== width ? this.scale.x = value / width : this.scale.x = 1;
      this._width = value;
    }
    get height() {
      return this.scale.y * this.getLocalBounds().height;
    }
    set height(value) {
      const height = this.getLocalBounds().height;
      0 !== height ? this.scale.y = value / height : this.scale.y = 1;
      this._height = value;
    }
  };
  global = node_modules$$pixi$display$lib$Container$classdecl$var13;
  global.defaultSortableChildren = !1;
  global.prototype.containerUpdateTransform = global.prototype.updateTransform;
  exports.Container = global;
};

//# sourceMappingURL=module$node_modules$$pixi$display$lib$Container.js.map
