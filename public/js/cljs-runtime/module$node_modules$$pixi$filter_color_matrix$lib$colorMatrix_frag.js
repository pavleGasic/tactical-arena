shadow$provide.module$node_modules$$pixi$filter_color_matrix$lib$colorMatrix_frag = function(global, require, module, exports) {
  Object.defineProperty(exports, "__esModule", {value:!0});
  exports.default = "varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform float m[20];\nuniform float uAlpha;\n\nvoid main(void)\n{\n    vec4 c \x3d texture2D(uSampler, vTextureCoord);\n\n    if (uAlpha \x3d\x3d 0.0) {\n        gl_FragColor \x3d c;\n        return;\n    }\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (c.a \x3e 0.0) {\n      c.rgb /\x3d c.a;\n    }\n\n    vec4 result;\n\n    result.r \x3d (m[0] * c.r);\n        result.r +\x3d (m[1] * c.g);\n        result.r +\x3d (m[2] * c.b);\n        result.r +\x3d (m[3] * c.a);\n        result.r +\x3d m[4];\n\n    result.g \x3d (m[5] * c.r);\n        result.g +\x3d (m[6] * c.g);\n        result.g +\x3d (m[7] * c.b);\n        result.g +\x3d (m[8] * c.a);\n        result.g +\x3d m[9];\n\n    result.b \x3d (m[10] * c.r);\n       result.b +\x3d (m[11] * c.g);\n       result.b +\x3d (m[12] * c.b);\n       result.b +\x3d (m[13] * c.a);\n       result.b +\x3d m[14];\n\n    result.a \x3d (m[15] * c.r);\n       result.a +\x3d (m[16] * c.g);\n       result.a +\x3d (m[17] * c.b);\n       result.a +\x3d (m[18] * c.a);\n       result.a +\x3d m[19];\n\n    vec3 rgb \x3d mix(c.rgb, result.rgb, uAlpha);\n\n    // Premultiply alpha again.\n    rgb *\x3d result.a;\n\n    gl_FragColor \x3d vec4(rgb, result.a);\n}\n";
};

//# sourceMappingURL=module$node_modules$$pixi$filter_color_matrix$lib$colorMatrix_frag.js.map
