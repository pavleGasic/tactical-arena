shadow$provide.module$node_modules$pixi_DOT_js$lib$compressed_textures$ktx$parseKTX = function(global, require, module, exports) {
  var _const = require("module$node_modules$pixi_DOT_js$lib$compressed_textures$ktx2$const");
  "use strict";
  exports.parseKTX = function(arrayBuffer, supportedFormats) {
    arrayBuffer = new DataView(arrayBuffer);
    var JSCompiler_inline_result;
    a: {
      for (JSCompiler_inline_result = 0; JSCompiler_inline_result < _const.KTX.FILE_IDENTIFIER.length; JSCompiler_inline_result++) {
        if (arrayBuffer.getUint8(JSCompiler_inline_result) !== _const.KTX.FILE_IDENTIFIER[JSCompiler_inline_result]) {
          JSCompiler_inline_result = !1;
          break a;
        }
      }
      JSCompiler_inline_result = !0;
    }
    if (!JSCompiler_inline_result) {
      throw Error("Invalid KTX identifier in header");
    }
    JSCompiler_inline_result = arrayBuffer.getUint32(_const.KTX.FIELDS.ENDIANNESS, !0) === _const.KTX.ENDIANNESS;
    var glType = arrayBuffer.getUint32(_const.KTX.FIELDS.GL_TYPE, JSCompiler_inline_result), glFormat$jscomp$0 = arrayBuffer.getUint32(_const.KTX.FIELDS.GL_FORMAT, JSCompiler_inline_result), glInternalFormat = arrayBuffer.getUint32(_const.KTX.FIELDS.GL_INTERNAL_FORMAT, JSCompiler_inline_result), pixelWidth = arrayBuffer.getUint32(_const.KTX.FIELDS.PIXEL_WIDTH, JSCompiler_inline_result), pixelHeight = arrayBuffer.getUint32(_const.KTX.FIELDS.PIXEL_HEIGHT, JSCompiler_inline_result) || 1, pixelDepth = 
    arrayBuffer.getUint32(_const.KTX.FIELDS.PIXEL_DEPTH, JSCompiler_inline_result) || 1, numberOfArrayElements = arrayBuffer.getUint32(_const.KTX.FIELDS.NUMBER_OF_ARRAY_ELEMENTS, JSCompiler_inline_result) || 1;
    const numberOfFaces = arrayBuffer.getUint32(_const.KTX.FIELDS.NUMBER_OF_FACES, JSCompiler_inline_result), numberOfMipmapLevels$jscomp$0 = arrayBuffer.getUint32(_const.KTX.FIELDS.NUMBER_OF_MIPMAP_LEVELS, JSCompiler_inline_result), bytesOfKeyValueData = arrayBuffer.getUint32(_const.KTX.FIELDS.BYTES_OF_KEY_VALUE_DATA, JSCompiler_inline_result);
    if (0 === pixelHeight || 1 !== pixelDepth) {
      throw Error("Only 2D textures are supported");
    }
    if (1 !== numberOfFaces) {
      throw Error("CubeTextures are not supported by KTXLoader yet!");
    }
    if (1 !== numberOfArrayElements) {
      throw Error("WebGL does not support array textures");
    }
    const {littleEndian, glType:glType$jscomp$0, glFormat, glInternalFormat:glInternalFormat$jscomp$0, pixelWidth:pixelWidth$jscomp$0, pixelHeight:pixelHeight$jscomp$0, numberOfMipmapLevels, offset} = {littleEndian:JSCompiler_inline_result, glType, glFormat:glFormat$jscomp$0, glInternalFormat, pixelWidth, pixelHeight, numberOfMipmapLevels:numberOfMipmapLevels$jscomp$0, offset:_const.KTX.FILE_HEADER_SIZE + bytesOfKeyValueData};
    JSCompiler_inline_result = _const.KTX.INTERNAL_FORMAT_TO_TEXTURE_FORMATS[glInternalFormat$jscomp$0];
    if (!JSCompiler_inline_result) {
      throw Error(`Unknown texture format ${glInternalFormat$jscomp$0}`);
    }
    if (!supportedFormats.includes(JSCompiler_inline_result)) {
      throw Error(`Unsupported texture format: ${JSCompiler_inline_result}, supportedFormats: ${supportedFormats}`);
    }
    supportedFormats = _const.KTX.INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[glInternalFormat$jscomp$0];
    0 !== glType$jscomp$0 && (supportedFormats = _const.KTX.TYPES_TO_BYTES_PER_COMPONENT[glType$jscomp$0] ? _const.KTX.TYPES_TO_BYTES_PER_COMPONENT[glType$jscomp$0] * _const.KTX.FORMATS_TO_COMPONENTS[glFormat] : _const.KTX.TYPES_TO_BYTES_PER_PIXEL[glType$jscomp$0]);
    if (void 0 === supportedFormats) {
      throw Error("Unable to resolve the pixel format stored in the *.ktx file!");
    }
    glType = pixelWidth$jscomp$0 * pixelHeight$jscomp$0;
    0 === glType$jscomp$0 && (glType = (pixelWidth$jscomp$0 + 3 & -4) * (pixelHeight$jscomp$0 + 3 & -4));
    pixelDepth = glType * supportedFormats;
    glType = pixelWidth$jscomp$0;
    glFormat$jscomp$0 = pixelHeight$jscomp$0;
    glInternalFormat = offset;
    pixelWidth = Array(numberOfMipmapLevels);
    for (pixelHeight = 0; pixelHeight < numberOfMipmapLevels; pixelHeight++) {
      numberOfArrayElements = arrayBuffer.getUint32(glInternalFormat, littleEndian), pixelWidth[pixelHeight] = new Uint8Array(arrayBuffer.buffer, glInternalFormat + 4, pixelDepth), glInternalFormat += numberOfArrayElements + 4, glInternalFormat = 0 !== glInternalFormat % 4 ? glInternalFormat + 4 - glInternalFormat % 4 : glInternalFormat, glType = glType >> 1 || 1, glFormat$jscomp$0 = glFormat$jscomp$0 >> 1 || 1, pixelDepth = glType + 4 - 1 & -4, numberOfArrayElements = glFormat$jscomp$0 + 4 - 1 & 
      -4, pixelDepth = pixelDepth * numberOfArrayElements * supportedFormats;
    }
    return {format:JSCompiler_inline_result, width:pixelWidth$jscomp$0, height:pixelHeight$jscomp$0, resource:pixelWidth, alphaMode:"no-premultiply-alpha"};
  };
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$compressed_textures$ktx$parseKTX.js.map
