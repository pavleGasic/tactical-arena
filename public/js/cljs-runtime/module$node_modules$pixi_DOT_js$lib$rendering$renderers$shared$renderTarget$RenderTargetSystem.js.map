{
"version":3,
"file":"module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$renderTarget$RenderTargetSystem.js",
"lineCount":110,
"mappings":"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",
"sources":["node_modules/pixi_DOT_js/lib/rendering/renderers/shared/renderTarget/RenderTargetSystem.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$renderTarget$RenderTargetSystem\"] = function(global,require,module,exports) {\n'use strict';\n\nvar Matrix = require('../../../../maths/matrix/Matrix.js');\nvar Rectangle = require('../../../../maths/shapes/Rectangle.js');\nvar _const = require('../../gl/const.js');\nvar calculateProjection = require('../../gpu/renderTarget/calculateProjection.js');\nvar SystemRunner = require('../system/SystemRunner.js');\nvar CanvasSource = require('../texture/sources/CanvasSource.js');\nvar TextureSource = require('../texture/sources/TextureSource.js');\nvar Texture = require('../texture/Texture.js');\nvar getCanvasTexture = require('../texture/utils/getCanvasTexture.js');\nvar isRenderingToScreen = require('./isRenderingToScreen.js');\nvar RenderTarget = require('./RenderTarget.js');\n\n\"use strict\";\nclass RenderTargetSystem {\n  constructor(renderer) {\n    /** This is the root viewport for the render pass*/\n    this.rootViewPort = new Rectangle.Rectangle();\n    /** the current viewport that the gpu is using */\n    this.viewport = new Rectangle.Rectangle();\n    /**\n     * a runner that lets systems know if the active render target has changed.\n     * Eg the Stencil System needs to know so it can manage the stencil buffer\n     */\n    this.onRenderTargetChange = new SystemRunner.SystemRunner(\"onRenderTargetChange\");\n    /** the projection matrix that is used by the shaders based on the active render target and the viewport */\n    this.projectionMatrix = new Matrix.Matrix();\n    /** the default clear color for render targets */\n    this.defaultClearColor = [0, 0, 0, 0];\n    /**\n     * a hash that stores the render target for a given render surface. When you pass in a texture source,\n     * a render target is created for it. This map stores and makes it easy to retrieve the render target\n     */\n    this._renderSurfaceToRenderTargetHash = /* @__PURE__ */ new Map();\n    /** A hash that stores a gpu render target for a given render target. */\n    this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);\n    /**\n     * A stack that stores the render target and frame that is currently being rendered to.\n     * When push is called, the current render target is stored in this stack.\n     * When pop is called, the previous render target is restored.\n     */\n    this._renderTargetStack = [];\n    this._renderer = renderer;\n    renderer.renderableGC.addManagedHash(this, \"_gpuRenderTargetHash\");\n  }\n  /** called when dev wants to finish a render pass */\n  finishRenderPass() {\n    this.adaptor.finishRenderPass(this.renderTarget);\n  }\n  /**\n   * called when the renderer starts to render a scene.\n   * @param options\n   * @param options.target - the render target to render to\n   * @param options.clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111\n   * @param options.clearColor - the color to clear to\n   * @param options.frame - the frame to render to\n   */\n  renderStart({\n    target,\n    clear,\n    clearColor,\n    frame\n  }) {\n    this._renderTargetStack.length = 0;\n    this.push(\n      target,\n      clear,\n      clearColor,\n      frame\n    );\n    this.rootViewPort.copyFrom(this.viewport);\n    this.rootRenderTarget = this.renderTarget;\n    this.renderingToScreen = isRenderingToScreen.isRenderingToScreen(this.rootRenderTarget);\n    this.adaptor.prerender?.(this.rootRenderTarget);\n  }\n  postrender() {\n    this.adaptor.postrender?.(this.rootRenderTarget);\n  }\n  /**\n   * Binding a render surface! This is the main function of the render target system.\n   * It will take the RenderSurface (which can be a texture, canvas, or render target) and bind it to the renderer.\n   * Once bound all draw calls will be rendered to the render surface.\n   *\n   * If a frame is not provide and the render surface is a texture, the frame of the texture will be used.\n   * @param renderSurface - the render surface to bind\n   * @param clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111\n   * @param clearColor - the color to clear to\n   * @param frame - the frame to render to\n   * @returns the render target that was bound\n   */\n  bind(renderSurface, clear = true, clearColor, frame) {\n    const renderTarget = this.getRenderTarget(renderSurface);\n    const didChange = this.renderTarget !== renderTarget;\n    this.renderTarget = renderTarget;\n    this.renderSurface = renderSurface;\n    const gpuRenderTarget = this.getGpuRenderTarget(renderTarget);\n    if (renderTarget.pixelWidth !== gpuRenderTarget.width || renderTarget.pixelHeight !== gpuRenderTarget.height) {\n      this.adaptor.resizeGpuRenderTarget(renderTarget);\n      gpuRenderTarget.width = renderTarget.pixelWidth;\n      gpuRenderTarget.height = renderTarget.pixelHeight;\n    }\n    const source = renderTarget.colorTexture;\n    const viewport = this.viewport;\n    const pixelWidth = source.pixelWidth;\n    const pixelHeight = source.pixelHeight;\n    if (!frame && renderSurface instanceof Texture.Texture) {\n      frame = renderSurface.frame;\n    }\n    if (frame) {\n      const resolution = source._resolution;\n      viewport.x = frame.x * resolution + 0.5 | 0;\n      viewport.y = frame.y * resolution + 0.5 | 0;\n      viewport.width = frame.width * resolution + 0.5 | 0;\n      viewport.height = frame.height * resolution + 0.5 | 0;\n    } else {\n      viewport.x = 0;\n      viewport.y = 0;\n      viewport.width = pixelWidth;\n      viewport.height = pixelHeight;\n    }\n    calculateProjection.calculateProjection(\n      this.projectionMatrix,\n      0,\n      0,\n      viewport.width / source.resolution,\n      viewport.height / source.resolution,\n      !renderTarget.isRoot\n    );\n    this.adaptor.startRenderPass(renderTarget, clear, clearColor, viewport);\n    if (didChange) {\n      this.onRenderTargetChange.emit(renderTarget);\n    }\n    return renderTarget;\n  }\n  clear(target, clear = _const.CLEAR.ALL, clearColor) {\n    if (!clear)\n      return;\n    if (target) {\n      target = this.getRenderTarget(target);\n    }\n    this.adaptor.clear(\n      target || this.renderTarget,\n      clear,\n      clearColor,\n      this.viewport\n    );\n  }\n  contextChange() {\n    this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);\n  }\n  /**\n   * Push a render surface to the renderer. This will bind the render surface to the renderer,\n   * @param renderSurface - the render surface to push\n   * @param clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111\n   * @param clearColor - the color to clear to\n   * @param frame - the frame to use when rendering to the render surface\n   */\n  push(renderSurface, clear = _const.CLEAR.ALL, clearColor, frame) {\n    const renderTarget = this.bind(renderSurface, clear, clearColor, frame);\n    this._renderTargetStack.push({\n      renderTarget,\n      frame\n    });\n    return renderTarget;\n  }\n  /** Pops the current render target from the renderer and restores the previous render target. */\n  pop() {\n    this._renderTargetStack.pop();\n    const currentRenderTargetData = this._renderTargetStack[this._renderTargetStack.length - 1];\n    this.bind(currentRenderTargetData.renderTarget, false, null, currentRenderTargetData.frame);\n  }\n  /**\n   * Gets the render target from the provide render surface. Eg if its a texture,\n   * it will return the render target for the texture.\n   * If its a render target, it will return the same render target.\n   * @param renderSurface - the render surface to get the render target for\n   * @returns the render target for the render surface\n   */\n  getRenderTarget(renderSurface) {\n    if (renderSurface.isTexture) {\n      renderSurface = renderSurface.source;\n    }\n    return this._renderSurfaceToRenderTargetHash.get(renderSurface) ?? this._initRenderTarget(renderSurface);\n  }\n  /**\n   * Copies a render surface to another texture.\n   *\n   * NOTE:\n   * for sourceRenderSurfaceTexture, The render target must be something that is written too by the renderer\n   *\n   * The following is not valid:\n   * @example\n   * const canvas = document.createElement('canvas')\n   * canvas.width = 200;\n   * canvas.height = 200;\n   *\n   * const ctx = canvas2.getContext('2d')!\n   * ctx.fillStyle = 'red'\n   * ctx.fillRect(0, 0, 200, 200);\n   *\n   * const texture = RenderTexture.create({\n   *   width: 200,\n   *   height: 200,\n   * })\n   * const renderTarget = renderer.renderTarget.getRenderTarget(canvas2);\n   *\n   * renderer.renderTarget.copyToTexture(renderTarget,texture, {x:0,y:0},{width:200,height:200},{x:0,y:0});\n   *\n   * The best way to copy a canvas is to create a texture from it. Then render with that.\n   *\n   * Parsing in a RenderTarget canvas context (with a 2d context)\n   * @param sourceRenderSurfaceTexture - the render surface to copy from\n   * @param destinationTexture - the texture to copy to\n   * @param originSrc - the origin of the copy\n   * @param originSrc.x - the x origin of the copy\n   * @param originSrc.y - the y origin of the copy\n   * @param size - the size of the copy\n   * @param size.width - the width of the copy\n   * @param size.height - the height of the copy\n   * @param originDest - the destination origin (top left to paste from!)\n   * @param originDest.x - the x origin of the paste\n   * @param originDest.y - the y origin of the paste\n   */\n  copyToTexture(sourceRenderSurfaceTexture, destinationTexture, originSrc, size, originDest) {\n    if (originSrc.x < 0) {\n      size.width += originSrc.x;\n      originDest.x -= originSrc.x;\n      originSrc.x = 0;\n    }\n    if (originSrc.y < 0) {\n      size.height += originSrc.y;\n      originDest.y -= originSrc.y;\n      originSrc.y = 0;\n    }\n    const { pixelWidth, pixelHeight } = sourceRenderSurfaceTexture;\n    size.width = Math.min(size.width, pixelWidth - originSrc.x);\n    size.height = Math.min(size.height, pixelHeight - originSrc.y);\n    return this.adaptor.copyToTexture(\n      sourceRenderSurfaceTexture,\n      destinationTexture,\n      originSrc,\n      size,\n      originDest\n    );\n  }\n  /**\n   * ensures that we have a depth stencil buffer available to render to\n   * This is used by the mask system to make sure we have a stencil buffer.\n   */\n  ensureDepthStencil() {\n    if (!this.renderTarget.stencil) {\n      this.renderTarget.stencil = true;\n      this.adaptor.startRenderPass(this.renderTarget, false, null, this.viewport);\n    }\n  }\n  /** nukes the render target system */\n  destroy() {\n    this._renderer = null;\n    this._renderSurfaceToRenderTargetHash.forEach((renderTarget, key) => {\n      if (renderTarget !== key) {\n        renderTarget.destroy();\n      }\n    });\n    this._renderSurfaceToRenderTargetHash.clear();\n    this._gpuRenderTargetHash = /* @__PURE__ */ Object.create(null);\n  }\n  _initRenderTarget(renderSurface) {\n    let renderTarget = null;\n    if (CanvasSource.CanvasSource.test(renderSurface)) {\n      renderSurface = getCanvasTexture.getCanvasTexture(renderSurface).source;\n    }\n    if (renderSurface instanceof RenderTarget.RenderTarget) {\n      renderTarget = renderSurface;\n    } else if (renderSurface instanceof TextureSource.TextureSource) {\n      renderTarget = new RenderTarget.RenderTarget({\n        colorTextures: [renderSurface]\n      });\n      if (CanvasSource.CanvasSource.test(renderSurface.source.resource)) {\n        renderTarget.isRoot = true;\n      }\n      renderSurface.once(\"destroy\", () => {\n        renderTarget.destroy();\n        this._renderSurfaceToRenderTargetHash.delete(renderSurface);\n        const gpuRenderTarget = this._gpuRenderTargetHash[renderTarget.uid];\n        if (gpuRenderTarget) {\n          this._gpuRenderTargetHash[renderTarget.uid] = null;\n          this.adaptor.destroyGpuRenderTarget(gpuRenderTarget);\n        }\n      });\n    }\n    this._renderSurfaceToRenderTargetHash.set(renderSurface, renderTarget);\n    return renderTarget;\n  }\n  getGpuRenderTarget(renderTarget) {\n    return this._gpuRenderTargetHash[renderTarget.uid] || (this._gpuRenderTargetHash[renderTarget.uid] = this.adaptor.initGpuRenderTarget(renderTarget));\n  }\n  resetState() {\n    this.renderTarget = null;\n    this.renderSurface = null;\n  }\n}\n\nexports.RenderTargetSystem = RenderTargetSystem;\n//# sourceMappingURL=RenderTargetSystem.js.map\n\n};"],
"names":["shadow$provide","global","require","module","exports","Matrix","Rectangle","_const","calculateProjection","SystemRunner","CanvasSource","TextureSource","Texture","getCanvasTexture","isRenderingToScreen","RenderTarget","RenderTargetSystem","constructor","renderer","rootViewPort","viewport","onRenderTargetChange","projectionMatrix","defaultClearColor","_renderSurfaceToRenderTargetHash","Map","_gpuRenderTargetHash","Object","create","_renderTargetStack","_renderer","renderableGC","addManagedHash","finishRenderPass","adaptor","renderTarget","renderStart","target","clear","clearColor","frame","length","push","copyFrom","rootRenderTarget","renderingToScreen","prerender","postrender","bind","renderSurface","getRenderTarget","didChange","gpuRenderTarget","getGpuRenderTarget","pixelWidth","width","pixelHeight","height","resizeGpuRenderTarget","source","colorTexture","resolution","_resolution","x","y","isRoot","startRenderPass","emit","CLEAR","ALL","contextChange","pop","currentRenderTargetData","isTexture","get","_initRenderTarget","copyToTexture","sourceRenderSurfaceTexture","destinationTexture","originSrc","size","originDest","Math","min","ensureDepthStencil","stencil","destroy","forEach","key","test","colorTextures","resource","once","delete","uid","destroyGpuRenderTarget","set","initGpuRenderTarget","resetState"]
}
