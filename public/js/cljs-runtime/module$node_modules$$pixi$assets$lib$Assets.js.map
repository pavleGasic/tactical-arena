{
"version":3,
"file":"module$node_modules$$pixi$assets$lib$Assets.js",
"lineCount":162,
"mappings":"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",
"sources":["node_modules/@pixi/assets/lib/Assets.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$$pixi$assets$lib$Assets\"] = function(global,require,module,exports) {\n\"use strict\";\nvar core = require(\"@pixi/core\"), BackgroundLoader = require(\"./BackgroundLoader.js\"), Cache = require(\"./cache/Cache.js\"), Loader = require(\"./loader/Loader.js\");\nrequire(\"./loader/parsers/index.js\");\nvar Resolver = require(\"./resolver/Resolver.js\"), convertToList = require(\"./utils/convertToList.js\"), isSingleItem = require(\"./utils/isSingleItem.js\"), loadTextures = require(\"./loader/parsers/textures/loadTextures.js\");\nclass AssetsClass {\n  constructor() {\n    this._detections = [], this._initialized = !1, this.resolver = new Resolver.Resolver(), this.loader = new Loader.Loader(), this.cache = Cache.Cache, this._backgroundLoader = new BackgroundLoader.BackgroundLoader(this.loader), this._backgroundLoader.active = !0, this.reset();\n  }\n  /**\n   * Best practice is to call this function before any loading commences\n   * Initiating is the best time to add any customization to the way things are loaded.\n   *\n   * you do not need to call this for the Asset class to work, only if you want to set any initial properties\n   * @param options - options to initialize the Asset manager with\n   */\n  async init(options = {}) {\n    if (this._initialized) {\n      console.warn(\"[Assets]AssetManager already initialized, did you load before calling this Assets.init()?\");\n      return;\n    }\n    if (this._initialized = !0, options.defaultSearchParams && this.resolver.setDefaultSearchParams(options.defaultSearchParams), options.basePath && (this.resolver.basePath = options.basePath), options.bundleIdentifier && this.resolver.setBundleIdentifier(options.bundleIdentifier), options.manifest) {\n      let manifest = options.manifest;\n      typeof manifest == \"string\" && (manifest = await this.load(manifest)), this.resolver.addManifest(manifest);\n    }\n    const resolutionPref = options.texturePreference?.resolution ?? 1, resolution = typeof resolutionPref == \"number\" ? [resolutionPref] : resolutionPref, formats = await this._detectFormats({\n      preferredFormats: options.texturePreference?.format,\n      skipDetections: options.skipDetections,\n      detections: this._detections\n    });\n    this.resolver.prefer({\n      params: {\n        format: formats,\n        resolution\n      }\n    }), options.preferences && this.setPreferences(options.preferences);\n  }\n  add(aliases, srcs, data, format, loadParser) {\n    this.resolver.add(aliases, srcs, data, format, loadParser);\n  }\n  async load(urls, onProgress) {\n    this._initialized || await this.init();\n    const singleAsset = isSingleItem.isSingleItem(urls), urlArray = convertToList.convertToList(urls).map((url) => {\n      if (typeof url != \"string\") {\n        const aliases = this.resolver.getAlias(url);\n        return aliases.some((alias) => !this.resolver.hasKey(alias)) && this.add(url), Array.isArray(aliases) ? aliases[0] : aliases;\n      }\n      return this.resolver.hasKey(url) || this.add({ alias: url, src: url }), url;\n    }), resolveResults = this.resolver.resolve(urlArray), out = await this._mapLoadToResolve(resolveResults, onProgress);\n    return singleAsset ? out[urlArray[0]] : out;\n  }\n  /**\n   * This adds a bundle of assets in one go so that you can load them as a group.\n   * For example you could add a bundle for each screen in you pixi app\n   * @example\n   * import { Assets } from 'pixi.js';\n   *\n   * Assets.addBundle('animals', {\n   *     bunny: 'bunny.png',\n   *     chicken: 'chicken.png',\n   *     thumper: 'thumper.png',\n   * });\n   *\n   * const assets = await Assets.loadBundle('animals');\n   * @param bundleId - the id of the bundle to add\n   * @param assets - a record of the asset or assets that will be chosen from when loading via the specified key\n   */\n  addBundle(bundleId, assets) {\n    this.resolver.addBundle(bundleId, assets);\n  }\n  /**\n   * Bundles are a way to load multiple assets at once.\n   * If a manifest has been provided to the init function then you can load a bundle, or bundles.\n   * you can also add bundles via `addBundle`\n   * @example\n   * import { Assets } from 'pixi.js';\n   *\n   * // Manifest Example\n   * const manifest = {\n   *     bundles: [\n   *         {\n   *             name: 'load-screen',\n   *             assets: [\n   *                 {\n   *                     alias: 'background',\n   *                     src: 'sunset.png',\n   *                 },\n   *                 {\n   *                     alias: 'bar',\n   *                     src: 'load-bar.{png,webp}',\n   *                 },\n   *             ],\n   *         },\n   *         {\n   *             name: 'game-screen',\n   *             assets: [\n   *                 {\n   *                     alias: 'character',\n   *                     src: 'robot.png',\n   *                 },\n   *                 {\n   *                     alias: 'enemy',\n   *                     src: 'bad-guy.png',\n   *                 },\n   *             ],\n   *         },\n   *     ]\n   * };\n   *\n   * await Assets.init({ manifest });\n   *\n   * // Load a bundle...\n   * loadScreenAssets = await Assets.loadBundle('load-screen');\n   * // Load another bundle...\n   * gameScreenAssets = await Assets.loadBundle('game-screen');\n   * @param bundleIds - the bundle id or ids to load\n   * @param onProgress - Optional function that is called when progress on asset loading is made.\n   * The function is passed a single parameter, `progress`, which represents the percentage (0.0 - 1.0)\n   * of the assets loaded. Do not use this function to detect when assets are complete and available,\n   * instead use the Promise returned by this function.\n   * @returns all the bundles assets or a hash of assets for each bundle specified\n   */\n  async loadBundle(bundleIds, onProgress) {\n    this._initialized || await this.init();\n    let singleAsset = !1;\n    typeof bundleIds == \"string\" && (singleAsset = !0, bundleIds = [bundleIds]);\n    const resolveResults = this.resolver.resolveBundle(bundleIds), out = {}, keys = Object.keys(resolveResults);\n    let count = 0, total = 0;\n    const _onProgress = () => {\n      onProgress?.(++count / total);\n    }, promises = keys.map((bundleId) => {\n      const resolveResult = resolveResults[bundleId];\n      return total += Object.keys(resolveResult).length, this._mapLoadToResolve(resolveResult, _onProgress).then((resolveResult2) => {\n        out[bundleId] = resolveResult2;\n      });\n    });\n    return await Promise.all(promises), singleAsset ? out[bundleIds[0]] : out;\n  }\n  /**\n   * Initiate a background load of some assets. It will passively begin to load these assets in the background.\n   * So when you actually come to loading them you will get a promise that resolves to the loaded assets immediately\n   *\n   * An example of this might be that you would background load game assets after your inital load.\n   * then when you got to actually load your game screen assets when a player goes to the game - the loading\n   * would already have stared or may even be complete, saving you having to show an interim load bar.\n   * @example\n   * import { Assets } from 'pixi.js';\n   *\n   * Assets.backgroundLoad('bunny.png');\n   *\n   * // later on in your app...\n   * await Assets.loadBundle('bunny.png'); // Will resolve quicker as loading may have completed!\n   * @param urls - the url / urls you want to background load\n   */\n  async backgroundLoad(urls) {\n    this._initialized || await this.init(), typeof urls == \"string\" && (urls = [urls]);\n    const resolveResults = this.resolver.resolve(urls);\n    this._backgroundLoader.add(Object.values(resolveResults));\n  }\n  /**\n   * Initiate a background of a bundle, works exactly like backgroundLoad but for bundles.\n   * this can only be used if the loader has been initiated with a manifest\n   * @example\n   * import { Assets } from 'pixi.js';\n   *\n   * await Assets.init({\n   *     manifest: {\n   *         bundles: [\n   *             {\n   *                 name: 'load-screen',\n   *                 assets: [...],\n   *             },\n   *             ...\n   *         ],\n   *     },\n   * });\n   *\n   * Assets.backgroundLoadBundle('load-screen');\n   *\n   * // Later on in your app...\n   * await Assets.loadBundle('load-screen'); // Will resolve quicker as loading may have completed!\n   * @param bundleIds - the bundleId / bundleIds you want to background load\n   */\n  async backgroundLoadBundle(bundleIds) {\n    this._initialized || await this.init(), typeof bundleIds == \"string\" && (bundleIds = [bundleIds]);\n    const resolveResults = this.resolver.resolveBundle(bundleIds);\n    Object.values(resolveResults).forEach((resolveResult) => {\n      this._backgroundLoader.add(Object.values(resolveResult));\n    });\n  }\n  /**\n   * Only intended for development purposes.\n   * This will wipe the resolver and caches.\n   * You will need to reinitialize the Asset\n   */\n  reset() {\n    this.resolver.reset(), this.loader.reset(), this.cache.reset(), this._initialized = !1;\n  }\n  get(keys) {\n    if (typeof keys == \"string\")\n      return Cache.Cache.get(keys);\n    const assets = {};\n    for (let i = 0; i < keys.length; i++)\n      assets[i] = Cache.Cache.get(keys[i]);\n    return assets;\n  }\n  /**\n   * helper function to map resolved assets back to loaded assets\n   * @param resolveResults - the resolve results from the resolver\n   * @param onProgress - the progress callback\n   */\n  async _mapLoadToResolve(resolveResults, onProgress) {\n    const resolveArray = Object.values(resolveResults), resolveKeys = Object.keys(resolveResults);\n    this._backgroundLoader.active = !1;\n    const loadedAssets = await this.loader.load(resolveArray, onProgress);\n    this._backgroundLoader.active = !0;\n    const out = {};\n    return resolveArray.forEach((resolveResult, i) => {\n      const asset = loadedAssets[resolveResult.src], keys = [resolveResult.src];\n      resolveResult.alias && keys.push(...resolveResult.alias), out[resolveKeys[i]] = asset, Cache.Cache.set(keys, asset);\n    }), out;\n  }\n  /**\n   * Unload an asset or assets. As the Assets class is responsible for creating the assets via the `load` function\n   * this will make sure to destroy any assets and release them from memory.\n   * Once unloaded, you will need to load the asset again.\n   *\n   * Use this to help manage assets if you find that you have a large app and you want to free up memory.\n   *\n   * - it's up to you as the developer to make sure that textures are not actively being used when you unload them,\n   * Pixi won't break but you will end up with missing assets. Not a good look for the user!\n   * @example\n   * import { Assets } from 'pixi.js';\n   *\n   * // Load a URL:\n   * const myImageTexture = await Assets.load('http://some.url.com/image.png'); // => returns a texture\n   *\n   * await Assets.unload('http://some.url.com/image.png')\n   *\n   * // myImageTexture will be destroyed now.\n   *\n   * // Unload multiple assets:\n   * const textures = await Assets.unload(['thumper', 'chicko']);\n   * @param urls - the urls to unload\n   */\n  async unload(urls) {\n    this._initialized || await this.init();\n    const urlArray = convertToList.convertToList(urls).map((url) => typeof url != \"string\" ? url.src : url), resolveResults = this.resolver.resolve(urlArray);\n    await this._unloadFromResolved(resolveResults);\n  }\n  /**\n   * Bundles are a way to manage multiple assets at once.\n   * this will unload all files in a bundle.\n   *\n   * once a bundle has been unloaded, you need to load it again to have access to the assets.\n   * @example\n   * import { Assets } from 'pixi.js';\n   *\n   * Assets.addBundle({\n   *     'thumper': 'http://some.url.com/thumper.png',\n   * })\n   *\n   * const assets = await Assets.loadBundle('thumper');\n   *\n   * // Now to unload...\n   *\n   * await Assets.unloadBundle('thumper');\n   *\n   * // All assets in the assets object will now have been destroyed and purged from the cache\n   * @param bundleIds - the bundle id or ids to unload\n   */\n  async unloadBundle(bundleIds) {\n    this._initialized || await this.init(), bundleIds = convertToList.convertToList(bundleIds);\n    const resolveResults = this.resolver.resolveBundle(bundleIds), promises = Object.keys(resolveResults).map((bundleId) => this._unloadFromResolved(resolveResults[bundleId]));\n    await Promise.all(promises);\n  }\n  async _unloadFromResolved(resolveResult) {\n    const resolveArray = Object.values(resolveResult);\n    resolveArray.forEach((resolveResult2) => {\n      Cache.Cache.remove(resolveResult2.src);\n    }), await this.loader.unload(resolveArray);\n  }\n  /**\n   * Detects the supported formats for the browser, and returns an array of supported formats, respecting\n   * the users preferred formats order.\n   * @param options - the options to use when detecting formats\n   * @param options.preferredFormats - the preferred formats to use\n   * @param options.skipDetections - if we should skip the detections altogether\n   * @param options.detections - the detections to use\n   * @returns - the detected formats\n   */\n  async _detectFormats(options) {\n    let formats = [];\n    options.preferredFormats && (formats = Array.isArray(options.preferredFormats) ? options.preferredFormats : [options.preferredFormats]);\n    for (const detection of options.detections)\n      options.skipDetections || await detection.test() ? formats = await detection.add(formats) : options.skipDetections || (formats = await detection.remove(formats));\n    return formats = formats.filter((format, index) => formats.indexOf(format) === index), formats;\n  }\n  /** All the detection parsers currently added to the Assets class. */\n  get detections() {\n    return this._detections;\n  }\n  /**\n   * @deprecated since 7.2.0\n   * @see {@link Assets.setPreferences}\n   */\n  get preferWorkers() {\n    return loadTextures.loadTextures.config.preferWorkers;\n  }\n  set preferWorkers(value) {\n    core.utils.deprecation(\"7.2.0\", \"Assets.prefersWorkers is deprecated, use Assets.setPreferences({ preferWorkers: true }) instead.\"), this.setPreferences({ preferWorkers: value });\n  }\n  /**\n   * General setter for preferences. This is a helper function to set preferences on all parsers.\n   * @param preferences - the preferences to set\n   */\n  setPreferences(preferences) {\n    this.loader.parsers.forEach((parser) => {\n      parser.config && Object.keys(parser.config).filter((key) => key in preferences).forEach((key) => {\n        parser.config[key] = preferences[key];\n      });\n    });\n  }\n}\nconst Assets = new AssetsClass();\ncore.extensions.handleByList(core.ExtensionType.LoadParser, Assets.loader.parsers).handleByList(core.ExtensionType.ResolveParser, Assets.resolver.parsers).handleByList(core.ExtensionType.CacheParser, Assets.cache.parsers).handleByList(core.ExtensionType.DetectionParser, Assets.detections);\nexports.Assets = Assets;\nexports.AssetsClass = AssetsClass;\n//# sourceMappingURL=Assets.js.map\n\n};"],
"names":["shadow$provide","global","require","module","exports","core","BackgroundLoader","Cache","Loader","Resolver","convertToList","isSingleItem","loadTextures","AssetsClass","constructor","_detections","_initialized","resolver","loader","cache","_backgroundLoader","active","reset","init","options","console","warn","defaultSearchParams","setDefaultSearchParams","basePath","bundleIdentifier","setBundleIdentifier","manifest","load","addManifest","resolutionPref","texturePreference","resolution","formats","_detectFormats","preferredFormats","format","skipDetections","detections","prefer","params","preferences","setPreferences","add","aliases","srcs","data","loadParser","urls","onProgress","singleAsset","urlArray","map","url","getAlias","some","alias","hasKey","Array","isArray","src","resolveResults","resolve","out","_mapLoadToResolve","addBundle","bundleId","assets","loadBundle","bundleIds","resolveBundle","count","total","_onProgress","promises","Object","keys","resolveResult","length","then","resolveResult2","Promise","all","backgroundLoad","values","backgroundLoadBundle","forEach","get","i","resolveArray","resolveKeys","loadedAssets","asset","push","set","unload","_unloadFromResolved","unloadBundle","remove","detection","test","filter","index","indexOf","config","preferWorkers","value","utils","deprecation","parsers","parser","key","Assets","extensions","handleByList","ExtensionType","LoadParser","ResolveParser","CacheParser","DetectionParser"]
}
