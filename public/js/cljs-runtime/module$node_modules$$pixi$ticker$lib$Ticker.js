shadow$provide.module$node_modules$$pixi$ticker$lib$Ticker = function(global, require, module, exports) {
  var _const = require("module$node_modules$$pixi$ticker$lib$const"), TickerListener = require("module$node_modules$$pixi$ticker$lib$TickerListener");
  const node_modules$$pixi$ticker$lib$Ticker$classdecl$var8 = class {
    constructor() {
      this.autoStart = !1;
      this.deltaTime = 1;
      this.lastTime = -1;
      this.speed = 1;
      this.started = !1;
      this._requestId = null;
      this._maxElapsedMS = 100;
      this._minElapsedMS = 0;
      this._protected = !1;
      this._lastFrame = -1;
      this._head = new TickerListener.TickerListener(null, null, 1 / 0);
      this.deltaMS = 1 / node_modules$$pixi$ticker$lib$Ticker$classdecl$var8.targetFPMS;
      this.elapsedMS = 1 / node_modules$$pixi$ticker$lib$Ticker$classdecl$var8.targetFPMS;
      this._tick = time => {
        this._requestId = null;
        this.started && (this.update(time), this.started && null === this._requestId && this._head.next && (this._requestId = requestAnimationFrame(this._tick)));
      };
    }
    _requestIfNeeded() {
      null === this._requestId && this._head.next && (this.lastTime = performance.now(), this._lastFrame = this.lastTime, this._requestId = requestAnimationFrame(this._tick));
    }
    _cancelIfNeeded() {
      null !== this._requestId && (cancelAnimationFrame(this._requestId), this._requestId = null);
    }
    _startIfPossible() {
      this.started ? this._requestIfNeeded() : this.autoStart && this.start();
    }
    add(fn, context, priority = _const.UPDATE_PRIORITY.NORMAL) {
      return this._addListener(new TickerListener.TickerListener(fn, context, priority));
    }
    addOnce(fn, context, priority = _const.UPDATE_PRIORITY.NORMAL) {
      return this._addListener(new TickerListener.TickerListener(fn, context, priority, !0));
    }
    _addListener(listener) {
      let current = this._head.next, previous = this._head;
      if (current) {
        for (; current;) {
          if (listener.priority > current.priority) {
            listener.connect(previous);
            break;
          }
          previous = current;
          current = current.next;
        }
        listener.previous || listener.connect(previous);
      } else {
        listener.connect(previous);
      }
      return this._startIfPossible(), this;
    }
    remove(fn, context) {
      let listener = this._head.next;
      for (; listener;) {
        listener.match(fn, context) ? listener = listener.destroy() : listener = listener.next;
      }
      return this._head.next || this._cancelIfNeeded(), this;
    }
    get count() {
      if (!this._head) {
        return 0;
      }
      let count = 0, current = this._head;
      for (; current = current.next;) {
        count++;
      }
      return count;
    }
    start() {
      this.started || (this.started = !0, this._requestIfNeeded());
    }
    stop() {
      this.started && (this.started = !1, this._cancelIfNeeded());
    }
    destroy() {
      if (!this._protected) {
        this.stop();
        let listener = this._head.next;
        for (; listener;) {
          listener = listener.destroy(!0);
        }
        this._head.destroy();
        this._head = null;
      }
    }
    update(currentTime = performance.now()) {
      var elapsedMS;
      if (currentTime > this.lastTime) {
        if (elapsedMS = this.elapsedMS = currentTime - this.lastTime, elapsedMS > this._maxElapsedMS && (elapsedMS = this._maxElapsedMS), elapsedMS *= this.speed, this._minElapsedMS) {
          var delta = currentTime - this._lastFrame | 0;
          if (delta < this._minElapsedMS) {
            return;
          }
          this._lastFrame = currentTime - delta % this._minElapsedMS;
        }
        this.deltaMS = elapsedMS;
        this.deltaTime = this.deltaMS * node_modules$$pixi$ticker$lib$Ticker$classdecl$var8.targetFPMS;
        elapsedMS = this._head;
        for (delta = elapsedMS.next; delta;) {
          delta = delta.emit(this.deltaTime);
        }
        elapsedMS.next || this._cancelIfNeeded();
      } else {
        this.deltaTime = this.deltaMS = this.elapsedMS = 0;
      }
      this.lastTime = currentTime;
    }
    get FPS() {
      return 1e3 / this.elapsedMS;
    }
    get minFPS() {
      return 1e3 / this._maxElapsedMS;
    }
    set minFPS(fps) {
      this._maxElapsedMS = 1 / Math.min(Math.max(0, Math.min(this.maxFPS, fps)) / 1e3, node_modules$$pixi$ticker$lib$Ticker$classdecl$var8.targetFPMS);
    }
    get maxFPS() {
      return this._minElapsedMS ? Math.round(1e3 / this._minElapsedMS) : 0;
    }
    set maxFPS(fps) {
      this._minElapsedMS = 0 === fps ? 0 : 1 / (Math.max(this.minFPS, fps) / 1e3);
    }
    static get shared() {
      if (!node_modules$$pixi$ticker$lib$Ticker$classdecl$var8._shared) {
        const shared = node_modules$$pixi$ticker$lib$Ticker$classdecl$var8._shared = new node_modules$$pixi$ticker$lib$Ticker$classdecl$var8();
        shared.autoStart = !0;
        shared._protected = !0;
      }
      return node_modules$$pixi$ticker$lib$Ticker$classdecl$var8._shared;
    }
    static get system() {
      if (!node_modules$$pixi$ticker$lib$Ticker$classdecl$var8._system) {
        const system = node_modules$$pixi$ticker$lib$Ticker$classdecl$var8._system = new node_modules$$pixi$ticker$lib$Ticker$classdecl$var8();
        system.autoStart = !0;
        system._protected = !0;
      }
      return node_modules$$pixi$ticker$lib$Ticker$classdecl$var8._system;
    }
  };
  global = node_modules$$pixi$ticker$lib$Ticker$classdecl$var8;
  global.targetFPMS = 0.06;
  exports.Ticker = global;
};

//# sourceMappingURL=module$node_modules$$pixi$ticker$lib$Ticker.js.map
