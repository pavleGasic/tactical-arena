shadow$provide.module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$texture$sources$VideoSource = function(global, require, module, exports) {
  global = require("module$node_modules$pixi_DOT_js$lib$extensions$Extensions");
  var Ticker = require("module$node_modules$pixi_DOT_js$lib$ticker$Ticker"), detectVideoAlphaMode = require("module$node_modules$pixi_DOT_js$lib$utils$browser$detectVideoAlphaMode");
  require = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$texture$sources$TextureSource");
  "use strict";
  const node_modules$pixi_DOT_js$lib$rendering$renderers$shared$texture$sources$VideoSource$classdecl$var7 = class extends require.TextureSource {
    constructor(options) {
      super(options);
      this.isReady = !1;
      this.uploadMethodId = "video";
      options = {...node_modules$pixi_DOT_js$lib$rendering$renderers$shared$texture$sources$VideoSource$classdecl$var7.defaultOptions, ...options};
      this._autoUpdate = !0;
      this._isConnectedToTicker = !1;
      this._updateFPS = options.updateFPS || 0;
      this._msToNextUpdate = 0;
      this.autoPlay = !1 !== options.autoPlay;
      this.alphaMode = options.alphaMode ?? "premultiply-alpha-on-upload";
      this._videoFrameRequestCallback = this._videoFrameRequestCallback.bind(this);
      this._reject = this._resolve = this._load = this._videoFrameRequestCallbackHandle = null;
      this._onCanPlay = this._onCanPlay.bind(this);
      this._onCanPlayThrough = this._onCanPlayThrough.bind(this);
      this._onError = this._onError.bind(this);
      this._onPlayStart = this._onPlayStart.bind(this);
      this._onPlayStop = this._onPlayStop.bind(this);
      this._onSeeked = this._onSeeked.bind(this);
      !1 !== options.autoLoad && this.load();
    }
    updateFrame() {
      if (!this.destroyed) {
        this._updateFPS && (this._msToNextUpdate = Math.floor(this._msToNextUpdate - Ticker.Ticker.shared.elapsedMS * this.resource.playbackRate));
        if (!this._updateFPS || 0 >= this._msToNextUpdate) {
          this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0;
        }
        this.isValid && this.update();
      }
    }
    _videoFrameRequestCallback() {
      this.updateFrame();
      this._videoFrameRequestCallbackHandle = this.destroyed ? null : this.resource.requestVideoFrameCallback(this._videoFrameRequestCallback);
    }
    get isValid() {
      return !!this.resource.videoWidth && !!this.resource.videoHeight;
    }
    async load() {
      if (this._load) {
        return this._load;
      }
      const source = this.resource, options = this.options;
      (source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA) && source.width && source.height && (source.complete = !0);
      source.addEventListener("play", this._onPlayStart);
      source.addEventListener("pause", this._onPlayStop);
      source.addEventListener("seeked", this._onSeeked);
      this._isSourceReady() ? this._mediaReady() : (options.preload || source.addEventListener("canplay", this._onCanPlay), source.addEventListener("canplaythrough", this._onCanPlayThrough), source.addEventListener("error", this._onError, !0));
      this.alphaMode = await detectVideoAlphaMode.detectVideoAlphaMode();
      return this._load = new Promise((resolve, reject) => {
        this.isValid ? resolve(this) : (this._resolve = resolve, this._reject = reject, void 0 !== options.preloadTimeoutMs && (this._preloadTimeout = setTimeout(() => {
          this._onError(new ErrorEvent(`Preload exceeded timeout of ${options.preloadTimeoutMs}ms`));
        })), source.load());
      });
    }
    _onError(event) {
      this.resource.removeEventListener("error", this._onError, !0);
      this.emit("error", event);
      this._reject && (this._reject(event), this._resolve = this._reject = null);
    }
    _isSourcePlaying() {
      const source = this.resource;
      return !source.paused && !source.ended;
    }
    _isSourceReady() {
      return 2 < this.resource.readyState;
    }
    _onPlayStart() {
      this.isValid || this._mediaReady();
      this._configureAutoUpdate();
    }
    _onPlayStop() {
      this._configureAutoUpdate();
    }
    _onSeeked() {
      this._autoUpdate && !this._isSourcePlaying() && (this._msToNextUpdate = 0, this.updateFrame(), this._msToNextUpdate = 0);
    }
    _onCanPlay() {
      this.resource.removeEventListener("canplay", this._onCanPlay);
      this._mediaReady();
    }
    _onCanPlayThrough() {
      this.resource.removeEventListener("canplaythrough", this._onCanPlay);
      this._preloadTimeout && (clearTimeout(this._preloadTimeout), this._preloadTimeout = void 0);
      this._mediaReady();
    }
    _mediaReady() {
      const source = this.resource;
      this.isValid && (this.isReady = !0, this.resize(source.videoWidth, source.videoHeight));
      this._msToNextUpdate = 0;
      this.updateFrame();
      this._msToNextUpdate = 0;
      this._resolve && (this._resolve(this), this._reject = this._resolve = null);
      this._isSourcePlaying() ? this._onPlayStart() : this.autoPlay && this.resource.play();
    }
    destroy() {
      this._configureAutoUpdate();
      const source = this.resource;
      source && (source.removeEventListener("play", this._onPlayStart), source.removeEventListener("pause", this._onPlayStop), source.removeEventListener("seeked", this._onSeeked), source.removeEventListener("canplay", this._onCanPlay), source.removeEventListener("canplaythrough", this._onCanPlayThrough), source.removeEventListener("error", this._onError, !0), source.pause(), source.src = "", source.load());
      super.destroy();
    }
    get autoUpdate() {
      return this._autoUpdate;
    }
    set autoUpdate(value) {
      value !== this._autoUpdate && (this._autoUpdate = value, this._configureAutoUpdate());
    }
    get updateFPS() {
      return this._updateFPS;
    }
    set updateFPS(value) {
      value !== this._updateFPS && (this._updateFPS = value, this._configureAutoUpdate());
    }
    _configureAutoUpdate() {
      this._autoUpdate && this._isSourcePlaying() ? !this._updateFPS && this.resource.requestVideoFrameCallback ? (this._isConnectedToTicker && (Ticker.Ticker.shared.remove(this.updateFrame, this), this._isConnectedToTicker = !1, this._msToNextUpdate = 0), null === this._videoFrameRequestCallbackHandle && (this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(this._videoFrameRequestCallback))) : (null !== this._videoFrameRequestCallbackHandle && (this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle), 
      this._videoFrameRequestCallbackHandle = null), this._isConnectedToTicker || (Ticker.Ticker.shared.add(this.updateFrame, this), this._isConnectedToTicker = !0, this._msToNextUpdate = 0)) : (null !== this._videoFrameRequestCallbackHandle && (this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle), this._videoFrameRequestCallbackHandle = null), this._isConnectedToTicker && (Ticker.Ticker.shared.remove(this.updateFrame, this), this._isConnectedToTicker = !1, this._msToNextUpdate = 
      0));
    }
    static test(resource) {
      return globalThis.HTMLVideoElement && resource instanceof HTMLVideoElement;
    }
  };
  module = node_modules$pixi_DOT_js$lib$rendering$renderers$shared$texture$sources$VideoSource$classdecl$var7;
  module.extension = global.ExtensionType.TextureSource;
  module.defaultOptions = {...require.TextureSource.defaultOptions, autoLoad:!0, autoPlay:!0, updateFPS:0, crossorigin:!0, loop:!1, muted:!0, playsinline:!0, preload:!1};
  module.MIME_TYPES = {ogv:"video/ogg", mov:"video/quicktime", m4v:"video/mp4"};
  exports.VideoSource = module;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$texture$sources$VideoSource.js.map
