shadow$provide.module$node_modules$pixi_DOT_js$lib$scene$graphics$shared$GraphicsContext = function(global, require, module, exports) {
  module = require("module$node_modules$eventemitter3$index");
  var Color = require("module$node_modules$pixi_DOT_js$lib$color$Color"), Matrix = require("module$node_modules$pixi_DOT_js$lib$maths$matrix$Matrix"), Point = require("module$node_modules$pixi_DOT_js$lib$maths$point$Point");
  global = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$texture$Texture");
  var uid = require("module$node_modules$pixi_DOT_js$lib$utils$data$uid"), deprecation = require("module$node_modules$pixi_DOT_js$lib$utils$logging$deprecation"), Bounds = require("module$node_modules$pixi_DOT_js$lib$scene$container$bounds$Bounds"), GraphicsPath = require("module$node_modules$pixi_DOT_js$lib$scene$graphics$shared$path$GraphicsPath"), SVGParser = require("module$node_modules$pixi_DOT_js$lib$scene$graphics$shared$svg$SVGParser"), convertFillInputToFillStyle = require("module$node_modules$pixi_DOT_js$lib$scene$graphics$shared$utils$convertFillInputToFillStyle");
  "use strict";
  const tmpPoint = new Point.Point(), tempMatrix = new Matrix.Matrix(), node_modules$pixi_DOT_js$lib$scene$graphics$shared$GraphicsContext$classdecl$var15 = class extends module {
    constructor() {
      super(...arguments);
      this.uid = uid.uid("graphicsContext");
      this.dirty = !0;
      this.batchMode = "auto";
      this.instructions = [];
      this._activePath = new GraphicsPath.GraphicsPath();
      this._transform = new Matrix.Matrix();
      this._fillStyle = {...node_modules$pixi_DOT_js$lib$scene$graphics$shared$GraphicsContext$classdecl$var15.defaultFillStyle};
      this._strokeStyle = {...node_modules$pixi_DOT_js$lib$scene$graphics$shared$GraphicsContext$classdecl$var15.defaultStrokeStyle};
      this._stateStack = [];
      this._tick = 0;
      this._bounds = new Bounds.Bounds();
      this._boundsDirty = !0;
    }
    clone() {
      const clone = new node_modules$pixi_DOT_js$lib$scene$graphics$shared$GraphicsContext$classdecl$var15();
      clone.batchMode = this.batchMode;
      clone.instructions = this.instructions.slice();
      clone._activePath = this._activePath.clone();
      clone._transform = this._transform.clone();
      clone._fillStyle = {...this._fillStyle};
      clone._strokeStyle = {...this._strokeStyle};
      clone._stateStack = this._stateStack.slice();
      clone._bounds = this._bounds.clone();
      clone._boundsDirty = !0;
      return clone;
    }
    get fillStyle() {
      return this._fillStyle;
    }
    set fillStyle(value) {
      this._fillStyle = convertFillInputToFillStyle.toFillStyle(value, node_modules$pixi_DOT_js$lib$scene$graphics$shared$GraphicsContext$classdecl$var15.defaultFillStyle);
    }
    get strokeStyle() {
      return this._strokeStyle;
    }
    set strokeStyle(value) {
      this._strokeStyle = convertFillInputToFillStyle.toStrokeStyle(value, node_modules$pixi_DOT_js$lib$scene$graphics$shared$GraphicsContext$classdecl$var15.defaultStrokeStyle);
    }
    setFillStyle(style) {
      this._fillStyle = convertFillInputToFillStyle.toFillStyle(style, node_modules$pixi_DOT_js$lib$scene$graphics$shared$GraphicsContext$classdecl$var15.defaultFillStyle);
      return this;
    }
    setStrokeStyle(style) {
      this._strokeStyle = convertFillInputToFillStyle.toFillStyle(style, node_modules$pixi_DOT_js$lib$scene$graphics$shared$GraphicsContext$classdecl$var15.defaultStrokeStyle);
      return this;
    }
    texture(texture, tint, dx, dy, dw, dh) {
      this.instructions.push({action:"texture", data:{image:texture, dx:dx || 0, dy:dy || 0, dw:dw || texture.frame.width, dh:dh || texture.frame.height, transform:this._transform.clone(), alpha:this._fillStyle.alpha, style:tint ? Color.Color.shared.setValue(tint).toNumber() : 16777215}});
      this.onUpdate();
      return this;
    }
    beginPath() {
      this._activePath = new GraphicsPath.GraphicsPath();
      return this;
    }
    fill(style, alpha) {
      var path = this.instructions[this.instructions.length - 1];
      path = 0 === this._tick && path && "stroke" === path.action ? path.data.path : this._activePath.clone();
      if (!path) {
        return this;
      }
      null != style && (void 0 !== alpha && "number" === typeof style && (deprecation.deprecation(deprecation.v8_0_0, "GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead"), style = {color:style, alpha}), this._fillStyle = convertFillInputToFillStyle.toFillStyle(style, node_modules$pixi_DOT_js$lib$scene$graphics$shared$GraphicsContext$classdecl$var15.defaultFillStyle));
      this.instructions.push({action:"fill", data:{style:this.fillStyle, path}});
      this.onUpdate();
      this._initNextPathLocation();
      this._tick = 0;
      return this;
    }
    _initNextPathLocation() {
      const {x, y} = this._activePath.getLastPoint(Point.Point.shared);
      this._activePath.clear();
      this._activePath.moveTo(x, y);
    }
    stroke(style) {
      var path = this.instructions[this.instructions.length - 1];
      path = 0 === this._tick && path && "fill" === path.action ? path.data.path : this._activePath.clone();
      if (!path) {
        return this;
      }
      null != style && (this._strokeStyle = convertFillInputToFillStyle.toStrokeStyle(style, node_modules$pixi_DOT_js$lib$scene$graphics$shared$GraphicsContext$classdecl$var15.defaultStrokeStyle));
      this.instructions.push({action:"stroke", data:{style:this.strokeStyle, path}});
      this.onUpdate();
      this._initNextPathLocation();
      this._tick = 0;
      return this;
    }
    cut() {
      for (let i = 0; 2 > i; i++) {
        const lastInstruction = this.instructions[this.instructions.length - 1 - i], holePath = this._activePath.clone();
        if (lastInstruction && ("stroke" === lastInstruction.action || "fill" === lastInstruction.action)) {
          if (lastInstruction.data.hole) {
            lastInstruction.data.hole.addPath(holePath);
          } else {
            lastInstruction.data.hole = holePath;
            break;
          }
        }
      }
      this._initNextPathLocation();
      return this;
    }
    arc(x, y, radius, startAngle, endAngle, counterclockwise) {
      this._tick++;
      const t = this._transform;
      this._activePath.arc(t.a * x + t.c * y + t.tx, t.b * x + t.d * y + t.ty, radius, startAngle, endAngle, counterclockwise);
      return this;
    }
    arcTo(x1, y1, x2, y2, radius) {
      this._tick++;
      const t = this._transform;
      this._activePath.arcTo(t.a * x1 + t.c * y1 + t.tx, t.b * x1 + t.d * y1 + t.ty, t.a * x2 + t.c * y2 + t.tx, t.b * x2 + t.d * y2 + t.ty, radius);
      return this;
    }
    arcToSvg(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y) {
      this._tick++;
      const t = this._transform;
      this._activePath.arcToSvg(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, t.a * x + t.c * y + t.tx, t.b * x + t.d * y + t.ty);
      return this;
    }
    bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y, smoothness) {
      this._tick++;
      const t = this._transform;
      this._activePath.bezierCurveTo(t.a * cp1x + t.c * cp1y + t.tx, t.b * cp1x + t.d * cp1y + t.ty, t.a * cp2x + t.c * cp2y + t.tx, t.b * cp2x + t.d * cp2y + t.ty, t.a * x + t.c * y + t.tx, t.b * x + t.d * y + t.ty, smoothness);
      return this;
    }
    closePath() {
      this._tick++;
      this._activePath?.closePath();
      return this;
    }
    ellipse(x, y, radiusX, radiusY) {
      this._tick++;
      this._activePath.ellipse(x, y, radiusX, radiusY, this._transform.clone());
      return this;
    }
    circle(x, y, radius) {
      this._tick++;
      this._activePath.circle(x, y, radius, this._transform.clone());
      return this;
    }
    path(path) {
      this._tick++;
      this._activePath.addPath(path, this._transform.clone());
      return this;
    }
    lineTo(x, y) {
      this._tick++;
      const t = this._transform;
      this._activePath.lineTo(t.a * x + t.c * y + t.tx, t.b * x + t.d * y + t.ty);
      return this;
    }
    moveTo(x, y) {
      this._tick++;
      const t = this._transform, instructions = this._activePath.instructions, transformedX = t.a * x + t.c * y + t.tx;
      x = t.b * x + t.d * y + t.ty;
      if (1 === instructions.length && "moveTo" === instructions[0].action) {
        return instructions[0].data[0] = transformedX, instructions[0].data[1] = x, this;
      }
      this._activePath.moveTo(transformedX, x);
      return this;
    }
    quadraticCurveTo(cpx, cpy, x, y, smoothness) {
      this._tick++;
      const t = this._transform;
      this._activePath.quadraticCurveTo(t.a * cpx + t.c * cpy + t.tx, t.b * cpx + t.d * cpy + t.ty, t.a * x + t.c * y + t.tx, t.b * x + t.d * y + t.ty, smoothness);
      return this;
    }
    rect(x, y, w, h) {
      this._tick++;
      this._activePath.rect(x, y, w, h, this._transform.clone());
      return this;
    }
    roundRect(x, y, w, h, radius) {
      this._tick++;
      this._activePath.roundRect(x, y, w, h, radius, this._transform.clone());
      return this;
    }
    poly(points, close) {
      this._tick++;
      this._activePath.poly(points, close, this._transform.clone());
      return this;
    }
    regularPoly(x, y, radius, sides, rotation = 0, transform) {
      this._tick++;
      this._activePath.regularPoly(x, y, radius, sides, rotation, transform);
      return this;
    }
    roundPoly(x, y, radius, sides, corner, rotation) {
      this._tick++;
      this._activePath.roundPoly(x, y, radius, sides, corner, rotation);
      return this;
    }
    roundShape(points, radius, useQuadratic, smoothness) {
      this._tick++;
      this._activePath.roundShape(points, radius, useQuadratic, smoothness);
      return this;
    }
    filletRect(x, y, width, height, fillet) {
      this._tick++;
      this._activePath.filletRect(x, y, width, height, fillet);
      return this;
    }
    chamferRect(x, y, width, height, chamfer, transform) {
      this._tick++;
      this._activePath.chamferRect(x, y, width, height, chamfer, transform);
      return this;
    }
    star(x, y, points, radius, innerRadius = 0, rotation = 0) {
      this._tick++;
      this._activePath.star(x, y, points, radius, innerRadius, rotation, this._transform.clone());
      return this;
    }
    svg(svg) {
      this._tick++;
      SVGParser.SVGParser(svg, this);
      return this;
    }
    restore() {
      const state = this._stateStack.pop();
      state && (this._transform = state.transform, this._fillStyle = state.fillStyle, this._strokeStyle = state.strokeStyle);
      return this;
    }
    save() {
      this._stateStack.push({transform:this._transform.clone(), fillStyle:{...this._fillStyle}, strokeStyle:{...this._strokeStyle}});
      return this;
    }
    getTransform() {
      return this._transform;
    }
    resetTransform() {
      this._transform.identity();
      return this;
    }
    rotate(angle) {
      this._transform.rotate(angle);
      return this;
    }
    scale(x, y = x) {
      this._transform.scale(x, y);
      return this;
    }
    setTransform(a, b, c, d, dx, dy) {
      if (a instanceof Matrix.Matrix) {
        return this._transform.set(a.a, a.b, a.c, a.d, a.tx, a.ty), this;
      }
      this._transform.set(a, b, c, d, dx, dy);
      return this;
    }
    transform(a, b, c, d, dx, dy) {
      if (a instanceof Matrix.Matrix) {
        return this._transform.append(a), this;
      }
      tempMatrix.set(a, b, c, d, dx, dy);
      this._transform.append(tempMatrix);
      return this;
    }
    translate(x, y = x) {
      this._transform.translate(x, y);
      return this;
    }
    clear() {
      this._activePath.clear();
      this.instructions.length = 0;
      this.resetTransform();
      this.onUpdate();
      return this;
    }
    onUpdate() {
      this.dirty || (this.emit("update", this, 16), this._boundsDirty = this.dirty = !0);
    }
    get bounds() {
      if (!this._boundsDirty) {
        return this._bounds;
      }
      const bounds = this._bounds;
      bounds.clear();
      for (let i = 0; i < this.instructions.length; i++) {
        var instruction = this.instructions[i], action = instruction.action;
        if ("fill" === action) {
          bounds.addBounds(instruction.data.path.bounds);
        } else if ("texture" === action) {
          const data = instruction.data;
          bounds.addFrame(data.dx, data.dy, data.dx + data.dw, data.dy + data.dh, data.transform);
        }
        "stroke" === action && (action = instruction.data, instruction = action.style.width * (1 - action.style.alignment), action = action.path.bounds, bounds.addFrame(action.minX - instruction, action.minY - instruction, action.maxX + instruction, action.maxY + instruction));
      }
      return bounds;
    }
    containsPoint(point) {
      if (!this.bounds.containsPoint(point.x, point.y)) {
        return !1;
      }
      const instructions = this.instructions;
      var hasHit = !1;
      for (let k = 0; k < instructions.length; k++) {
        const instruction = instructions[k], data = instruction.data;
        var path = data.path;
        if (!instruction.action || !path) {
          continue;
        }
        const style = data.style;
        path = path.shapePath.shapePrimitives;
        for (let i = 0; i < path.length; i++) {
          var shape = path[i].shape;
          if (!style || !shape) {
            continue;
          }
          const transformedPoint = (hasHit = path[i].transform) ? hasHit.applyInverse(point, tmpPoint) : point;
          "fill" === instruction.action ? hasHit = shape.contains(transformedPoint.x, transformedPoint.y) : (hasHit = style, hasHit = shape.strokeContains(transformedPoint.x, transformedPoint.y, hasHit.width, hasHit.alignment));
          if (shape = data.hole) {
            if (shape = shape.shapePath?.shapePrimitives) {
              for (let j = 0; j < shape.length; j++) {
                shape[j].shape.contains(transformedPoint.x, transformedPoint.y) && (hasHit = !1);
              }
            }
          }
          if (hasHit) {
            return !0;
          }
        }
      }
      return hasHit;
    }
    destroy(options = !1) {
      this._stateStack.length = 0;
      this._transform = null;
      this.emit("destroy", this);
      this.removeAllListeners();
      if ("boolean" === typeof options ? options : options?.texture) {
        options = "boolean" === typeof options ? options : options?.textureSource, this._fillStyle.texture && this._fillStyle.texture.destroy(options), this._strokeStyle.texture && this._strokeStyle.texture.destroy(options);
      }
      this._transform = this.customShader = this._stateStack = this._bounds = this._activePath = this.instructions = this._strokeStyle = this._fillStyle = null;
    }
  };
  require = node_modules$pixi_DOT_js$lib$scene$graphics$shared$GraphicsContext$classdecl$var15;
  require.defaultFillStyle = {color:16777215, alpha:1, texture:global.Texture.WHITE, matrix:null, fill:null, textureSpace:"local"};
  require.defaultStrokeStyle = {width:1, color:16777215, alpha:1, alignment:0.5, miterLimit:10, cap:"butt", join:"miter", texture:global.Texture.WHITE, matrix:null, fill:null, textureSpace:"local", pixelLine:!1};
  exports.GraphicsContext = require;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$scene$graphics$shared$GraphicsContext.js.map
