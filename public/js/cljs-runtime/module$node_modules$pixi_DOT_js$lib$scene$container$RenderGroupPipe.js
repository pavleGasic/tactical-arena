shadow$provide.module$node_modules$pixi_DOT_js$lib$scene$container$RenderGroupPipe = function(global, require, module, exports) {
  global = require("module$node_modules$pixi_DOT_js$lib$extensions$Extensions");
  module = require("module$node_modules$pixi_DOT_js$lib$maths$matrix$Matrix");
  var PoolGroup = require("module$node_modules$pixi_DOT_js$lib$utils$pool$PoolGroup"), BatchableSprite = require("module$node_modules$pixi_DOT_js$lib$scene$sprite$BatchableSprite"), executeInstructions = require("module$node_modules$pixi_DOT_js$lib$scene$container$utils$executeInstructions");
  "use strict";
  const tempMatrix = new module.Matrix();
  class RenderGroupPipe {
    constructor(renderer) {
      this._renderer = renderer;
    }
    addRenderGroup(renderGroup, instructionSet) {
      renderGroup.isCachedAsTexture ? this._addRenderableCacheAsTexture(renderGroup, instructionSet) : this._addRenderableDirect(renderGroup, instructionSet);
    }
    execute(renderGroup) {
      renderGroup.isRenderable && (renderGroup.isCachedAsTexture ? this._executeCacheAsTexture(renderGroup) : this._executeDirect(renderGroup));
    }
    destroy() {
      this._renderer = null;
    }
    _addRenderableDirect(renderGroup, instructionSet) {
      this._renderer.renderPipes.batch.break(instructionSet);
      renderGroup._batchableRenderGroup && (PoolGroup.BigPool.return(renderGroup._batchableRenderGroup), renderGroup._batchableRenderGroup = null);
      instructionSet.add(renderGroup);
    }
    _addRenderableCacheAsTexture(renderGroup, instructionSet) {
      const batchableRenderGroup = renderGroup._batchableRenderGroup ?? (renderGroup._batchableRenderGroup = PoolGroup.BigPool.get(BatchableSprite.BatchableSprite));
      batchableRenderGroup.renderable = renderGroup.root;
      batchableRenderGroup.transform = renderGroup.root.relativeGroupTransform;
      batchableRenderGroup.texture = renderGroup.texture;
      batchableRenderGroup.bounds = renderGroup._textureBounds;
      instructionSet.add(renderGroup);
      this._renderer.renderPipes.batch.addToBatch(batchableRenderGroup, instructionSet);
    }
    _executeCacheAsTexture(renderGroup) {
      if (renderGroup.textureNeedsUpdate) {
        renderGroup.textureNeedsUpdate = !1;
        const worldTransformMatrix = tempMatrix.identity().translate(-renderGroup._textureBounds.x, -renderGroup._textureBounds.y);
        this._renderer.renderTarget.push(renderGroup.texture, !0, null, renderGroup.texture.frame);
        this._renderer.globalUniforms.push({worldTransformMatrix, worldColor:4294967295});
        executeInstructions.executeInstructions(renderGroup, this._renderer.renderPipes);
        this._renderer.renderTarget.finishRenderPass();
        this._renderer.renderTarget.pop();
        this._renderer.globalUniforms.pop();
      }
      renderGroup._batchableRenderGroup._batcher.updateElement(renderGroup._batchableRenderGroup);
      renderGroup._batchableRenderGroup._batcher.geometry.buffers[0].update();
    }
    _executeDirect(renderGroup) {
      this._renderer.globalUniforms.push({worldTransformMatrix:renderGroup.inverseParentTextureTransform, worldColor:renderGroup.worldColorAlpha});
      executeInstructions.executeInstructions(renderGroup, this._renderer.renderPipes);
      this._renderer.globalUniforms.pop();
    }
  }
  RenderGroupPipe.extension = {type:[global.ExtensionType.WebGLPipes, global.ExtensionType.WebGPUPipes, global.ExtensionType.CanvasPipes], name:"renderGroup"};
  exports.RenderGroupPipe = RenderGroupPipe;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$scene$container$RenderGroupPipe.js.map
