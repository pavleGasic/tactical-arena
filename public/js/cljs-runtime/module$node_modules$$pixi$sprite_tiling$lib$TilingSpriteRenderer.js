shadow$provide.module$node_modules$$pixi$sprite_tiling$lib$TilingSpriteRenderer = function(global, require, module, exports) {
  var core = require("module$node_modules$$pixi$core$lib$index"), spriteTiling$1 = require("module$node_modules$$pixi$sprite_tiling$lib$sprite_tiling_frag"), spriteTiling = require("module$node_modules$$pixi$sprite_tiling$lib$sprite_tiling_vert"), spriteTilingFallback$1 = require("module$node_modules$$pixi$sprite_tiling$lib$sprite_tiling_fallback_frag"), spriteTilingFallback = require("module$node_modules$$pixi$sprite_tiling$lib$sprite_tiling_fallback_vert"), spriteTilingSimple = require("module$node_modules$$pixi$sprite_tiling$lib$sprite_tiling_simple_frag");
  const tempMat = new core.Matrix();
  class TilingSpriteRenderer extends core.ObjectRenderer {
    constructor(renderer) {
      super(renderer);
      renderer.runners.contextChange.add(this);
      this.quad = new core.QuadUv();
      this.state = core.State.for2d();
    }
    contextChange() {
      const renderer = this.renderer, uniforms = {globals:renderer.globalUniforms};
      this.simpleShader = core.Shader.from(spriteTilingFallback.default, spriteTilingSimple.default, uniforms);
      this.shader = 1 < renderer.context.webGLVersion ? core.Shader.from(spriteTiling.default, spriteTiling$1.default, uniforms) : core.Shader.from(spriteTilingFallback.default, spriteTilingFallback$1.default, uniforms);
    }
    render(ts) {
      const renderer = this.renderer, quad = this.quad;
      var vertices = quad.vertices;
      vertices[0] = vertices[6] = ts._width * -ts.anchor.x;
      vertices[1] = vertices[3] = ts._height * -ts.anchor.y;
      vertices[2] = vertices[4] = ts._width * (1 - ts.anchor.x);
      vertices[5] = vertices[7] = ts._height * (1 - ts.anchor.y);
      var anchorX = ts.uvRespectAnchor ? ts.anchor.x : 0, anchorY = ts.uvRespectAnchor ? ts.anchor.y : 0;
      vertices = quad.uvs;
      vertices[0] = vertices[6] = -anchorX;
      vertices[1] = vertices[3] = -anchorY;
      vertices[2] = vertices[4] = 1 - anchorX;
      vertices[5] = vertices[7] = 1 - anchorY;
      quad.invalidate();
      vertices = ts._texture;
      var baseTex = vertices.baseTexture;
      anchorX = 0 < baseTex.alphaMode;
      anchorY = ts.tileTransform.localTransform;
      const uv = ts.uvMatrix;
      let isSimple = baseTex.isPowerOfTwo && vertices.frame.width === baseTex.width && vertices.frame.height === baseTex.height;
      isSimple && (baseTex._glTextures[renderer.CONTEXT_UID] ? isSimple = baseTex.wrapMode !== core.WRAP_MODES.CLAMP : baseTex.wrapMode === core.WRAP_MODES.CLAMP && (baseTex.wrapMode = core.WRAP_MODES.REPEAT));
      baseTex = isSimple ? this.simpleShader : this.shader;
      const w = vertices.width, h = vertices.height, W = ts._width, H = ts._height;
      tempMat.set(anchorY.a * w / W, anchorY.b * w / H, anchorY.c * h / W, anchorY.d * h / H, anchorY.tx / W, anchorY.ty / H);
      tempMat.invert();
      isSimple ? tempMat.prepend(uv.mapCoord) : (baseTex.uniforms.uMapCoord = uv.mapCoord.toArray(!0), baseTex.uniforms.uClampFrame = uv.uClampFrame, baseTex.uniforms.uClampOffset = uv.uClampOffset);
      baseTex.uniforms.uTransform = tempMat.toArray(!0);
      baseTex.uniforms.uColor = core.Color.shared.setValue(ts.tint).premultiply(ts.worldAlpha, anchorX).toArray(baseTex.uniforms.uColor);
      baseTex.uniforms.translationMatrix = ts.transform.worldTransform.toArray(!0);
      baseTex.uniforms.uSampler = vertices;
      renderer.shader.bind(baseTex);
      renderer.geometry.bind(quad);
      this.state.blendMode = core.utils.correctBlendMode(ts.blendMode, anchorX);
      renderer.state.set(this.state);
      renderer.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0);
    }
  }
  TilingSpriteRenderer.extension = {name:"tilingSprite", type:core.ExtensionType.RendererPlugin};
  core.extensions.add(TilingSpriteRenderer);
  exports.TilingSpriteRenderer = TilingSpriteRenderer;
};

//# sourceMappingURL=module$node_modules$$pixi$sprite_tiling$lib$TilingSpriteRenderer.js.map
