shadow$provide.module$node_modules$pixi_DOT_js$lib$scene$sprite$SpritePipe = function(global, require, module, exports) {
  global = require("module$node_modules$pixi_DOT_js$lib$extensions$Extensions");
  var PoolGroup = require("module$node_modules$pixi_DOT_js$lib$utils$pool$PoolGroup"), BatchableSprite = require("module$node_modules$pixi_DOT_js$lib$scene$sprite$BatchableSprite");
  "use strict";
  class SpritePipe {
    constructor(renderer) {
      this._gpuSpriteHash = Object.create(null);
      this._destroyRenderableBound = this.destroyRenderable.bind(this);
      this._renderer = renderer;
      this._renderer.renderableGC.addManagedHash(this, "_gpuSpriteHash");
    }
    addRenderable(sprite, instructionSet) {
      const gpuSprite = this._getGpuSprite(sprite);
      sprite.didViewUpdate && this._updateBatchableSprite(sprite, gpuSprite);
      this._renderer.renderPipes.batch.addToBatch(gpuSprite, instructionSet);
    }
    updateRenderable(sprite) {
      const gpuSprite = this._gpuSpriteHash[sprite.uid];
      sprite.didViewUpdate && this._updateBatchableSprite(sprite, gpuSprite);
      gpuSprite._batcher.updateElement(gpuSprite);
    }
    validateRenderable(sprite) {
      const gpuSprite = this._getGpuSprite(sprite);
      return !gpuSprite._batcher.checkAndUpdateTexture(gpuSprite, sprite._texture);
    }
    destroyRenderable(sprite) {
      PoolGroup.BigPool.return(this._gpuSpriteHash[sprite.uid]);
      this._gpuSpriteHash[sprite.uid] = null;
      sprite.off("destroyed", this._destroyRenderableBound);
    }
    _updateBatchableSprite(sprite, batchableSprite) {
      batchableSprite.bounds = sprite.visualBounds;
      batchableSprite.texture = sprite._texture;
    }
    _getGpuSprite(sprite) {
      return this._gpuSpriteHash[sprite.uid] || this._initGPUSprite(sprite);
    }
    _initGPUSprite(sprite) {
      const batchableSprite = PoolGroup.BigPool.get(BatchableSprite.BatchableSprite);
      batchableSprite.renderable = sprite;
      batchableSprite.transform = sprite.groupTransform;
      batchableSprite.texture = sprite._texture;
      batchableSprite.bounds = sprite.visualBounds;
      batchableSprite.roundPixels = this._renderer._roundPixels | sprite._roundPixels;
      this._gpuSpriteHash[sprite.uid] = batchableSprite;
      sprite.on("destroyed", this._destroyRenderableBound);
      return batchableSprite;
    }
    destroy() {
      for (const i in this._gpuSpriteHash) {
        PoolGroup.BigPool.return(this._gpuSpriteHash[i]);
      }
      this._renderer = this._gpuSpriteHash = null;
    }
  }
  SpritePipe.extension = {type:[global.ExtensionType.WebGLPipes, global.ExtensionType.WebGPUPipes, global.ExtensionType.CanvasPipes], name:"sprite"};
  exports.SpritePipe = SpritePipe;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$scene$sprite$SpritePipe.js.map
