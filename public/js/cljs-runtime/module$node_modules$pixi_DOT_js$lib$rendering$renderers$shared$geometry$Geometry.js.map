{
"version":3,
"file":"module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$geometry$Geometry.js",
"lineCount":72,
"mappings":"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",
"sources":["node_modules/pixi_DOT_js/lib/rendering/renderers/shared/geometry/Geometry.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$geometry$Geometry\"] = function(global,require,module,exports) {\n'use strict';\n\nvar EventEmitter = require('eventemitter3');\nvar Bounds = require('../../../../scene/container/bounds/Bounds.js');\nvar uid = require('../../../../utils/data/uid.js');\nvar Buffer = require('../buffer/Buffer.js');\nvar ensureIsBuffer = require('./utils/ensureIsBuffer.js');\nvar getGeometryBounds = require('./utils/getGeometryBounds.js');\n\n\"use strict\";\nfunction ensureIsAttribute(attribute) {\n  if (attribute instanceof Buffer.Buffer || Array.isArray(attribute) || attribute.BYTES_PER_ELEMENT) {\n    attribute = {\n      buffer: attribute\n    };\n  }\n  attribute.buffer = ensureIsBuffer.ensureIsBuffer(attribute.buffer, false);\n  return attribute;\n}\nclass Geometry extends EventEmitter {\n  /**\n   * Create a new instance of a geometry\n   * @param options - The options for the geometry.\n   */\n  constructor(options = {}) {\n    super();\n    /** The unique id of the geometry. */\n    this.uid = uid.uid(\"geometry\");\n    /**\n     * the layout key will be generated by WebGPU all geometries that have the same structure\n     * will have the same layout key. This is used to cache the pipeline layout\n     * @internal\n     * @ignore\n     */\n    this._layoutKey = 0;\n    /** the instance count of the geometry to draw */\n    this.instanceCount = 1;\n    this._bounds = new Bounds.Bounds();\n    this._boundsDirty = true;\n    const { attributes, indexBuffer, topology } = options;\n    this.buffers = [];\n    this.attributes = {};\n    if (attributes) {\n      for (const i in attributes) {\n        this.addAttribute(i, attributes[i]);\n      }\n    }\n    this.instanceCount = options.instanceCount ?? 1;\n    if (indexBuffer) {\n      this.addIndex(indexBuffer);\n    }\n    this.topology = topology || \"triangle-list\";\n  }\n  onBufferUpdate() {\n    this._boundsDirty = true;\n    this.emit(\"update\", this);\n  }\n  /**\n   * Returns the requested attribute.\n   * @param id - The name of the attribute required\n   * @returns - The attribute requested.\n   */\n  getAttribute(id) {\n    return this.attributes[id];\n  }\n  /**\n   * Returns the index buffer\n   * @returns - The index buffer.\n   */\n  getIndex() {\n    return this.indexBuffer;\n  }\n  /**\n   * Returns the requested buffer.\n   * @param id - The name of the buffer required.\n   * @returns - The buffer requested.\n   */\n  getBuffer(id) {\n    return this.getAttribute(id).buffer;\n  }\n  /**\n   * Used to figure out how many vertices there are in this geometry\n   * @returns the number of vertices in the geometry\n   */\n  getSize() {\n    for (const i in this.attributes) {\n      const attribute = this.attributes[i];\n      const buffer = attribute.buffer;\n      return buffer.data.length / (attribute.stride / 4 || attribute.size);\n    }\n    return 0;\n  }\n  /**\n   * Adds an attribute to the geometry.\n   * @param name - The name of the attribute to add.\n   * @param attributeOption - The attribute option to add.\n   */\n  addAttribute(name, attributeOption) {\n    const attribute = ensureIsAttribute(attributeOption);\n    const bufferIndex = this.buffers.indexOf(attribute.buffer);\n    if (bufferIndex === -1) {\n      this.buffers.push(attribute.buffer);\n      attribute.buffer.on(\"update\", this.onBufferUpdate, this);\n      attribute.buffer.on(\"change\", this.onBufferUpdate, this);\n    }\n    this.attributes[name] = attribute;\n  }\n  /**\n   * Adds an index buffer to the geometry.\n   * @param indexBuffer - The index buffer to add. Can be a Buffer, TypedArray, or an array of numbers.\n   */\n  addIndex(indexBuffer) {\n    this.indexBuffer = ensureIsBuffer.ensureIsBuffer(indexBuffer, true);\n    this.buffers.push(this.indexBuffer);\n  }\n  /** Returns the bounds of the geometry. */\n  get bounds() {\n    if (!this._boundsDirty)\n      return this._bounds;\n    this._boundsDirty = false;\n    return getGeometryBounds.getGeometryBounds(this, \"aPosition\", this._bounds);\n  }\n  /**\n   * destroys the geometry.\n   * @param destroyBuffers - destroy the buffers associated with this geometry\n   */\n  destroy(destroyBuffers = false) {\n    this.emit(\"destroy\", this);\n    this.removeAllListeners();\n    if (destroyBuffers) {\n      this.buffers.forEach((buffer) => buffer.destroy());\n    }\n    this.attributes = null;\n    this.buffers = null;\n    this.indexBuffer = null;\n    this._bounds = null;\n  }\n}\n\nexports.Geometry = Geometry;\n//# sourceMappingURL=Geometry.js.map\n\n};"],
"names":["shadow$provide","global","require","module","exports","EventEmitter","Bounds","uid","Buffer","ensureIsBuffer","getGeometryBounds","Geometry","constructor","options","_layoutKey","instanceCount","_bounds","_boundsDirty","attributes","indexBuffer","topology","buffers","i","addAttribute","addIndex","onBufferUpdate","emit","getAttribute","id","getIndex","getBuffer","buffer","getSize","attribute","data","length","stride","size","name","attributeOption","Array","isArray","BYTES_PER_ELEMENT","indexOf","bufferIndex","push","on","destroy","destroyBuffers","removeAllListeners","forEach"]
}
