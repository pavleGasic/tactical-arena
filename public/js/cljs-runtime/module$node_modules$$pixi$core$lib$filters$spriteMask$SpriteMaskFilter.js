shadow$provide.module$node_modules$$pixi$core$lib$filters$spriteMask$SpriteMaskFilter = function(global, require, module, exports) {
  var math = require("module$node_modules$$pixi$math$lib$index"), TextureMatrix = require("module$node_modules$$pixi$core$lib$textures$TextureMatrix");
  global = require("module$node_modules$$pixi$core$lib$filters$Filter");
  var spriteMaskFilter$1 = require("module$node_modules$$pixi$core$lib$filters$spriteMask$spriteMaskFilter_frag"), spriteMaskFilter = require("module$node_modules$$pixi$core$lib$filters$spriteMask$spriteMaskFilter_vert");
  class SpriteMaskFilter extends global.Filter {
    constructor(vertexSrc, fragmentSrc, uniforms) {
      let sprite = null;
      "string" != typeof vertexSrc && void 0 === fragmentSrc && void 0 === uniforms && (sprite = vertexSrc, vertexSrc = void 0, fragmentSrc = void 0, uniforms = void 0);
      super(vertexSrc || spriteMaskFilter.default, fragmentSrc || spriteMaskFilter$1.default, uniforms);
      this.maskSprite = sprite;
      this.maskMatrix = new math.Matrix();
    }
    get maskSprite() {
      return this._maskSprite;
    }
    set maskSprite(value) {
      (this._maskSprite = value) && (this._maskSprite.renderable = !1);
    }
    apply(filterManager, input, output, clearMode) {
      const maskSprite = this._maskSprite, tex = maskSprite._texture;
      tex.valid && (tex.uvMatrix || (tex.uvMatrix = new TextureMatrix.TextureMatrix(tex, 0)), tex.uvMatrix.update(), this.uniforms.npmAlpha = tex.baseTexture.alphaMode ? 0 : 1, this.uniforms.mask = tex, this.uniforms.otherMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, maskSprite).prepend(tex.uvMatrix.mapCoord), this.uniforms.alpha = maskSprite.worldAlpha, this.uniforms.maskClamp = tex.uvMatrix.uClampFrame, filterManager.applyFilter(this, input, output, clearMode));
    }
  }
  exports.SpriteMaskFilter = SpriteMaskFilter;
};

//# sourceMappingURL=module$node_modules$$pixi$core$lib$filters$spriteMask$SpriteMaskFilter.js.map
