shadow$provide.module$node_modules$$pixi$core$lib$shader$utils$generateUniformBufferSync = function(global, require, module, exports) {
  function uboUpdate(_ud, _uv, _renderer, _syncData, buffer) {
    _renderer.buffer.update(buffer);
  }
  function createUBOElements(uniformData) {
    uniformData = uniformData.map(data => ({data, offset:0, dataLen:0, dirty:0}));
    let size = 0, chunkSize = 0, offset = 0;
    for (let i = 0; i < uniformData.length; i++) {
      const uboElement = uniformData[i];
      if (size = GLSL_TO_STD40_SIZE[uboElement.data.type], 1 < uboElement.data.size && (size = Math.max(size, 16) * uboElement.data.size), uboElement.dataLen = size, 0 !== chunkSize % size && 16 > chunkSize) {
        const lineUpValue = chunkSize % size % 16;
        chunkSize += lineUpValue;
        offset += lineUpValue;
      }
      16 < chunkSize + size ? (offset = 16 * Math.ceil(offset / 16), uboElement.offset = offset, offset += size, chunkSize = size) : (uboElement.offset = offset, chunkSize += size, offset += size);
    }
    return offset = 16 * Math.ceil(offset / 16), {uboElements:uniformData, size:offset};
  }
  function getUBOData(uniforms, uniformData) {
    const usedUniformDatas = [];
    for (const i in uniforms) {
      uniformData[i] && usedUniformDatas.push(uniformData[i]);
    }
    return usedUniformDatas.sort((a, b) => a.index - b.index), usedUniformDatas;
  }
  require("module$node_modules$$pixi$core$lib$shader$utils$index");
  var uniformParsers = require("module$node_modules$$pixi$core$lib$shader$utils$uniformParsers"), mapSize = require("module$node_modules$$pixi$core$lib$shader$utils$mapSize");
  const UBO_TO_SINGLE_SETTERS = {float:"\n        data[offset] \x3d v;\n    ", vec2:"\n        data[offset] \x3d v[0];\n        data[offset+1] \x3d v[1];\n    ", vec3:"\n        data[offset] \x3d v[0];\n        data[offset+1] \x3d v[1];\n        data[offset+2] \x3d v[2];\n\n    ", vec4:"\n        data[offset] \x3d v[0];\n        data[offset+1] \x3d v[1];\n        data[offset+2] \x3d v[2];\n        data[offset+3] \x3d v[3];\n    ", mat2:"\n        data[offset] \x3d v[0];\n        data[offset+1] \x3d v[1];\n\n        data[offset+4] \x3d v[2];\n        data[offset+5] \x3d v[3];\n    ", 
  mat3:"\n        data[offset] \x3d v[0];\n        data[offset+1] \x3d v[1];\n        data[offset+2] \x3d v[2];\n\n        data[offset + 4] \x3d v[3];\n        data[offset + 5] \x3d v[4];\n        data[offset + 6] \x3d v[5];\n\n        data[offset + 8] \x3d v[6];\n        data[offset + 9] \x3d v[7];\n        data[offset + 10] \x3d v[8];\n    ", mat4:"\n        for(var i \x3d 0; i \x3c 16; i++)\n        {\n            data[offset + i] \x3d v[i];\n        }\n    "}, GLSL_TO_STD40_SIZE = {float:4, vec2:8, 
  vec3:12, vec4:16, int:4, ivec2:8, ivec3:12, ivec4:16, uint:4, uvec2:8, uvec3:12, uvec4:16, bool:4, bvec2:8, bvec3:12, bvec4:16, mat2:32, mat3:48, mat4:64};
  exports.createUBOElements = createUBOElements;
  exports.generateUniformBufferSync = function(group, uniformData) {
    if (!group.autoManage) {
      return {size:0, syncFunc:uboUpdate};
    }
    uniformData = getUBOData(group.uniforms, uniformData);
    const {uboElements, size} = createUBOElements(uniformData);
    uniformData = ["\n    var v \x3d null;\n    var v2 \x3d null;\n    var cv \x3d null;\n    var t \x3d 0;\n    var gl \x3d renderer.gl\n    var index \x3d 0;\n    var data \x3d buffer.data;\n    "];
    for (let i = 0; i < uboElements.length; i++) {
      const uboElement = uboElements[i];
      var uniform = group.uniforms[uboElement.data.name];
      const name = uboElement.data.name;
      var parsed = !1;
      for (let j = 0; j < uniformParsers.uniformParsers.length; j++) {
        const uniformParser = uniformParsers.uniformParsers[j];
        if (uniformParser.codeUbo && uniformParser.test(uboElement.data, uniform)) {
          uniformData.push(`offset = ${uboElement.offset / 4};`, uniformParsers.uniformParsers[j].codeUbo(uboElement.data.name, uniform));
          parsed = !0;
          break;
        }
      }
      parsed || (1 < uboElement.data.size ? (parsed = mapSize.mapSize(uboElement.data.type), uniform = Math.max(GLSL_TO_STD40_SIZE[uboElement.data.type] / 16, 1), parsed /= uniform, uniformData.push(`
                cv = ud.${name}.value;
                v = uv.${name};
                offset = ${uboElement.offset / 4};

                t = 0;

                for(var i=0; i < ${uboElement.data.size * uniform}; i++)
                {
                    for(var j = 0; j < ${parsed}; j++)
                    {
                        data[offset++] = v[t++];
                    }
                    offset += ${(4 - parsed % 4) % 4};
                }

                `)) : uniformData.push(`
                cv = ud.${name}.value;
                v = uv.${name};
                offset = ${uboElement.offset / 4};
                ${UBO_TO_SINGLE_SETTERS[uboElement.data.type]};
                `));
    }
    return uniformData.push("\n       renderer.buffer.update(buffer);\n    "), {size, syncFunc:new Function("ud", "uv", "renderer", "syncData", "buffer", uniformData.join("\n"))};
  };
  exports.getUBOData = getUBOData;
};

//# sourceMappingURL=module$node_modules$$pixi$core$lib$shader$utils$generateUniformBufferSync.js.map
