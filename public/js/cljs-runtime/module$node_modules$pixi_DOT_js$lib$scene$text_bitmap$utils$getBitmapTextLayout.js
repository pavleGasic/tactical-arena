shadow$provide.module$node_modules$pixi_DOT_js$lib$scene$text_bitmap$utils$getBitmapTextLayout = function(global, require, module, exports) {
  function alignCenter(measurementData) {
    for (let i = 0; i < measurementData.lines.length; i++) {
      const line = measurementData.lines[i], offset = measurementData.width / 2 - line.width / 2;
      for (let j = 0; j < line.charPositions.length; j++) {
        line.charPositions[j] += offset;
      }
    }
  }
  function alignRight(measurementData) {
    for (let i = 0; i < measurementData.lines.length; i++) {
      const line = measurementData.lines[i], offset = measurementData.width - line.width;
      for (let j = 0; j < line.charPositions.length; j++) {
        line.charPositions[j] += offset;
      }
    }
  }
  function alignJustify(measurementData) {
    const width = measurementData.width;
    for (let i = 0; i < measurementData.lines.length; i++) {
      const line = measurementData.lines[i];
      let indy = 0, spaceIndex = line.spacesIndex[indy++], offset = 0;
      const spaceWidth = (width - line.width) / line.spacesIndex.length;
      for (let j = 0; j < line.charPositions.length; j++) {
        j === spaceIndex && (spaceIndex = line.spacesIndex[indy++], offset += spaceWidth), line.charPositions[j] += offset;
      }
    }
  }
  exports.getBitmapTextLayout = function(chars, style, font, trimEnd) {
    const layoutData = {width:0, height:0, offsetY:0, scale:style.fontSize / font.baseMeasurementFontSize, lines:[{width:0, charPositions:[], spaceWidth:0, spacesIndex:[], chars:[]}]};
    layoutData.offsetY = font.baseLineOffset;
    let currentLine = layoutData.lines[0];
    var previousChar = null;
    let firstWord = !0;
    const currentWord = {spaceWord:!1, width:0, start:0, index:0, positions:[], chars:[]}, nextWord = word => {
      const start = currentLine.width;
      for (let j = 0; j < currentWord.index; j++) {
        const position = word.positions[j];
        currentLine.chars.push(word.chars[j]);
        currentLine.charPositions.push(position + start);
      }
      currentLine.width += word.width;
      firstWord = !1;
      currentWord.width = 0;
      currentWord.index = 0;
      currentWord.chars.length = 0;
    }, nextLine = () => {
      let index = currentLine.chars.length - 1;
      if (trimEnd) {
        let lastChar = currentLine.chars[index];
        for (; " " === lastChar;) {
          currentLine.width -= font.chars[lastChar].xAdvance, lastChar = currentLine.chars[--index];
        }
      }
      layoutData.width = Math.max(layoutData.width, currentLine.width);
      currentLine = {width:0, charPositions:[], chars:[], spaceWidth:0, spacesIndex:[]};
      firstWord = !0;
      layoutData.lines.push(currentLine);
      layoutData.height += font.lineHeight;
    };
    var scale = font.baseMeasurementFontSize / style.fontSize;
    const adjustedLetterSpacing = style.letterSpacing * scale;
    scale *= style.wordWrapWidth;
    for (let i = 0; i < chars.length + 1; i++) {
      let char;
      const isEnd = i === chars.length;
      isEnd || (char = chars[i]);
      var charData = font.chars[char] || font.chars[" "];
      /(?:\s)/.test(char) || "\r" === char || "\n" === char || isEnd ? (!firstWord && style.wordWrap && currentLine.width + currentWord.width - adjustedLetterSpacing > scale ? nextLine() : currentWord.start = currentLine.width, nextWord(currentWord), isEnd || currentLine.charPositions.push(0), "\r" === char || "\n" === char ? 0 !== currentLine.width && nextLine() : isEnd || (previousChar = charData.xAdvance + (charData.kerning[previousChar] || 0) + adjustedLetterSpacing, currentLine.width += previousChar, 
      currentLine.spaceWidth = previousChar, currentLine.spacesIndex.push(currentLine.charPositions.length), currentLine.chars.push(char))) : (previousChar = charData.kerning[previousChar] || 0, charData = charData.xAdvance + previousChar + adjustedLetterSpacing, currentWord.positions[currentWord.index++] = currentWord.width + previousChar, currentWord.chars.push(char), currentWord.width += charData);
      previousChar = char;
    }
    nextLine();
    "center" === style.align ? alignCenter(layoutData) : "right" === style.align ? alignRight(layoutData) : "justify" === style.align && alignJustify(layoutData);
    return layoutData;
  };
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$scene$text_bitmap$utils$getBitmapTextLayout.js.map
