shadow$provide.module$node_modules$pixi_DOT_js$lib$scene$mesh$shared$Mesh = function(global, require, module, exports) {
  var pointInTriangle = require("module$node_modules$pixi_DOT_js$lib$maths$point$pointInTriangle"), Geometry = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$geometry$Geometry"), State = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$state$State"), Texture = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$texture$Texture"), deprecation = require("module$node_modules$pixi_DOT_js$lib$utils$logging$deprecation");
  global = require("module$node_modules$pixi_DOT_js$lib$scene$view$ViewContainer");
  var MeshGeometry = require("module$node_modules$pixi_DOT_js$lib$scene$mesh$shared$MeshGeometry");
  "use strict";
  class Mesh extends global.ViewContainer {
    constructor(...args) {
      let options = args[0];
      options instanceof Geometry.Geometry && (deprecation.deprecation(deprecation.v8_0_0, "Mesh: use new Mesh({ geometry, shader }) instead"), options = {geometry:options, shader:args[1]}, args[3] && (deprecation.deprecation(deprecation.v8_0_0, "Mesh: drawMode argument has been removed, use geometry.topology instead"), options.geometry.topology = args[3]));
      const {geometry, shader, texture, roundPixels, state, ...rest} = options;
      super({label:"Mesh", ...rest});
      this.renderPipeId = "mesh";
      this._shader = null;
      this.allowChildren = !1;
      this.shader = shader ?? null;
      this.texture = texture ?? shader?.texture ?? Texture.Texture.WHITE;
      this.state = state ?? State.State.for2d();
      this._geometry = geometry;
      this._geometry.on("update", this.onViewUpdate, this);
      this.roundPixels = roundPixels ?? !1;
    }
    get material() {
      deprecation.deprecation(deprecation.v8_0_0, "mesh.material property has been removed, use mesh.shader instead");
      return this._shader;
    }
    set shader(value) {
      this._shader !== value && (this._shader = value, this.onViewUpdate());
    }
    get shader() {
      return this._shader;
    }
    set geometry(value) {
      this._geometry !== value && (this._geometry?.off("update", this.onViewUpdate, this), value.on("update", this.onViewUpdate, this), this._geometry = value, this.onViewUpdate());
    }
    get geometry() {
      return this._geometry;
    }
    set texture(value) {
      value || (value = Texture.Texture.EMPTY);
      const currentTexture = this._texture;
      if (currentTexture !== value) {
        currentTexture && currentTexture.dynamic && currentTexture.off("update", this.onViewUpdate, this);
        if (value.dynamic) {
          value.on("update", this.onViewUpdate, this);
        }
        this.shader && (this.shader.texture = value);
        this._texture = value;
        this.onViewUpdate();
      }
    }
    get texture() {
      return this._texture;
    }
    get batched() {
      return this._shader || 0 !== (this.state.data & 12) ? !1 : this._geometry instanceof MeshGeometry.MeshGeometry ? "auto" === this._geometry.batchMode ? 100 >= this._geometry.positions.length / 2 : "batch" === this._geometry.batchMode : !1;
    }
    get bounds() {
      return this._geometry.bounds;
    }
    updateBounds() {
      this._bounds = this._geometry.bounds;
    }
    containsPoint(point) {
      const {x, y} = point;
      if (!this.bounds.containsPoint(x, y)) {
        return !1;
      }
      point = this.geometry.getBuffer("aPosition").data;
      const step = "triangle-strip" === this.geometry.topology ? 3 : 1;
      if (this.geometry.getIndex()) {
        var indices = this.geometry.getIndex().data, len = indices.length;
        for (var i = 0; i + 2 < len; i += step) {
          var ind0 = 2 * indices[i], ind1 = 2 * indices[i + 1];
          const ind2 = 2 * indices[i + 2];
          if (pointInTriangle.pointInTriangle(x, y, point[ind0], point[ind0 + 1], point[ind1], point[ind1 + 1], point[ind2], point[ind2 + 1])) {
            return !0;
          }
        }
      } else {
        for (indices = point.length / 2, len = 0; len + 2 < indices; len += step) {
          if (i = 2 * len, ind0 = 2 * (len + 1), ind1 = 2 * (len + 2), pointInTriangle.pointInTriangle(x, y, point[i], point[i + 1], point[ind0], point[ind0 + 1], point[ind1], point[ind1 + 1])) {
            return !0;
          }
        }
      }
      return !1;
    }
    destroy(options) {
      super.destroy(options);
      ("boolean" === typeof options ? options : options?.texture) && this._texture.destroy("boolean" === typeof options ? options : options?.textureSource);
      this._geometry?.off("update", this.onViewUpdate, this);
      this._shader = this._geometry = this._texture = null;
    }
  }
  exports.Mesh = Mesh;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$scene$mesh$shared$Mesh.js.map
