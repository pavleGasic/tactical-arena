shadow$provide.module$node_modules$$pixi$prepare$lib$Prepare = function(global, require, module, exports) {
  function uploadBaseTextures(renderer, item) {
    return item instanceof core.BaseTexture ? (item._glTextures[renderer.CONTEXT_UID] || renderer.texture.bind(item), !0) : !1;
  }
  function uploadGraphics(renderer, item) {
    if (!(item instanceof graphics.Graphics)) {
      return !1;
    }
    const {geometry} = item;
    item.finishPoly();
    geometry.updateBatches();
    const {batches} = geometry;
    for (let i = 0; i < batches.length; i++) {
      const {texture} = batches[i].style;
      texture && uploadBaseTextures(renderer, texture.baseTexture);
    }
    return geometry.batchable || renderer.geometry.bind(geometry, item._resolveDirectShader(renderer)), !0;
  }
  function findGraphics(item, queue) {
    return item instanceof graphics.Graphics ? (queue.push(item), !0) : !1;
  }
  var core = require("module$node_modules$$pixi$core$lib$index"), graphics = require("module$node_modules$$pixi$graphics$lib$index");
  global = require("module$node_modules$$pixi$prepare$lib$BasePrepare");
  class Prepare extends global.BasePrepare {
    constructor(renderer) {
      super(renderer);
      this.uploadHookHelper = this.renderer;
      this.registerFindHook(findGraphics);
      this.registerUploadHook(uploadBaseTextures);
      this.registerUploadHook(uploadGraphics);
    }
  }
  Prepare.extension = {name:"prepare", type:core.ExtensionType.RendererSystem};
  core.extensions.add(Prepare);
  exports.Prepare = Prepare;
};

//# sourceMappingURL=module$node_modules$$pixi$prepare$lib$Prepare.js.map
