shadow$provide.module$node_modules$pixi_DOT_js$lib$filters$defaults$color_matrix$colorMatrixFilter_wgsl = function(global, require, module, exports) {
  Object.defineProperty(exports, "__esModule", {value:!0});
  exports.default = "struct GlobalFilterUniforms {\n  uInputSize:vec4\x3cf32\x3e,\n  uInputPixel:vec4\x3cf32\x3e,\n  uInputClamp:vec4\x3cf32\x3e,\n  uOutputFrame:vec4\x3cf32\x3e,\n  uGlobalFrame:vec4\x3cf32\x3e,\n  uOutputTexture:vec4\x3cf32\x3e,\n};\n\nstruct ColorMatrixUniforms {\n  uColorMatrix:array\x3cvec4\x3cf32\x3e, 5\x3e,\n  uAlpha:f32,\n};\n\n\n@group(0) @binding(0) var\x3cuniform\x3e gfu: GlobalFilterUniforms;\n@group(0) @binding(1) var uTexture: texture_2d\x3cf32\x3e;\n@group(0) @binding(2) var uSampler : sampler;\n@group(1) @binding(0) var\x3cuniform\x3e colorMatrixUniforms : ColorMatrixUniforms;\n\n\nstruct VSOutput {\n    @builtin(position) position: vec4\x3cf32\x3e,\n    @location(0) uv : vec2\x3cf32\x3e,\n  };\n  \nfn filterVertexPosition(aPosition:vec2\x3cf32\x3e) -\x3e vec4\x3cf32\x3e\n{\n    var position \x3d aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x \x3d position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y \x3d position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2\x3cf32\x3e ) -\x3e vec2\x3cf32\x3e\n{\n  return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2\x3cf32\x3e, \n) -\x3e VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition),\n  );\n}\n\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2\x3cf32\x3e,\n) -\x3e @location(0) vec4\x3cf32\x3e {\n\n\n  var c \x3d textureSample(uTexture, uSampler, uv);\n  \n  if (colorMatrixUniforms.uAlpha \x3d\x3d 0.0) {\n    return c;\n  }\n\n \n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (c.a \x3e 0.0) {\n      c.r /\x3d c.a;\n      c.g /\x3d c.a;\n      c.b /\x3d c.a;\n    }\n\n    var cm \x3d colorMatrixUniforms.uColorMatrix;\n\n\n    var result \x3d vec4\x3cf32\x3e(0.);\n\n    result.r \x3d (cm[0][0] * c.r);\n    result.r +\x3d (cm[0][1] * c.g);\n    result.r +\x3d (cm[0][2] * c.b);\n    result.r +\x3d (cm[0][3] * c.a);\n    result.r +\x3d cm[1][0];\n\n    result.g \x3d (cm[1][1] * c.r);\n    result.g +\x3d (cm[1][2] * c.g);\n    result.g +\x3d (cm[1][3] * c.b);\n    result.g +\x3d (cm[2][0] * c.a);\n    result.g +\x3d cm[2][1];\n\n    result.b \x3d (cm[2][2] * c.r);\n    result.b +\x3d (cm[2][3] * c.g);\n    result.b +\x3d (cm[3][0] * c.b);\n    result.b +\x3d (cm[3][1] * c.a);\n    result.b +\x3d cm[3][2];\n\n    result.a \x3d (cm[3][3] * c.r);\n    result.a +\x3d (cm[4][0] * c.g);\n    result.a +\x3d (cm[4][1] * c.b);\n    result.a +\x3d (cm[4][2] * c.a);\n    result.a +\x3d cm[4][3];\n\n    var rgb \x3d mix(c.rgb, result.rgb, colorMatrixUniforms.uAlpha);\n\n    rgb.r *\x3d result.a;\n    rgb.g *\x3d result.a;\n    rgb.b *\x3d result.a;\n\n    return vec4(rgb, result.a);\n}";
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$filters$defaults$color_matrix$colorMatrixFilter_wgsl.js.map
