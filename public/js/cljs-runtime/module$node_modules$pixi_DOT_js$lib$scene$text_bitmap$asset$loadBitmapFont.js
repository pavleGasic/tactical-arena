shadow$provide.module$node_modules$pixi_DOT_js$lib$scene$text_bitmap$asset$loadBitmapFont = function(global, require, module, exports) {
  module = require("module$node_modules$pixi_DOT_js$lib$assets$loader$parsers$LoaderParser");
  var copySearchParams = require("module$node_modules$pixi_DOT_js$lib$assets$utils$copySearchParams"), adapter = require("module$node_modules$pixi_DOT_js$lib$environment$adapter");
  global = require("module$node_modules$pixi_DOT_js$lib$extensions$Extensions");
  var path = require("module$node_modules$pixi_DOT_js$lib$utils$path"), BitmapFont = require("module$node_modules$pixi_DOT_js$lib$scene$text_bitmap$BitmapFont"), bitmapFontTextParser = require("module$node_modules$pixi_DOT_js$lib$scene$text_bitmap$asset$bitmapFontTextParser"), bitmapFontXMLStringParser = require("module$node_modules$pixi_DOT_js$lib$scene$text_bitmap$asset$bitmapFontXMLStringParser");
  "use strict";
  const validExtensions = [".xml", ".fnt"];
  require = {extension:{type:global.ExtensionType.LoadParser, priority:module.LoaderParserPriority.Normal}, name:"loadBitmapFont", test(url) {
    return validExtensions.includes(path.path.extname(url).toLowerCase());
  }, async testParse(data) {
    return bitmapFontTextParser.bitmapFontTextParser.test(data) || bitmapFontXMLStringParser.bitmapFontXMLStringParser.test(data);
  }, async parse(asset, data, loader) {
    asset = bitmapFontTextParser.bitmapFontTextParser.test(asset) ? bitmapFontTextParser.bitmapFontTextParser.parse(asset) : bitmapFontXMLStringParser.bitmapFontXMLStringParser.parse(asset);
    ({src:data} = data);
    const {pages} = asset, textureUrls = [], textureOptions = asset.distanceField ? {scaleMode:"linear", alphaMode:"premultiply-alpha-on-upload", autoGenerateMipmaps:!1, resolution:1} : {};
    for (let i = 0; i < pages.length; ++i) {
      var pageFile = pages[i].file;
      pageFile = path.path.join(path.path.dirname(data), pageFile);
      pageFile = copySearchParams.copySearchParams(pageFile, data);
      textureUrls.push({src:pageFile, data:textureOptions});
    }
    const loadedTextures = await loader.load(textureUrls);
    loader = textureUrls.map(url => loadedTextures[url.src]);
    return new BitmapFont.BitmapFont({data:asset, textures:loader}, data);
  }, async load(url, _options) {
    return await (await adapter.DOMAdapter.get().fetch(url)).text();
  }, async unload(bitmapFont, _resolvedAsset, loader) {
    await Promise.all(bitmapFont.pages.map(page => loader.unload(page.texture.source._sourceOrigin)));
    bitmapFont.destroy();
  }};
  exports.bitmapFontCachePlugin = {extension:{type:global.ExtensionType.CacheParser, name:"cacheBitmapFont"}, test:asset => asset instanceof BitmapFont.BitmapFont, getCacheableAssets(keys, asset) {
    const out = {};
    keys.forEach(key => {
      out[key] = asset;
      out[`${key}-bitmap`] = asset;
    });
    out[`${asset.fontFamily}-bitmap`] = asset;
    return out;
  }};
  exports.loadBitmapFont = require;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$scene$text_bitmap$asset$loadBitmapFont.js.map
