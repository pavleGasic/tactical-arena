{
"version":3,
"file":"module$node_modules$pixi_DOT_js$lib$rendering$renderers$gpu$texture$utils$GpuMipmapGenerator.js",
"lineCount":49,
"mappings":"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",
"sources":["node_modules/pixi_DOT_js/lib/rendering/renderers/gpu/texture/utils/GpuMipmapGenerator.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$pixi_DOT_js$lib$rendering$renderers$gpu$texture$utils$GpuMipmapGenerator\"] = function(global,require,module,exports) {\n'use strict';\n\n\"use strict\";\nclass GpuMipmapGenerator {\n  constructor(device) {\n    this.device = device;\n    this.sampler = device.createSampler({ minFilter: \"linear\" });\n    this.pipelines = {};\n  }\n  _getMipmapPipeline(format) {\n    let pipeline = this.pipelines[format];\n    if (!pipeline) {\n      if (!this.mipmapShaderModule) {\n        this.mipmapShaderModule = this.device.createShaderModule({\n          code: (\n            /* wgsl */\n            `\n                        var<private> pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(\n                        vec2<f32>(-1.0, -1.0), vec2<f32>(-1.0, 3.0), vec2<f32>(3.0, -1.0));\n\n                        struct VertexOutput {\n                        @builtin(position) position : vec4<f32>,\n                        @location(0) texCoord : vec2<f32>,\n                        };\n\n                        @vertex\n                        fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {\n                        var output : VertexOutput;\n                        output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);\n                        output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);\n                        return output;\n                        }\n\n                        @group(0) @binding(0) var imgSampler : sampler;\n                        @group(0) @binding(1) var img : texture_2d<f32>;\n\n                        @fragment\n                        fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {\n                        return textureSample(img, imgSampler, texCoord);\n                        }\n                    `\n          )\n        });\n      }\n      pipeline = this.device.createRenderPipeline({\n        layout: \"auto\",\n        vertex: {\n          module: this.mipmapShaderModule,\n          entryPoint: \"vertexMain\"\n        },\n        fragment: {\n          module: this.mipmapShaderModule,\n          entryPoint: \"fragmentMain\",\n          targets: [{ format }]\n        }\n      });\n      this.pipelines[format] = pipeline;\n    }\n    return pipeline;\n  }\n  /**\n   * Generates mipmaps for the given GPUTexture from the data in level 0.\n   * @param {module:External.GPUTexture} texture - Texture to generate mipmaps for.\n   * @returns {module:External.GPUTexture} - The originally passed texture\n   */\n  generateMipmap(texture) {\n    const pipeline = this._getMipmapPipeline(texture.format);\n    if (texture.dimension === \"3d\" || texture.dimension === \"1d\") {\n      throw new Error(\"Generating mipmaps for non-2d textures is currently unsupported!\");\n    }\n    let mipTexture = texture;\n    const arrayLayerCount = texture.depthOrArrayLayers || 1;\n    const renderToSource = texture.usage & GPUTextureUsage.RENDER_ATTACHMENT;\n    if (!renderToSource) {\n      const mipTextureDescriptor = {\n        size: {\n          width: Math.ceil(texture.width / 2),\n          height: Math.ceil(texture.height / 2),\n          depthOrArrayLayers: arrayLayerCount\n        },\n        format: texture.format,\n        usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n        mipLevelCount: texture.mipLevelCount - 1\n      };\n      mipTexture = this.device.createTexture(mipTextureDescriptor);\n    }\n    const commandEncoder = this.device.createCommandEncoder({});\n    const bindGroupLayout = pipeline.getBindGroupLayout(0);\n    for (let arrayLayer = 0; arrayLayer < arrayLayerCount; ++arrayLayer) {\n      let srcView = texture.createView({\n        baseMipLevel: 0,\n        mipLevelCount: 1,\n        dimension: \"2d\",\n        baseArrayLayer: arrayLayer,\n        arrayLayerCount: 1\n      });\n      let dstMipLevel = renderToSource ? 1 : 0;\n      for (let i = 1; i < texture.mipLevelCount; ++i) {\n        const dstView = mipTexture.createView({\n          baseMipLevel: dstMipLevel++,\n          mipLevelCount: 1,\n          dimension: \"2d\",\n          baseArrayLayer: arrayLayer,\n          arrayLayerCount: 1\n        });\n        const passEncoder = commandEncoder.beginRenderPass({\n          colorAttachments: [{\n            view: dstView,\n            storeOp: \"store\",\n            loadOp: \"clear\",\n            clearValue: { r: 0, g: 0, b: 0, a: 0 }\n          }]\n        });\n        const bindGroup = this.device.createBindGroup({\n          layout: bindGroupLayout,\n          entries: [{\n            binding: 0,\n            resource: this.sampler\n          }, {\n            binding: 1,\n            resource: srcView\n          }]\n        });\n        passEncoder.setPipeline(pipeline);\n        passEncoder.setBindGroup(0, bindGroup);\n        passEncoder.draw(3, 1, 0, 0);\n        passEncoder.end();\n        srcView = dstView;\n      }\n    }\n    if (!renderToSource) {\n      const mipLevelSize = {\n        width: Math.ceil(texture.width / 2),\n        height: Math.ceil(texture.height / 2),\n        depthOrArrayLayers: arrayLayerCount\n      };\n      for (let i = 1; i < texture.mipLevelCount; ++i) {\n        commandEncoder.copyTextureToTexture({\n          texture: mipTexture,\n          mipLevel: i - 1\n        }, {\n          texture,\n          mipLevel: i\n        }, mipLevelSize);\n        mipLevelSize.width = Math.ceil(mipLevelSize.width / 2);\n        mipLevelSize.height = Math.ceil(mipLevelSize.height / 2);\n      }\n    }\n    this.device.queue.submit([commandEncoder.finish()]);\n    if (!renderToSource) {\n      mipTexture.destroy();\n    }\n    return texture;\n  }\n}\n\nexports.GpuMipmapGenerator = GpuMipmapGenerator;\n//# sourceMappingURL=GpuMipmapGenerator.js.map\n\n};"],
"names":["shadow$provide","global","require","module","exports","GpuMipmapGenerator","constructor","device","sampler","createSampler","minFilter","pipelines","_getMipmapPipeline","format","pipeline","mipmapShaderModule","createShaderModule","code","createRenderPipeline","layout","vertex","entryPoint","fragment","targets","generateMipmap","texture","dimension","Error","mipTexture","arrayLayerCount","depthOrArrayLayers","renderToSource","usage","GPUTextureUsage","RENDER_ATTACHMENT","createTexture","mipTextureDescriptor","size","width","Math","ceil","height","TEXTURE_BINDING","COPY_SRC","mipLevelCount","commandEncoder","createCommandEncoder","bindGroupLayout","getBindGroupLayout","arrayLayer","srcView","createView","baseMipLevel","baseArrayLayer","dstMipLevel","i","dstView","passEncoder","beginRenderPass","colorAttachments","view","storeOp","loadOp","clearValue","r","g","b","a","bindGroup","createBindGroup","entries","binding","resource","setPipeline","setBindGroup","draw","end","mipLevelSize","copyTextureToTexture","mipLevel","queue","submit","finish","destroy"]
}
