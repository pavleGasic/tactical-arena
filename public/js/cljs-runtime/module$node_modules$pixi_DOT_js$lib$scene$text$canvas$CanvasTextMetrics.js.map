{
"version":3,
"file":"module$node_modules$pixi_DOT_js$lib$scene$text$canvas$CanvasTextMetrics.js",
"lineCount":222,
"mappings":"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",
"sources":["node_modules/pixi_DOT_js/lib/scene/text/canvas/CanvasTextMetrics.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$pixi_DOT_js$lib$scene$text$canvas$CanvasTextMetrics\"] = function(global,require,module,exports) {\n'use strict';\n\nvar adapter = require('../../../environment/adapter.js');\nvar fontStringFromTextStyle = require('./utils/fontStringFromTextStyle.js');\n\n\"use strict\";\nconst contextSettings = {\n  // TextMetrics requires getImageData readback for measuring fonts.\n  willReadFrequently: true\n};\nconst _CanvasTextMetrics = class _CanvasTextMetrics {\n  /**\n   * Checking that we can use modern canvas 2D API.\n   *\n   * Note: This is an unstable API, Chrome < 94 use `textLetterSpacing`, later versions use `letterSpacing`.\n   * @see TextMetrics.experimentalLetterSpacing\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/ICanvasRenderingContext2D/letterSpacing\n   * @see https://developer.chrome.com/origintrials/#/view_trial/3585991203293757441\n   */\n  static get experimentalLetterSpacingSupported() {\n    let result = _CanvasTextMetrics._experimentalLetterSpacingSupported;\n    if (result !== void 0) {\n      const proto = adapter.DOMAdapter.get().getCanvasRenderingContext2D().prototype;\n      result = _CanvasTextMetrics._experimentalLetterSpacingSupported = \"letterSpacing\" in proto || \"textLetterSpacing\" in proto;\n    }\n    return result;\n  }\n  /**\n   * @param text - the text that was measured\n   * @param style - the style that was measured\n   * @param width - the measured width of the text\n   * @param height - the measured height of the text\n   * @param lines - an array of the lines of text broken by new lines and wrapping if specified in style\n   * @param lineWidths - an array of the line widths for each line matched to `lines`\n   * @param lineHeight - the measured line height for this style\n   * @param maxLineWidth - the maximum line width for all measured lines\n   * @param {FontMetrics} fontProperties - the font properties object from TextMetrics.measureFont\n   */\n  constructor(text, style, width, height, lines, lineWidths, lineHeight, maxLineWidth, fontProperties) {\n    this.text = text;\n    this.style = style;\n    this.width = width;\n    this.height = height;\n    this.lines = lines;\n    this.lineWidths = lineWidths;\n    this.lineHeight = lineHeight;\n    this.maxLineWidth = maxLineWidth;\n    this.fontProperties = fontProperties;\n  }\n  /**\n   * Measures the supplied string of text and returns a Rectangle.\n   * @param text - The text to measure.\n   * @param style - The text style to use for measuring\n   * @param canvas - optional specification of the canvas to use for measuring.\n   * @param wordWrap\n   * @returns Measured width and height of the text.\n   */\n  static measureText(text = \" \", style, canvas = _CanvasTextMetrics._canvas, wordWrap = style.wordWrap) {\n    const textKey = `${text}:${style.styleKey}`;\n    if (_CanvasTextMetrics._measurementCache[textKey])\n      return _CanvasTextMetrics._measurementCache[textKey];\n    const font = fontStringFromTextStyle.fontStringFromTextStyle(style);\n    const fontProperties = _CanvasTextMetrics.measureFont(font);\n    if (fontProperties.fontSize === 0) {\n      fontProperties.fontSize = style.fontSize;\n      fontProperties.ascent = style.fontSize;\n    }\n    const context = _CanvasTextMetrics.__context;\n    context.font = font;\n    const outputText = wordWrap ? _CanvasTextMetrics._wordWrap(text, style, canvas) : text;\n    const lines = outputText.split(/(?:\\r\\n|\\r|\\n)/);\n    const lineWidths = new Array(lines.length);\n    let maxLineWidth = 0;\n    for (let i = 0; i < lines.length; i++) {\n      const lineWidth = _CanvasTextMetrics._measureText(lines[i], style.letterSpacing, context);\n      lineWidths[i] = lineWidth;\n      maxLineWidth = Math.max(maxLineWidth, lineWidth);\n    }\n    const strokeWidth = style._stroke?.width || 0;\n    let width = maxLineWidth + strokeWidth;\n    if (style.dropShadow) {\n      width += style.dropShadow.distance;\n    }\n    const lineHeight = style.lineHeight || fontProperties.fontSize;\n    let height = Math.max(lineHeight, fontProperties.fontSize + strokeWidth) + (lines.length - 1) * (lineHeight + style.leading);\n    if (style.dropShadow) {\n      height += style.dropShadow.distance;\n    }\n    const measurements = new _CanvasTextMetrics(\n      text,\n      style,\n      width,\n      height,\n      lines,\n      lineWidths,\n      lineHeight + style.leading,\n      maxLineWidth,\n      fontProperties\n    );\n    return measurements;\n  }\n  static _measureText(text, letterSpacing, context) {\n    let useExperimentalLetterSpacing = false;\n    if (_CanvasTextMetrics.experimentalLetterSpacingSupported) {\n      if (_CanvasTextMetrics.experimentalLetterSpacing) {\n        context.letterSpacing = `${letterSpacing}px`;\n        context.textLetterSpacing = `${letterSpacing}px`;\n        useExperimentalLetterSpacing = true;\n      } else {\n        context.letterSpacing = \"0px\";\n        context.textLetterSpacing = \"0px\";\n      }\n    }\n    const metrics = context.measureText(text);\n    let metricWidth = metrics.width;\n    const actualBoundingBoxLeft = -metrics.actualBoundingBoxLeft;\n    const actualBoundingBoxRight = metrics.actualBoundingBoxRight;\n    let boundsWidth = actualBoundingBoxRight - actualBoundingBoxLeft;\n    if (metricWidth > 0) {\n      if (useExperimentalLetterSpacing) {\n        metricWidth -= letterSpacing;\n        boundsWidth -= letterSpacing;\n      } else {\n        const val = (_CanvasTextMetrics.graphemeSegmenter(text).length - 1) * letterSpacing;\n        metricWidth += val;\n        boundsWidth += val;\n      }\n    }\n    return Math.max(metricWidth, boundsWidth);\n  }\n  /**\n   * Applies newlines to a string to have it optimally fit into the horizontal\n   * bounds set by the Text object's wordWrapWidth property.\n   * @param text - String to apply word wrapping to\n   * @param style - the style to use when wrapping\n   * @param canvas - optional specification of the canvas to use for measuring.\n   * @returns New string with new lines applied where required\n   */\n  static _wordWrap(text, style, canvas = _CanvasTextMetrics._canvas) {\n    const context = canvas.getContext(\"2d\", contextSettings);\n    let width = 0;\n    let line = \"\";\n    let lines = \"\";\n    const cache = /* @__PURE__ */ Object.create(null);\n    const { letterSpacing, whiteSpace } = style;\n    const collapseSpaces = _CanvasTextMetrics._collapseSpaces(whiteSpace);\n    const collapseNewlines = _CanvasTextMetrics._collapseNewlines(whiteSpace);\n    let canPrependSpaces = !collapseSpaces;\n    const wordWrapWidth = style.wordWrapWidth + letterSpacing;\n    const tokens = _CanvasTextMetrics._tokenize(text);\n    for (let i = 0; i < tokens.length; i++) {\n      let token = tokens[i];\n      if (_CanvasTextMetrics._isNewline(token)) {\n        if (!collapseNewlines) {\n          lines += _CanvasTextMetrics._addLine(line);\n          canPrependSpaces = !collapseSpaces;\n          line = \"\";\n          width = 0;\n          continue;\n        }\n        token = \" \";\n      }\n      if (collapseSpaces) {\n        const currIsBreakingSpace = _CanvasTextMetrics.isBreakingSpace(token);\n        const lastIsBreakingSpace = _CanvasTextMetrics.isBreakingSpace(line[line.length - 1]);\n        if (currIsBreakingSpace && lastIsBreakingSpace) {\n          continue;\n        }\n      }\n      const tokenWidth = _CanvasTextMetrics._getFromCache(token, letterSpacing, cache, context);\n      if (tokenWidth > wordWrapWidth) {\n        if (line !== \"\") {\n          lines += _CanvasTextMetrics._addLine(line);\n          line = \"\";\n          width = 0;\n        }\n        if (_CanvasTextMetrics.canBreakWords(token, style.breakWords)) {\n          const characters = _CanvasTextMetrics.wordWrapSplit(token);\n          for (let j = 0; j < characters.length; j++) {\n            let char = characters[j];\n            let lastChar = char;\n            let k = 1;\n            while (characters[j + k]) {\n              const nextChar = characters[j + k];\n              if (!_CanvasTextMetrics.canBreakChars(lastChar, nextChar, token, j, style.breakWords)) {\n                char += nextChar;\n              } else {\n                break;\n              }\n              lastChar = nextChar;\n              k++;\n            }\n            j += k - 1;\n            const characterWidth = _CanvasTextMetrics._getFromCache(char, letterSpacing, cache, context);\n            if (characterWidth + width > wordWrapWidth) {\n              lines += _CanvasTextMetrics._addLine(line);\n              canPrependSpaces = false;\n              line = \"\";\n              width = 0;\n            }\n            line += char;\n            width += characterWidth;\n          }\n        } else {\n          if (line.length > 0) {\n            lines += _CanvasTextMetrics._addLine(line);\n            line = \"\";\n            width = 0;\n          }\n          const isLastToken = i === tokens.length - 1;\n          lines += _CanvasTextMetrics._addLine(token, !isLastToken);\n          canPrependSpaces = false;\n          line = \"\";\n          width = 0;\n        }\n      } else {\n        if (tokenWidth + width > wordWrapWidth) {\n          canPrependSpaces = false;\n          lines += _CanvasTextMetrics._addLine(line);\n          line = \"\";\n          width = 0;\n        }\n        if (line.length > 0 || !_CanvasTextMetrics.isBreakingSpace(token) || canPrependSpaces) {\n          line += token;\n          width += tokenWidth;\n        }\n      }\n    }\n    lines += _CanvasTextMetrics._addLine(line, false);\n    return lines;\n  }\n  /**\n   * Convenience function for logging each line added during the wordWrap method.\n   * @param line    - The line of text to add\n   * @param newLine - Add new line character to end\n   * @returns A formatted line\n   */\n  static _addLine(line, newLine = true) {\n    line = _CanvasTextMetrics._trimRight(line);\n    line = newLine ? `${line}\n` : line;\n    return line;\n  }\n  /**\n   * Gets & sets the widths of calculated characters in a cache object\n   * @param key            - The key\n   * @param letterSpacing  - The letter spacing\n   * @param cache          - The cache\n   * @param context        - The canvas context\n   * @returns The from cache.\n   */\n  static _getFromCache(key, letterSpacing, cache, context) {\n    let width = cache[key];\n    if (typeof width !== \"number\") {\n      width = _CanvasTextMetrics._measureText(key, letterSpacing, context) + letterSpacing;\n      cache[key] = width;\n    }\n    return width;\n  }\n  /**\n   * Determines whether we should collapse breaking spaces.\n   * @param whiteSpace - The TextStyle property whiteSpace\n   * @returns Should collapse\n   */\n  static _collapseSpaces(whiteSpace) {\n    return whiteSpace === \"normal\" || whiteSpace === \"pre-line\";\n  }\n  /**\n   * Determines whether we should collapse newLine chars.\n   * @param whiteSpace - The white space\n   * @returns should collapse\n   */\n  static _collapseNewlines(whiteSpace) {\n    return whiteSpace === \"normal\";\n  }\n  /**\n   * Trims breaking whitespaces from string.\n   * @param text - The text\n   * @returns Trimmed string\n   */\n  static _trimRight(text) {\n    if (typeof text !== \"string\") {\n      return \"\";\n    }\n    for (let i = text.length - 1; i >= 0; i--) {\n      const char = text[i];\n      if (!_CanvasTextMetrics.isBreakingSpace(char)) {\n        break;\n      }\n      text = text.slice(0, -1);\n    }\n    return text;\n  }\n  /**\n   * Determines if char is a newline.\n   * @param char - The character\n   * @returns True if newline, False otherwise.\n   */\n  static _isNewline(char) {\n    if (typeof char !== \"string\") {\n      return false;\n    }\n    return _CanvasTextMetrics._newlines.includes(char.charCodeAt(0));\n  }\n  /**\n   * Determines if char is a breaking whitespace.\n   *\n   * It allows one to determine whether char should be a breaking whitespace\n   * For example certain characters in CJK langs or numbers.\n   * It must return a boolean.\n   * @param char - The character\n   * @param [_nextChar] - The next character\n   * @returns True if whitespace, False otherwise.\n   */\n  static isBreakingSpace(char, _nextChar) {\n    if (typeof char !== \"string\") {\n      return false;\n    }\n    return _CanvasTextMetrics._breakingSpaces.includes(char.charCodeAt(0));\n  }\n  /**\n   * Splits a string into words, breaking-spaces and newLine characters\n   * @param text - The text\n   * @returns A tokenized array\n   */\n  static _tokenize(text) {\n    const tokens = [];\n    let token = \"\";\n    if (typeof text !== \"string\") {\n      return tokens;\n    }\n    for (let i = 0; i < text.length; i++) {\n      const char = text[i];\n      const nextChar = text[i + 1];\n      if (_CanvasTextMetrics.isBreakingSpace(char, nextChar) || _CanvasTextMetrics._isNewline(char)) {\n        if (token !== \"\") {\n          tokens.push(token);\n          token = \"\";\n        }\n        tokens.push(char);\n        continue;\n      }\n      token += char;\n    }\n    if (token !== \"\") {\n      tokens.push(token);\n    }\n    return tokens;\n  }\n  /**\n   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n   *\n   * It allows one to customise which words should break\n   * Examples are if the token is CJK or numbers.\n   * It must return a boolean.\n   * @param _token - The token\n   * @param breakWords - The style attr break words\n   * @returns Whether to break word or not\n   */\n  static canBreakWords(_token, breakWords) {\n    return breakWords;\n  }\n  /**\n   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n   *\n   * It allows one to determine whether a pair of characters\n   * should be broken by newlines\n   * For example certain characters in CJK langs or numbers.\n   * It must return a boolean.\n   * @param _char - The character\n   * @param _nextChar - The next character\n   * @param _token - The token/word the characters are from\n   * @param _index - The index in the token of the char\n   * @param _breakWords - The style attr break words\n   * @returns whether to break word or not\n   */\n  static canBreakChars(_char, _nextChar, _token, _index, _breakWords) {\n    return true;\n  }\n  /**\n   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n   *\n   * It is called when a token (usually a word) has to be split into separate pieces\n   * in order to determine the point to break a word.\n   * It must return an array of characters.\n   * @param token - The token to split\n   * @returns The characters of the token\n   * @see CanvasTextMetrics.graphemeSegmenter\n   */\n  static wordWrapSplit(token) {\n    return _CanvasTextMetrics.graphemeSegmenter(token);\n  }\n  /**\n   * Calculates the ascent, descent and fontSize of a given font-style\n   * @param font - String representing the style of the font\n   * @returns Font properties object\n   */\n  static measureFont(font) {\n    if (_CanvasTextMetrics._fonts[font]) {\n      return _CanvasTextMetrics._fonts[font];\n    }\n    const context = _CanvasTextMetrics._context;\n    context.font = font;\n    const metrics = context.measureText(_CanvasTextMetrics.METRICS_STRING + _CanvasTextMetrics.BASELINE_SYMBOL);\n    const properties = {\n      ascent: metrics.actualBoundingBoxAscent,\n      descent: metrics.actualBoundingBoxDescent,\n      fontSize: metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent\n    };\n    _CanvasTextMetrics._fonts[font] = properties;\n    return properties;\n  }\n  /**\n   * Clear font metrics in metrics cache.\n   * @param {string} [font] - font name. If font name not set then clear cache for all fonts.\n   */\n  static clearMetrics(font = \"\") {\n    if (font) {\n      delete _CanvasTextMetrics._fonts[font];\n    } else {\n      _CanvasTextMetrics._fonts = {};\n    }\n  }\n  /**\n   * Cached canvas element for measuring text\n   * TODO: this should be private, but isn't because of backward compat, will fix later.\n   * @ignore\n   */\n  static get _canvas() {\n    if (!_CanvasTextMetrics.__canvas) {\n      let canvas;\n      try {\n        const c = new OffscreenCanvas(0, 0);\n        const context = c.getContext(\"2d\", contextSettings);\n        if (context?.measureText) {\n          _CanvasTextMetrics.__canvas = c;\n          return c;\n        }\n        canvas = adapter.DOMAdapter.get().createCanvas();\n      } catch (_cx) {\n        canvas = adapter.DOMAdapter.get().createCanvas();\n      }\n      canvas.width = canvas.height = 10;\n      _CanvasTextMetrics.__canvas = canvas;\n    }\n    return _CanvasTextMetrics.__canvas;\n  }\n  /**\n   * TODO: this should be private, but isn't because of backward compat, will fix later.\n   * @ignore\n   */\n  static get _context() {\n    if (!_CanvasTextMetrics.__context) {\n      _CanvasTextMetrics.__context = _CanvasTextMetrics._canvas.getContext(\"2d\", contextSettings);\n    }\n    return _CanvasTextMetrics.__context;\n  }\n};\n/**\n * String used for calculate font metrics.\n * These characters are all tall to help calculate the height required for text.\n */\n_CanvasTextMetrics.METRICS_STRING = \"|\\xC9q\\xC5\";\n/** Baseline symbol for calculate font metrics. */\n_CanvasTextMetrics.BASELINE_SYMBOL = \"M\";\n/** Baseline multiplier for calculate font metrics. */\n_CanvasTextMetrics.BASELINE_MULTIPLIER = 1.4;\n/** Height multiplier for setting height of canvas to calculate font metrics. */\n_CanvasTextMetrics.HEIGHT_MULTIPLIER = 2;\n/**\n * A Unicode \"character\", or \"grapheme cluster\", can be composed of multiple Unicode code points,\n * such as letters with diacritical marks (e.g. `'\\u0065\\u0301'`, letter e with acute)\n * or emojis with modifiers (e.g. `'\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB'`, technologist).\n * The new `Intl.Segmenter` API in ES2022 can split the string into grapheme clusters correctly. If it is not available,\n * PixiJS will fallback to use the iterator of String, which can only spilt the string into code points.\n * If you want to get full functionality in environments that don't support `Intl.Segmenter` (such as Firefox),\n * you can use other libraries such as [grapheme-splitter]{@link https://www.npmjs.com/package/grapheme-splitter}\n * or [graphemer]{@link https://www.npmjs.com/package/graphemer} to create a polyfill. Since these libraries can be\n * relatively large in size to handle various Unicode grapheme clusters properly, PixiJS won't use them directly.\n */\n_CanvasTextMetrics.graphemeSegmenter = (() => {\n  if (typeof Intl?.Segmenter === \"function\") {\n    const segmenter = new Intl.Segmenter();\n    return (s) => [...segmenter.segment(s)].map((x) => x.segment);\n  }\n  return (s) => [...s];\n})();\n/**\n * New rendering behavior for letter-spacing which uses Chrome's new native API. This will\n * lead to more accurate letter-spacing results because it does not try to manually draw\n * each character. However, this Chrome API is experimental and may not serve all cases yet.\n * @see TextMetrics.experimentalLetterSpacingSupported\n */\n_CanvasTextMetrics.experimentalLetterSpacing = false;\n/** Cache of {@see TextMetrics.FontMetrics} objects. */\n_CanvasTextMetrics._fonts = {};\n/** Cache of new line chars. */\n_CanvasTextMetrics._newlines = [\n  10,\n  // line feed\n  13\n  // carriage return\n];\n/** Cache of breaking spaces. */\n_CanvasTextMetrics._breakingSpaces = [\n  9,\n  // character tabulation\n  32,\n  // space\n  8192,\n  // en quad\n  8193,\n  // em quad\n  8194,\n  // en space\n  8195,\n  // em space\n  8196,\n  // three-per-em space\n  8197,\n  // four-per-em space\n  8198,\n  // six-per-em space\n  8200,\n  // punctuation space\n  8201,\n  // thin space\n  8202,\n  // hair space\n  8287,\n  // medium mathematical space\n  12288\n  // ideographic space\n];\n_CanvasTextMetrics._measurementCache = {};\nlet CanvasTextMetrics = _CanvasTextMetrics;\n\nexports.CanvasTextMetrics = CanvasTextMetrics;\n//# sourceMappingURL=CanvasTextMetrics.js.map\n\n};"],
"names":["shadow$provide","global","require","module","exports","adapter","fontStringFromTextStyle","contextSettings","willReadFrequently","result","_CanvasTextMetrics","_experimentalLetterSpacingSupported","proto","DOMAdapter","get","getCanvasRenderingContext2D","prototype","constructor","text","style","width","height","lines","lineWidths","lineHeight","maxLineWidth","fontProperties","measureText","canvas","_canvas","wordWrap","textKey","styleKey","_measurementCache","font","measureFont","fontSize","ascent","context","__context","split","outputText","_wordWrap","Array","length","i","lineWidth","_measureText","letterSpacing","Math","max","strokeWidth","_stroke","dropShadow","distance","leading","measurements","useExperimentalLetterSpacing","experimentalLetterSpacingSupported","experimentalLetterSpacing","textLetterSpacing","metrics","metricWidth","boundsWidth","actualBoundingBoxRight","actualBoundingBoxLeft","val","graphemeSegmenter","getContext","line","cache","Object","create","whiteSpace","collapseSpaces","_collapseSpaces","collapseNewlines","_collapseNewlines","canPrependSpaces","wordWrapWidth","tokens","_tokenize","token","_isNewline","_addLine","currIsBreakingSpace","isBreakingSpace","lastIsBreakingSpace","tokenWidth","_getFromCache","canBreakWords","breakWords","characters","j","wordWrapSplit","char","lastChar","k","nextChar","canBreakChars","characterWidth","newLine","_trimRight","key","slice","_newlines","includes","charCodeAt","_nextChar","_breakingSpaces","push","_token","_char","_index","_breakWords","_fonts","_context","METRICS_STRING","BASELINE_SYMBOL","properties","actualBoundingBoxAscent","descent","actualBoundingBoxDescent","clearMetrics","__canvas","c","OffscreenCanvas","createCanvas","_cx","BASELINE_MULTIPLIER","HEIGHT_MULTIPLIER","Intl","Segmenter","segmenter","s","segment","map","x","CanvasTextMetrics"]
}
