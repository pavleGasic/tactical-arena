{
"version":3,
"file":"module$node_modules$pixi_DOT_js$lib$maths$shapes$Polygon.js",
"lineCount":112,
"mappings":"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",
"sources":["node_modules/pixi_DOT_js/lib/maths/shapes/Polygon.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$pixi_DOT_js$lib$maths$shapes$Polygon\"] = function(global,require,module,exports) {\n'use strict';\n\nvar squaredDistanceToLineSegment = require('../misc/squaredDistanceToLineSegment.js');\nvar Rectangle = require('./Rectangle.js');\n\n\"use strict\";\nlet tempRect;\nlet tempRect2;\nclass Polygon {\n  /**\n   * @param points - This can be an array of Points\n   *  that form the polygon, a flat array of numbers that will be interpreted as [x,y, x,y, ...], or\n   *  the arguments passed can be all the points of the polygon e.g.\n   *  `new Polygon(new Point(), new Point(), ...)`, or the arguments passed can be flat\n   *  x,y values e.g. `new Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are Numbers.\n   */\n  constructor(...points) {\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'polygon'\n     */\n    this.type = \"polygon\";\n    let flat = Array.isArray(points[0]) ? points[0] : points;\n    if (typeof flat[0] !== \"number\") {\n      const p = [];\n      for (let i = 0, il = flat.length; i < il; i++) {\n        p.push(flat[i].x, flat[i].y);\n      }\n      flat = p;\n    }\n    this.points = flat;\n    this.closePath = true;\n  }\n  /**\n   * Determines whether the polygon's points are arranged in a clockwise direction.\n   * This is calculated using the \"shoelace formula\" (also known as surveyor's formula) to find the signed area.\n   * A positive area indicates clockwise winding, while negative indicates counter-clockwise.\n   *\n   * The formula sums up the cross products of adjacent vertices:\n   * For each pair of adjacent points (x1,y1) and (x2,y2), we calculate (x1*y2 - x2*y1)\n   * The final sum divided by 2 gives the signed area - positive for clockwise.\n   * @returns `true` if the polygon's points are arranged clockwise, `false` if counter-clockwise\n   */\n  isClockwise() {\n    let area = 0;\n    const points = this.points;\n    const length = points.length;\n    for (let i = 0; i < length; i += 2) {\n      const x1 = points[i];\n      const y1 = points[i + 1];\n      const x2 = points[(i + 2) % length];\n      const y2 = points[(i + 3) % length];\n      area += (x2 - x1) * (y2 + y1);\n    }\n    return area < 0;\n  }\n  /**\n   * Checks if this polygon completely contains another polygon.\n   *\n   * This is useful for detecting holes in shapes, like when parsing SVG paths.\n   * For example, if you have two polygons:\n   * ```ts\n   * const outerSquare = new Polygon([0,0, 100,0, 100,100, 0,100]); // A square\n   * const innerSquare = new Polygon([25,25, 75,25, 75,75, 25,75]); // A smaller square inside\n   *\n   * outerSquare.containsPolygon(innerSquare); // Returns true\n   * innerSquare.containsPolygon(outerSquare); // Returns false\n   * ```\n   * @param polygon - The polygon to test for containment\n   * @returns True if this polygon completely contains the other polygon\n   */\n  containsPolygon(polygon) {\n    const thisBounds = this.getBounds(tempRect);\n    const otherBounds = polygon.getBounds(tempRect2);\n    if (!thisBounds.containsRect(otherBounds)) {\n      return false;\n    }\n    const points = polygon.points;\n    for (let i = 0; i < points.length; i += 2) {\n      const x = points[i];\n      const y = points[i + 1];\n      if (!this.contains(x, y)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  /**\n   * Creates a clone of this polygon.\n   * @returns - A copy of the polygon.\n   */\n  clone() {\n    const points = this.points.slice();\n    const polygon = new Polygon(points);\n    polygon.closePath = this.closePath;\n    return polygon;\n  }\n  /**\n   * Checks whether the x and y coordinates passed to this function are contained within this polygon.\n   * @param x - The X coordinate of the point to test.\n   * @param y - The Y coordinate of the point to test.\n   * @returns - Whether the x/y coordinates are within this polygon.\n   */\n  contains(x, y) {\n    let inside = false;\n    const length = this.points.length / 2;\n    for (let i = 0, j = length - 1; i < length; j = i++) {\n      const xi = this.points[i * 2];\n      const yi = this.points[i * 2 + 1];\n      const xj = this.points[j * 2];\n      const yj = this.points[j * 2 + 1];\n      const intersect = yi > y !== yj > y && x < (xj - xi) * ((y - yi) / (yj - yi)) + xi;\n      if (intersect) {\n        inside = !inside;\n      }\n    }\n    return inside;\n  }\n  /**\n   * Checks whether the x and y coordinates given are contained within this polygon including the stroke.\n   * @param x - The X coordinate of the point to test\n   * @param y - The Y coordinate of the point to test\n   * @param strokeWidth - The width of the line to check\n   * @param alignment - The alignment of the stroke, 0.5 by default\n   * @returns Whether the x/y coordinates are within this polygon\n   */\n  strokeContains(x, y, strokeWidth, alignment = 0.5) {\n    const strokeWidthSquared = strokeWidth * strokeWidth;\n    const rightWidthSquared = strokeWidthSquared * (1 - alignment);\n    const leftWidthSquared = strokeWidthSquared - rightWidthSquared;\n    const { points } = this;\n    const iterationLength = points.length - (this.closePath ? 0 : 2);\n    for (let i = 0; i < iterationLength; i += 2) {\n      const x1 = points[i];\n      const y1 = points[i + 1];\n      const x2 = points[(i + 2) % points.length];\n      const y2 = points[(i + 3) % points.length];\n      const distanceSquared = squaredDistanceToLineSegment.squaredDistanceToLineSegment(x, y, x1, y1, x2, y2);\n      const sign = Math.sign((x2 - x1) * (y - y1) - (y2 - y1) * (x - x1));\n      if (distanceSquared <= (sign < 0 ? leftWidthSquared : rightWidthSquared)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Returns the framing rectangle of the polygon as a Rectangle object\n   * @param out - optional rectangle to store the result\n   * @returns The framing rectangle\n   */\n  getBounds(out) {\n    out || (out = new Rectangle.Rectangle());\n    const points = this.points;\n    let minX = Infinity;\n    let maxX = -Infinity;\n    let minY = Infinity;\n    let maxY = -Infinity;\n    for (let i = 0, n = points.length; i < n; i += 2) {\n      const x = points[i];\n      const y = points[i + 1];\n      minX = x < minX ? x : minX;\n      maxX = x > maxX ? x : maxX;\n      minY = y < minY ? y : minY;\n      maxY = y > maxY ? y : maxY;\n    }\n    out.x = minX;\n    out.width = maxX - minX;\n    out.y = minY;\n    out.height = maxY - minY;\n    return out;\n  }\n  /**\n   * Copies another polygon to this one.\n   * @param polygon - The polygon to copy from.\n   * @returns Returns itself.\n   */\n  copyFrom(polygon) {\n    this.points = polygon.points.slice();\n    this.closePath = polygon.closePath;\n    return this;\n  }\n  /**\n   * Copies this polygon to another one.\n   * @param polygon - The polygon to copy to.\n   * @returns Returns given parameter.\n   */\n  copyTo(polygon) {\n    polygon.copyFrom(this);\n    return polygon;\n  }\n  toString() {\n    return `[pixi.js/math:PolygoncloseStroke=${this.closePath}points=${this.points.reduce((pointsDesc, currentPoint) => `${pointsDesc}, ${currentPoint}`, \"\")}]`;\n  }\n  /**\n   * Get the last X coordinate of the polygon\n   * @readonly\n   */\n  get lastX() {\n    return this.points[this.points.length - 2];\n  }\n  /**\n   * Get the last Y coordinate of the polygon\n   * @readonly\n   */\n  get lastY() {\n    return this.points[this.points.length - 1];\n  }\n  /**\n   * Get the first X coordinate of the polygon\n   * @readonly\n   */\n  get x() {\n    return this.points[this.points.length - 2];\n  }\n  /**\n   * Get the first Y coordinate of the polygon\n   * @readonly\n   */\n  get y() {\n    return this.points[this.points.length - 1];\n  }\n}\n\nexports.Polygon = Polygon;\n//# sourceMappingURL=Polygon.js.map\n\n};"],
"names":["shadow$provide","global","require","module","exports","squaredDistanceToLineSegment","Rectangle","Polygon","constructor","points","type","flat","Array","isArray","p","i","il","length","push","x","y","closePath","isClockwise","area","x2","x1","y2","y1","containsPolygon","polygon","thisBounds","getBounds","tempRect","otherBounds","tempRect2","containsRect","contains","clone","slice","inside","j","xi","yi","xj","yj","strokeContains","strokeWidth","alignment","strokeWidthSquared","rightWidthSquared","leftWidthSquared","iterationLength","distanceSquared","Math","sign","out","minX","Infinity","maxX","minY","maxY","n","width","height","copyFrom","copyTo","toString","reduce","pointsDesc","currentPoint"]
}
