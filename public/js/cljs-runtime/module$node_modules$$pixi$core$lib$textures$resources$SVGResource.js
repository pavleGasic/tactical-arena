shadow$provide.module$node_modules$$pixi$core$lib$textures$resources$SVGResource = function(global, require, module, exports) {
  var settings = require("module$node_modules$$pixi$settings$lib$index"), utils = require("module$node_modules$$pixi$utils$lib$index"), BaseImageResource = require("module$node_modules$$pixi$core$lib$textures$resources$BaseImageResource");
  const node_modules$$pixi$core$lib$textures$resources$SVGResource$classdecl$var11 = class extends BaseImageResource.BaseImageResource {
    constructor(sourceBase64, options) {
      options = options || {};
      super(settings.settings.ADAPTER.createCanvas());
      this._height = this._width = 0;
      this.svg = sourceBase64;
      this.scale = options.scale || 1;
      this._overrideWidth = options.width;
      this._overrideHeight = options.height;
      this._resolve = null;
      this._crossorigin = options.crossorigin;
      this._load = null;
      !1 !== options.autoLoad && this.load();
    }
    load() {
      return this._load ? this._load : (this._load = new Promise(resolve => {
        if (this._resolve = () => {
          this.update();
          resolve(this);
        }, node_modules$$pixi$core$lib$textures$resources$SVGResource$classdecl$var11.SVG_XML.test(this.svg.trim())) {
          if (!btoa) {
            throw Error("Your browser doesn't support base64 conversions.");
          }
          this.svg = `data:image/svg+xml;base64,${btoa(unescape(encodeURIComponent(this.svg)))}`;
        }
        this._loadSvg();
      }), this._load);
    }
    _loadSvg() {
      const tempImage = new Image();
      BaseImageResource.BaseImageResource.crossOrigin(tempImage, this.svg, this._crossorigin);
      tempImage.src = this.svg;
      tempImage.onerror = event => {
        this._resolve && (tempImage.onerror = null, this.onError.emit(event));
      };
      tempImage.onload = () => {
        if (this._resolve) {
          var svgWidth = tempImage.width, svgHeight = tempImage.height;
          if (!svgWidth || !svgHeight) {
            throw Error("The SVG image must have width and height defined (in pixels), canvas API needs them.");
          }
          var width = svgWidth * this.scale, height = svgHeight * this.scale;
          (this._overrideWidth || this._overrideHeight) && (width = this._overrideWidth || this._overrideHeight / svgHeight * svgWidth, height = this._overrideHeight || this._overrideWidth / svgWidth * svgHeight);
          width = Math.round(width);
          height = Math.round(height);
          var canvas = this.source;
          canvas.width = width;
          canvas.height = height;
          canvas._pixiId = `canvas_${utils.uid()}`;
          canvas.getContext("2d").drawImage(tempImage, 0, 0, svgWidth, svgHeight, 0, 0, width, height);
          this._resolve();
          this._resolve = null;
        }
      };
    }
    static getSize(svgString) {
      svgString = node_modules$$pixi$core$lib$textures$resources$SVGResource$classdecl$var11.SVG_SIZE.exec(svgString);
      const size = {};
      return svgString && (size[svgString[1]] = Math.round(parseFloat(svgString[3])), size[svgString[5]] = Math.round(parseFloat(svgString[7]))), size;
    }
    dispose() {
      super.dispose();
      this._crossorigin = this._resolve = null;
    }
    static test(source, extension) {
      return "svg" === extension || "string" == typeof source && source.startsWith("data:image/svg+xml") || "string" == typeof source && node_modules$$pixi$core$lib$textures$resources$SVGResource$classdecl$var11.SVG_XML.test(source);
    }
  };
  global = node_modules$$pixi$core$lib$textures$resources$SVGResource$classdecl$var11;
  global.SVG_XML = /^(<\?xml[^?]+\?>)?\s*(\x3c!--[^(--\x3e)]*--\x3e)?\s*<svg/m;
  global.SVG_SIZE = /<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i;
  exports.SVGResource = global;
};

//# sourceMappingURL=module$node_modules$$pixi$core$lib$textures$resources$SVGResource.js.map
