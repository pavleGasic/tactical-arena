shadow$provide.module$node_modules$pixi_DOT_js$lib$rendering$mask$alpha$AlphaMask = function(global, require, module, exports) {
  global = require("module$node_modules$pixi_DOT_js$lib$extensions$Extensions");
  var Sprite = require("module$node_modules$pixi_DOT_js$lib$scene$sprite$Sprite"), addMaskBounds = require("module$node_modules$pixi_DOT_js$lib$rendering$mask$utils$addMaskBounds"), addMaskLocalBounds = require("module$node_modules$pixi_DOT_js$lib$rendering$mask$utils$addMaskLocalBounds");
  "use strict";
  class AlphaMask {
    constructor(options) {
      this.priority = 0;
      this.inverse = !1;
      this.pipe = "alphaMask";
      options?.mask && this.init(options.mask);
    }
    init(mask) {
      this.mask = mask;
      this.renderMaskToTexture = !(mask instanceof Sprite.Sprite);
      this.mask.renderable = this.renderMaskToTexture;
      this.mask.includeInBuild = !this.renderMaskToTexture;
      this.mask.measurable = !1;
    }
    reset() {
      this.mask.measurable = !0;
      this.mask = null;
    }
    addBounds(bounds, skipUpdateTransform) {
      this.inverse || addMaskBounds.addMaskBounds(this.mask, bounds, skipUpdateTransform);
    }
    addLocalBounds(bounds, localRoot) {
      addMaskLocalBounds.addMaskLocalBounds(this.mask, bounds, localRoot);
    }
    containsPoint(point, hitTestFn) {
      return hitTestFn(this.mask, point);
    }
    destroy() {
      this.reset();
    }
    static test(mask) {
      return mask instanceof Sprite.Sprite;
    }
  }
  AlphaMask.extension = global.ExtensionType.MaskEffect;
  exports.AlphaMask = AlphaMask;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$rendering$mask$alpha$AlphaMask.js.map
