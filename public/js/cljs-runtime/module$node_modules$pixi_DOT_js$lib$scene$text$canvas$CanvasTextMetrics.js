shadow$provide.module$node_modules$pixi_DOT_js$lib$scene$text$canvas$CanvasTextMetrics = function(global, require, module, exports) {
  var adapter = require("module$node_modules$pixi_DOT_js$lib$environment$adapter"), fontStringFromTextStyle = require("module$node_modules$pixi_DOT_js$lib$scene$text$canvas$utils$fontStringFromTextStyle");
  "use strict";
  const contextSettings = {willReadFrequently:!0}, node_modules$pixi_DOT_js$lib$scene$text$canvas$CanvasTextMetrics$classdecl$var17 = class {
    static get experimentalLetterSpacingSupported() {
      var result = node_modules$pixi_DOT_js$lib$scene$text$canvas$CanvasTextMetrics$classdecl$var17._experimentalLetterSpacingSupported;
      void 0 !== result && (result = adapter.DOMAdapter.get().getCanvasRenderingContext2D().prototype, result = node_modules$pixi_DOT_js$lib$scene$text$canvas$CanvasTextMetrics$classdecl$var17._experimentalLetterSpacingSupported = "letterSpacing" in result || "textLetterSpacing" in result);
      return result;
    }
    constructor(text, style, width, height, lines, lineWidths, lineHeight, maxLineWidth, fontProperties) {
      this.text = text;
      this.style = style;
      this.width = width;
      this.height = height;
      this.lines = lines;
      this.lineWidths = lineWidths;
      this.lineHeight = lineHeight;
      this.maxLineWidth = maxLineWidth;
      this.fontProperties = fontProperties;
    }
    static measureText(text = " ", style, canvas = node_modules$pixi_DOT_js$lib$scene$text$canvas$CanvasTextMetrics$classdecl$var17._canvas, wordWrap = style.wordWrap) {
      var textKey = `${text}:${style.styleKey}`;
      if (node_modules$pixi_DOT_js$lib$scene$text$canvas$CanvasTextMetrics$classdecl$var17._measurementCache[textKey]) {
        return node_modules$pixi_DOT_js$lib$scene$text$canvas$CanvasTextMetrics$classdecl$var17._measurementCache[textKey];
      }
      var font = fontStringFromTextStyle.fontStringFromTextStyle(style);
      textKey = node_modules$pixi_DOT_js$lib$scene$text$canvas$CanvasTextMetrics$classdecl$var17.measureFont(font);
      0 === textKey.fontSize && (textKey.fontSize = style.fontSize, textKey.ascent = style.fontSize);
      var context = node_modules$pixi_DOT_js$lib$scene$text$canvas$CanvasTextMetrics$classdecl$var17.__context;
      context.font = font;
      canvas = (wordWrap ? node_modules$pixi_DOT_js$lib$scene$text$canvas$CanvasTextMetrics$classdecl$var17._wordWrap(text, style, canvas) : text).split(/(?:\r\n|\r|\n)/);
      wordWrap = Array(canvas.length);
      font = 0;
      for (var i = 0; i < canvas.length; i++) {
        var lineWidth = node_modules$pixi_DOT_js$lib$scene$text$canvas$CanvasTextMetrics$classdecl$var17._measureText(canvas[i], style.letterSpacing, context);
        wordWrap[i] = lineWidth;
        font = Math.max(font, lineWidth);
      }
      lineWidth = style._stroke?.width || 0;
      context = font + lineWidth;
      style.dropShadow && (context += style.dropShadow.distance);
      i = style.lineHeight || textKey.fontSize;
      lineWidth = Math.max(i, textKey.fontSize + lineWidth) + (canvas.length - 1) * (i + style.leading);
      style.dropShadow && (lineWidth += style.dropShadow.distance);
      return new node_modules$pixi_DOT_js$lib$scene$text$canvas$CanvasTextMetrics$classdecl$var17(text, style, context, lineWidth, canvas, wordWrap, i + style.leading, font, textKey);
    }
    static _measureText(text, letterSpacing, context) {
      let useExperimentalLetterSpacing = !1;
      node_modules$pixi_DOT_js$lib$scene$text$canvas$CanvasTextMetrics$classdecl$var17.experimentalLetterSpacingSupported && (node_modules$pixi_DOT_js$lib$scene$text$canvas$CanvasTextMetrics$classdecl$var17.experimentalLetterSpacing ? (context.letterSpacing = `${letterSpacing}px`, context.textLetterSpacing = `${letterSpacing}px`, useExperimentalLetterSpacing = !0) : (context.letterSpacing = "0px", context.textLetterSpacing = "0px"));
      var metrics = context.measureText(text);
      context = metrics.width;
      metrics = metrics.actualBoundingBoxRight - -metrics.actualBoundingBoxLeft;
      0 < context && (useExperimentalLetterSpacing ? (context -= letterSpacing, metrics -= letterSpacing) : (text = (node_modules$pixi_DOT_js$lib$scene$text$canvas$CanvasTextMetrics$classdecl$var17.graphemeSegmenter(text).length - 1) * letterSpacing, context += text, metrics += text));
      return Math.max(context, metrics);
    }
    static _wordWrap(text, style, canvas = node_modules$pixi_DOT_js$lib$scene$text$canvas$CanvasTextMetrics$classdecl$var17._canvas) {
      canvas = canvas.getContext("2d", contextSettings);
      let width = 0, line = "", lines = "";
      const cache = Object.create(null), {letterSpacing, whiteSpace} = style, collapseSpaces = node_modules$pixi_DOT_js$lib$scene$text$canvas$CanvasTextMetrics$classdecl$var17._collapseSpaces(whiteSpace), collapseNewlines = node_modules$pixi_DOT_js$lib$scene$text$canvas$CanvasTextMetrics$classdecl$var17._collapseNewlines(whiteSpace);
      let canPrependSpaces = !collapseSpaces;
      const wordWrapWidth = style.wordWrapWidth + letterSpacing;
      text = node_modules$pixi_DOT_js$lib$scene$text$canvas$CanvasTextMetrics$classdecl$var17._tokenize(text);
      for (let i = 0; i < text.length; i++) {
        let token = text[i];
        if (node_modules$pixi_DOT_js$lib$scene$text$canvas$CanvasTextMetrics$classdecl$var17._isNewline(token)) {
          if (!collapseNewlines) {
            lines += node_modules$pixi_DOT_js$lib$scene$text$canvas$CanvasTextMetrics$classdecl$var17._addLine(line);
            canPrependSpaces = !collapseSpaces;
            line = "";
            width = 0;
            continue;
          }
          token = " ";
        }
        if (collapseSpaces) {
          var currIsBreakingSpace = node_modules$pixi_DOT_js$lib$scene$text$canvas$CanvasTextMetrics$classdecl$var17.isBreakingSpace(token), lastIsBreakingSpace = node_modules$pixi_DOT_js$lib$scene$text$canvas$CanvasTextMetrics$classdecl$var17.isBreakingSpace(line[line.length - 1]);
          if (currIsBreakingSpace && lastIsBreakingSpace) {
            continue;
          }
        }
        currIsBreakingSpace = node_modules$pixi_DOT_js$lib$scene$text$canvas$CanvasTextMetrics$classdecl$var17._getFromCache(token, letterSpacing, cache, canvas);
        if (currIsBreakingSpace > wordWrapWidth) {
          if ("" !== line && (lines += node_modules$pixi_DOT_js$lib$scene$text$canvas$CanvasTextMetrics$classdecl$var17._addLine(line), line = "", width = 0), node_modules$pixi_DOT_js$lib$scene$text$canvas$CanvasTextMetrics$classdecl$var17.canBreakWords(token, style.breakWords)) {
            for (currIsBreakingSpace = node_modules$pixi_DOT_js$lib$scene$text$canvas$CanvasTextMetrics$classdecl$var17.wordWrapSplit(token), lastIsBreakingSpace = 0; lastIsBreakingSpace < currIsBreakingSpace.length; lastIsBreakingSpace++) {
              let char = currIsBreakingSpace[lastIsBreakingSpace];
              var lastChar = char;
              let k = 1;
              for (; currIsBreakingSpace[lastIsBreakingSpace + k];) {
                const nextChar = currIsBreakingSpace[lastIsBreakingSpace + k];
                if (node_modules$pixi_DOT_js$lib$scene$text$canvas$CanvasTextMetrics$classdecl$var17.canBreakChars(lastChar, nextChar, token, lastIsBreakingSpace, style.breakWords)) {
                  break;
                } else {
                  char += nextChar;
                }
                lastChar = nextChar;
                k++;
              }
              lastIsBreakingSpace += k - 1;
              lastChar = node_modules$pixi_DOT_js$lib$scene$text$canvas$CanvasTextMetrics$classdecl$var17._getFromCache(char, letterSpacing, cache, canvas);
              lastChar + width > wordWrapWidth && (lines += node_modules$pixi_DOT_js$lib$scene$text$canvas$CanvasTextMetrics$classdecl$var17._addLine(line), canPrependSpaces = !1, line = "", width = 0);
              line += char;
              width += lastChar;
            }
          } else {
            0 < line.length && (lines += node_modules$pixi_DOT_js$lib$scene$text$canvas$CanvasTextMetrics$classdecl$var17._addLine(line)), lines += node_modules$pixi_DOT_js$lib$scene$text$canvas$CanvasTextMetrics$classdecl$var17._addLine(token, i !== text.length - 1), canPrependSpaces = !1, line = "", width = 0;
          }
        } else {
          if (currIsBreakingSpace + width > wordWrapWidth && (canPrependSpaces = !1, lines += node_modules$pixi_DOT_js$lib$scene$text$canvas$CanvasTextMetrics$classdecl$var17._addLine(line), line = "", width = 0), 0 < line.length || !node_modules$pixi_DOT_js$lib$scene$text$canvas$CanvasTextMetrics$classdecl$var17.isBreakingSpace(token) || canPrependSpaces) {
            line += token, width += currIsBreakingSpace;
          }
        }
      }
      return lines += node_modules$pixi_DOT_js$lib$scene$text$canvas$CanvasTextMetrics$classdecl$var17._addLine(line, !1);
    }
    static _addLine(line, newLine = !0) {
      line = node_modules$pixi_DOT_js$lib$scene$text$canvas$CanvasTextMetrics$classdecl$var17._trimRight(line);
      return newLine ? `${line}
` : line;
    }
    static _getFromCache(key, letterSpacing, cache, context) {
      let width = cache[key];
      "number" !== typeof width && (width = node_modules$pixi_DOT_js$lib$scene$text$canvas$CanvasTextMetrics$classdecl$var17._measureText(key, letterSpacing, context) + letterSpacing, cache[key] = width);
      return width;
    }
    static _collapseSpaces(whiteSpace) {
      return "normal" === whiteSpace || "pre-line" === whiteSpace;
    }
    static _collapseNewlines(whiteSpace) {
      return "normal" === whiteSpace;
    }
    static _trimRight(text) {
      if ("string" !== typeof text) {
        return "";
      }
      for (let i = text.length - 1; 0 <= i && node_modules$pixi_DOT_js$lib$scene$text$canvas$CanvasTextMetrics$classdecl$var17.isBreakingSpace(text[i]); i--) {
        text = text.slice(0, -1);
      }
      return text;
    }
    static _isNewline(char) {
      return "string" !== typeof char ? !1 : node_modules$pixi_DOT_js$lib$scene$text$canvas$CanvasTextMetrics$classdecl$var17._newlines.includes(char.charCodeAt(0));
    }
    static isBreakingSpace(char, _nextChar) {
      return "string" !== typeof char ? !1 : node_modules$pixi_DOT_js$lib$scene$text$canvas$CanvasTextMetrics$classdecl$var17._breakingSpaces.includes(char.charCodeAt(0));
    }
    static _tokenize(text) {
      const tokens = [];
      let token = "";
      if ("string" !== typeof text) {
        return tokens;
      }
      for (let i = 0; i < text.length; i++) {
        const char = text[i];
        node_modules$pixi_DOT_js$lib$scene$text$canvas$CanvasTextMetrics$classdecl$var17.isBreakingSpace(char, text[i + 1]) || node_modules$pixi_DOT_js$lib$scene$text$canvas$CanvasTextMetrics$classdecl$var17._isNewline(char) ? ("" !== token && (tokens.push(token), token = ""), tokens.push(char)) : token += char;
      }
      "" !== token && tokens.push(token);
      return tokens;
    }
    static canBreakWords(_token, breakWords) {
      return breakWords;
    }
    static canBreakChars(_char, _nextChar, _token, _index, _breakWords) {
      return !0;
    }
    static wordWrapSplit(token) {
      return node_modules$pixi_DOT_js$lib$scene$text$canvas$CanvasTextMetrics$classdecl$var17.graphemeSegmenter(token);
    }
    static measureFont(font) {
      if (node_modules$pixi_DOT_js$lib$scene$text$canvas$CanvasTextMetrics$classdecl$var17._fonts[font]) {
        return node_modules$pixi_DOT_js$lib$scene$text$canvas$CanvasTextMetrics$classdecl$var17._fonts[font];
      }
      var context = node_modules$pixi_DOT_js$lib$scene$text$canvas$CanvasTextMetrics$classdecl$var17._context;
      context.font = font;
      context = context.measureText(node_modules$pixi_DOT_js$lib$scene$text$canvas$CanvasTextMetrics$classdecl$var17.METRICS_STRING + node_modules$pixi_DOT_js$lib$scene$text$canvas$CanvasTextMetrics$classdecl$var17.BASELINE_SYMBOL);
      context = {ascent:context.actualBoundingBoxAscent, descent:context.actualBoundingBoxDescent, fontSize:context.actualBoundingBoxAscent + context.actualBoundingBoxDescent};
      return node_modules$pixi_DOT_js$lib$scene$text$canvas$CanvasTextMetrics$classdecl$var17._fonts[font] = context;
    }
    static clearMetrics(font = "") {
      font ? delete node_modules$pixi_DOT_js$lib$scene$text$canvas$CanvasTextMetrics$classdecl$var17._fonts[font] : node_modules$pixi_DOT_js$lib$scene$text$canvas$CanvasTextMetrics$classdecl$var17._fonts = {};
    }
    static get _canvas() {
      if (!node_modules$pixi_DOT_js$lib$scene$text$canvas$CanvasTextMetrics$classdecl$var17.__canvas) {
        let canvas;
        try {
          const c = new OffscreenCanvas(0, 0);
          if (c.getContext("2d", contextSettings)?.measureText) {
            return node_modules$pixi_DOT_js$lib$scene$text$canvas$CanvasTextMetrics$classdecl$var17.__canvas = c;
          }
          canvas = adapter.DOMAdapter.get().createCanvas();
        } catch (_cx) {
          canvas = adapter.DOMAdapter.get().createCanvas();
        }
        canvas.width = canvas.height = 10;
        node_modules$pixi_DOT_js$lib$scene$text$canvas$CanvasTextMetrics$classdecl$var17.__canvas = canvas;
      }
      return node_modules$pixi_DOT_js$lib$scene$text$canvas$CanvasTextMetrics$classdecl$var17.__canvas;
    }
    static get _context() {
      node_modules$pixi_DOT_js$lib$scene$text$canvas$CanvasTextMetrics$classdecl$var17.__context || (node_modules$pixi_DOT_js$lib$scene$text$canvas$CanvasTextMetrics$classdecl$var17.__context = node_modules$pixi_DOT_js$lib$scene$text$canvas$CanvasTextMetrics$classdecl$var17._canvas.getContext("2d", contextSettings));
      return node_modules$pixi_DOT_js$lib$scene$text$canvas$CanvasTextMetrics$classdecl$var17.__context;
    }
  };
  global = node_modules$pixi_DOT_js$lib$scene$text$canvas$CanvasTextMetrics$classdecl$var17;
  global.METRICS_STRING = "|ÉqÅ";
  global.BASELINE_SYMBOL = "M";
  global.BASELINE_MULTIPLIER = 1.4;
  global.HEIGHT_MULTIPLIER = 2;
  global.graphemeSegmenter = (() => {
    if ("function" === typeof Intl?.Segmenter) {
      const segmenter = new Intl.Segmenter();
      return s => [...segmenter.segment(s)].map(x => x.segment);
    }
    return s => [...s];
  })();
  global.experimentalLetterSpacing = !1;
  global._fonts = {};
  global._newlines = [10, 13];
  global._breakingSpaces = [9, 32, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8200, 8201, 8202, 8287, 12288];
  global._measurementCache = {};
  exports.CanvasTextMetrics = global;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$scene$text$canvas$CanvasTextMetrics.js.map
