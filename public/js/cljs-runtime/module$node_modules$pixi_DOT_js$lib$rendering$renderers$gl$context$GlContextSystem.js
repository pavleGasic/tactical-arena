shadow$provide.module$node_modules$pixi_DOT_js$lib$rendering$renderers$gl$context$GlContextSystem = function(global, require, module, exports) {
  var adapter = require("module$node_modules$pixi_DOT_js$lib$environment$adapter");
  global = require("module$node_modules$pixi_DOT_js$lib$extensions$Extensions");
  var warn = require("module$node_modules$pixi_DOT_js$lib$utils$logging$warn");
  "use strict";
  const node_modules$pixi_DOT_js$lib$rendering$renderers$gl$context$GlContextSystem$classdecl$var31 = class {
    constructor(renderer) {
      this.supports = {uint32Indices:!0, uniformBufferObject:!0, vertexArrayObject:!0, srgbTextures:!0, nonPowOf2wrapping:!0, msaa:!0, nonPowOf2mipmaps:!0};
      this._renderer = renderer;
      this.extensions = Object.create(null);
      this.handleContextLost = this.handleContextLost.bind(this);
      this.handleContextRestored = this.handleContextRestored.bind(this);
    }
    get isLost() {
      return !this.gl || this.gl.isContextLost();
    }
    contextChange(gl) {
      this.gl = gl;
      this._renderer.gl = gl;
    }
    init(options) {
      options = {...node_modules$pixi_DOT_js$lib$rendering$renderers$gl$context$GlContextSystem$classdecl$var31.defaultOptions, ...options};
      let multiView = this.multiView = options.multiView;
      options.context && multiView && (warn.warn("Renderer created with both a context and multiview enabled. Disabling multiView as both cannot work together."), multiView = !1);
      this.canvas = multiView ? adapter.DOMAdapter.get().createCanvas(this._renderer.canvas.width, this._renderer.canvas.height) : this._renderer.view.canvas;
      options.context ? this.initFromContext(options.context) : this.createContext(options.preferWebGLVersion, {alpha:1 > this._renderer.background.alpha, premultipliedAlpha:options.premultipliedAlpha ?? !0, antialias:options.antialias && !this._renderer.backBuffer.useBackBuffer, stencil:!0, preserveDrawingBuffer:options.preserveDrawingBuffer, powerPreference:options.powerPreference ?? "default"});
    }
    ensureCanvasSize(targetCanvas) {
      if (this.multiView) {
        var {canvas} = this;
        if (canvas.width < targetCanvas.width || canvas.height < targetCanvas.height) {
          canvas.width = Math.max(targetCanvas.width, targetCanvas.width), canvas.height = Math.max(targetCanvas.height, targetCanvas.height);
        }
      } else {
        targetCanvas !== this.canvas && warn.warn("multiView is disabled, but targetCanvas is not the main canvas");
      }
    }
    initFromContext(gl) {
      this.gl = gl;
      this.webGLVersion = gl instanceof adapter.DOMAdapter.get().getWebGLRenderingContext() ? 1 : 2;
      this.getExtensions();
      this.validateContext(gl);
      this._renderer.runners.contextChange.emit(gl);
      gl = this._renderer.view.canvas;
      gl.addEventListener("webglcontextlost", this.handleContextLost, !1);
      gl.addEventListener("webglcontextrestored", this.handleContextRestored, !1);
    }
    createContext(preferWebGLVersion, options) {
      let gl;
      const canvas = this.canvas;
      2 === preferWebGLVersion && (gl = canvas.getContext("webgl2", options));
      if (!gl && (gl = canvas.getContext("webgl", options), !gl)) {
        throw Error("This browser does not support WebGL. Try using the canvas renderer");
      }
      this.gl = gl;
      this.initFromContext(this.gl);
    }
    getExtensions() {
      var {gl} = this;
      const common = {anisotropicFiltering:gl.getExtension("EXT_texture_filter_anisotropic"), floatTextureLinear:gl.getExtension("OES_texture_float_linear"), s3tc:gl.getExtension("WEBGL_compressed_texture_s3tc"), s3tc_sRGB:gl.getExtension("WEBGL_compressed_texture_s3tc_srgb"), etc:gl.getExtension("WEBGL_compressed_texture_etc"), etc1:gl.getExtension("WEBGL_compressed_texture_etc1"), pvrtc:gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"), 
      atc:gl.getExtension("WEBGL_compressed_texture_atc"), astc:gl.getExtension("WEBGL_compressed_texture_astc"), bptc:gl.getExtension("EXT_texture_compression_bptc"), rgtc:gl.getExtension("EXT_texture_compression_rgtc"), loseContext:gl.getExtension("WEBGL_lose_context")};
      1 === this.webGLVersion ? this.extensions = {...common, drawBuffers:gl.getExtension("WEBGL_draw_buffers"), depthTexture:gl.getExtension("WEBGL_depth_texture"), vertexArrayObject:gl.getExtension("OES_vertex_array_object") || gl.getExtension("MOZ_OES_vertex_array_object") || gl.getExtension("WEBKIT_OES_vertex_array_object"), uint32ElementIndex:gl.getExtension("OES_element_index_uint"), floatTexture:gl.getExtension("OES_texture_float"), floatTextureLinear:gl.getExtension("OES_texture_float_linear"), 
      textureHalfFloat:gl.getExtension("OES_texture_half_float"), textureHalfFloatLinear:gl.getExtension("OES_texture_half_float_linear"), vertexAttribDivisorANGLE:gl.getExtension("ANGLE_instanced_arrays"), srgb:gl.getExtension("EXT_sRGB")} : (this.extensions = {...common, colorBufferFloat:gl.getExtension("EXT_color_buffer_float")}, (gl = gl.getExtension("WEBGL_provoking_vertex")) && gl.provokingVertexWEBGL(gl.FIRST_VERTEX_CONVENTION_WEBGL));
    }
    handleContextLost(event) {
      event.preventDefault();
      this._contextLossForced && (this._contextLossForced = !1, setTimeout(() => {
        this.gl.isContextLost() && this.extensions.loseContext?.restoreContext();
      }, 0));
    }
    handleContextRestored() {
      this.getExtensions();
      this._renderer.runners.contextChange.emit(this.gl);
    }
    destroy() {
      const element = this._renderer.view.canvas;
      this._renderer = null;
      element.removeEventListener("webglcontextlost", this.handleContextLost);
      element.removeEventListener("webglcontextrestored", this.handleContextRestored);
      this.gl.useProgram(null);
      this.extensions.loseContext?.loseContext();
    }
    forceContextLoss() {
      this.extensions.loseContext?.loseContext();
      this._contextLossForced = !0;
    }
    validateContext(gl) {
      (gl = gl.getContextAttributes()) && !gl.stencil && warn.warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
      gl = this.supports;
      const isWebGl2 = 2 === this.webGLVersion, extensions = this.extensions;
      gl.uint32Indices = isWebGl2 || !!extensions.uint32ElementIndex;
      gl.uniformBufferObject = isWebGl2;
      gl.vertexArrayObject = isWebGl2 || !!extensions.vertexArrayObject;
      gl.srgbTextures = isWebGl2 || !!extensions.srgb;
      gl.nonPowOf2wrapping = isWebGl2;
      gl.nonPowOf2mipmaps = isWebGl2;
      gl.msaa = isWebGl2;
      gl.uint32Indices || warn.warn("Provided WebGL context does not support 32 index buffer, large scenes may not render correctly");
    }
  };
  require = node_modules$pixi_DOT_js$lib$rendering$renderers$gl$context$GlContextSystem$classdecl$var31;
  require.extension = {type:[global.ExtensionType.WebGLSystem], name:"context"};
  require.defaultOptions = {context:null, premultipliedAlpha:!0, preserveDrawingBuffer:!1, powerPreference:void 0, preferWebGLVersion:2, multiView:!1};
  exports.GlContextSystem = require;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$rendering$renderers$gl$context$GlContextSystem.js.map
