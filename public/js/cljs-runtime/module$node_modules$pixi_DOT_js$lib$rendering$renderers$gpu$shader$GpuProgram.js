shadow$provide.module$node_modules$pixi_DOT_js$lib$rendering$renderers$gpu$shader$GpuProgram = function(global, require, module, exports) {
  var createIdFromString = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$utils$createIdFromString"), extractAttributesFromGpuProgram = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$gpu$shader$utils$extractAttributesFromGpuProgram"), extractStructAndGroups = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$gpu$shader$utils$extractStructAndGroups"), generateGpuLayoutGroups = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$gpu$shader$utils$generateGpuLayoutGroups"), 
  generateLayoutHash = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$gpu$shader$utils$generateLayoutHash"), removeStructAndGroupDuplicates = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$gpu$shader$utils$removeStructAndGroupDuplicates");
  "use strict";
  const programCache = Object.create(null);
  class GpuProgram {
    constructor(options) {
      this._attributeLocationsKey = this._layoutKey = 0;
      const {fragment, vertex, layout, gpuLayout, name} = options;
      this.name = name;
      this.fragment = fragment;
      this.vertex = vertex;
      if (fragment.source === vertex.source) {
        this.structsAndGroups = extractStructAndGroups.extractStructAndGroups(fragment.source);
      } else {
        options = extractStructAndGroups.extractStructAndGroups(vertex.source);
        const fragmentStructsAndGroups = extractStructAndGroups.extractStructAndGroups(fragment.source);
        this.structsAndGroups = removeStructAndGroupDuplicates.removeStructAndGroupDuplicates(options, fragmentStructsAndGroups);
      }
      this.layout = layout ?? generateLayoutHash.generateLayoutHash(this.structsAndGroups);
      this.gpuLayout = gpuLayout ?? generateGpuLayoutGroups.generateGpuLayoutGroups(this.structsAndGroups);
      this.autoAssignGlobalUniforms = void 0 !== this.layout[0]?.globalUniforms;
      this.autoAssignLocalUniforms = void 0 !== this.layout[1]?.localUniforms;
      this._generateProgramKey();
    }
    _generateProgramKey() {
      const {vertex, fragment} = this;
      this._layoutKey = createIdFromString.createIdFromString(vertex.source + fragment.source + vertex.entryPoint + fragment.entryPoint, "program");
    }
    get attributeData() {
      this._attributeData ?? (this._attributeData = extractAttributesFromGpuProgram.extractAttributesFromGpuProgram(this.vertex));
      return this._attributeData;
    }
    destroy() {
      this.vertex = this.fragment = this.structsAndGroups = this.layout = this.gpuLayout = null;
    }
    static from(options) {
      const key = `${options.vertex.source}:${options.fragment.source}:${options.fragment.entryPoint}:${options.vertex.entryPoint}`;
      programCache[key] || (programCache[key] = new GpuProgram(options));
      return programCache[key];
    }
  }
  exports.GpuProgram = GpuProgram;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$rendering$renderers$gpu$shader$GpuProgram.js.map
