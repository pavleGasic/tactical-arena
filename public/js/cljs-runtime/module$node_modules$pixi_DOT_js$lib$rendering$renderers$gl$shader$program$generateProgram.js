shadow$provide.module$node_modules$pixi_DOT_js$lib$rendering$renderers$gl$shader$program$generateProgram = function(global, require, module, exports) {
  var warn = require("module$node_modules$pixi_DOT_js$lib$utils$logging$warn"), GlProgramData = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$gl$shader$GlProgramData"), compileShader = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$gl$shader$program$compileShader"), defaultValue = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$gl$shader$program$defaultValue"), extractAttributesFromGlProgram = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$gl$shader$program$extractAttributesFromGlProgram"), 
  getUboData = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$gl$shader$program$getUboData"), getUniformData = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$gl$shader$program$getUniformData"), logProgramError = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$gl$shader$program$logProgramError");
  "use strict";
  exports.generateProgram = function(gl, program) {
    var glVertShader = compileShader.compileShader(gl, gl.VERTEX_SHADER, program.vertex), glFragShader = compileShader.compileShader(gl, gl.FRAGMENT_SHADER, program.fragment);
    const webGLProgram = gl.createProgram();
    gl.attachShader(webGLProgram, glVertShader);
    gl.attachShader(webGLProgram, glFragShader);
    const transformFeedbackVaryings = program.transformFeedbackVaryings;
    transformFeedbackVaryings && ("function" !== typeof gl.transformFeedbackVaryings ? warn.warn("TransformFeedback is not supported but TransformFeedbackVaryings are given.") : gl.transformFeedbackVaryings(webGLProgram, transformFeedbackVaryings.names, "separate" === transformFeedbackVaryings.bufferMode ? gl.SEPARATE_ATTRIBS : gl.INTERLEAVED_ATTRIBS));
    gl.linkProgram(webGLProgram);
    gl.getProgramParameter(webGLProgram, gl.LINK_STATUS) || logProgramError.logProgramError(gl, webGLProgram, glVertShader, glFragShader);
    program._attributeData = extractAttributesFromGlProgram.extractAttributesFromGlProgram(webGLProgram, gl, !/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(program.vertex));
    program._uniformData = getUniformData.getUniformData(webGLProgram, gl);
    program._uniformBlockData = getUboData.getUboData(webGLProgram, gl);
    gl.deleteShader(glVertShader);
    gl.deleteShader(glFragShader);
    glVertShader = {};
    for (const i in program._uniformData) {
      glFragShader = program._uniformData[i], glVertShader[i] = {location:gl.getUniformLocation(webGLProgram, i), value:defaultValue.defaultValue(glFragShader.type, glFragShader.size)};
    }
    return new GlProgramData.GlProgramData(webGLProgram, glVertShader);
  };
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$rendering$renderers$gl$shader$program$generateProgram.js.map
