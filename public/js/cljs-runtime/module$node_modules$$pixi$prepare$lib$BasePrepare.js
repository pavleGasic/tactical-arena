shadow$provide.module$node_modules$$pixi$prepare$lib$BasePrepare = function(global, require, module, exports) {
  function findMultipleBaseTextures(item, queue) {
    let result = !1;
    if (item?._textures?.length) {
      for (let i = 0; i < item._textures.length; i++) {
        if (item._textures[i] instanceof core.Texture) {
          const baseTexture = item._textures[i].baseTexture;
          queue.includes(baseTexture) || (queue.push(baseTexture), result = !0);
        }
      }
    }
    return result;
  }
  function findBaseTexture(item, queue) {
    return item.baseTexture instanceof core.BaseTexture ? (item = item.baseTexture, queue.includes(item) || queue.push(item), !0) : !1;
  }
  function findTexture(item, queue) {
    return item._texture && item._texture instanceof core.Texture ? (item = item._texture.baseTexture, queue.includes(item) || queue.push(item), !0) : !1;
  }
  function drawText(_helper, item) {
    return item instanceof text.Text ? (item.updateText(!0), !0) : !1;
  }
  function calculateTextStyle(_helper, item) {
    return item instanceof text.TextStyle ? (_helper = item.toFontString(), text.TextMetrics.measureFont(_helper), !0) : !1;
  }
  function findText(item, queue) {
    return item instanceof text.Text ? (queue.includes(item.style) || queue.push(item.style), queue.includes(item) || queue.push(item), item = item._texture.baseTexture, queue.includes(item) || queue.push(item), !0) : !1;
  }
  function findTextStyle(item, queue) {
    return item instanceof text.TextStyle ? (queue.includes(item) || queue.push(item), !0) : !1;
  }
  var core = require("module$node_modules$$pixi$core$lib$index"), display = require("module$node_modules$$pixi$display$lib$index"), text = require("module$node_modules$$pixi$text$lib$index"), CountLimiter = require("module$node_modules$$pixi$prepare$lib$CountLimiter");
  const node_modules$$pixi$prepare$lib$BasePrepare$classdecl$var23 = class {
    constructor(renderer) {
      this.limiter = new CountLimiter.CountLimiter(node_modules$$pixi$prepare$lib$BasePrepare$classdecl$var23.uploadsPerFrame);
      this.renderer = renderer;
      this.uploadHookHelper = null;
      this.queue = [];
      this.addHooks = [];
      this.uploadHooks = [];
      this.completes = [];
      this.ticking = !1;
      this.delayedTick = () => {
        this.queue && this.prepareItems();
      };
      this.registerFindHook(findText);
      this.registerFindHook(findTextStyle);
      this.registerFindHook(findMultipleBaseTextures);
      this.registerFindHook(findBaseTexture);
      this.registerFindHook(findTexture);
      this.registerUploadHook(drawText);
      this.registerUploadHook(calculateTextStyle);
    }
    upload(item) {
      return new Promise(resolve => {
        item && this.add(item);
        this.queue.length ? (this.completes.push(resolve), this.ticking || (this.ticking = !0, core.Ticker.system.addOnce(this.tick, this, core.UPDATE_PRIORITY.UTILITY))) : resolve();
      });
    }
    tick() {
      setTimeout(this.delayedTick, 0);
    }
    prepareItems() {
      for (this.limiter.beginFrame(); this.queue.length && this.limiter.allowedToUpload();) {
        var item = this.queue[0];
        let uploaded = !1;
        if (item && !item._destroyed) {
          for (let i = 0, len = this.uploadHooks.length; i < len; i++) {
            if (this.uploadHooks[i](this.uploadHookHelper, item)) {
              this.queue.shift();
              uploaded = !0;
              break;
            }
          }
        }
        uploaded || this.queue.shift();
      }
      if (this.queue.length) {
        core.Ticker.system.addOnce(this.tick, this, core.UPDATE_PRIORITY.UTILITY);
      } else {
        this.ticking = !1;
        item = this.completes.slice(0);
        this.completes.length = 0;
        for (let i = 0, len = item.length; i < len; i++) {
          item[i]();
        }
      }
    }
    registerFindHook(addHook) {
      return addHook && this.addHooks.push(addHook), this;
    }
    registerUploadHook(uploadHook) {
      return uploadHook && this.uploadHooks.push(uploadHook), this;
    }
    add(item) {
      for (let i = 0, len = this.addHooks.length; i < len && !this.addHooks[i](item, this.queue); i++) {
      }
      if (item instanceof display.Container) {
        for (let i = item.children.length - 1; 0 <= i; i--) {
          this.add(item.children[i]);
        }
      }
      return this;
    }
    destroy() {
      this.ticking && core.Ticker.system.remove(this.tick, this);
      this.ticking = !1;
      this.uploadHookHelper = this.limiter = this.queue = this.completes = this.renderer = this.uploadHooks = this.addHooks = null;
    }
  };
  global = node_modules$$pixi$prepare$lib$BasePrepare$classdecl$var23;
  global.uploadsPerFrame = 4;
  exports.BasePrepare = global;
};

//# sourceMappingURL=module$node_modules$$pixi$prepare$lib$BasePrepare.js.map
