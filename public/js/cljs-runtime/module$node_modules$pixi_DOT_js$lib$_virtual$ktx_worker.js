shadow$provide.module$node_modules$pixi_DOT_js$lib$_virtual$ktx_worker = function(global, require, module, exports) {
  Object.defineProperty(exports, "__esModule", {value:!0});
  let WORKER_URL = null;
  class WorkerInstance {
    constructor() {
      WORKER_URL || (WORKER_URL = URL.createObjectURL(new Blob(['(function () {\n    \'use strict\';\n\n    const converters \x3d {\n      rgb8unorm: {\n        convertedFormat: "rgba8unorm",\n        convertFunction: convertRGBtoRGBA\n      },\n      "rgb8unorm-srgb": {\n        convertedFormat: "rgba8unorm-srgb",\n        convertFunction: convertRGBtoRGBA\n      }\n    };\n    function convertFormatIfRequired(textureOptions) {\n      const format \x3d textureOptions.format;\n      if (converters[format]) {\n        const convertFunction \x3d converters[format].convertFunction;\n        const levelBuffers \x3d textureOptions.resource;\n        for (let i \x3d 0; i \x3c levelBuffers.length; i++) {\n          levelBuffers[i] \x3d convertFunction(levelBuffers[i]);\n        }\n        textureOptions.format \x3d converters[format].convertedFormat;\n      }\n    }\n    function convertRGBtoRGBA(levelBuffer) {\n      const pixelCount \x3d levelBuffer.byteLength / 3;\n      const levelBufferWithAlpha \x3d new Uint32Array(pixelCount);\n      for (let i \x3d 0; i \x3c pixelCount; ++i) {\n        levelBufferWithAlpha[i] \x3d levelBuffer[i * 3] + (levelBuffer[i * 3 + 1] \x3c\x3c 8) + (levelBuffer[i * 3 + 2] \x3c\x3c 16) + 4278190080;\n      }\n      return new Uint8Array(levelBufferWithAlpha.buffer);\n    }\n\n    function createLevelBuffersFromKTX(ktxTexture) {\n      const levelBuffers \x3d [];\n      for (let i \x3d 0; i \x3c ktxTexture.numLevels; i++) {\n        const imageData \x3d ktxTexture.getImageData(i, 0, 0);\n        const levelBuffer \x3d new Uint8Array(imageData.byteLength);\n        levelBuffer.set(imageData);\n        levelBuffers.push(levelBuffer);\n      }\n      return levelBuffers;\n    }\n\n    const glFormatToGPUFormatMap \x3d {\n      6408: "rgba8unorm",\n      32856: "bgra8unorm",\n      //\n      32857: "rgb10a2unorm",\n      33189: "depth16unorm",\n      33190: "depth24plus",\n      33321: "r8unorm",\n      33323: "rg8unorm",\n      33325: "r16float",\n      33326: "r32float",\n      33327: "rg16float",\n      33328: "rg32float",\n      33329: "r8sint",\n      33330: "r8uint",\n      33331: "r16sint",\n      33332: "r16uint",\n      33333: "r32sint",\n      33334: "r32uint",\n      33335: "rg8sint",\n      33336: "rg8uint",\n      33337: "rg16sint",\n      33338: "rg16uint",\n      33339: "rg32sint",\n      33340: "rg32uint",\n      33778: "bc2-rgba-unorm",\n      33779: "bc3-rgba-unorm",\n      34836: "rgba32float",\n      34842: "rgba16float",\n      35056: "depth24plus-stencil8",\n      35898: "rg11b10ufloat",\n      35901: "rgb9e5ufloat",\n      35907: "rgba8unorm-srgb",\n      // bgra8unorm-srgb\n      36012: "depth32float",\n      36013: "depth32float-stencil8",\n      36168: "stencil8",\n      36208: "rgba32uint",\n      36214: "rgba16uint",\n      36220: "rgba8uint",\n      36226: "rgba32sint",\n      36232: "rgba16sint",\n      36238: "rgba8sint",\n      36492: "bc7-rgba-unorm",\n      36756: "r8snorm",\n      36757: "rg8snorm",\n      36759: "rgba8snorm",\n      37496: "etc2-rgba8unorm",\n      37808: "astc-4x4-unorm"\n    };\n    function glFormatToGPUFormat(glInternalFormat) {\n      const format \x3d glFormatToGPUFormatMap[glInternalFormat];\n      if (format) {\n        return format;\n      }\n      throw new Error(`Unsupported glInternalFormat: ${glInternalFormat}`);\n    }\n\n    const vkFormatToGPUFormatMap \x3d {\n      23: "rgb8unorm",\n      // VK_FORMAT_R8G8B8_UNORM\n      37: "rgba8unorm",\n      // VK_FORMAT_R8G8B8A8_UNORM\n      43: "rgba8unorm-srgb"\n      // VK_FORMAT_R8G8B8A8_SRGB\n      // TODO add more!\n    };\n    function vkFormatToGPUFormat(vkFormat) {\n      const format \x3d vkFormatToGPUFormatMap[vkFormat];\n      if (format) {\n        return format;\n      }\n      throw new Error(`Unsupported VkFormat: ${vkFormat}`);\n    }\n\n    function getTextureFormatFromKTXTexture(ktxTexture) {\n      if (ktxTexture.classId \x3d\x3d\x3d 2) {\n        return vkFormatToGPUFormat(ktxTexture.vkFormat);\n      }\n      return glFormatToGPUFormat(ktxTexture.glInternalformat);\n    }\n\n    const gpuFormatToBasisTranscoderFormatMap \x3d {\n      "bc3-rgba-unorm": "BC3_RGBA",\n      "bc7-rgba-unorm": "BC7_M5_RGBA",\n      "etc2-rgba8unorm": "ETC2_RGBA",\n      "astc-4x4-unorm": "ASTC_4x4_RGBA",\n      // Uncompressed\n      rgba8unorm: "RGBA32",\n      rg11b10ufloat: "R11F_G11F_B10F"\n    };\n    function gpuFormatToKTXBasisTranscoderFormat(transcoderFormat) {\n      const format \x3d gpuFormatToBasisTranscoderFormatMap[transcoderFormat];\n      if (format) {\n        return format;\n      }\n      throw new Error(`Unsupported transcoderFormat: ${transcoderFormat}`);\n    }\n\n    const settings \x3d {\n      jsUrl: "",\n      wasmUrl: ""\n    };\n    let basisTranscoderFormat;\n    let basisTranscodedTextureFormat;\n    let ktxPromise;\n    async function getKTX() {\n      if (!ktxPromise) {\n        const absoluteJsUrl \x3d new URL(settings.jsUrl, location.origin).href;\n        const absoluteWasmUrl \x3d new URL(settings.wasmUrl, location.origin).href;\n        importScripts(absoluteJsUrl);\n        ktxPromise \x3d new Promise((resolve) \x3d\x3e {\n          LIBKTX({\n            locateFile: (_file) \x3d\x3e absoluteWasmUrl\n          }).then((libktx) \x3d\x3e {\n            resolve(libktx);\n          });\n        });\n      }\n      return ktxPromise;\n    }\n    async function fetchKTXTexture(url, ktx) {\n      const ktx2Response \x3d await fetch(url);\n      if (ktx2Response.ok) {\n        const ktx2ArrayBuffer \x3d await ktx2Response.arrayBuffer();\n        return new ktx.ktxTexture(new Uint8Array(ktx2ArrayBuffer));\n      }\n      throw new Error(`Failed to load KTX(2) texture: ${url}`);\n    }\n    const preferredTranscodedFormat \x3d [\n      "bc7-rgba-unorm",\n      "astc-4x4-unorm",\n      "etc2-rgba8unorm",\n      "bc3-rgba-unorm",\n      "rgba8unorm"\n    ];\n    async function load(url) {\n      const ktx \x3d await getKTX();\n      const ktxTexture \x3d await fetchKTXTexture(url, ktx);\n      let format;\n      if (ktxTexture.needsTranscoding) {\n        format \x3d basisTranscodedTextureFormat;\n        const transcodeFormat \x3d ktx.TranscodeTarget[basisTranscoderFormat];\n        const result \x3d ktxTexture.transcodeBasis(transcodeFormat, 0);\n        if (result !\x3d\x3d ktx.ErrorCode.SUCCESS) {\n          throw new Error("Unable to transcode basis texture.");\n        }\n      } else {\n        format \x3d getTextureFormatFromKTXTexture(ktxTexture);\n      }\n      const levelBuffers \x3d createLevelBuffersFromKTX(ktxTexture);\n      const textureOptions \x3d {\n        width: ktxTexture.baseWidth,\n        height: ktxTexture.baseHeight,\n        format,\n        mipLevelCount: ktxTexture.numLevels,\n        resource: levelBuffers,\n        alphaMode: "no-premultiply-alpha"\n      };\n      convertFormatIfRequired(textureOptions);\n      return textureOptions;\n    }\n    async function init(jsUrl, wasmUrl, supportedTextures) {\n      if (jsUrl)\n        settings.jsUrl \x3d jsUrl;\n      if (wasmUrl)\n        settings.wasmUrl \x3d wasmUrl;\n      basisTranscodedTextureFormat \x3d preferredTranscodedFormat.filter((format) \x3d\x3e supportedTextures.includes(format))[0];\n      basisTranscoderFormat \x3d gpuFormatToKTXBasisTranscoderFormat(basisTranscodedTextureFormat);\n      await getKTX();\n    }\n    const messageHandlers \x3d {\n      init: async (data) \x3d\x3e {\n        const { jsUrl, wasmUrl, supportedTextures } \x3d data;\n        await init(jsUrl, wasmUrl, supportedTextures);\n      },\n      load: async (data) \x3d\x3e {\n        try {\n          const textureOptions \x3d await load(data.url);\n          return {\n            type: "load",\n            url: data.url,\n            success: true,\n            textureOptions,\n            transferables: textureOptions.resource?.map((arr) \x3d\x3e arr.buffer)\n          };\n        } catch (e) {\n          throw e;\n        }\n      }\n    };\n    self.onmessage \x3d async (messageEvent) \x3d\x3e {\n      const message \x3d messageEvent.data;\n      const response \x3d await messageHandlers[message.type]?.(message);\n      if (response) {\n        self.postMessage(response, response.transferables);\n      }\n    };\n\n})();\n'], 
      {type:"application/javascript"})));
      this.worker = new Worker(WORKER_URL);
    }
  }
  WorkerInstance.revokeObjectURL = function() {
    WORKER_URL && (URL.revokeObjectURL(WORKER_URL), WORKER_URL = null);
  };
  exports.default = WorkerInstance;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$_virtual$ktx_worker.js.map
