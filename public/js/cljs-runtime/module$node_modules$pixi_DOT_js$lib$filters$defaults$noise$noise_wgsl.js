shadow$provide.module$node_modules$pixi_DOT_js$lib$filters$defaults$noise$noise_wgsl = function(global, require, module, exports) {
  Object.defineProperty(exports, "__esModule", {value:!0});
  exports.default = "\n\nstruct GlobalFilterUniforms {\n  uInputSize:vec4\x3cf32\x3e,\n  uInputPixel:vec4\x3cf32\x3e,\n  uInputClamp:vec4\x3cf32\x3e,\n  uOutputFrame:vec4\x3cf32\x3e,\n  uGlobalFrame:vec4\x3cf32\x3e,\n  uOutputTexture:vec4\x3cf32\x3e,\n};\n\nstruct NoiseUniforms {\n  uNoise:f32,\n  uSeed:f32,\n};\n\n@group(0) @binding(0) var\x3cuniform\x3e gfu: GlobalFilterUniforms;\n@group(0) @binding(1) var uTexture: texture_2d\x3cf32\x3e;\n@group(0) @binding(2) var uSampler : sampler;\n\n@group(1) @binding(0) var\x3cuniform\x3e noiseUniforms : NoiseUniforms;\n\nstruct VSOutput {\n    @builtin(position) position: vec4\x3cf32\x3e,\n    @location(0) uv : vec2\x3cf32\x3e\n  };\n\nfn filterVertexPosition(aPosition:vec2\x3cf32\x3e) -\x3e vec4\x3cf32\x3e\n{\n    var position \x3d aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x \x3d position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y \x3d position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2\x3cf32\x3e ) -\x3e vec2\x3cf32\x3e\n{\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\nfn globalTextureCoord( aPosition:vec2\x3cf32\x3e ) -\x3e vec2\x3cf32\x3e\n{\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  \n}\n\nfn getSize() -\x3e vec2\x3cf32\x3e\n{\n  return gfu.uGlobalFrame.zw;\n}\n  \n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2\x3cf32\x3e, \n) -\x3e VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition)\n  );\n}\n\nfn rand(co:vec2\x3cf32\x3e) -\x3e f32\n{\n  return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2\x3cf32\x3e,\n  @builtin(position) position: vec4\x3cf32\x3e\n) -\x3e @location(0) vec4\x3cf32\x3e {\n\n    var pixelPosition \x3d  globalTextureCoord(position.xy);// / (getSize());//-  gfu.uOutputFrame.xy);\n  \n    \n    var sample \x3d textureSample(uTexture, uSampler, uv);\n    var randomValue \x3d  rand(pixelPosition.xy * noiseUniforms.uSeed);\n    var diff \x3d (randomValue - 0.5) * noiseUniforms.uNoise;\n  \n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (sample.a \x3e 0.0) {\n      sample.r /\x3d sample.a;\n      sample.g /\x3d sample.a;\n      sample.b /\x3d sample.a;\n    }\n\n    sample.r +\x3d diff;\n    sample.g +\x3d diff;\n    sample.b +\x3d diff;\n\n    // Premultiply alpha again.\n    sample.r *\x3d sample.a;\n    sample.g *\x3d sample.a;\n    sample.b *\x3d sample.a;\n    \n    return sample;\n}";
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$filters$defaults$noise$noise_wgsl.js.map
