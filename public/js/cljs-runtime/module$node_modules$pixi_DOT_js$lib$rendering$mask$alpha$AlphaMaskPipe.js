shadow$provide.module$node_modules$pixi_DOT_js$lib$rendering$mask$alpha$AlphaMaskPipe = function(global, require, module, exports) {
  global = require("module$node_modules$pixi_DOT_js$lib$extensions$Extensions");
  module = require("module$node_modules$pixi_DOT_js$lib$filters$FilterEffect");
  var MaskFilter = require("module$node_modules$pixi_DOT_js$lib$filters$mask$MaskFilter"), Bounds = require("module$node_modules$pixi_DOT_js$lib$scene$container$bounds$Bounds"), getGlobalBounds = require("module$node_modules$pixi_DOT_js$lib$scene$container$bounds$getGlobalBounds"), Sprite = require("module$node_modules$pixi_DOT_js$lib$scene$sprite$Sprite"), PoolGroup = require("module$node_modules$pixi_DOT_js$lib$utils$pool$PoolGroup"), Texture = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$texture$Texture"), 
  TexturePool = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$texture$TexturePool"), types = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$types");
  "use strict";
  const tempBounds = new Bounds.Bounds();
  class AlphaMaskEffect extends module.FilterEffect {
    constructor() {
      super();
      this.filters = [new MaskFilter.MaskFilter({sprite:new Sprite.Sprite(Texture.Texture.EMPTY), inverse:!1, resolution:"inherit", antialias:"inherit"})];
    }
    get sprite() {
      return this.filters[0].sprite;
    }
    set sprite(value) {
      this.filters[0].sprite = value;
    }
    get inverse() {
      return this.filters[0].inverse;
    }
    set inverse(value) {
      this.filters[0].inverse = value;
    }
  }
  class AlphaMaskPipe {
    constructor(renderer) {
      this._activeMaskStage = [];
      this._renderer = renderer;
    }
    push(mask, maskedContainer, instructionSet) {
      const renderer = this._renderer;
      renderer.renderPipes.batch.break(instructionSet);
      instructionSet.add({renderPipeId:"alphaMask", action:"pushMaskBegin", mask, inverse:maskedContainer._maskOptions.inverse, canBundle:!1, maskedContainer});
      mask.inverse = maskedContainer._maskOptions.inverse;
      if (mask.renderMaskToTexture) {
        const maskContainer = mask.mask;
        maskContainer.includeInBuild = !0;
        maskContainer.collectRenderables(instructionSet, renderer, null);
        maskContainer.includeInBuild = !1;
      }
      renderer.renderPipes.batch.break(instructionSet);
      instructionSet.add({renderPipeId:"alphaMask", action:"pushMaskEnd", mask, maskedContainer, inverse:maskedContainer._maskOptions.inverse, canBundle:!1});
    }
    pop(mask, _maskedContainer, instructionSet) {
      this._renderer.renderPipes.batch.break(instructionSet);
      instructionSet.add({renderPipeId:"alphaMask", action:"popMaskEnd", mask, inverse:_maskedContainer._maskOptions.inverse, canBundle:!1});
    }
    execute(instruction) {
      var renderer = this._renderer, renderMask = instruction.mask.renderMaskToTexture;
      if ("pushMaskBegin" === instruction.action) {
        const filterEffect = PoolGroup.BigPool.get(AlphaMaskEffect);
        filterEffect.inverse = instruction.inverse;
        if (renderMask) {
          instruction.mask.mask.measurable = !0;
          renderMask = getGlobalBounds.getGlobalBounds(instruction.mask.mask, !0, tempBounds);
          instruction.mask.mask.measurable = !1;
          renderMask.ceil();
          var colorTextureSource = renderer.renderTarget.renderTarget.colorTexture.source;
          colorTextureSource = TexturePool.TexturePool.getOptimalTexture(renderMask.width, renderMask.height, colorTextureSource._resolution, colorTextureSource.antialias);
          renderer.renderTarget.push(colorTextureSource, !0);
          renderer.globalUniforms.push({offset:renderMask, worldColor:4294967295});
          renderer = filterEffect.sprite;
          renderer.texture = colorTextureSource;
          renderer.worldTransform.tx = renderMask.minX;
          renderer.worldTransform.ty = renderMask.minY;
          this._activeMaskStage.push({filterEffect, maskedContainer:instruction.maskedContainer, filterTexture:colorTextureSource});
        } else {
          filterEffect.sprite = instruction.mask.mask, this._activeMaskStage.push({filterEffect, maskedContainer:instruction.maskedContainer});
        }
      } else {
        "pushMaskEnd" === instruction.action ? (instruction = this._activeMaskStage[this._activeMaskStage.length - 1], renderMask && (renderer.type === types.RendererType.WEBGL && renderer.renderTarget.finishRenderPass(), renderer.renderTarget.pop(), renderer.globalUniforms.pop()), renderer.filter.push({renderPipeId:"filter", action:"pushFilter", container:instruction.maskedContainer, filterEffect:instruction.filterEffect, canBundle:!1})) : "popMaskEnd" === instruction.action && (renderer.filter.pop(), 
        instruction = this._activeMaskStage.pop(), renderMask && TexturePool.TexturePool.returnTexture(instruction.filterTexture), PoolGroup.BigPool.return(instruction.filterEffect));
      }
    }
    destroy() {
      this._activeMaskStage = this._renderer = null;
    }
  }
  AlphaMaskPipe.extension = {type:[global.ExtensionType.WebGLPipes, global.ExtensionType.WebGPUPipes, global.ExtensionType.CanvasPipes], name:"alphaMask"};
  exports.AlphaMaskPipe = AlphaMaskPipe;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$rendering$mask$alpha$AlphaMaskPipe.js.map
