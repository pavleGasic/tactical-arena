shadow$provide.module$node_modules$pixi_DOT_js$lib$scene$particle_container$shared$ParticleContainer = function(global, require, module, exports) {
  global = require("module$node_modules$pixi_DOT_js$lib$scene$container$bounds$Bounds");
  module = require("module$node_modules$pixi_DOT_js$lib$scene$view$ViewContainer");
  var particleData = require("module$node_modules$pixi_DOT_js$lib$scene$particle_container$shared$particleData");
  "use strict";
  const emptyBounds = new global.Bounds(0, 0, 0, 0), node_modules$pixi_DOT_js$lib$scene$particle_container$shared$ParticleContainer$classdecl$var46 = class extends module.ViewContainer {
    constructor(options = {}) {
      options = {...node_modules$pixi_DOT_js$lib$scene$particle_container$shared$ParticleContainer$classdecl$var46.defaultOptions, ...options, dynamicProperties:{...node_modules$pixi_DOT_js$lib$scene$particle_container$shared$ParticleContainer$classdecl$var46.defaultOptions.dynamicProperties, ...options?.dynamicProperties}};
      const {dynamicProperties, shader, roundPixels, texture, particles, ...rest} = options;
      super({label:"ParticleContainer", ...rest});
      this.renderPipeId = "particle";
      this._childrenDirty = this.batched = !1;
      this.texture = texture || null;
      this.shader = shader;
      this._properties = {};
      for (const key in particleData.particleData) {
        this._properties[key] = {...particleData.particleData[key], dynamic:dynamicProperties[key]};
      }
      this.allowChildren = !0;
      this.roundPixels = roundPixels ?? !1;
      this.particleChildren = particles ?? [];
    }
    addParticle(...children) {
      for (let i = 0; i < children.length; i++) {
        this.particleChildren.push(children[i]);
      }
      this.onViewUpdate();
      return children[0];
    }
    removeParticle(...children) {
      let didRemove = !1;
      for (let i = 0; i < children.length; i++) {
        const index = this.particleChildren.indexOf(children[i]);
        -1 < index && (this.particleChildren.splice(index, 1), didRemove = !0);
      }
      if (didRemove) {
        this.onViewUpdate();
      }
      return children[0];
    }
    update() {
      this._childrenDirty = !0;
    }
    onViewUpdate() {
      this._childrenDirty = !0;
      super.onViewUpdate();
    }
    get bounds() {
      return emptyBounds;
    }
    updateBounds() {
    }
    destroy(options = !1) {
      super.destroy(options);
      if ("boolean" === typeof options ? options : options?.texture) {
        const texture = this.texture ?? this.particleChildren[0]?.texture;
        texture && texture.destroy("boolean" === typeof options ? options : options?.textureSource);
      }
      this.texture = null;
      this.shader?.destroy();
    }
    removeParticles(beginIndex, endIndex) {
      beginIndex = this.particleChildren.splice(beginIndex, endIndex);
      this.onViewUpdate();
      return beginIndex;
    }
    removeParticleAt(index) {
      index = this.particleChildren.splice(index, 1);
      this.onViewUpdate();
      return index[0];
    }
    addParticleAt(child, index) {
      this.particleChildren.splice(index, 0, child);
      this.onViewUpdate();
      return child;
    }
    addChild(..._children) {
      throw Error("ParticleContainer.addChild() is not available. Please use ParticleContainer.addParticle()");
    }
    removeChild(..._children) {
      throw Error("ParticleContainer.removeChild() is not available. Please use ParticleContainer.removeParticle()");
    }
    removeChildren(_beginIndex, _endIndex) {
      throw Error("ParticleContainer.removeChildren() is not available. Please use ParticleContainer.removeParticles()");
    }
    removeChildAt(_index) {
      throw Error("ParticleContainer.removeChildAt() is not available. Please use ParticleContainer.removeParticleAt()");
    }
    getChildAt(_index) {
      throw Error("ParticleContainer.getChildAt() is not available. Please use ParticleContainer.getParticleAt()");
    }
    setChildIndex(_child, _index) {
      throw Error("ParticleContainer.setChildIndex() is not available. Please use ParticleContainer.setParticleIndex()");
    }
    getChildIndex(_child) {
      throw Error("ParticleContainer.getChildIndex() is not available. Please use ParticleContainer.getParticleIndex()");
    }
    addChildAt(_child, _index) {
      throw Error("ParticleContainer.addChildAt() is not available. Please use ParticleContainer.addParticleAt()");
    }
    swapChildren(_child, _child2) {
      throw Error("ParticleContainer.swapChildren() is not available. Please use ParticleContainer.swapParticles()");
    }
    reparentChild(..._child) {
      throw Error("ParticleContainer.reparentChild() is not available with the particle container");
    }
    reparentChildAt(_child, _index) {
      throw Error("ParticleContainer.reparentChildAt() is not available with the particle container");
    }
  };
  require = node_modules$pixi_DOT_js$lib$scene$particle_container$shared$ParticleContainer$classdecl$var46;
  require.defaultOptions = {dynamicProperties:{vertex:!1, position:!0, rotation:!1, uvs:!1, color:!1}, roundPixels:!1};
  exports.ParticleContainer = require;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$scene$particle_container$shared$ParticleContainer.js.map
