shadow$provide.module$node_modules$$pixi$filter_displacement$lib$DisplacementFilter = function(global, require, module, exports) {
  var core = require("module$node_modules$$pixi$core$lib$index"), displacement$1 = require("module$node_modules$$pixi$filter_displacement$lib$displacement_frag"), displacement = require("module$node_modules$$pixi$filter_displacement$lib$displacement_vert");
  class DisplacementFilter extends core.Filter {
    constructor(sprite, scale) {
      const maskMatrix = new core.Matrix();
      sprite.renderable = !1;
      super(displacement.default, displacement$1.default, {mapSampler:sprite._texture, filterMatrix:maskMatrix, scale:{x:1, y:1}, rotation:new Float32Array([1, 0, 0, 1])});
      this.maskSprite = sprite;
      this.maskMatrix = maskMatrix;
      null == scale && (scale = 20);
      this.scale = new core.Point(scale, scale);
    }
    apply(filterManager, input, output, clearMode) {
      this.uniforms.filterMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, this.maskSprite);
      this.uniforms.scale.x = this.scale.x;
      this.uniforms.scale.y = this.scale.y;
      const wt = this.maskSprite.worldTransform, lenX = Math.sqrt(wt.a * wt.a + wt.b * wt.b), lenY = Math.sqrt(wt.c * wt.c + wt.d * wt.d);
      0 !== lenX && 0 !== lenY && (this.uniforms.rotation[0] = wt.a / lenX, this.uniforms.rotation[1] = wt.b / lenX, this.uniforms.rotation[2] = wt.c / lenY, this.uniforms.rotation[3] = wt.d / lenY);
      filterManager.applyFilter(this, input, output, clearMode);
    }
    get map() {
      return this.uniforms.mapSampler;
    }
    set map(value) {
      this.uniforms.mapSampler = value;
    }
  }
  exports.DisplacementFilter = DisplacementFilter;
};

//# sourceMappingURL=module$node_modules$$pixi$filter_displacement$lib$DisplacementFilter.js.map
