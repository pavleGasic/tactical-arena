shadow$provide.module$node_modules$pixi_DOT_js$lib$scene$particle_container$shared$particleData = function(global, require, module, exports) {
  exports.particleData = {vertex:{attributeName:"aVertex", format:"float32x2", code:"\n            const texture \x3d p.texture;\n            const sx \x3d p.scaleX;\n            const sy \x3d p.scaleY;\n            const ax \x3d p.anchorX;\n            const ay \x3d p.anchorY;\n            const trim \x3d texture.trim;\n            const orig \x3d texture.orig;\n\n            if (trim)\n            {\n                w1 \x3d trim.x - (ax * orig.width);\n                w0 \x3d w1 + trim.width;\n\n                h1 \x3d trim.y - (ay * orig.height);\n                h0 \x3d h1 + trim.height;\n            }\n            else\n            {\n                w1 \x3d -ax * (orig.width);\n                w0 \x3d w1 + orig.width;\n\n                h1 \x3d -ay * (orig.height);\n                h0 \x3d h1 + orig.height;\n            }\n\n            f32v[offset] \x3d w1 * sx;\n            f32v[offset + 1] \x3d h1 * sy;\n\n            f32v[offset + stride] \x3d w0 * sx;\n            f32v[offset + stride + 1] \x3d h1 * sy;\n\n            f32v[offset + (stride * 2)] \x3d w0 * sx;\n            f32v[offset + (stride * 2) + 1] \x3d h0 * sy;\n\n            f32v[offset + (stride * 3)] \x3d w1 * sx;\n            f32v[offset + (stride * 3) + 1] \x3d h0 * sy;\n        ", 
  dynamic:!1}, position:{attributeName:"aPosition", format:"float32x2", code:"\n            var x \x3d p.x;\n            var y \x3d p.y;\n\n            f32v[offset] \x3d x;\n            f32v[offset + 1] \x3d y;\n\n            f32v[offset + stride] \x3d x;\n            f32v[offset + stride + 1] \x3d y;\n\n            f32v[offset + (stride * 2)] \x3d x;\n            f32v[offset + (stride * 2) + 1] \x3d y;\n\n            f32v[offset + (stride * 3)] \x3d x;\n            f32v[offset + (stride * 3) + 1] \x3d y;\n        ", 
  dynamic:!0}, rotation:{attributeName:"aRotation", format:"float32", code:"\n            var rotation \x3d p.rotation;\n\n            f32v[offset] \x3d rotation;\n            f32v[offset + stride] \x3d rotation;\n            f32v[offset + (stride * 2)] \x3d rotation;\n            f32v[offset + (stride * 3)] \x3d rotation;\n        ", dynamic:!1}, uvs:{attributeName:"aUV", format:"float32x2", code:"\n            var uvs \x3d p.texture.uvs;\n\n            f32v[offset] \x3d uvs.x0;\n            f32v[offset + 1] \x3d uvs.y0;\n\n            f32v[offset + stride] \x3d uvs.x1;\n            f32v[offset + stride + 1] \x3d uvs.y1;\n\n            f32v[offset + (stride * 2)] \x3d uvs.x2;\n            f32v[offset + (stride * 2) + 1] \x3d uvs.y2;\n\n            f32v[offset + (stride * 3)] \x3d uvs.x3;\n            f32v[offset + (stride * 3) + 1] \x3d uvs.y3;\n        ", 
  dynamic:!1}, color:{attributeName:"aColor", format:"unorm8x4", code:"\n            const c \x3d p.color;\n\n            u32v[offset] \x3d c;\n            u32v[offset + stride] \x3d c;\n            u32v[offset + (stride * 2)] \x3d c;\n            u32v[offset + (stride * 3)] \x3d c;\n        ", dynamic:!1}};
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$scene$particle_container$shared$particleData.js.map
