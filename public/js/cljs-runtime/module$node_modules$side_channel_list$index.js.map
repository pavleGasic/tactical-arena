{
"version":3,
"file":"module$node_modules$side_channel_list$index.js",
"lineCount":33,
"mappings":"AAAAA,cAAA,CAAA,2CAAA,GAAgE,QAAQ,CAACC,MAAD,EAAQC,OAAR,EAAgBC,MAAhB,EAAuBC,OAAvB,CAAgC;AAGxG,MAAIC,UAAUH,OAAA,CAAQ,0CAAR,CAAd,EAEII,aAAaJ,OAAA,CAAQ,oCAAR,CAFjB,EAYIK,cAAcA,QAAS,CAACC,IAAD,EAAOC,GAAP,EAAYC,QAAZ,CAAsB;AAMhD,SAJA,IAAIC,OAAOH,IAAX,EAEII,IAEJ,EAA6B,IAA7B,KAAQA,IAAR,GAAeD,IAAKE,CAAAA,IAApB,GAAmCF,IAAnC,GAA0CC,IAA1C;AACC,UAAIA,IAAKH,CAAAA,GAAT,KAAiBA,GAAjB;AAOC,eANAE,IAAKE,CAAAA,IAMED,GANKA,IAAKC,CAAAA,IAMVD,EALFF,QAKEE,KAHNA,IAAKC,CAAAA,IACL,GAD0DL,IAAKK,CAAAA,IAC/D,EAAAL,IAAKK,CAAAA,IAAL,GAAYD,IAENA,GAAAA,IAAP;AAPD;AADD;AANgD,GAZjD;AAqEAT,QAAOC,CAAAA,OAAP,GAAiBU,QAA2B,EAAG;AAKkB,QAAIC,EAAJ,EAG5DC,UAAU,CACbC,OAAQA,QAAS,CAACR,GAAD,CAAM;AACtB,UAAI,CAACO,OAAQE,CAAAA,GAAR,CAAYT,GAAZ,CAAL;AACC,cAAM,IAAIH,UAAJ,CAAe,gCAAf,GAAkDD,OAAA,CAAQI,GAAR,CAAlD,CAAN;AADD;AADsB,KADV,EAMb,SAAUU,QAAS,CAACV,GAAD,CAAM;AACxB,UAAIW,OAAOL,EAAPK,IAAaL,EAAGF,CAAAA,IAApB;AApBD,SAAA,GAqB8BE,EAtB/B,GACQR,WAAA,CAqBuBQ,EArBvB,EAqB2BN,GArB3B,EAA0B,CAAA,CAA1B,CADR,GADwC,IAAA,EAEvC;AAsBKY,SAAJ,IAAmBD,IAAnB,IAA2BA,IAA3B,KAAoCC,GAApC,KACCN,EADD,GACM,IAAKO,EADX;AAGA,aAAO,CAAC,CAACD,GAAT;AANwB,KANZ,EAcbE,IAAKA,QAAS,CAACd,GAAD,CAAM;AAtDrB,SAAA,GAuDiBM,EA3DjB,IAGIS,GAHJ,GAGWjB,WAAA,CAwDMQ,EAxDN,EAwDUN,GAxDV,CAHX,KAIee,GAAKC,CAAAA,KAJpB,GACQ,IAAKH,EAGb;AAuDE,aAAO,GAAP;AADmB,KAdP,EAiBbJ,IAAKA,QAAS,CAACT,GAAD,CAAM;AApCrB,SAAA,GAqCiBM,EAxCjB,GAGO,CAAC,CAACR,WAAA,CAqCQQ,EArCR,EAqCYN,GArCZ,CAHT,GACQ,CAAA,CAER;AAqCE,aAAO,GAAP;AADmB,KAjBP,EAoBbiB,IAAKA,QAAS,CAACjB,GAAD,EAAMgB,KAAN,CAAa;AACrBV,QAAL,KAECA,EAFD,GAEM,CACJF,KAAM,IAAKS,EADP,CAFN;AAO+CP,UAAAA,UAAAA,EAAAA,EAhE7CS,OAAOjB,WAAA,CAAYoB,OAAZ,EAgE2ClB,GAhE3C,CAgEsCM;AA/D7CS,UAAJ,GACCA,IAAKC,CAAAA,KADN,GA+D2DA,KA/D3D,GAICE,OAAQd,CAAAA,IAJT,GAIyF,CA2DnCJ,GA3DmC,EAEvFI,KAAMc,OAAQd,CAAAA,IAFyE,EA2D9BY,KA3D8B,CAJzF;AAuD4B,KApBd,CAHkD;AAmChE,WAAOT,OAAP;AAxC8C,GAA/C;AAxEwG,CAAxG;;",
"sources":["node_modules/side-channel-list/index.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$side_channel_list$index\"] = function(global,require,module,exports) {\n'use strict';\n\nvar inspect = require('object-inspect');\n\nvar $TypeError = require('es-errors/type');\n\n/*\n* This function traverses the list returning the node corresponding to the given key.\n*\n* That node is also moved to the head of the list, so that if it's accessed again we don't need to traverse the whole list.\n* By doing so, all the recently used nodes can be accessed relatively quickly.\n*/\n/** @type {import('./list.d.ts').listGetNode} */\n// eslint-disable-next-line consistent-return\nvar listGetNode = function (list, key, isDelete) {\n\t/** @type {typeof list | NonNullable<(typeof list)['next']>} */\n\tvar prev = list;\n\t/** @type {(typeof list)['next']} */\n\tvar curr;\n\t// eslint-disable-next-line eqeqeq\n\tfor (; (curr = prev.next) != null; prev = curr) {\n\t\tif (curr.key === key) {\n\t\t\tprev.next = curr.next;\n\t\t\tif (!isDelete) {\n\t\t\t\t// eslint-disable-next-line no-extra-parens\n\t\t\t\tcurr.next = /** @type {NonNullable<typeof list.next>} */ (list.next);\n\t\t\t\tlist.next = curr; // eslint-disable-line no-param-reassign\n\t\t\t}\n\t\t\treturn curr;\n\t\t}\n\t}\n};\n\n/** @type {import('./list.d.ts').listGet} */\nvar listGet = function (objects, key) {\n\tif (!objects) {\n\t\treturn void undefined;\n\t}\n\tvar node = listGetNode(objects, key);\n\treturn node && node.value;\n};\n/** @type {import('./list.d.ts').listSet} */\nvar listSet = function (objects, key, value) {\n\tvar node = listGetNode(objects, key);\n\tif (node) {\n\t\tnode.value = value;\n\t} else {\n\t\t// Prepend the new node to the beginning of the list\n\t\tobjects.next = /** @type {import('./list.d.ts').ListNode<typeof value, typeof key>} */ ({ // eslint-disable-line no-param-reassign, no-extra-parens\n\t\t\tkey: key,\n\t\t\tnext: objects.next,\n\t\t\tvalue: value\n\t\t});\n\t}\n};\n/** @type {import('./list.d.ts').listHas} */\nvar listHas = function (objects, key) {\n\tif (!objects) {\n\t\treturn false;\n\t}\n\treturn !!listGetNode(objects, key);\n};\n/** @type {import('./list.d.ts').listDelete} */\n// eslint-disable-next-line consistent-return\nvar listDelete = function (objects, key) {\n\tif (objects) {\n\t\treturn listGetNode(objects, key, true);\n\t}\n};\n\n/** @type {import('.')} */\nmodule.exports = function getSideChannelList() {\n\t/** @typedef {ReturnType<typeof getSideChannelList>} Channel */\n\t/** @typedef {Parameters<Channel['get']>[0]} K */\n\t/** @typedef {Parameters<Channel['set']>[1]} V */\n\n\t/** @type {import('./list.d.ts').RootNode<V, K> | undefined} */ var $o;\n\n\t/** @type {Channel} */\n\tvar channel = {\n\t\tassert: function (key) {\n\t\t\tif (!channel.has(key)) {\n\t\t\t\tthrow new $TypeError('Side channel does not contain ' + inspect(key));\n\t\t\t}\n\t\t},\n\t\t'delete': function (key) {\n\t\t\tvar root = $o && $o.next;\n\t\t\tvar deletedNode = listDelete($o, key);\n\t\t\tif (deletedNode && root && root === deletedNode) {\n\t\t\t\t$o = void undefined;\n\t\t\t}\n\t\t\treturn !!deletedNode;\n\t\t},\n\t\tget: function (key) {\n\t\t\treturn listGet($o, key);\n\t\t},\n\t\thas: function (key) {\n\t\t\treturn listHas($o, key);\n\t\t},\n\t\tset: function (key, value) {\n\t\t\tif (!$o) {\n\t\t\t\t// Initialize the linked list as an empty node, so that we don't have to special-case handling of the first node: we can always refer to it as (previous node).next, instead of something like (list).head\n\t\t\t\t$o = {\n\t\t\t\t\tnext: void undefined\n\t\t\t\t};\n\t\t\t}\n\t\t\t// eslint-disable-next-line no-extra-parens\n\t\t\tlistSet(/** @type {NonNullable<typeof $o>} */ ($o), key, value);\n\t\t}\n\t};\n\t// @ts-expect-error TODO: figure out why this is erroring\n\treturn channel;\n};\n\n};"],
"names":["shadow$provide","global","require","module","exports","inspect","$TypeError","listGetNode","list","key","isDelete","prev","curr","next","module.exports","$o","channel","assert","has","delete","root","deletedNode","undefined","get","node","value","set","objects"]
}
