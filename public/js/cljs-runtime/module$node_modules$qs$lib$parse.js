shadow$provide.module$node_modules$qs$lib$parse = function(global, require, module, exports) {
  var utils = require("module$node_modules$qs$lib$utils"), has = Object.prototype.hasOwnProperty, isArray = Array.isArray, defaults = {allowDots:!1, allowEmptyArrays:!1, allowPrototypes:!1, allowSparse:!1, arrayLimit:20, charset:"utf-8", charsetSentinel:!1, comma:!1, decodeDotInKeys:!1, decoder:utils.decode, delimiter:"\x26", depth:5, duplicates:"combine", ignoreQueryPrefix:!1, interpretNumericEntities:!1, parameterLimit:1000, parseArrays:!0, plainObjects:!1, strictDepth:!1, strictNullHandling:!1, 
  throwOnLimitExceeded:!1}, interpretNumericEntities = function(str) {
    return str.replace(/&#(\d+);/g, function($0, numberStr) {
      return String.fromCharCode(parseInt(numberStr, 10));
    });
  }, parseArrayValue = function(val, options, currentArrayLength) {
    if (val && "string" === typeof val && options.comma && -1 < val.indexOf(",")) {
      return val.split(",");
    }
    if (options.throwOnLimitExceeded && currentArrayLength >= options.arrayLimit) {
      throw new RangeError("Array limit exceeded. Only " + options.arrayLimit + " element" + (1 === options.arrayLimit ? "" : "s") + " allowed in an array.");
    }
    return val;
  }, parseValues = function(str, options) {
    var obj = {__proto__:null};
    str = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
    str = str.replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    var limit = Infinity === options.parameterLimit ? void 0 : options.parameterLimit;
    str = str.split(options.delimiter, options.throwOnLimitExceeded ? limit + 1 : limit);
    if (options.throwOnLimitExceeded && str.length > limit) {
      throw new RangeError("Parameter limit exceeded. Only " + limit + " parameter" + (1 === limit ? "" : "s") + " allowed.");
    }
    limit = -1;
    var i, charset = options.charset;
    if (options.charsetSentinel) {
      for (i = 0; i < str.length; ++i) {
        0 === str[i].indexOf("utf8\x3d") && ("utf8\x3d%E2%9C%93" === str[i] ? charset = "utf-8" : "utf8\x3d%26%2310003%3B" === str[i] && (charset = "iso-8859-1"), limit = i, i = str.length);
      }
    }
    for (i = 0; i < str.length; ++i) {
      if (i !== limit) {
        var part = str[i], bracketEqualsPos = part.indexOf("]\x3d"), pos = -1 === bracketEqualsPos ? part.indexOf("\x3d") : bracketEqualsPos + 1;
        -1 === pos ? (bracketEqualsPos = options.decoder(part, defaults.decoder, charset, "key"), pos = options.strictNullHandling ? null : "") : (bracketEqualsPos = options.decoder(part.slice(0, pos), defaults.decoder, charset, "key"), pos = utils.maybeMap(parseArrayValue(part.slice(pos + 1), options, isArray(obj[bracketEqualsPos]) ? obj[bracketEqualsPos].length : 0), function(encodedVal) {
          return options.decoder(encodedVal, defaults.decoder, charset, "value");
        }));
        pos && options.interpretNumericEntities && "iso-8859-1" === charset && (pos = interpretNumericEntities(String(pos)));
        -1 < part.indexOf("[]\x3d") && (pos = isArray(pos) ? [pos] : pos);
        (part = has.call(obj, bracketEqualsPos)) && "combine" === options.duplicates ? obj[bracketEqualsPos] = utils.combine(obj[bracketEqualsPos], pos) : part && "last" !== options.duplicates || (obj[bracketEqualsPos] = pos);
      }
    }
    return obj;
  };
  module.exports = function(str, opts) {
    if (opts) {
      if ("undefined" !== typeof opts.allowEmptyArrays && "boolean" !== typeof opts.allowEmptyArrays) {
        throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
      }
      if ("undefined" !== typeof opts.decodeDotInKeys && "boolean" !== typeof opts.decodeDotInKeys) {
        throw new TypeError("`decodeDotInKeys` option can only be `true` or `false`, when provided");
      }
      if (null !== opts.decoder && "undefined" !== typeof opts.decoder && "function" !== typeof opts.decoder) {
        throw new TypeError("Decoder has to be a function.");
      }
      if ("undefined" !== typeof opts.charset && "utf-8" !== opts.charset && "iso-8859-1" !== opts.charset) {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      if ("undefined" !== typeof opts.throwOnLimitExceeded && "boolean" !== typeof opts.throwOnLimitExceeded) {
        throw new TypeError("`throwOnLimitExceeded` option must be a boolean");
      }
      var charset = "undefined" === typeof opts.charset ? defaults.charset : opts.charset, duplicates = "undefined" === typeof opts.duplicates ? defaults.duplicates : opts.duplicates;
      if ("combine" !== duplicates && "first" !== duplicates && "last" !== duplicates) {
        throw new TypeError("The duplicates option must be either combine, first, or last");
      }
      opts = {allowDots:"undefined" === typeof opts.allowDots ? !0 === opts.decodeDotInKeys ? !0 : defaults.allowDots : !!opts.allowDots, allowEmptyArrays:"boolean" === typeof opts.allowEmptyArrays ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays, allowPrototypes:"boolean" === typeof opts.allowPrototypes ? opts.allowPrototypes : defaults.allowPrototypes, allowSparse:"boolean" === typeof opts.allowSparse ? opts.allowSparse : defaults.allowSparse, arrayLimit:"number" === typeof opts.arrayLimit ? 
      opts.arrayLimit : defaults.arrayLimit, charset, charsetSentinel:"boolean" === typeof opts.charsetSentinel ? opts.charsetSentinel : defaults.charsetSentinel, comma:"boolean" === typeof opts.comma ? opts.comma : defaults.comma, decodeDotInKeys:"boolean" === typeof opts.decodeDotInKeys ? opts.decodeDotInKeys : defaults.decodeDotInKeys, decoder:"function" === typeof opts.decoder ? opts.decoder : defaults.decoder, delimiter:"string" === typeof opts.delimiter || utils.isRegExp(opts.delimiter) ? opts.delimiter : 
      defaults.delimiter, depth:"number" === typeof opts.depth || !1 === opts.depth ? +opts.depth : defaults.depth, duplicates, ignoreQueryPrefix:!0 === opts.ignoreQueryPrefix, interpretNumericEntities:"boolean" === typeof opts.interpretNumericEntities ? opts.interpretNumericEntities : defaults.interpretNumericEntities, parameterLimit:"number" === typeof opts.parameterLimit ? opts.parameterLimit : defaults.parameterLimit, parseArrays:!1 !== opts.parseArrays, plainObjects:"boolean" === typeof opts.plainObjects ? 
      opts.plainObjects : defaults.plainObjects, strictDepth:"boolean" === typeof opts.strictDepth ? !!opts.strictDepth : defaults.strictDepth, strictNullHandling:"boolean" === typeof opts.strictNullHandling ? opts.strictNullHandling : defaults.strictNullHandling, throwOnLimitExceeded:"boolean" === typeof opts.throwOnLimitExceeded ? opts.throwOnLimitExceeded : !1};
    } else {
      opts = defaults;
    }
    if ("" === str || null === str || "undefined" === typeof str) {
      return opts.plainObjects ? {__proto__:null} : {};
    }
    charset = "string" === typeof str ? parseValues(str, opts) : str;
    duplicates = opts.plainObjects ? {__proto__:null} : {};
    for (var keys = Object.keys(charset), i = 0; i < keys.length; ++i) {
      var key = keys[i];
      a: {
        var newObj = key;
        var val = charset[key], options = opts;
        key = "string" === typeof str;
        if (newObj) {
          newObj = options.allowDots ? newObj.replace(/\.([^.[]+)/g, "[$1]") : newObj;
          var brackets = /(\[[^[\]]*])/, child = /(\[[^[\]]*])/g, parent = (brackets = 0 < options.depth && brackets.exec(newObj)) ? newObj.slice(0, brackets.index) : newObj, keys$jscomp$0 = [];
          if (parent) {
            if (!options.plainObjects && has.call(Object.prototype, parent) && !options.allowPrototypes) {
              newObj = void 0;
              break a;
            }
            keys$jscomp$0.push(parent);
          }
          for (parent = 0; 0 < options.depth && null !== (brackets = child.exec(newObj)) && parent < options.depth;) {
            parent += 1;
            if (!options.plainObjects && has.call(Object.prototype, brackets[1].slice(1, -1)) && !options.allowPrototypes) {
              newObj = void 0;
              break a;
            }
            keys$jscomp$0.push(brackets[1]);
          }
          if (brackets) {
            if (!0 === options.strictDepth) {
              throw new RangeError("Input depth exceeded depth option of " + options.depth + " and strictDepth is true");
            }
            keys$jscomp$0.push("[" + newObj.slice(brackets.index) + "]");
          }
          newObj = keys$jscomp$0;
          child = 0;
          0 < newObj.length && "[]" === newObj[newObj.length - 1] && (child = newObj.slice(0, -1).join(""), child = Array.isArray(val) && val[child] ? val[child].length : 0);
          key = key ? val : parseArrayValue(val, options, child);
          for (val = newObj.length - 1; 0 <= val; --val) {
            brackets = newObj[val], "[]" === brackets && options.parseArrays ? child = options.allowEmptyArrays && ("" === key || options.strictNullHandling && null === key) ? [] : utils.combine([], key) : (child = options.plainObjects ? {__proto__:null} : {}, keys$jscomp$0 = "[" === brackets.charAt(0) && "]" === brackets.charAt(brackets.length - 1) ? brackets.slice(1, -1) : brackets, keys$jscomp$0 = options.decodeDotInKeys ? keys$jscomp$0.replace(/%2E/g, ".") : keys$jscomp$0, parent = parseInt(keys$jscomp$0, 
            10), options.parseArrays || "" !== keys$jscomp$0 ? !isNaN(parent) && brackets !== keys$jscomp$0 && String(parent) === keys$jscomp$0 && 0 <= parent && options.parseArrays && parent <= options.arrayLimit ? (child = [], child[parent] = key) : "__proto__" !== keys$jscomp$0 && (child[keys$jscomp$0] = key) : child = {0:key}), key = child;
          }
          newObj = key;
        } else {
          newObj = void 0;
        }
      }
      duplicates = utils.merge(duplicates, newObj, opts);
    }
    return !0 === opts.allowSparse ? duplicates : utils.compact(duplicates);
  };
};

//# sourceMappingURL=module$node_modules$qs$lib$parse.js.map
