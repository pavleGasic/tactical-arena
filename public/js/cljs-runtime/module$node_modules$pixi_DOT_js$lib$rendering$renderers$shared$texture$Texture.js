shadow$provide.module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$texture$Texture = function(global, require, module, exports) {
  global = require("module$node_modules$eventemitter3$index");
  var groupD8 = require("module$node_modules$pixi_DOT_js$lib$maths$matrix$groupD8"), Rectangle = require("module$node_modules$pixi_DOT_js$lib$maths$shapes$Rectangle"), uid = require("module$node_modules$pixi_DOT_js$lib$utils$data$uid"), deprecation = require("module$node_modules$pixi_DOT_js$lib$utils$logging$deprecation");
  module = require("module$node_modules$pixi_DOT_js$lib$utils$misc$NOOP");
  var BufferImageSource = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$texture$sources$BufferImageSource"), TextureSource = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$texture$sources$TextureSource"), TextureMatrix = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$texture$TextureMatrix");
  "use strict";
  class Texture extends global {
    constructor({source, label, frame, orig, trim, defaultAnchor, defaultBorders, rotate, dynamic} = {}) {
      super();
      this.uid = uid.uid("texture");
      this.uvs = {x0:0, y0:0, x1:0, y1:0, x2:0, y2:0, x3:0, y3:0};
      this.frame = new Rectangle.Rectangle();
      this.dynamic = this.noFrame = !1;
      this.isTexture = !0;
      this.label = label;
      this.source = source?.source ?? new TextureSource.TextureSource();
      this.noFrame = !frame;
      if (frame) {
        this.frame.copyFrom(frame);
      } else {
        const {width, height} = this._source;
        this.frame.width = width;
        this.frame.height = height;
      }
      this.orig = orig || this.frame;
      this.trim = trim;
      this.rotate = rotate ?? 0;
      this.defaultAnchor = defaultAnchor;
      this.defaultBorders = defaultBorders;
      this.destroyed = !1;
      this.dynamic = dynamic || !1;
      this.updateUvs();
    }
    set source(value) {
      this._source && this._source.off("resize", this.update, this);
      this._source = value;
      value.on("resize", this.update, this);
      this.emit("update", this);
    }
    get source() {
      return this._source;
    }
    get textureMatrix() {
      this._textureMatrix || (this._textureMatrix = new TextureMatrix.TextureMatrix(this));
      return this._textureMatrix;
    }
    get width() {
      return this.orig.width;
    }
    get height() {
      return this.orig.height;
    }
    updateUvs() {
      const {uvs, frame} = this, {width, height} = this._source;
      var nX = frame.x / width, nY = frame.y / height, nW = frame.width / width, nH = frame.height / height;
      let rotate = this.rotate;
      rotate ? (nW /= 2, nH /= 2, nX += nW, nY += nH, rotate = groupD8.groupD8.add(rotate, groupD8.groupD8.NW), uvs.x0 = nX + nW * groupD8.groupD8.uX(rotate), uvs.y0 = nY + nH * groupD8.groupD8.uY(rotate), rotate = groupD8.groupD8.add(rotate, 2), uvs.x1 = nX + nW * groupD8.groupD8.uX(rotate), uvs.y1 = nY + nH * groupD8.groupD8.uY(rotate), rotate = groupD8.groupD8.add(rotate, 2), uvs.x2 = nX + nW * groupD8.groupD8.uX(rotate), uvs.y2 = nY + nH * groupD8.groupD8.uY(rotate), rotate = groupD8.groupD8.add(rotate, 
      2), uvs.x3 = nX + nW * groupD8.groupD8.uX(rotate), uvs.y3 = nY + nH * groupD8.groupD8.uY(rotate)) : (uvs.x0 = nX, uvs.y0 = nY, uvs.x1 = nX + nW, uvs.y1 = nY, uvs.x2 = nX + nW, uvs.y2 = nY + nH, uvs.x3 = nX, uvs.y3 = nY + nH);
    }
    destroy(destroySource = !1) {
      this._source && destroySource && (this._source.destroy(), this._source = null);
      this._textureMatrix = null;
      this.destroyed = !0;
      this.emit("destroy", this);
      this.removeAllListeners();
    }
    update() {
      this.noFrame && (this.frame.width = this._source.width, this.frame.height = this._source.height);
      this.updateUvs();
      this.emit("update", this);
    }
    get baseTexture() {
      deprecation.deprecation(deprecation.v8_0_0, "Texture.baseTexture is now Texture.source");
      return this._source;
    }
  }
  Texture.EMPTY = new Texture({label:"EMPTY", source:new TextureSource.TextureSource({label:"EMPTY"})});
  Texture.EMPTY.destroy = module.NOOP;
  Texture.WHITE = new Texture({source:new BufferImageSource.BufferImageSource({resource:new Uint8Array([255, 255, 255, 255]), width:1, height:1, alphaMode:"premultiply-alpha-on-upload", label:"WHITE"}), label:"WHITE"});
  Texture.WHITE.destroy = module.NOOP;
  exports.Texture = Texture;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$texture$Texture.js.map
