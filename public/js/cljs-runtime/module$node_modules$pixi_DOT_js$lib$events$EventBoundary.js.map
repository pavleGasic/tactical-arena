{
"version":3,
"file":"module$node_modules$pixi_DOT_js$lib$events$EventBoundary.js",
"lineCount":424,
"mappings":"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",
"sources":["node_modules/pixi_DOT_js/lib/events/EventBoundary.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$pixi_DOT_js$lib$events$EventBoundary\"] = function(global,require,module,exports) {\n'use strict';\n\nvar EventEmitter = require('eventemitter3');\nvar Point = require('../maths/point/Point.js');\nvar warn = require('../utils/logging/warn.js');\nvar EventTicker = require('./EventTicker.js');\nvar FederatedMouseEvent = require('./FederatedMouseEvent.js');\nvar FederatedPointerEvent = require('./FederatedPointerEvent.js');\nvar FederatedWheelEvent = require('./FederatedWheelEvent.js');\n\n\"use strict\";\nconst PROPAGATION_LIMIT = 2048;\nconst tempHitLocation = new Point.Point();\nconst tempLocalMapping = new Point.Point();\nclass EventBoundary {\n  /**\n   * @param rootTarget - The holder of the event boundary.\n   */\n  constructor(rootTarget) {\n    /**\n     * Emits events after they were dispatched into the scene graph.\n     *\n     * This can be used for global events listening, regardless of the scene graph being used. It should\n     * not be used by interactive libraries for normal use.\n     *\n     * Special events that do not bubble all the way to the root target are not emitted from here,\n     * e.g. pointerenter, pointerleave, click.\n     */\n    this.dispatch = new EventEmitter();\n    /**\n     * This flag would emit `pointermove`, `touchmove`, and `mousemove` events on all Containers.\n     *\n     * The `moveOnAll` semantics mirror those of earlier versions of PixiJS. This was disabled in favor of\n     * the Pointer Event API's approach.\n     */\n    this.moveOnAll = false;\n    /** Enables the global move events. `globalpointermove`, `globaltouchmove`, and `globalmousemove` */\n    this.enableGlobalMoveEvents = true;\n    /**\n     * State object for mapping methods.\n     * @see EventBoundary#trackingData\n     */\n    this.mappingState = {\n      trackingData: {}\n    };\n    /**\n     * The event pool maps event constructors to an free pool of instances of those specific events.\n     * @see EventBoundary#allocateEvent\n     * @see EventBoundary#freeEvent\n     */\n    this.eventPool = /* @__PURE__ */ new Map();\n    /** Every interactive element gathered from the scene. Only used in `pointermove` */\n    this._allInteractiveElements = [];\n    /** Every element that passed the hit test. Only used in `pointermove` */\n    this._hitElements = [];\n    /** Whether or not to collect all the interactive elements from the scene. Enabled in `pointermove` */\n    this._isPointerMoveEvent = false;\n    this.rootTarget = rootTarget;\n    this.hitPruneFn = this.hitPruneFn.bind(this);\n    this.hitTestFn = this.hitTestFn.bind(this);\n    this.mapPointerDown = this.mapPointerDown.bind(this);\n    this.mapPointerMove = this.mapPointerMove.bind(this);\n    this.mapPointerOut = this.mapPointerOut.bind(this);\n    this.mapPointerOver = this.mapPointerOver.bind(this);\n    this.mapPointerUp = this.mapPointerUp.bind(this);\n    this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this);\n    this.mapWheel = this.mapWheel.bind(this);\n    this.mappingTable = {};\n    this.addEventMapping(\"pointerdown\", this.mapPointerDown);\n    this.addEventMapping(\"pointermove\", this.mapPointerMove);\n    this.addEventMapping(\"pointerout\", this.mapPointerOut);\n    this.addEventMapping(\"pointerleave\", this.mapPointerOut);\n    this.addEventMapping(\"pointerover\", this.mapPointerOver);\n    this.addEventMapping(\"pointerup\", this.mapPointerUp);\n    this.addEventMapping(\"pointerupoutside\", this.mapPointerUpOutside);\n    this.addEventMapping(\"wheel\", this.mapWheel);\n  }\n  /**\n   * Adds an event mapping for the event `type` handled by `fn`.\n   *\n   * Event mappings can be used to implement additional or custom events. They take an event\n   * coming from the upstream scene (or directly from the {@link EventSystem}) and dispatch new downstream events\n   * generally trickling down and bubbling up to {@link EventBoundary.rootTarget this.rootTarget}.\n   *\n   * To modify the semantics of existing events, the built-in mapping methods of EventBoundary should be overridden\n   * instead.\n   * @param type - The type of upstream event to map.\n   * @param fn - The mapping method. The context of this function must be bound manually, if desired.\n   */\n  addEventMapping(type, fn) {\n    if (!this.mappingTable[type]) {\n      this.mappingTable[type] = [];\n    }\n    this.mappingTable[type].push({\n      fn,\n      priority: 0\n    });\n    this.mappingTable[type].sort((a, b) => a.priority - b.priority);\n  }\n  /**\n   * Dispatches the given event\n   * @param e - The event to dispatch.\n   * @param type - The type of event to dispatch. Defaults to `e.type`.\n   */\n  dispatchEvent(e, type) {\n    e.propagationStopped = false;\n    e.propagationImmediatelyStopped = false;\n    this.propagate(e, type);\n    this.dispatch.emit(type || e.type, e);\n  }\n  /**\n   * Maps the given upstream event through the event boundary and propagates it downstream.\n   * @param e - The event to map.\n   */\n  mapEvent(e) {\n    if (!this.rootTarget) {\n      return;\n    }\n    const mappers = this.mappingTable[e.type];\n    if (mappers) {\n      for (let i = 0, j = mappers.length; i < j; i++) {\n        mappers[i].fn(e);\n      }\n    } else {\n      warn.warn(`[EventBoundary]: Event mapping not defined for ${e.type}`);\n    }\n  }\n  /**\n   * Finds the Container that is the target of a event at the given coordinates.\n   *\n   * The passed (x,y) coordinates are in the world space above this event boundary.\n   * @param x - The x coordinate of the event.\n   * @param y - The y coordinate of the event.\n   */\n  hitTest(x, y) {\n    EventTicker.EventsTicker.pauseUpdate = true;\n    const useMove = this._isPointerMoveEvent && this.enableGlobalMoveEvents;\n    const fn = useMove ? \"hitTestMoveRecursive\" : \"hitTestRecursive\";\n    const invertedPath = this[fn](\n      this.rootTarget,\n      this.rootTarget.eventMode,\n      tempHitLocation.set(x, y),\n      this.hitTestFn,\n      this.hitPruneFn\n    );\n    return invertedPath && invertedPath[0];\n  }\n  /**\n   * Propagate the passed event from from {@link EventBoundary.rootTarget this.rootTarget} to its\n   * target {@code e.target}.\n   * @param e - The event to propagate.\n   * @param type - The type of event to propagate. Defaults to `e.type`.\n   */\n  propagate(e, type) {\n    if (!e.target) {\n      return;\n    }\n    const composedPath = e.composedPath();\n    e.eventPhase = e.CAPTURING_PHASE;\n    for (let i = 0, j = composedPath.length - 1; i < j; i++) {\n      e.currentTarget = composedPath[i];\n      this.notifyTarget(e, type);\n      if (e.propagationStopped || e.propagationImmediatelyStopped)\n        return;\n    }\n    e.eventPhase = e.AT_TARGET;\n    e.currentTarget = e.target;\n    this.notifyTarget(e, type);\n    if (e.propagationStopped || e.propagationImmediatelyStopped)\n      return;\n    e.eventPhase = e.BUBBLING_PHASE;\n    for (let i = composedPath.length - 2; i >= 0; i--) {\n      e.currentTarget = composedPath[i];\n      this.notifyTarget(e, type);\n      if (e.propagationStopped || e.propagationImmediatelyStopped)\n        return;\n    }\n  }\n  /**\n   * Emits the event {@code e} to all interactive containers. The event is propagated in the bubbling phase always.\n   *\n   * This is used in the `globalpointermove` event.\n   * @param e - The emitted event.\n   * @param type - The listeners to notify.\n   * @param targets - The targets to notify.\n   */\n  all(e, type, targets = this._allInteractiveElements) {\n    if (targets.length === 0)\n      return;\n    e.eventPhase = e.BUBBLING_PHASE;\n    const events = Array.isArray(type) ? type : [type];\n    for (let i = targets.length - 1; i >= 0; i--) {\n      events.forEach((event) => {\n        e.currentTarget = targets[i];\n        this.notifyTarget(e, event);\n      });\n    }\n  }\n  /**\n   * Finds the propagation path from {@link EventBoundary.rootTarget rootTarget} to the passed\n   * {@code target}. The last element in the path is {@code target}.\n   * @param target - The target to find the propagation path to.\n   */\n  propagationPath(target) {\n    const propagationPath = [target];\n    for (let i = 0; i < PROPAGATION_LIMIT && (target !== this.rootTarget && target.parent); i++) {\n      if (!target.parent) {\n        throw new Error(\"Cannot find propagation path to disconnected target\");\n      }\n      propagationPath.push(target.parent);\n      target = target.parent;\n    }\n    propagationPath.reverse();\n    return propagationPath;\n  }\n  hitTestMoveRecursive(currentTarget, eventMode, location, testFn, pruneFn, ignore = false) {\n    let shouldReturn = false;\n    if (this._interactivePrune(currentTarget))\n      return null;\n    if (currentTarget.eventMode === \"dynamic\" || eventMode === \"dynamic\") {\n      EventTicker.EventsTicker.pauseUpdate = false;\n    }\n    if (currentTarget.interactiveChildren && currentTarget.children) {\n      const children = currentTarget.children;\n      for (let i = children.length - 1; i >= 0; i--) {\n        const child = children[i];\n        const nestedHit = this.hitTestMoveRecursive(\n          child,\n          this._isInteractive(eventMode) ? eventMode : child.eventMode,\n          location,\n          testFn,\n          pruneFn,\n          ignore || pruneFn(currentTarget, location)\n        );\n        if (nestedHit) {\n          if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent) {\n            continue;\n          }\n          const isInteractive = currentTarget.isInteractive();\n          if (nestedHit.length > 0 || isInteractive) {\n            if (isInteractive)\n              this._allInteractiveElements.push(currentTarget);\n            nestedHit.push(currentTarget);\n          }\n          if (this._hitElements.length === 0)\n            this._hitElements = nestedHit;\n          shouldReturn = true;\n        }\n      }\n    }\n    const isInteractiveMode = this._isInteractive(eventMode);\n    const isInteractiveTarget = currentTarget.isInteractive();\n    if (isInteractiveTarget && isInteractiveTarget)\n      this._allInteractiveElements.push(currentTarget);\n    if (ignore || this._hitElements.length > 0)\n      return null;\n    if (shouldReturn)\n      return this._hitElements;\n    if (isInteractiveMode && (!pruneFn(currentTarget, location) && testFn(currentTarget, location))) {\n      return isInteractiveTarget ? [currentTarget] : [];\n    }\n    return null;\n  }\n  /**\n   * Recursive implementation for {@link EventBoundary.hitTest hitTest}.\n   * @param currentTarget - The Container that is to be hit tested.\n   * @param eventMode - The event mode for the `currentTarget` or one of its parents.\n   * @param location - The location that is being tested for overlap.\n   * @param testFn - Callback that determines whether the target passes hit testing. This callback\n   *  can assume that `pruneFn` failed to prune the container.\n   * @param pruneFn - Callback that determiness whether the target and all of its children\n   *  cannot pass the hit test. It is used as a preliminary optimization to prune entire subtrees\n   *  of the scene graph.\n   * @returns An array holding the hit testing target and all its ancestors in order. The first element\n   *  is the target itself and the last is {@link EventBoundary.rootTarget rootTarget}. This is the opposite\n   *  order w.r.t. the propagation path. If no hit testing target is found, null is returned.\n   */\n  hitTestRecursive(currentTarget, eventMode, location, testFn, pruneFn) {\n    if (this._interactivePrune(currentTarget) || pruneFn(currentTarget, location)) {\n      return null;\n    }\n    if (currentTarget.eventMode === \"dynamic\" || eventMode === \"dynamic\") {\n      EventTicker.EventsTicker.pauseUpdate = false;\n    }\n    if (currentTarget.interactiveChildren && currentTarget.children) {\n      const children = currentTarget.children;\n      const relativeLocation = location;\n      for (let i = children.length - 1; i >= 0; i--) {\n        const child = children[i];\n        const nestedHit = this.hitTestRecursive(\n          child,\n          this._isInteractive(eventMode) ? eventMode : child.eventMode,\n          relativeLocation,\n          testFn,\n          pruneFn\n        );\n        if (nestedHit) {\n          if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent) {\n            continue;\n          }\n          const isInteractive = currentTarget.isInteractive();\n          if (nestedHit.length > 0 || isInteractive)\n            nestedHit.push(currentTarget);\n          return nestedHit;\n        }\n      }\n    }\n    const isInteractiveMode = this._isInteractive(eventMode);\n    const isInteractiveTarget = currentTarget.isInteractive();\n    if (isInteractiveMode && testFn(currentTarget, location)) {\n      return isInteractiveTarget ? [currentTarget] : [];\n    }\n    return null;\n  }\n  _isInteractive(int) {\n    return int === \"static\" || int === \"dynamic\";\n  }\n  _interactivePrune(container) {\n    if (!container || !container.visible || !container.renderable || !container.measurable) {\n      return true;\n    }\n    if (container.eventMode === \"none\") {\n      return true;\n    }\n    if (container.eventMode === \"passive\" && !container.interactiveChildren) {\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Checks whether the container or any of its children cannot pass the hit test at all.\n   *\n   * {@link EventBoundary}'s implementation uses the {@link Container.hitArea hitArea}\n   * and {@link Container._maskEffect} for pruning.\n   * @param container - The container to prune.\n   * @param location - The location to test for overlap.\n   */\n  hitPruneFn(container, location) {\n    if (container.hitArea) {\n      container.worldTransform.applyInverse(location, tempLocalMapping);\n      if (!container.hitArea.contains(tempLocalMapping.x, tempLocalMapping.y)) {\n        return true;\n      }\n    }\n    if (container.effects && container.effects.length) {\n      for (let i = 0; i < container.effects.length; i++) {\n        const effect = container.effects[i];\n        if (effect.containsPoint) {\n          const effectContainsPoint = effect.containsPoint(location, this.hitTestFn);\n          if (!effectContainsPoint) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n  /**\n   * Checks whether the container passes hit testing for the given location.\n   * @param container - The container to test.\n   * @param location - The location to test for overlap.\n   * @returns - Whether `container` passes hit testing for `location`.\n   */\n  hitTestFn(container, location) {\n    if (container.hitArea) {\n      return true;\n    }\n    if (container?.containsPoint) {\n      container.worldTransform.applyInverse(location, tempLocalMapping);\n      return container.containsPoint(tempLocalMapping);\n    }\n    return false;\n  }\n  /**\n   * Notify all the listeners to the event's `currentTarget`.\n   *\n   * If the `currentTarget` contains the property `on<type>`, then it is called here,\n   * simulating the behavior from version 6.x and prior.\n   * @param e - The event passed to the target.\n   * @param type - The type of event to notify. Defaults to `e.type`.\n   */\n  notifyTarget(e, type) {\n    if (!e.currentTarget.isInteractive()) {\n      return;\n    }\n    type ?? (type = e.type);\n    const handlerKey = `on${type}`;\n    e.currentTarget[handlerKey]?.(e);\n    const key = e.eventPhase === e.CAPTURING_PHASE || e.eventPhase === e.AT_TARGET ? `${type}capture` : type;\n    this._notifyListeners(e, key);\n    if (e.eventPhase === e.AT_TARGET) {\n      this._notifyListeners(e, type);\n    }\n  }\n  /**\n   * Maps the upstream `pointerdown` events to a downstream `pointerdown` event.\n   *\n   * `touchstart`, `rightdown`, `mousedown` events are also dispatched for specific pointer types.\n   * @param from - The upstream `pointerdown` event.\n   */\n  mapPointerDown(from) {\n    if (!(from instanceof FederatedPointerEvent.FederatedPointerEvent)) {\n      warn.warn(\"EventBoundary cannot map a non-pointer event as a pointer event\");\n      return;\n    }\n    const e = this.createPointerEvent(from);\n    this.dispatchEvent(e, \"pointerdown\");\n    if (e.pointerType === \"touch\") {\n      this.dispatchEvent(e, \"touchstart\");\n    } else if (e.pointerType === \"mouse\" || e.pointerType === \"pen\") {\n      const isRightButton = e.button === 2;\n      this.dispatchEvent(e, isRightButton ? \"rightdown\" : \"mousedown\");\n    }\n    const trackingData = this.trackingData(from.pointerId);\n    trackingData.pressTargetsByButton[from.button] = e.composedPath();\n    this.freeEvent(e);\n  }\n  /**\n   * Maps the upstream `pointermove` to downstream `pointerout`, `pointerover`, and `pointermove` events, in that order.\n   *\n   * The tracking data for the specific pointer has an updated `overTarget`. `mouseout`, `mouseover`,\n   * `mousemove`, and `touchmove` events are fired as well for specific pointer types.\n   * @param from - The upstream `pointermove` event.\n   */\n  mapPointerMove(from) {\n    if (!(from instanceof FederatedPointerEvent.FederatedPointerEvent)) {\n      warn.warn(\"EventBoundary cannot map a non-pointer event as a pointer event\");\n      return;\n    }\n    this._allInteractiveElements.length = 0;\n    this._hitElements.length = 0;\n    this._isPointerMoveEvent = true;\n    const e = this.createPointerEvent(from);\n    this._isPointerMoveEvent = false;\n    const isMouse = e.pointerType === \"mouse\" || e.pointerType === \"pen\";\n    const trackingData = this.trackingData(from.pointerId);\n    const outTarget = this.findMountedTarget(trackingData.overTargets);\n    if (trackingData.overTargets?.length > 0 && outTarget !== e.target) {\n      const outType = from.type === \"mousemove\" ? \"mouseout\" : \"pointerout\";\n      const outEvent = this.createPointerEvent(from, outType, outTarget);\n      this.dispatchEvent(outEvent, \"pointerout\");\n      if (isMouse)\n        this.dispatchEvent(outEvent, \"mouseout\");\n      if (!e.composedPath().includes(outTarget)) {\n        const leaveEvent = this.createPointerEvent(from, \"pointerleave\", outTarget);\n        leaveEvent.eventPhase = leaveEvent.AT_TARGET;\n        while (leaveEvent.target && !e.composedPath().includes(leaveEvent.target)) {\n          leaveEvent.currentTarget = leaveEvent.target;\n          this.notifyTarget(leaveEvent);\n          if (isMouse)\n            this.notifyTarget(leaveEvent, \"mouseleave\");\n          leaveEvent.target = leaveEvent.target.parent;\n        }\n        this.freeEvent(leaveEvent);\n      }\n      this.freeEvent(outEvent);\n    }\n    if (outTarget !== e.target) {\n      const overType = from.type === \"mousemove\" ? \"mouseover\" : \"pointerover\";\n      const overEvent = this.clonePointerEvent(e, overType);\n      this.dispatchEvent(overEvent, \"pointerover\");\n      if (isMouse)\n        this.dispatchEvent(overEvent, \"mouseover\");\n      let overTargetAncestor = outTarget?.parent;\n      while (overTargetAncestor && overTargetAncestor !== this.rootTarget.parent) {\n        if (overTargetAncestor === e.target)\n          break;\n        overTargetAncestor = overTargetAncestor.parent;\n      }\n      const didPointerEnter = !overTargetAncestor || overTargetAncestor === this.rootTarget.parent;\n      if (didPointerEnter) {\n        const enterEvent = this.clonePointerEvent(e, \"pointerenter\");\n        enterEvent.eventPhase = enterEvent.AT_TARGET;\n        while (enterEvent.target && enterEvent.target !== outTarget && enterEvent.target !== this.rootTarget.parent) {\n          enterEvent.currentTarget = enterEvent.target;\n          this.notifyTarget(enterEvent);\n          if (isMouse)\n            this.notifyTarget(enterEvent, \"mouseenter\");\n          enterEvent.target = enterEvent.target.parent;\n        }\n        this.freeEvent(enterEvent);\n      }\n      this.freeEvent(overEvent);\n    }\n    const allMethods = [];\n    const allowGlobalPointerEvents = this.enableGlobalMoveEvents ?? true;\n    this.moveOnAll ? allMethods.push(\"pointermove\") : this.dispatchEvent(e, \"pointermove\");\n    allowGlobalPointerEvents && allMethods.push(\"globalpointermove\");\n    if (e.pointerType === \"touch\") {\n      this.moveOnAll ? allMethods.splice(1, 0, \"touchmove\") : this.dispatchEvent(e, \"touchmove\");\n      allowGlobalPointerEvents && allMethods.push(\"globaltouchmove\");\n    }\n    if (isMouse) {\n      this.moveOnAll ? allMethods.splice(1, 0, \"mousemove\") : this.dispatchEvent(e, \"mousemove\");\n      allowGlobalPointerEvents && allMethods.push(\"globalmousemove\");\n      this.cursor = e.target?.cursor;\n    }\n    if (allMethods.length > 0) {\n      this.all(e, allMethods);\n    }\n    this._allInteractiveElements.length = 0;\n    this._hitElements.length = 0;\n    trackingData.overTargets = e.composedPath();\n    this.freeEvent(e);\n  }\n  /**\n   * Maps the upstream `pointerover` to downstream `pointerover` and `pointerenter` events, in that order.\n   *\n   * The tracking data for the specific pointer gets a new `overTarget`.\n   * @param from - The upstream `pointerover` event.\n   */\n  mapPointerOver(from) {\n    if (!(from instanceof FederatedPointerEvent.FederatedPointerEvent)) {\n      warn.warn(\"EventBoundary cannot map a non-pointer event as a pointer event\");\n      return;\n    }\n    const trackingData = this.trackingData(from.pointerId);\n    const e = this.createPointerEvent(from);\n    const isMouse = e.pointerType === \"mouse\" || e.pointerType === \"pen\";\n    this.dispatchEvent(e, \"pointerover\");\n    if (isMouse)\n      this.dispatchEvent(e, \"mouseover\");\n    if (e.pointerType === \"mouse\")\n      this.cursor = e.target?.cursor;\n    const enterEvent = this.clonePointerEvent(e, \"pointerenter\");\n    enterEvent.eventPhase = enterEvent.AT_TARGET;\n    while (enterEvent.target && enterEvent.target !== this.rootTarget.parent) {\n      enterEvent.currentTarget = enterEvent.target;\n      this.notifyTarget(enterEvent);\n      if (isMouse)\n        this.notifyTarget(enterEvent, \"mouseenter\");\n      enterEvent.target = enterEvent.target.parent;\n    }\n    trackingData.overTargets = e.composedPath();\n    this.freeEvent(e);\n    this.freeEvent(enterEvent);\n  }\n  /**\n   * Maps the upstream `pointerout` to downstream `pointerout`, `pointerleave` events, in that order.\n   *\n   * The tracking data for the specific pointer is cleared of a `overTarget`.\n   * @param from - The upstream `pointerout` event.\n   */\n  mapPointerOut(from) {\n    if (!(from instanceof FederatedPointerEvent.FederatedPointerEvent)) {\n      warn.warn(\"EventBoundary cannot map a non-pointer event as a pointer event\");\n      return;\n    }\n    const trackingData = this.trackingData(from.pointerId);\n    if (trackingData.overTargets) {\n      const isMouse = from.pointerType === \"mouse\" || from.pointerType === \"pen\";\n      const outTarget = this.findMountedTarget(trackingData.overTargets);\n      const outEvent = this.createPointerEvent(from, \"pointerout\", outTarget);\n      this.dispatchEvent(outEvent);\n      if (isMouse)\n        this.dispatchEvent(outEvent, \"mouseout\");\n      const leaveEvent = this.createPointerEvent(from, \"pointerleave\", outTarget);\n      leaveEvent.eventPhase = leaveEvent.AT_TARGET;\n      while (leaveEvent.target && leaveEvent.target !== this.rootTarget.parent) {\n        leaveEvent.currentTarget = leaveEvent.target;\n        this.notifyTarget(leaveEvent);\n        if (isMouse)\n          this.notifyTarget(leaveEvent, \"mouseleave\");\n        leaveEvent.target = leaveEvent.target.parent;\n      }\n      trackingData.overTargets = null;\n      this.freeEvent(outEvent);\n      this.freeEvent(leaveEvent);\n    }\n    this.cursor = null;\n  }\n  /**\n   * Maps the upstream `pointerup` event to downstream `pointerup`, `pointerupoutside`,\n   * and `click`/`rightclick`/`pointertap` events, in that order.\n   *\n   * The `pointerupoutside` event bubbles from the original `pointerdown` target to the most specific\n   * ancestor of the `pointerdown` and `pointerup` targets, which is also the `click` event's target. `touchend`,\n   * `rightup`, `mouseup`, `touchendoutside`, `rightupoutside`, `mouseupoutside`, and `tap` are fired as well for\n   * specific pointer types.\n   * @param from - The upstream `pointerup` event.\n   */\n  mapPointerUp(from) {\n    if (!(from instanceof FederatedPointerEvent.FederatedPointerEvent)) {\n      warn.warn(\"EventBoundary cannot map a non-pointer event as a pointer event\");\n      return;\n    }\n    const now = performance.now();\n    const e = this.createPointerEvent(from);\n    this.dispatchEvent(e, \"pointerup\");\n    if (e.pointerType === \"touch\") {\n      this.dispatchEvent(e, \"touchend\");\n    } else if (e.pointerType === \"mouse\" || e.pointerType === \"pen\") {\n      const isRightButton = e.button === 2;\n      this.dispatchEvent(e, isRightButton ? \"rightup\" : \"mouseup\");\n    }\n    const trackingData = this.trackingData(from.pointerId);\n    const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);\n    let clickTarget = pressTarget;\n    if (pressTarget && !e.composedPath().includes(pressTarget)) {\n      let currentTarget = pressTarget;\n      while (currentTarget && !e.composedPath().includes(currentTarget)) {\n        e.currentTarget = currentTarget;\n        this.notifyTarget(e, \"pointerupoutside\");\n        if (e.pointerType === \"touch\") {\n          this.notifyTarget(e, \"touchendoutside\");\n        } else if (e.pointerType === \"mouse\" || e.pointerType === \"pen\") {\n          const isRightButton = e.button === 2;\n          this.notifyTarget(e, isRightButton ? \"rightupoutside\" : \"mouseupoutside\");\n        }\n        currentTarget = currentTarget.parent;\n      }\n      delete trackingData.pressTargetsByButton[from.button];\n      clickTarget = currentTarget;\n    }\n    if (clickTarget) {\n      const clickEvent = this.clonePointerEvent(e, \"click\");\n      clickEvent.target = clickTarget;\n      clickEvent.path = null;\n      if (!trackingData.clicksByButton[from.button]) {\n        trackingData.clicksByButton[from.button] = {\n          clickCount: 0,\n          target: clickEvent.target,\n          timeStamp: now\n        };\n      }\n      const clickHistory = trackingData.clicksByButton[from.button];\n      if (clickHistory.target === clickEvent.target && now - clickHistory.timeStamp < 200) {\n        ++clickHistory.clickCount;\n      } else {\n        clickHistory.clickCount = 1;\n      }\n      clickHistory.target = clickEvent.target;\n      clickHistory.timeStamp = now;\n      clickEvent.detail = clickHistory.clickCount;\n      if (clickEvent.pointerType === \"mouse\") {\n        const isRightButton = clickEvent.button === 2;\n        this.dispatchEvent(clickEvent, isRightButton ? \"rightclick\" : \"click\");\n      } else if (clickEvent.pointerType === \"touch\") {\n        this.dispatchEvent(clickEvent, \"tap\");\n      }\n      this.dispatchEvent(clickEvent, \"pointertap\");\n      this.freeEvent(clickEvent);\n    }\n    this.freeEvent(e);\n  }\n  /**\n   * Maps the upstream `pointerupoutside` event to a downstream `pointerupoutside` event, bubbling from the original\n   * `pointerdown` target to `rootTarget`.\n   *\n   * (The most specific ancestor of the `pointerdown` event and the `pointerup` event must the\n   * `{@link EventBoundary}'s root because the `pointerup` event occurred outside of the boundary.)\n   *\n   * `touchendoutside`, `mouseupoutside`, and `rightupoutside` events are fired as well for specific pointer\n   * types. The tracking data for the specific pointer is cleared of a `pressTarget`.\n   * @param from - The upstream `pointerupoutside` event.\n   */\n  mapPointerUpOutside(from) {\n    if (!(from instanceof FederatedPointerEvent.FederatedPointerEvent)) {\n      warn.warn(\"EventBoundary cannot map a non-pointer event as a pointer event\");\n      return;\n    }\n    const trackingData = this.trackingData(from.pointerId);\n    const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);\n    const e = this.createPointerEvent(from);\n    if (pressTarget) {\n      let currentTarget = pressTarget;\n      while (currentTarget) {\n        e.currentTarget = currentTarget;\n        this.notifyTarget(e, \"pointerupoutside\");\n        if (e.pointerType === \"touch\") {\n          this.notifyTarget(e, \"touchendoutside\");\n        } else if (e.pointerType === \"mouse\" || e.pointerType === \"pen\") {\n          this.notifyTarget(e, e.button === 2 ? \"rightupoutside\" : \"mouseupoutside\");\n        }\n        currentTarget = currentTarget.parent;\n      }\n      delete trackingData.pressTargetsByButton[from.button];\n    }\n    this.freeEvent(e);\n  }\n  /**\n   * Maps the upstream `wheel` event to a downstream `wheel` event.\n   * @param from - The upstream `wheel` event.\n   */\n  mapWheel(from) {\n    if (!(from instanceof FederatedWheelEvent.FederatedWheelEvent)) {\n      warn.warn(\"EventBoundary cannot map a non-wheel event as a wheel event\");\n      return;\n    }\n    const wheelEvent = this.createWheelEvent(from);\n    this.dispatchEvent(wheelEvent);\n    this.freeEvent(wheelEvent);\n  }\n  /**\n   * Finds the most specific event-target in the given propagation path that is still mounted in the scene graph.\n   *\n   * This is used to find the correct `pointerup` and `pointerout` target in the case that the original `pointerdown`\n   * or `pointerover` target was unmounted from the scene graph.\n   * @param propagationPath - The propagation path was valid in the past.\n   * @returns - The most specific event-target still mounted at the same location in the scene graph.\n   */\n  findMountedTarget(propagationPath) {\n    if (!propagationPath) {\n      return null;\n    }\n    let currentTarget = propagationPath[0];\n    for (let i = 1; i < propagationPath.length; i++) {\n      if (propagationPath[i].parent === currentTarget) {\n        currentTarget = propagationPath[i];\n      } else {\n        break;\n      }\n    }\n    return currentTarget;\n  }\n  /**\n   * Creates an event whose {@code originalEvent} is {@code from}, with an optional `type` and `target` override.\n   *\n   * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.\n   * @param from - The {@code originalEvent} for the returned event.\n   * @param [type=from.type] - The type of the returned event.\n   * @param target - The target of the returned event.\n   */\n  createPointerEvent(from, type, target) {\n    const event = this.allocateEvent(FederatedPointerEvent.FederatedPointerEvent);\n    this.copyPointerData(from, event);\n    this.copyMouseData(from, event);\n    this.copyData(from, event);\n    event.nativeEvent = from.nativeEvent;\n    event.originalEvent = from;\n    event.target = target ?? this.hitTest(event.global.x, event.global.y) ?? this._hitElements[0];\n    if (typeof type === \"string\") {\n      event.type = type;\n    }\n    return event;\n  }\n  /**\n   * Creates a wheel event whose {@code originalEvent} is {@code from}.\n   *\n   * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.\n   * @param from - The upstream wheel event.\n   */\n  createWheelEvent(from) {\n    const event = this.allocateEvent(FederatedWheelEvent.FederatedWheelEvent);\n    this.copyWheelData(from, event);\n    this.copyMouseData(from, event);\n    this.copyData(from, event);\n    event.nativeEvent = from.nativeEvent;\n    event.originalEvent = from;\n    event.target = this.hitTest(event.global.x, event.global.y);\n    return event;\n  }\n  /**\n   * Clones the event {@code from}, with an optional {@code type} override.\n   *\n   * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.\n   * @param from - The event to clone.\n   * @param [type=from.type] - The type of the returned event.\n   */\n  clonePointerEvent(from, type) {\n    const event = this.allocateEvent(FederatedPointerEvent.FederatedPointerEvent);\n    event.nativeEvent = from.nativeEvent;\n    event.originalEvent = from.originalEvent;\n    this.copyPointerData(from, event);\n    this.copyMouseData(from, event);\n    this.copyData(from, event);\n    event.target = from.target;\n    event.path = from.composedPath().slice();\n    event.type = type ?? event.type;\n    return event;\n  }\n  /**\n   * Copies wheel {@link FederatedWheelEvent} data from {@code from} into {@code to}.\n   *\n   * The following properties are copied:\n   * + deltaMode\n   * + deltaX\n   * + deltaY\n   * + deltaZ\n   * @param from - The event to copy data from.\n   * @param to - The event to copy data into.\n   */\n  copyWheelData(from, to) {\n    to.deltaMode = from.deltaMode;\n    to.deltaX = from.deltaX;\n    to.deltaY = from.deltaY;\n    to.deltaZ = from.deltaZ;\n  }\n  /**\n   * Copies pointer {@link FederatedPointerEvent} data from {@code from} into {@code to}.\n   *\n   * The following properties are copied:\n   * + pointerId\n   * + width\n   * + height\n   * + isPrimary\n   * + pointerType\n   * + pressure\n   * + tangentialPressure\n   * + tiltX\n   * + tiltY\n   * @param from - The event to copy data from.\n   * @param to - The event to copy data into.\n   */\n  copyPointerData(from, to) {\n    if (!(from instanceof FederatedPointerEvent.FederatedPointerEvent && to instanceof FederatedPointerEvent.FederatedPointerEvent))\n      return;\n    to.pointerId = from.pointerId;\n    to.width = from.width;\n    to.height = from.height;\n    to.isPrimary = from.isPrimary;\n    to.pointerType = from.pointerType;\n    to.pressure = from.pressure;\n    to.tangentialPressure = from.tangentialPressure;\n    to.tiltX = from.tiltX;\n    to.tiltY = from.tiltY;\n    to.twist = from.twist;\n  }\n  /**\n   * Copies mouse {@link FederatedMouseEvent} data from {@code from} to {@code to}.\n   *\n   * The following properties are copied:\n   * + altKey\n   * + button\n   * + buttons\n   * + clientX\n   * + clientY\n   * + metaKey\n   * + movementX\n   * + movementY\n   * + pageX\n   * + pageY\n   * + x\n   * + y\n   * + screen\n   * + shiftKey\n   * + global\n   * @param from - The event to copy data from.\n   * @param to - The event to copy data into.\n   */\n  copyMouseData(from, to) {\n    if (!(from instanceof FederatedMouseEvent.FederatedMouseEvent && to instanceof FederatedMouseEvent.FederatedMouseEvent))\n      return;\n    to.altKey = from.altKey;\n    to.button = from.button;\n    to.buttons = from.buttons;\n    to.client.copyFrom(from.client);\n    to.ctrlKey = from.ctrlKey;\n    to.metaKey = from.metaKey;\n    to.movement.copyFrom(from.movement);\n    to.screen.copyFrom(from.screen);\n    to.shiftKey = from.shiftKey;\n    to.global.copyFrom(from.global);\n  }\n  /**\n   * Copies base {@link FederatedEvent} data from {@code from} into {@code to}.\n   *\n   * The following properties are copied:\n   * + isTrusted\n   * + srcElement\n   * + timeStamp\n   * + type\n   * @param from - The event to copy data from.\n   * @param to - The event to copy data into.\n   */\n  copyData(from, to) {\n    to.isTrusted = from.isTrusted;\n    to.srcElement = from.srcElement;\n    to.timeStamp = performance.now();\n    to.type = from.type;\n    to.detail = from.detail;\n    to.view = from.view;\n    to.which = from.which;\n    to.layer.copyFrom(from.layer);\n    to.page.copyFrom(from.page);\n  }\n  /**\n   * @param id - The pointer ID.\n   * @returns The tracking data stored for the given pointer. If no data exists, a blank\n   *  state will be created.\n   */\n  trackingData(id) {\n    if (!this.mappingState.trackingData[id]) {\n      this.mappingState.trackingData[id] = {\n        pressTargetsByButton: {},\n        clicksByButton: {},\n        overTarget: null\n      };\n    }\n    return this.mappingState.trackingData[id];\n  }\n  /**\n   * Allocate a specific type of event from {@link EventBoundary#eventPool this.eventPool}.\n   *\n   * This allocation is constructor-agnostic, as long as it only takes one argument - this event\n   * boundary.\n   * @param constructor - The event's constructor.\n   */\n  allocateEvent(constructor) {\n    if (!this.eventPool.has(constructor)) {\n      this.eventPool.set(constructor, []);\n    }\n    const event = this.eventPool.get(constructor).pop() || new constructor(this);\n    event.eventPhase = event.NONE;\n    event.currentTarget = null;\n    event.defaultPrevented = false;\n    event.path = null;\n    event.target = null;\n    return event;\n  }\n  /**\n   * Frees the event and puts it back into the event pool.\n   *\n   * It is illegal to reuse the event until it is allocated again, using `this.allocateEvent`.\n   *\n   * It is also advised that events not allocated from {@link EventBoundary#allocateEvent this.allocateEvent}\n   * not be freed. This is because of the possibility that the same event is freed twice, which can cause\n   * it to be allocated twice & result in overwriting.\n   * @param event - The event to be freed.\n   * @throws Error if the event is managed by another event boundary.\n   */\n  freeEvent(event) {\n    if (event.manager !== this)\n      throw new Error(\"It is illegal to free an event not managed by this EventBoundary!\");\n    const constructor = event.constructor;\n    if (!this.eventPool.has(constructor)) {\n      this.eventPool.set(constructor, []);\n    }\n    this.eventPool.get(constructor).push(event);\n  }\n  /**\n   * Similar to {@link EventEmitter.emit}, except it stops if the `propagationImmediatelyStopped` flag\n   * is set on the event.\n   * @param e - The event to call each listener with.\n   * @param type - The event key.\n   */\n  _notifyListeners(e, type) {\n    const listeners = e.currentTarget._events[type];\n    if (!listeners)\n      return;\n    if (\"fn\" in listeners) {\n      if (listeners.once)\n        e.currentTarget.removeListener(type, listeners.fn, void 0, true);\n      listeners.fn.call(listeners.context, e);\n    } else {\n      for (let i = 0, j = listeners.length; i < j && !e.propagationImmediatelyStopped; i++) {\n        if (listeners[i].once)\n          e.currentTarget.removeListener(type, listeners[i].fn, void 0, true);\n        listeners[i].fn.call(listeners[i].context, e);\n      }\n    }\n  }\n}\n\nexports.EventBoundary = EventBoundary;\n//# sourceMappingURL=EventBoundary.js.map\n\n};"],
"names":["shadow$provide","global","require","module","exports","EventEmitter","Point","warn","EventTicker","FederatedMouseEvent","FederatedPointerEvent","FederatedWheelEvent","tempHitLocation","tempLocalMapping","EventBoundary","constructor","rootTarget","dispatch","moveOnAll","enableGlobalMoveEvents","mappingState","trackingData","eventPool","Map","_allInteractiveElements","_hitElements","_isPointerMoveEvent","hitPruneFn","bind","hitTestFn","mapPointerDown","mapPointerMove","mapPointerOut","mapPointerOver","mapPointerUp","mapPointerUpOutside","mapWheel","mappingTable","addEventMapping","type","fn","push","priority","sort","a","b","dispatchEvent","e","propagationStopped","propagationImmediatelyStopped","propagate","emit","mapEvent","mappers","i","j","length","hitTest","x","y","EventsTicker","pauseUpdate","invertedPath","eventMode","set","target","composedPath","eventPhase","CAPTURING_PHASE","currentTarget","notifyTarget","AT_TARGET","BUBBLING_PHASE","all","targets","events","Array","isArray","forEach","event","propagationPath","PROPAGATION_LIMIT","parent","Error","reverse","hitTestMoveRecursive","location","testFn","pruneFn","ignore","shouldReturn","_interactivePrune","interactiveChildren","children","child","nestedHit","_isInteractive","isInteractive","isInteractiveMode","isInteractiveTarget","hitTestRecursive","int","container","visible","renderable","measurable","hitArea","worldTransform","applyInverse","contains","effects","effect","containsPoint","effectContainsPoint","handlerKey","_notifyListeners","key","from","createPointerEvent","pointerType","button","pointerId","pressTargetsByButton","freeEvent","isMouse","outTarget","findMountedTarget","overTargets","outEvent","outType","includes","leaveEvent","overEvent","clonePointerEvent","overType","overTargetAncestor","enterEvent","allMethods","allowGlobalPointerEvents","splice","cursor","now","performance","pressTarget","clickTarget","clickEvent","path","clicksByButton","clickCount","timeStamp","clickHistory","detail","wheelEvent","createWheelEvent","allocateEvent","copyPointerData","copyMouseData","copyData","nativeEvent","originalEvent","copyWheelData","slice","to","deltaMode","deltaX","deltaY","deltaZ","width","height","isPrimary","pressure","tangentialPressure","tiltX","tiltY","twist","altKey","buttons","client","copyFrom","ctrlKey","metaKey","movement","screen","shiftKey","isTrusted","srcElement","view","which","layer","page","id","overTarget","has","get","pop","NONE","defaultPrevented","manager","listeners","_events","once","removeListener","call","context"]
}
