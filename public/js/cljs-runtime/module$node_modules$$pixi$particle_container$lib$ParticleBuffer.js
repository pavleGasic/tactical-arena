shadow$provide.module$node_modules$$pixi$particle_container$lib$ParticleBuffer = function(global, require, module, exports) {
  var core = require("module$node_modules$$pixi$core$lib$index");
  class ParticleBuffer {
    constructor(properties, dynamicPropertyFlags, size) {
      this.geometry = new core.Geometry();
      this.indexBuffer = null;
      this.size = size;
      this.dynamicProperties = [];
      this.staticProperties = [];
      for (size = 0; size < properties.length; ++size) {
        let property = properties[size];
        property = {attributeName:property.attributeName, size:property.size, uploadFunction:property.uploadFunction, type:property.type || core.TYPES.FLOAT, offset:property.offset};
        dynamicPropertyFlags[size] ? this.dynamicProperties.push(property) : this.staticProperties.push(property);
      }
      this.staticStride = 0;
      this.staticDataUint32 = this.staticData = this.staticBuffer = null;
      this.dynamicStride = 0;
      this.dynamicDataUint32 = this.dynamicData = this.dynamicBuffer = null;
      this._updateID = 0;
      this.initBuffers();
    }
    initBuffers() {
      const geometry = this.geometry;
      var dynamicOffset = 0;
      this.indexBuffer = new core.Buffer(core.utils.createIndicesForQuads(this.size), !0, !0);
      geometry.addIndex(this.indexBuffer);
      this.dynamicStride = 0;
      for (var i = 0; i < this.dynamicProperties.length; ++i) {
        var property = this.dynamicProperties[i];
        property.offset = dynamicOffset;
        dynamicOffset += property.size;
        this.dynamicStride += property.size;
      }
      dynamicOffset = new ArrayBuffer(this.size * this.dynamicStride * 16);
      this.dynamicData = new Float32Array(dynamicOffset);
      this.dynamicDataUint32 = new Uint32Array(dynamicOffset);
      this.dynamicBuffer = new core.Buffer(this.dynamicData, !1, !1);
      this.staticStride = dynamicOffset = 0;
      for (i = 0; i < this.staticProperties.length; ++i) {
        property = this.staticProperties[i], property.offset = dynamicOffset, dynamicOffset += property.size, this.staticStride += property.size;
      }
      dynamicOffset = new ArrayBuffer(this.size * this.staticStride * 16);
      this.staticData = new Float32Array(dynamicOffset);
      this.staticDataUint32 = new Uint32Array(dynamicOffset);
      this.staticBuffer = new core.Buffer(this.staticData, !0, !1);
      for (dynamicOffset = 0; dynamicOffset < this.dynamicProperties.length; ++dynamicOffset) {
        i = this.dynamicProperties[dynamicOffset], geometry.addAttribute(i.attributeName, this.dynamicBuffer, 0, i.type === core.TYPES.UNSIGNED_BYTE, i.type, 4 * this.dynamicStride, 4 * i.offset);
      }
      for (dynamicOffset = 0; dynamicOffset < this.staticProperties.length; ++dynamicOffset) {
        i = this.staticProperties[dynamicOffset], geometry.addAttribute(i.attributeName, this.staticBuffer, 0, i.type === core.TYPES.UNSIGNED_BYTE, i.type, 4 * this.staticStride, 4 * i.offset);
      }
    }
    uploadDynamic(children, startIndex, amount) {
      for (let i = 0; i < this.dynamicProperties.length; i++) {
        const property = this.dynamicProperties[i];
        property.uploadFunction(children, startIndex, amount, property.type === core.TYPES.UNSIGNED_BYTE ? this.dynamicDataUint32 : this.dynamicData, this.dynamicStride, property.offset);
      }
      this.dynamicBuffer._updateID++;
    }
    uploadStatic(children, startIndex, amount) {
      for (let i = 0; i < this.staticProperties.length; i++) {
        const property = this.staticProperties[i];
        property.uploadFunction(children, startIndex, amount, property.type === core.TYPES.UNSIGNED_BYTE ? this.staticDataUint32 : this.staticData, this.staticStride, property.offset);
      }
      this.staticBuffer._updateID++;
    }
    destroy() {
      this.staticDataUint32 = this.staticData = this.staticBuffer = this.staticProperties = this.dynamicDataUint32 = this.dynamicData = this.dynamicBuffer = this.dynamicProperties = this.indexBuffer = null;
      this.geometry.destroy();
    }
  }
  exports.ParticleBuffer = ParticleBuffer;
};

//# sourceMappingURL=module$node_modules$$pixi$particle_container$lib$ParticleBuffer.js.map
