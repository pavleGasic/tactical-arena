shadow$provide.module$node_modules$$pixi$graphics$lib$utils$buildCircle = function(global, require, module, exports) {
  var core = require("module$node_modules$$pixi$core$lib$index");
  exports.buildCircle = {build(graphicsData) {
    const points = graphicsData.points;
    var dy, ry;
    if (graphicsData.type === core.SHAPES.CIRC) {
      var dx = graphicsData.shape;
      var x = dx.x;
      graphicsData = dx.y;
      var rx = ry = dx.radius;
      dx = dy = 0;
    } else if (graphicsData.type === core.SHAPES.ELIP) {
      dx = graphicsData.shape, x = dx.x, graphicsData = dx.y, rx = dx.width, ry = dx.height, dx = dy = 0;
    } else {
      var roundedRect = graphicsData.shape;
      dx = roundedRect.width / 2;
      var halfHeight = roundedRect.height / 2;
      x = roundedRect.x + dx;
      graphicsData = roundedRect.y + halfHeight;
      rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(dx, halfHeight)));
      dx -= rx;
      dy = halfHeight - ry;
    }
    if (0 <= rx && 0 <= ry && 0 <= dx && 0 <= dy) {
      var n = Math.ceil(2.3 * Math.sqrt(rx + ry));
      roundedRect = 8 * n + (dx ? 4 : 0) + (dy ? 4 : 0);
      if (points.length = roundedRect, 0 !== roundedRect) {
        if (0 === n) {
          points.length = 8, points[0] = points[6] = x + dx, points[1] = points[3] = graphicsData + dy, points[2] = points[4] = x - dx, points[5] = points[7] = graphicsData - dy;
        } else {
          halfHeight = 0;
          var j2 = 4 * n + (dx ? 2 : 0) + 2, j3 = j2, x0 = dx + rx, y0 = dy, x1 = x + x0;
          x0 = x - x0;
          var y1$jscomp$0 = graphicsData + y0;
          if (points[halfHeight++] = x1, points[halfHeight++] = y1$jscomp$0, points[--j2] = y1$jscomp$0, points[--j2] = x0, dy) {
            y0 = graphicsData - y0, points[j3++] = x0, points[j3++] = y0, points[--roundedRect] = y0, points[--roundedRect] = x1;
          }
          for (x1 = 1; x1 < n; x1++) {
            y0 = Math.PI / 2 * (x1 / n);
            y1$jscomp$0 = dx + Math.cos(y0) * rx;
            x0 = dy + Math.sin(y0) * ry;
            y0 = x + y1$jscomp$0;
            y1$jscomp$0 = x - y1$jscomp$0;
            const y1 = graphicsData + x0;
            x0 = graphicsData - x0;
            points[halfHeight++] = y0;
            points[halfHeight++] = y1;
            points[--j2] = y1;
            points[--j2] = y1$jscomp$0;
            points[j3++] = y1$jscomp$0;
            points[j3++] = x0;
            points[--roundedRect] = x0;
            points[--roundedRect] = y0;
          }
          n = dx;
          ry = dy + ry;
          rx = x + n;
          x -= n;
          dy = graphicsData + ry;
          graphicsData -= ry;
          points[halfHeight++] = rx;
          points[halfHeight++] = dy;
          points[--roundedRect] = graphicsData;
          points[--roundedRect] = rx;
          dx && (points[halfHeight++] = x, points[halfHeight++] = dy, points[--roundedRect] = graphicsData, points[--roundedRect] = x);
        }
      }
    } else {
      points.length = 0;
    }
  }, triangulate(graphicsData, graphicsGeometry) {
    const points = graphicsData.points, verts = graphicsGeometry.points;
    graphicsGeometry = graphicsGeometry.indices;
    if (0 !== points.length) {
      var vertPos = verts.length / 2, center = vertPos;
      if (graphicsData.type !== core.SHAPES.RREC) {
        var y = graphicsData.shape;
        var x = y.x;
        y = y.y;
      } else {
        y = graphicsData.shape, x = y.x + y.width / 2, y = y.y + y.height / 2;
      }
      var matrix = graphicsData.matrix;
      verts.push(graphicsData.matrix ? matrix.a * x + matrix.c * y + matrix.tx : x, graphicsData.matrix ? matrix.b * x + matrix.d * y + matrix.ty : y);
      vertPos++;
      verts.push(points[0], points[1]);
      for (graphicsData = 2; graphicsData < points.length; graphicsData += 2) {
        verts.push(points[graphicsData], points[graphicsData + 1]), graphicsGeometry.push(vertPos++, center, vertPos);
      }
      graphicsGeometry.push(center + 1, center, vertPos);
    }
  }};
};

//# sourceMappingURL=module$node_modules$$pixi$graphics$lib$utils$buildCircle.js.map
