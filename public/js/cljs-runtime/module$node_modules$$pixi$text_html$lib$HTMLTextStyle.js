shadow$provide.module$node_modules$$pixi$text_html$lib$HTMLTextStyle = function(global, require, module, exports) {
  var core = require("module$node_modules$$pixi$core$lib$index");
  global = require("module$node_modules$$pixi$text$lib$index");
  const node_modules$$pixi$text_html$lib$HTMLTextStyle$classdecl$var27 = class extends global.TextStyle {
    constructor() {
      super(...arguments);
      this._fonts = [];
      this._overrides = [];
      this._stylesheet = "";
      this.fontsDirty = !1;
    }
    static from(originalStyle) {
      return new node_modules$$pixi$text_html$lib$HTMLTextStyle$classdecl$var27(Object.keys(node_modules$$pixi$text_html$lib$HTMLTextStyle$classdecl$var27.defaultOptions).reduce((obj, prop) => ({...obj, [prop]:originalStyle[prop]}), {}));
    }
    cleanFonts() {
      0 < this._fonts.length && (this._fonts.forEach(font => {
        URL.revokeObjectURL(font.src);
        font.refs--;
        0 === font.refs && (font.fontFace && document.fonts.delete(font.fontFace), delete node_modules$$pixi$text_html$lib$HTMLTextStyle$classdecl$var27.availableFonts[font.originalUrl]);
      }), this.fontFamily = "Arial", this._fonts.length = 0, this.styleID++, this.fontsDirty = !0);
    }
    loadFont(url, options = {}) {
      const {availableFonts} = node_modules$$pixi$text_html$lib$HTMLTextStyle$classdecl$var27;
      if (availableFonts[url]) {
        const font = availableFonts[url];
        return this._fonts.push(font), font.refs++, this.styleID++, this.fontsDirty = !0, Promise.resolve();
      }
      return core.settings.ADAPTER.fetch(url).then(response => response.blob()).then(async blob => new Promise((resolve, reject) => {
        const src = URL.createObjectURL(blob), reader = new FileReader();
        reader.onload = () => resolve([src, reader.result]);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
      })).then(async([src, dataSrc]) => {
        src = Object.assign({family:core.utils.path.basename(url, core.utils.path.extname(url)), weight:"normal", style:"normal", display:"auto", src, dataSrc, refs:1, originalUrl:url, fontFace:null}, options);
        availableFonts[url] = src;
        this._fonts.push(src);
        this.styleID++;
        dataSrc = new FontFace(src.family, `url(${src.src})`, {weight:src.weight, style:src.style, display:src.display});
        src.fontFace = dataSrc;
        await dataSrc.load();
        document.fonts.add(dataSrc);
        await document.fonts.ready;
        this.styleID++;
        this.fontsDirty = !0;
      });
    }
    addOverride(...value) {
      value = value.filter(v => !this._overrides.includes(v));
      0 < value.length && (this._overrides.push(...value), this.styleID++);
    }
    removeOverride(...value) {
      const toRemove = value.filter(v => this._overrides.includes(v));
      0 < toRemove.length && (this._overrides = this._overrides.filter(v => !toRemove.includes(v)), this.styleID++);
    }
    toCSS(scale) {
      return [`transform: scale(${scale})`, "transform-origin: top left;display: inline-block", `color: ${this.normalizeColor(this.fill)}`, `font-size: ${this.fontSize}px`, `font-family: ${this.fontFamily}`, `font-weight: ${this.fontWeight}`, `font-style: ${this.fontStyle}`, `font-variant: ${this.fontVariant}`, `letter-spacing: ${this.letterSpacing}px`, `text-align: ${this.align}`, `padding: ${this.padding}px`, `white-space: ${this.whiteSpace}`, ...(this.lineHeight ? [`line-height: ${this.lineHeight}px`] : 
      []), ...(this.wordWrap ? [`word-wrap: ${this.breakWords ? "break-all" : "break-word"}`, `max-width: ${this.wordWrapWidth}px`] : []), ...(this.strokeThickness ? [`-webkit-text-stroke-width: ${this.strokeThickness}px`, `-webkit-text-stroke-color: ${this.normalizeColor(this.stroke)}`, `text-stroke-width: ${this.strokeThickness}px`, `text-stroke-color: ${this.normalizeColor(this.stroke)}`, "paint-order: stroke"] : []), ...(this.dropShadow ? [this.dropShadowToCSS()] : []), ...this._overrides].join(";");
    }
    toGlobalCSS() {
      return this._fonts.reduce((result, font) => `${result}
            @font-face {
                font-family: "${font.family}";
                src: url('${font.dataSrc}');
                font-weight: ${font.weight};
                font-style: ${font.style};
                font-display: ${font.display};
            }`, this._stylesheet);
    }
    get stylesheet() {
      return this._stylesheet;
    }
    set stylesheet(value) {
      this._stylesheet !== value && (this._stylesheet = value, this.styleID++);
    }
    normalizeColor(color) {
      return Array.isArray(color) && (color = core.utils.rgb2hex(color)), "number" == typeof color ? core.utils.hex2string(color) : color;
    }
    dropShadowToCSS() {
      let color = this.normalizeColor(this.dropShadowColor);
      var alpha = this.dropShadowAlpha;
      const x = Math.round(Math.cos(this.dropShadowAngle) * this.dropShadowDistance), y = Math.round(Math.sin(this.dropShadowAngle) * this.dropShadowDistance);
      color.startsWith("#") && 1 > alpha && (color += (255 * alpha | 0).toString(16).padStart(2, "0"));
      alpha = `${x}px ${y}px`;
      return 0 < this.dropShadowBlur ? `text-shadow: ${alpha} ${this.dropShadowBlur}px ${color}` : `text-shadow: ${alpha} ${color}`;
    }
    reset() {
      Object.assign(this, node_modules$$pixi$text_html$lib$HTMLTextStyle$classdecl$var27.defaultOptions);
    }
    onBeforeDraw() {
      const {fontsDirty:prevFontsDirty} = this;
      return this.fontsDirty = !1, this.isSafari && 0 < this._fonts.length && prevFontsDirty ? new Promise(resolve => setTimeout(resolve, 100)) : Promise.resolve();
    }
    get isSafari() {
      const {userAgent} = core.settings.ADAPTER.getNavigator();
      return /^((?!chrome|android).)*safari/i.test(userAgent);
    }
    set fillGradientStops(_value) {
      console.warn("[HTMLTextStyle] fillGradientStops is not supported by HTMLText");
    }
    get fillGradientStops() {
      return super.fillGradientStops;
    }
    set fillGradientType(_value) {
      console.warn("[HTMLTextStyle] fillGradientType is not supported by HTMLText");
    }
    get fillGradientType() {
      return super.fillGradientType;
    }
    set miterLimit(_value) {
      console.warn("[HTMLTextStyle] miterLimit is not supported by HTMLText");
    }
    get miterLimit() {
      return super.miterLimit;
    }
    set trim(_value) {
      console.warn("[HTMLTextStyle] trim is not supported by HTMLText");
    }
    get trim() {
      return super.trim;
    }
    set textBaseline(_value) {
      console.warn("[HTMLTextStyle] textBaseline is not supported by HTMLText");
    }
    get textBaseline() {
      return super.textBaseline;
    }
    set leading(_value) {
      console.warn("[HTMLTextStyle] leading is not supported by HTMLText");
    }
    get leading() {
      return super.leading;
    }
    set lineJoin(_value) {
      console.warn("[HTMLTextStyle] lineJoin is not supported by HTMLText");
    }
    get lineJoin() {
      return super.lineJoin;
    }
  };
  global = node_modules$$pixi$text_html$lib$HTMLTextStyle$classdecl$var27;
  global.availableFonts = {};
  global.defaultOptions = {align:"left", breakWords:!1, dropShadow:!1, dropShadowAlpha:1, dropShadowAngle:Math.PI / 6, dropShadowBlur:0, dropShadowColor:"black", dropShadowDistance:5, fill:"black", fontFamily:"Arial", fontSize:26, fontStyle:"normal", fontVariant:"normal", fontWeight:"normal", letterSpacing:0, lineHeight:0, padding:0, stroke:"black", strokeThickness:0, whiteSpace:"normal", wordWrap:!1, wordWrapWidth:100};
  exports.HTMLTextStyle = global;
};

//# sourceMappingURL=module$node_modules$$pixi$text_html$lib$HTMLTextStyle.js.map
