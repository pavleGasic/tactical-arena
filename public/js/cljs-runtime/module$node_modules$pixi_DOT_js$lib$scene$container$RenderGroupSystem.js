shadow$provide.module$node_modules$pixi_DOT_js$lib$scene$container$RenderGroupSystem = function(global, require, module, exports) {
  global = require("module$node_modules$pixi_DOT_js$lib$extensions$Extensions");
  module = require("module$node_modules$pixi_DOT_js$lib$maths$matrix$Matrix");
  var TexturePool = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$texture$TexturePool"), Bounds = require("module$node_modules$pixi_DOT_js$lib$scene$container$bounds$Bounds"), clearList = require("module$node_modules$pixi_DOT_js$lib$scene$container$utils$clearList"), executeInstructions = require("module$node_modules$pixi_DOT_js$lib$scene$container$utils$executeInstructions"), updateRenderGroupTransforms = require("module$node_modules$pixi_DOT_js$lib$scene$container$utils$updateRenderGroupTransforms"), 
  validateRenderables = require("module$node_modules$pixi_DOT_js$lib$scene$container$utils$validateRenderables");
  "use strict";
  const tempMatrix = new module.Matrix();
  class RenderGroupSystem {
    constructor(renderer) {
      this._renderer = renderer;
    }
    render({container, transform}) {
      const parent = container.parent, renderGroupParent = container.renderGroup.renderGroupParent;
      container.parent = null;
      container.renderGroup.renderGroupParent = null;
      const renderer = this._renderer;
      let originalLocalTransform = tempMatrix;
      transform && (originalLocalTransform = originalLocalTransform.copyFrom(container.renderGroup.localTransform), container.renderGroup.localTransform.copyFrom(transform));
      const renderPipes = renderer.renderPipes;
      this._updateCachedRenderGroups(container.renderGroup, null);
      this._updateRenderGroups(container.renderGroup);
      renderer.globalUniforms.start({worldTransformMatrix:transform ? container.renderGroup.localTransform : container.renderGroup.worldTransform, worldColor:container.renderGroup.worldColorAlpha});
      executeInstructions.executeInstructions(container.renderGroup, renderPipes);
      renderPipes.uniformBatch && renderPipes.uniformBatch.renderEnd();
      transform && container.renderGroup.localTransform.copyFrom(originalLocalTransform);
      container.parent = parent;
      container.renderGroup.renderGroupParent = renderGroupParent;
    }
    destroy() {
      this._renderer = null;
    }
    _updateCachedRenderGroups(renderGroup, closestCacheAsTexture) {
      if (renderGroup.isCachedAsTexture) {
        if (!renderGroup.updateCacheTexture) {
          return;
        }
        closestCacheAsTexture = renderGroup;
      }
      renderGroup._parentCacheAsTextureRenderGroup = closestCacheAsTexture;
      for (var i = renderGroup.renderGroupChildren.length - 1; 0 <= i; i--) {
        this._updateCachedRenderGroups(renderGroup.renderGroupChildren[i], closestCacheAsTexture);
      }
      renderGroup.invalidateMatrices();
      if (renderGroup.isCachedAsTexture) {
        if (renderGroup.textureNeedsUpdate) {
          closestCacheAsTexture = renderGroup.root.getLocalBounds();
          closestCacheAsTexture.ceil();
          (i = renderGroup.texture) && TexturePool.TexturePool.returnTexture(renderGroup.texture);
          const renderer = this._renderer;
          renderGroup.texture = TexturePool.TexturePool.getOptimalTexture(closestCacheAsTexture.width, closestCacheAsTexture.height, renderGroup.textureOptions.resolution || renderer.view.resolution, renderGroup.textureOptions.antialias ?? renderer.view.antialias);
          renderGroup._textureBounds || (renderGroup._textureBounds = new Bounds.Bounds());
          renderGroup._textureBounds.copyFrom(closestCacheAsTexture);
          i !== renderGroup.texture && renderGroup.renderGroupParent && (renderGroup.renderGroupParent.structureDidChange = !0);
        }
      } else {
        renderGroup.texture && (TexturePool.TexturePool.returnTexture(renderGroup.texture), renderGroup.texture = null);
      }
    }
    _updateRenderGroups(renderGroup) {
      var renderer = this._renderer;
      const renderPipes = renderer.renderPipes;
      renderGroup.runOnRender(renderer);
      renderGroup.instructionSet.renderPipes = renderPipes;
      renderGroup.structureDidChange ? clearList.clearList(renderGroup.childrenRenderablesToUpdate.list, 0) : validateRenderables.validateRenderables(renderGroup, renderPipes);
      updateRenderGroupTransforms.updateRenderGroupTransforms(renderGroup);
      renderGroup.structureDidChange ? (renderGroup.structureDidChange = !1, this._buildInstructions(renderGroup, renderer)) : this._updateRenderables(renderGroup);
      renderGroup.childrenRenderablesToUpdate.index = 0;
      renderer.renderPipes.batch.upload(renderGroup.instructionSet);
      if (!renderGroup.isCachedAsTexture || renderGroup.textureNeedsUpdate) {
        for (renderer = 0; renderer < renderGroup.renderGroupChildren.length; renderer++) {
          this._updateRenderGroups(renderGroup.renderGroupChildren[renderer]);
        }
      }
    }
    _updateRenderables(renderGroup) {
      const {list, index} = renderGroup.childrenRenderablesToUpdate;
      for (let i = 0; i < index; i++) {
        const container = list[i];
        container.didViewUpdate && renderGroup.updateRenderable(container);
      }
      clearList.clearList(list, index);
    }
    _buildInstructions(renderGroup, rendererOrPipes) {
      const root = renderGroup.root;
      renderGroup = renderGroup.instructionSet;
      renderGroup.reset();
      rendererOrPipes = rendererOrPipes.renderPipes ? rendererOrPipes : rendererOrPipes.batch.renderer;
      const renderPipes = rendererOrPipes.renderPipes;
      renderPipes.batch.buildStart(renderGroup);
      renderPipes.blendMode.buildStart();
      renderPipes.colorMask.buildStart();
      root.sortableChildren && root.sortChildren();
      root.collectRenderablesWithEffects(renderGroup, rendererOrPipes, null);
      renderPipes.batch.buildEnd(renderGroup);
      renderPipes.blendMode.buildEnd(renderGroup);
    }
  }
  RenderGroupSystem.extension = {type:[global.ExtensionType.WebGLSystem, global.ExtensionType.WebGPUSystem, global.ExtensionType.CanvasSystem], name:"renderGroup"};
  exports.RenderGroupSystem = RenderGroupSystem;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$scene$container$RenderGroupSystem.js.map
