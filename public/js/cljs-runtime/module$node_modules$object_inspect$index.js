shadow$provide.module$node_modules$object_inspect$index = function(global, require, module, exports) {
  function addNumericSeparator(num, str) {
    if (Infinity === num || -Infinity === num || num !== num || num && -1000 < num && 1000 > num || $test.call(/e/, str)) {
      return str;
    }
    var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
    if ("number" === typeof num) {
      var int = 0 > num ? -$floor(-num) : $floor(num);
      if (int !== num) {
        return num = String(int), str = $slice.call(str, num.length + 1), $replace.call(num, sepRegex, "$\x26_") + "." + $replace.call($replace.call(str, /([0-9]{3})/g, "$\x26_"), /_$/, "");
      }
    }
    return $replace.call(str, sepRegex, "$\x26_");
  }
  function wrapQuotes(s, defaultStyle, opts) {
    defaultStyle = quotes[opts.quoteStyle || defaultStyle];
    return defaultStyle + s + defaultStyle;
  }
  function canTrustToString(obj) {
    return !toStringTag || !("object" === typeof obj && (toStringTag in obj || "undefined" !== typeof obj[toStringTag]));
  }
  function isArray(obj) {
    return "[object Array]" === objectToString.call(obj) && canTrustToString(obj);
  }
  function isDate(obj) {
    return "[object Date]" === objectToString.call(obj) && canTrustToString(obj);
  }
  function isRegExp(obj) {
    return "[object RegExp]" === objectToString.call(obj) && canTrustToString(obj);
  }
  function isError(obj) {
    return "[object Error]" === objectToString.call(obj) && canTrustToString(obj);
  }
  function isString(obj) {
    return "[object String]" === objectToString.call(obj) && canTrustToString(obj);
  }
  function isNumber(obj) {
    return "[object Number]" === objectToString.call(obj) && canTrustToString(obj);
  }
  function isBoolean(obj) {
    return "[object Boolean]" === objectToString.call(obj) && canTrustToString(obj);
  }
  function isSymbol(obj) {
    if (hasShammedSymbols) {
      return obj && "object" === typeof obj && obj instanceof Symbol;
    }
    if ("symbol" === typeof obj) {
      return !0;
    }
    if (!obj || "object" !== typeof obj || !symToString) {
      return !1;
    }
    try {
      return symToString.call(obj), !0;
    } catch (e) {
    }
    return !1;
  }
  function nameOf(f) {
    return f.name ? f.name : (f = $match.call(functionToString.call(f), /^function\s*([\w$]+)/)) ? f[1] : null;
  }
  function indexOf(xs, x) {
    if (xs.indexOf) {
      return xs.indexOf(x);
    }
    for (var i = 0, l = xs.length; i < l; i++) {
      if (xs[i] === x) {
        return i;
      }
    }
    return -1;
  }
  function isMap(x) {
    if (!mapSize || !x || "object" !== typeof x) {
      return !1;
    }
    try {
      mapSize.call(x);
      try {
        setSize.call(x);
      } catch (s) {
        return !0;
      }
      return x instanceof Map;
    } catch (e) {
    }
    return !1;
  }
  function isWeakMap(x) {
    if (!weakMapHas || !x || "object" !== typeof x) {
      return !1;
    }
    try {
      weakMapHas.call(x, weakMapHas);
      try {
        weakSetHas.call(x, weakSetHas);
      } catch (s) {
        return !0;
      }
      return x instanceof WeakMap;
    } catch (e) {
    }
    return !1;
  }
  function isSet(x) {
    if (!setSize || !x || "object" !== typeof x) {
      return !1;
    }
    try {
      setSize.call(x);
      try {
        mapSize.call(x);
      } catch (m) {
        return !0;
      }
      return x instanceof Set;
    } catch (e) {
    }
    return !1;
  }
  function isWeakSet(x) {
    if (!weakSetHas || !x || "object" !== typeof x) {
      return !1;
    }
    try {
      weakSetHas.call(x, weakSetHas);
      try {
        weakMapHas.call(x, weakMapHas);
      } catch (s) {
        return !0;
      }
      return x instanceof WeakSet;
    } catch (e) {
    }
    return !1;
  }
  function inspectString(str, opts) {
    if (str.length > opts.maxStringLength) {
      var remaining = str.length - opts.maxStringLength;
      remaining = "... " + remaining + " more character" + (1 < remaining ? "s" : "");
      return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + remaining;
    }
    remaining = quoteREs[opts.quoteStyle || "single"];
    remaining.lastIndex = 0;
    str = $replace.call($replace.call(str, remaining, "\\$1"), /[\x00-\x1f]/g, lowbyte);
    return wrapQuotes(str, "single", opts);
  }
  function lowbyte(c) {
    c = c.charCodeAt(0);
    var x = {8:"b", 9:"t", 10:"n", 12:"f", 13:"r"}[c];
    return x ? "\\" + x : "\\x" + (16 > c ? "0" : "") + $toUpperCase.call(c.toString(16));
  }
  function markBoxed(str) {
    return "Object(" + str + ")";
  }
  function collectionOf(type, size, entries, indent) {
    entries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
    return type + " (" + size + ") {" + entries + "}";
  }
  function singleLineValues(xs) {
    for (var i = 0; i < xs.length; i++) {
      if (0 <= indexOf(xs[i], "\n")) {
        return !1;
      }
    }
    return !0;
  }
  function getIndent(opts, depth) {
    if ("\t" === opts.indent) {
      opts = "\t";
    } else if ("number" === typeof opts.indent && 0 < opts.indent) {
      opts = $join.call(Array(opts.indent + 1), " ");
    } else {
      return null;
    }
    return {base:opts, prev:$join.call(Array(depth + 1), opts)};
  }
  function indentedJoin(xs, indent) {
    if (0 === xs.length) {
      return "";
    }
    var lineJoiner = "\n" + indent.prev + indent.base;
    return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
  }
  function arrObjKeys(obj, inspect) {
    var isArr = isArray(obj), xs = [];
    if (isArr) {
      xs.length = obj.length;
      for (var i = 0; i < obj.length; i++) {
        xs[i] = hasOwn.call(obj, i) ? inspect(obj[i], obj) : "";
      }
    }
    i = "function" === typeof gOPS ? gOPS(obj) : [];
    if (hasShammedSymbols) {
      var symMap = {};
      for (var k = 0; k < i.length; k++) {
        symMap["$" + i[k]] = i[k];
      }
    }
    for (var key in obj) {
      hasOwn.call(obj, key) && (isArr && String(Number(key)) === key && key < obj.length || hasShammedSymbols && symMap["$" + key] instanceof Symbol || ($test.call(/[^\w$]/, key) ? xs.push(inspect(key, obj) + ": " + inspect(obj[key], obj)) : xs.push(key + ": " + inspect(obj[key], obj))));
    }
    if ("function" === typeof gOPS) {
      for (isArr = 0; isArr < i.length; isArr++) {
        isEnumerable.call(obj, i[isArr]) && xs.push("[" + inspect(i[isArr]) + "]: " + inspect(obj[i[isArr]], obj));
      }
    }
    return xs;
  }
  exports = "function" === typeof Map && Map.prototype;
  var mapSizeDescriptor = Object.getOwnPropertyDescriptor && exports ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null, mapSize = exports && mapSizeDescriptor && "function" === typeof mapSizeDescriptor.get ? mapSizeDescriptor.get : null, mapForEach = exports && Map.prototype.forEach;
  exports = "function" === typeof Set && Set.prototype;
  mapSizeDescriptor = Object.getOwnPropertyDescriptor && exports ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
  var setSize = exports && mapSizeDescriptor && "function" === typeof mapSizeDescriptor.get ? mapSizeDescriptor.get : null, setForEach = exports && Set.prototype.forEach, weakMapHas = "function" === typeof WeakMap && WeakMap.prototype ? WeakMap.prototype.has : null, weakSetHas = "function" === typeof WeakSet && WeakSet.prototype ? WeakSet.prototype.has : null, weakRefDeref = "function" === typeof WeakRef && WeakRef.prototype ? WeakRef.prototype.deref : null, booleanValueOf = Boolean.prototype.valueOf, 
  objectToString = Object.prototype.toString, functionToString = Function.prototype.toString, $match = String.prototype.match, $slice = String.prototype.slice, $replace = String.prototype.replace, $toUpperCase = String.prototype.toUpperCase, $toLowerCase = String.prototype.toLowerCase, $test = RegExp.prototype.test, $concat = Array.prototype.concat, $join = Array.prototype.join, $arrSlice = Array.prototype.slice, $floor = Math.floor, bigIntValueOf = "function" === typeof BigInt ? BigInt.prototype.valueOf : 
  null, gOPS = Object.getOwnPropertySymbols, symToString = "function" === typeof Symbol && "symbol" === typeof Symbol.iterator ? Symbol.prototype.toString : null, hasShammedSymbols = "function" === typeof Symbol && "object" === typeof Symbol.iterator, toStringTag = "function" === typeof Symbol && Symbol.toStringTag ? Symbol.toStringTag : null, isEnumerable = Object.prototype.propertyIsEnumerable, gPO = ("function" === typeof Reflect ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === 
  Array.prototype ? function(O) {
    return O.__proto__;
  } : null), utilInspect = require("shadow$empty");
  require = utilInspect.custom;
  var inspectSymbol = isSymbol(require) ? require : null, quotes = {__proto__:null, "double":'"', single:"'"}, quoteREs = {__proto__:null, "double":/(["\\])/g, single:/(['\\])/g};
  module.exports = function inspect_(obj, options, depth, seen) {
    function inspect(value, from, noIndent) {
      from && (seen = $arrSlice.call(seen), seen.push(from));
      return noIndent ? (from = {depth:opts.depth}, hasOwn.call(opts, "quoteStyle") && (from.quoteStyle = opts.quoteStyle), inspect_(value, from, depth + 1, seen)) : inspect_(value, opts, depth + 1, seen);
    }
    var opts = options || {};
    if (hasOwn.call(opts, "quoteStyle") && !hasOwn.call(quotes, opts.quoteStyle)) {
      throw new TypeError('option "quoteStyle" must be "single" or "double"');
    }
    if (hasOwn.call(opts, "maxStringLength") && ("number" === typeof opts.maxStringLength ? 0 > opts.maxStringLength && Infinity !== opts.maxStringLength : null !== opts.maxStringLength)) {
      throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
    }
    var customInspect = hasOwn.call(opts, "customInspect") ? opts.customInspect : !0;
    if ("boolean" !== typeof customInspect && "symbol" !== customInspect) {
      throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
    }
    if (hasOwn.call(opts, "indent") && null !== opts.indent && "\t" !== opts.indent && !(parseInt(opts.indent, 10) === opts.indent && 0 < opts.indent)) {
      throw new TypeError('option "indent" must be "\\t", an integer \x3e 0, or `null`');
    }
    if (hasOwn.call(opts, "numericSeparator") && "boolean" !== typeof opts.numericSeparator) {
      throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
    }
    options = opts.numericSeparator;
    if ("undefined" === typeof obj) {
      return "undefined";
    }
    if (null === obj) {
      return "null";
    }
    if ("boolean" === typeof obj) {
      return obj ? "true" : "false";
    }
    if ("string" === typeof obj) {
      return inspectString(obj, opts);
    }
    if ("number" === typeof obj) {
      if (0 === obj) {
        return 0 < Infinity / obj ? "0" : "-0";
      }
      var str = String(obj);
      return options ? addNumericSeparator(obj, str) : str;
    }
    if ("bigint" === typeof obj) {
      return str = String(obj) + "n", options ? addNumericSeparator(obj, str) : str;
    }
    var maxDepth = "undefined" === typeof opts.depth ? 5 : opts.depth;
    "undefined" === typeof depth && (depth = 0);
    if (depth >= maxDepth && 0 < maxDepth && "object" === typeof obj) {
      return isArray(obj) ? "[Array]" : "[Object]";
    }
    options = getIndent(opts, depth);
    if ("undefined" === typeof seen) {
      seen = [];
    } else if (0 <= indexOf(seen, obj)) {
      return "[Circular]";
    }
    if ("function" === typeof obj && !isRegExp(obj)) {
      return options = nameOf(obj), str = arrObjKeys(obj, inspect), "[Function" + (options ? ": " + options : " (anonymous)") + "]" + (0 < str.length ? " { " + $join.call(str, ", ") + " }" : "");
    }
    if (isSymbol(obj)) {
      return options = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj), "object" !== typeof obj || hasShammedSymbols ? options : markBoxed(options);
    }
    var JSCompiler_inline_result = obj && "object" === typeof obj ? "undefined" !== typeof HTMLElement && obj instanceof HTMLElement ? !0 : "string" === typeof obj.nodeName && "function" === typeof obj.getAttribute : !1;
    if (JSCompiler_inline_result) {
      options = "\x3c" + $toLowerCase.call(String(obj.nodeName));
      str = obj.attributes || [];
      for (var i = 0; i < str.length; i++) {
        options += " " + str[i].name + "\x3d" + wrapQuotes($replace.call(String(str[i].value), /"/g, "\x26quot;"), "double", opts);
      }
      options += "\x3e";
      obj.childNodes && obj.childNodes.length && (options += "...");
      return options += "\x3c/" + $toLowerCase.call(String(obj.nodeName)) + "\x3e";
    }
    if (isArray(obj)) {
      if (0 === obj.length) {
        return "[]";
      }
      str = arrObjKeys(obj, inspect);
      return options && !singleLineValues(str) ? "[" + indentedJoin(str, options) + "]" : "[ " + $join.call(str, ", ") + " ]";
    }
    if (isError(obj)) {
      return options = arrObjKeys(obj, inspect), "cause" in Error.prototype || !("cause" in obj) || isEnumerable.call(obj, "cause") ? 0 === options.length ? "[" + String(obj) + "]" : "{ [" + String(obj) + "] " + $join.call(options, ", ") + " }" : "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect(obj.cause), options), ", ") + " }";
    }
    if ("object" === typeof obj && customInspect) {
      if (inspectSymbol && "function" === typeof obj[inspectSymbol] && utilInspect) {
        return utilInspect(obj, {depth:maxDepth - depth});
      }
      if ("symbol" !== customInspect && "function" === typeof obj.inspect) {
        return obj.inspect();
      }
    }
    if (isMap(obj)) {
      var mapParts = [];
      mapForEach && mapForEach.call(obj, function(value, key) {
        mapParts.push(inspect(key, obj, !0) + " \x3d\x3e " + inspect(value, obj));
      });
      return collectionOf("Map", mapSize.call(obj), mapParts, options);
    }
    if (isSet(obj)) {
      var setParts = [];
      setForEach && setForEach.call(obj, function(value) {
        setParts.push(inspect(value, obj));
      });
      return collectionOf("Set", setSize.call(obj), setParts, options);
    }
    if (isWeakMap(obj)) {
      return "WeakMap { ? }";
    }
    if (isWeakSet(obj)) {
      return "WeakSet { ? }";
    }
    a: {
      if (weakRefDeref && obj && "object" === typeof obj) {
        try {
          weakRefDeref.call(obj);
          str = !0;
          break a;
        } catch (e) {
        }
      }
      str = !1;
    }
    if (str) {
      return "WeakRef { ? }";
    }
    if (isNumber(obj)) {
      return markBoxed(inspect(Number(obj)));
    }
    a: {
      if (obj && "object" === typeof obj && bigIntValueOf) {
        try {
          bigIntValueOf.call(obj);
          i = !0;
          break a;
        } catch (e) {
        }
      }
      i = !1;
    }
    return i ? markBoxed(inspect(bigIntValueOf.call(obj))) : isBoolean(obj) ? markBoxed(booleanValueOf.call(obj)) : isString(obj) ? markBoxed(inspect(String(obj))) : "undefined" !== typeof window && obj === window ? "{ [object Window] }" : "undefined" !== typeof globalThis && obj === globalThis || "undefined" !== typeof global && obj === global ? "{ [object globalThis] }" : isDate(obj) || isRegExp(obj) ? String(obj) : (str = arrObjKeys(obj, inspect), i = gPO ? gPO(obj) === Object.prototype : obj instanceof 
    Object || obj.constructor === Object, customInspect = obj instanceof Object ? "" : "null prototype", maxDepth = !i && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(objectToString.call(obj), 8, -1) : customInspect ? "Object" : "", i = (i || "function" !== typeof obj.constructor ? "" : obj.constructor.name ? obj.constructor.name + " " : "") + (maxDepth || customInspect ? "[" + $join.call($concat.call([], maxDepth || [], customInspect || []), ": ") + "] " : ""), 0 === str.length ? 
    i + "{}" : options ? i + "{" + indentedJoin(str, options) + "}" : i + "{ " + $join.call(str, ", ") + " }");
  };
  var hasOwn = Object.prototype.hasOwnProperty || function(key) {
    return key in this;
  };
};

//# sourceMappingURL=module$node_modules$object_inspect$index.js.map
