shadow$provide.module$node_modules$pixi_DOT_js$lib$filters$blend_modes$BlendModeFilter = function(global, require, module, exports) {
  function compileBlendModeShader(options) {
    const {source, functions, main} = options;
    return source.replace("{FUNCTIONS}", functions).replace("{MAIN}", main);
  }
  var GlProgram = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$gl$shader$GlProgram"), GpuProgram = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$gpu$shader$GpuProgram"), UniformGroup = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$shader$UniformGroup"), Texture = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$texture$Texture");
  global = require("module$node_modules$pixi_DOT_js$lib$filters$Filter");
  var blendTemplate$1 = require("module$node_modules$pixi_DOT_js$lib$filters$blend_modes$blend_template_frag"), blendTemplate$2 = require("module$node_modules$pixi_DOT_js$lib$filters$blend_modes$blend_template_vert"), blendTemplate = require("module$node_modules$pixi_DOT_js$lib$filters$blend_modes$blend_template_wgsl");
  "use strict";
  class BlendModeFilter extends global.Filter {
    constructor(options) {
      var gpuSource = compileBlendModeShader({source:blendTemplate.default, ...options.gpu});
      gpuSource = GpuProgram.GpuProgram.from({vertex:{source:gpuSource, entryPoint:"mainVertex"}, fragment:{source:gpuSource, entryPoint:"mainFragment"}});
      options = compileBlendModeShader({source:blendTemplate$1.default, ...options.gl});
      options = GlProgram.GlProgram.from({vertex:blendTemplate$2.default, fragment:options});
      const uniformGroup = new UniformGroup.UniformGroup({uBlend:{value:1, type:"f32"}});
      super({gpuProgram:gpuSource, glProgram:options, blendRequired:!0, resources:{blendUniforms:uniformGroup, uBackTexture:Texture.Texture.EMPTY}});
    }
  }
  exports.BlendModeFilter = BlendModeFilter;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$filters$blend_modes$BlendModeFilter.js.map
