shadow$provide.module$node_modules$pixi_DOT_js$lib$rendering$batcher$gl$GlBatchAdaptor = function(global, require, module, exports) {
  global = require("module$node_modules$pixi_DOT_js$lib$extensions$Extensions");
  var State = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$state$State");
  "use strict";
  class GlBatchAdaptor {
    constructor() {
      this._tempState = State.State.for2d();
      this._didUploadHash = {};
    }
    init(batcherPipe) {
      batcherPipe.renderer.runners.contextChange.add(this);
    }
    contextChange() {
      this._didUploadHash = {};
    }
    start(batchPipe, geometry, shader) {
      batchPipe = batchPipe.renderer;
      const didUpload = this._didUploadHash[shader.uid];
      batchPipe.shader.bind(shader, didUpload);
      didUpload || (this._didUploadHash[shader.uid] = !0);
      batchPipe.shader.updateUniformGroup(batchPipe.globalUniforms.uniformGroup);
      batchPipe.geometry.bind(geometry, shader.glProgram);
    }
    execute(batchPipe, batch) {
      batchPipe = batchPipe.renderer;
      this._tempState.blendMode = batch.blendMode;
      batchPipe.state.set(this._tempState);
      const textures = batch.textures.textures;
      for (let i = 0; i < batch.textures.count; i++) {
        batchPipe.texture.bind(textures[i], i);
      }
      batchPipe.geometry.draw(batch.topology, batch.size, batch.start);
    }
  }
  GlBatchAdaptor.extension = {type:[global.ExtensionType.WebGLPipesAdaptor], name:"batch"};
  exports.GlBatchAdaptor = GlBatchAdaptor;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$rendering$batcher$gl$GlBatchAdaptor.js.map
