shadow$provide.module$node_modules$pixi_DOT_js$lib$scene$container$bounds$Bounds = function(global, require, module, exports) {
  global = require("module$node_modules$pixi_DOT_js$lib$maths$matrix$Matrix");
  var Rectangle = require("module$node_modules$pixi_DOT_js$lib$maths$shapes$Rectangle");
  "use strict";
  const defaultMatrix = new global.Matrix();
  class Bounds {
    constructor(minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity) {
      this.minY = this.minX = Infinity;
      this.maxY = this.maxX = -Infinity;
      this.matrix = defaultMatrix;
      this.minX = minX;
      this.minY = minY;
      this.maxX = maxX;
      this.maxY = maxY;
    }
    isEmpty() {
      return this.minX > this.maxX || this.minY > this.maxY;
    }
    get rectangle() {
      this._rectangle || (this._rectangle = new Rectangle.Rectangle());
      const rectangle = this._rectangle;
      this.minX > this.maxX || this.minY > this.maxY ? (rectangle.x = 0, rectangle.y = 0, rectangle.width = 0, rectangle.height = 0) : rectangle.copyFromBounds(this);
      return rectangle;
    }
    clear() {
      this.minY = this.minX = Infinity;
      this.maxY = this.maxX = -Infinity;
      this.matrix = defaultMatrix;
      return this;
    }
    set(x0, y0, x1, y1) {
      this.minX = x0;
      this.minY = y0;
      this.maxX = x1;
      this.maxY = y1;
    }
    addFrame(x0, y0, x1, y1, matrix) {
      matrix || (matrix = this.matrix);
      const a = matrix.a, b = matrix.b, c = matrix.c, d = matrix.d, tx = matrix.tx;
      matrix = matrix.ty;
      let minX = this.minX, minY = this.minY, maxX = this.maxX, maxY = this.maxY, x = a * x0 + c * y0 + tx, y = b * x0 + d * y0 + matrix;
      x < minX && (minX = x);
      y < minY && (minY = y);
      x > maxX && (maxX = x);
      y > maxY && (maxY = y);
      x = a * x1 + c * y0 + tx;
      y = b * x1 + d * y0 + matrix;
      x < minX && (minX = x);
      y < minY && (minY = y);
      x > maxX && (maxX = x);
      y > maxY && (maxY = y);
      x = a * x0 + c * y1 + tx;
      y = b * x0 + d * y1 + matrix;
      x < minX && (minX = x);
      y < minY && (minY = y);
      x > maxX && (maxX = x);
      y > maxY && (maxY = y);
      x = a * x1 + c * y1 + tx;
      y = b * x1 + d * y1 + matrix;
      x < minX && (minX = x);
      y < minY && (minY = y);
      x > maxX && (maxX = x);
      y > maxY && (maxY = y);
      this.minX = minX;
      this.minY = minY;
      this.maxX = maxX;
      this.maxY = maxY;
    }
    addRect(rect, matrix) {
      this.addFrame(rect.x, rect.y, rect.x + rect.width, rect.y + rect.height, matrix);
    }
    addBounds(bounds, matrix) {
      this.addFrame(bounds.minX, bounds.minY, bounds.maxX, bounds.maxY, matrix);
    }
    addBoundsMask(mask) {
      this.minX = this.minX > mask.minX ? this.minX : mask.minX;
      this.minY = this.minY > mask.minY ? this.minY : mask.minY;
      this.maxX = this.maxX < mask.maxX ? this.maxX : mask.maxX;
      this.maxY = this.maxY < mask.maxY ? this.maxY : mask.maxY;
    }
    applyMatrix(matrix) {
      const minX = this.minX, minY = this.minY, maxX = this.maxX, maxY = this.maxY, {a, b, c, d, tx, ty} = matrix;
      matrix = a * minX + c * minY + tx;
      let y = b * minX + d * minY + ty;
      this.minX = matrix;
      this.minY = y;
      this.maxX = matrix;
      this.maxY = y;
      matrix = a * maxX + c * minY + tx;
      y = b * maxX + d * minY + ty;
      this.minX = matrix < this.minX ? matrix : this.minX;
      this.minY = y < this.minY ? y : this.minY;
      this.maxX = matrix > this.maxX ? matrix : this.maxX;
      this.maxY = y > this.maxY ? y : this.maxY;
      matrix = a * minX + c * maxY + tx;
      y = b * minX + d * maxY + ty;
      this.minX = matrix < this.minX ? matrix : this.minX;
      this.minY = y < this.minY ? y : this.minY;
      this.maxX = matrix > this.maxX ? matrix : this.maxX;
      this.maxY = y > this.maxY ? y : this.maxY;
      matrix = a * maxX + c * maxY + tx;
      y = b * maxX + d * maxY + ty;
      this.minX = matrix < this.minX ? matrix : this.minX;
      this.minY = y < this.minY ? y : this.minY;
      this.maxX = matrix > this.maxX ? matrix : this.maxX;
      this.maxY = y > this.maxY ? y : this.maxY;
    }
    fit(rect) {
      this.minX < rect.left && (this.minX = rect.left);
      this.maxX > rect.right && (this.maxX = rect.right);
      this.minY < rect.top && (this.minY = rect.top);
      this.maxY > rect.bottom && (this.maxY = rect.bottom);
      return this;
    }
    fitBounds(left, right, top, bottom) {
      this.minX < left && (this.minX = left);
      this.maxX > right && (this.maxX = right);
      this.minY < top && (this.minY = top);
      this.maxY > bottom && (this.maxY = bottom);
      return this;
    }
    pad(paddingX, paddingY = paddingX) {
      this.minX -= paddingX;
      this.maxX += paddingX;
      this.minY -= paddingY;
      this.maxY += paddingY;
      return this;
    }
    ceil() {
      this.minX = Math.floor(this.minX);
      this.minY = Math.floor(this.minY);
      this.maxX = Math.ceil(this.maxX);
      this.maxY = Math.ceil(this.maxY);
      return this;
    }
    clone() {
      return new Bounds(this.minX, this.minY, this.maxX, this.maxY);
    }
    scale(x, y = x) {
      this.minX *= x;
      this.minY *= y;
      this.maxX *= x;
      this.maxY *= y;
      return this;
    }
    get x() {
      return this.minX;
    }
    set x(value) {
      const width = this.maxX - this.minX;
      this.minX = value;
      this.maxX = value + width;
    }
    get y() {
      return this.minY;
    }
    set y(value) {
      const height = this.maxY - this.minY;
      this.minY = value;
      this.maxY = value + height;
    }
    get width() {
      return this.maxX - this.minX;
    }
    set width(value) {
      this.maxX = this.minX + value;
    }
    get height() {
      return this.maxY - this.minY;
    }
    set height(value) {
      this.maxY = this.minY + value;
    }
    get left() {
      return this.minX;
    }
    get right() {
      return this.maxX;
    }
    get top() {
      return this.minY;
    }
    get bottom() {
      return this.maxY;
    }
    get isPositive() {
      return 0 < this.maxX - this.minX && 0 < this.maxY - this.minY;
    }
    get isValid() {
      return Infinity !== this.minX + this.minY;
    }
    addVertexData(vertexData, beginOffset, endOffset, matrix) {
      let minX = this.minX, minY = this.minY, maxX = this.maxX, maxY = this.maxY;
      matrix || (matrix = this.matrix);
      const a = matrix.a, b = matrix.b, c = matrix.c, d = matrix.d, tx = matrix.tx;
      for (matrix = matrix.ty; beginOffset < endOffset; beginOffset += 2) {
        var localX = vertexData[beginOffset];
        const localY = vertexData[beginOffset + 1], x = a * localX + c * localY + tx;
        localX = b * localX + d * localY + matrix;
        minX = x < minX ? x : minX;
        minY = localX < minY ? localX : minY;
        maxX = x > maxX ? x : maxX;
        maxY = localX > maxY ? localX : maxY;
      }
      this.minX = minX;
      this.minY = minY;
      this.maxX = maxX;
      this.maxY = maxY;
    }
    containsPoint(x, y) {
      return this.minX <= x && this.minY <= y && this.maxX >= x && this.maxY >= y ? !0 : !1;
    }
    toString() {
      return `[pixi.js:Bounds minX=${this.minX} minY=${this.minY} maxX=${this.maxX} maxY=${this.maxY} width=${this.width} height=${this.height}]`;
    }
    copyFrom(bounds) {
      this.minX = bounds.minX;
      this.minY = bounds.minY;
      this.maxX = bounds.maxX;
      this.maxY = bounds.maxY;
      return this;
    }
  }
  exports.Bounds = Bounds;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$scene$container$bounds$Bounds.js.map
