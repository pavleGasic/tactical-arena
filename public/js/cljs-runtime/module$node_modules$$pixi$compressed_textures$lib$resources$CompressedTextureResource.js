shadow$provide.module$node_modules$$pixi$compressed_textures$lib$resources$CompressedTextureResource = function(global, require, module, exports) {
  var _const = require("module$node_modules$$pixi$compressed_textures$lib$const");
  global = require("module$node_modules$$pixi$compressed_textures$lib$resources$BlobResource");
  class CompressedTextureResource extends global.BlobResource {
    constructor(source, options) {
      super(source, options);
      this.format = options.format;
      this.levels = options.levels || 1;
      this._width = options.width;
      this._height = options.height;
      this._extension = CompressedTextureResource._formatToExtension(this.format);
      (options.levelBuffers || this.buffer) && (this._levelBuffers = options.levelBuffers || CompressedTextureResource._createLevelBuffers(source instanceof Uint8Array ? source : this.buffer.uint8View, this.format, this.levels, 4, 4, this.width, this.height));
    }
    upload(renderer, _texture, _glTexture) {
      _texture = renderer.gl;
      if (!renderer.context.extensions[this._extension]) {
        throw Error(`${this._extension} textures are not supported on the current machine`);
      }
      if (!this._levelBuffers) {
        return !1;
      }
      _texture.pixelStorei(_texture.UNPACK_ALIGNMENT, 4);
      for (let i = 0, j = this.levels; i < j; i++) {
        const {levelID, levelWidth, levelHeight, levelBuffer} = this._levelBuffers[i];
        _texture.compressedTexImage2D(_texture.TEXTURE_2D, levelID, this.format, levelWidth, levelHeight, 0, levelBuffer);
      }
      return !0;
    }
    onBlobLoaded() {
      this._levelBuffers = CompressedTextureResource._createLevelBuffers(this.buffer.uint8View, this.format, this.levels, 4, 4, this.width, this.height);
    }
    static _formatToExtension(format) {
      if (33776 <= format && 33779 >= format) {
        return "s3tc";
      }
      if (35916 <= format && 35919 >= format) {
        return "s3tc_sRGB";
      }
      if (37488 <= format && 37497 >= format) {
        return "etc";
      }
      if (35840 <= format && 35843 >= format) {
        return "pvrtc";
      }
      if (36196 === format) {
        return "etc1";
      }
      if (35986 === format || 35987 === format || 34798 === format) {
        return "atc";
      }
      if (36492 <= format && 36495 >= format) {
        return "bptc";
      }
      if (37808 === format) {
        return "astc";
      }
      throw Error(`Invalid (compressed) texture format given: ${format}`);
    }
    static _createLevelBuffers(buffer, format, levels, blockWidth, blockHeight, imageWidth, imageHeight) {
      const buffers = Array(levels);
      let offset = buffer.byteOffset, alignedLevelWidth = imageWidth + blockWidth - 1 & ~(blockWidth - 1), alignedLevelHeight = imageHeight + blockHeight - 1 & ~(blockHeight - 1), levelSize = alignedLevelWidth * alignedLevelHeight * _const.INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[format];
      for (let i = 0; i < levels; i++) {
        buffers[i] = {levelID:i, levelWidth:1 < levels ? imageWidth : alignedLevelWidth, levelHeight:1 < levels ? imageHeight : alignedLevelHeight, levelBuffer:new Uint8Array(buffer.buffer, offset, levelSize)}, offset += levelSize, imageWidth = imageWidth >> 1 || 1, imageHeight = imageHeight >> 1 || 1, alignedLevelWidth = imageWidth + blockWidth - 1 & ~(blockWidth - 1), alignedLevelHeight = imageHeight + blockHeight - 1 & ~(blockHeight - 1), levelSize = alignedLevelWidth * alignedLevelHeight * _const.INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[format];
      }
      return buffers;
    }
  }
  exports.CompressedTextureResource = CompressedTextureResource;
};

//# sourceMappingURL=module$node_modules$$pixi$compressed_textures$lib$resources$CompressedTextureResource.js.map
