shadow$provide.module$node_modules$pixi_DOT_js$lib$rendering$mask$color$ColorMaskPipe = function(global, require, module, exports) {
  global = require("module$node_modules$pixi_DOT_js$lib$extensions$Extensions");
  "use strict";
  class ColorMaskPipe {
    constructor(renderer) {
      this._colorStack = [];
      this._currentColor = this._colorStackIndex = 0;
      this._renderer = renderer;
    }
    buildStart() {
      this._colorStack[0] = 15;
      this._colorStackIndex = 1;
      this._currentColor = 15;
    }
    push(mask, _container, instructionSet) {
      this._renderer.renderPipes.batch.break(instructionSet);
      _container = this._colorStack;
      _container[this._colorStackIndex] = _container[this._colorStackIndex - 1] & mask.mask;
      mask = this._colorStack[this._colorStackIndex];
      mask !== this._currentColor && (this._currentColor = mask, instructionSet.add({renderPipeId:"colorMask", colorMask:mask, canBundle:!1}));
      this._colorStackIndex++;
    }
    pop(_mask, _container, instructionSet) {
      this._renderer.renderPipes.batch.break(instructionSet);
      _mask = this._colorStack;
      this._colorStackIndex--;
      _mask = _mask[this._colorStackIndex - 1];
      _mask !== this._currentColor && (this._currentColor = _mask, instructionSet.add({renderPipeId:"colorMask", colorMask:_mask, canBundle:!1}));
    }
    execute(instruction) {
      this._renderer.colorMask.setMask(instruction.colorMask);
    }
    destroy() {
      this._colorStack = null;
    }
  }
  ColorMaskPipe.extension = {type:[global.ExtensionType.WebGLPipes, global.ExtensionType.WebGPUPipes, global.ExtensionType.CanvasPipes], name:"colorMask"};
  exports.ColorMaskPipe = ColorMaskPipe;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$rendering$mask$color$ColorMaskPipe.js.map
