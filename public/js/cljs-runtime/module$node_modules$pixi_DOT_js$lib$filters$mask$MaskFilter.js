shadow$provide.module$node_modules$pixi_DOT_js$lib$filters$mask$MaskFilter = function(global, require, module, exports) {
  var Matrix = require("module$node_modules$pixi_DOT_js$lib$maths$matrix$Matrix"), GlProgram = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$gl$shader$GlProgram"), GpuProgram = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$gpu$shader$GpuProgram"), UniformGroup = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$shader$UniformGroup"), TextureMatrix = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$texture$TextureMatrix");
  global = require("module$node_modules$pixi_DOT_js$lib$filters$Filter");
  var mask$2 = require("module$node_modules$pixi_DOT_js$lib$filters$mask$mask_frag"), mask$1 = require("module$node_modules$pixi_DOT_js$lib$filters$mask$mask_vert"), mask = require("module$node_modules$pixi_DOT_js$lib$filters$mask$mask_wgsl");
  "use strict";
  class MaskFilter extends global.Filter {
    constructor(options) {
      const {sprite, ...rest} = options, textureMatrix = new TextureMatrix.TextureMatrix(sprite.texture);
      options = new UniformGroup.UniformGroup({uFilterMatrix:{value:new Matrix.Matrix(), type:"mat3x3\x3cf32\x3e"}, uMaskClamp:{value:textureMatrix.uClampFrame, type:"vec4\x3cf32\x3e"}, uAlpha:{value:1, type:"f32"}, uInverse:{value:options.inverse ? 1 : 0, type:"f32"}});
      const gpuProgram = GpuProgram.GpuProgram.from({vertex:{source:mask.default, entryPoint:"mainVertex"}, fragment:{source:mask.default, entryPoint:"mainFragment"}}), glProgram = GlProgram.GlProgram.from({vertex:mask$1.default, fragment:mask$2.default, name:"mask-filter"});
      super({...rest, gpuProgram, glProgram, resources:{filterUniforms:options, uMaskTexture:sprite.texture.source}});
      this.sprite = sprite;
      this._textureMatrix = textureMatrix;
    }
    set inverse(value) {
      this.resources.filterUniforms.uniforms.uInverse = value ? 1 : 0;
    }
    get inverse() {
      return 1 === this.resources.filterUniforms.uniforms.uInverse;
    }
    apply(filterManager, input, output, clearMode) {
      this._textureMatrix.texture = this.sprite.texture;
      filterManager.calculateSpriteMatrix(this.resources.filterUniforms.uniforms.uFilterMatrix, this.sprite).prepend(this._textureMatrix.mapCoord);
      this.resources.uMaskTexture = this.sprite.texture.source;
      filterManager.applyFilter(this, input, output, clearMode);
    }
  }
  exports.MaskFilter = MaskFilter;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$filters$mask$MaskFilter.js.map
