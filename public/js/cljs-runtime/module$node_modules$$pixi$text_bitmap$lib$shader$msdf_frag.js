shadow$provide.module$node_modules$$pixi$text_bitmap$lib$shader$msdf_frag = function(global, require, module, exports) {
  Object.defineProperty(exports, "__esModule", {value:!0});
  exports.default = "// Pixi texture info\r\nvarying vec2 vTextureCoord;\r\nuniform sampler2D uSampler;\r\n\r\n// Tint\r\nuniform vec4 uColor;\r\n\r\n// on 2D applications fwidth is screenScale / glyphAtlasScale * distanceFieldRange\r\nuniform float uFWidth;\r\n\r\nvoid main(void) {\r\n\r\n  // To stack MSDF and SDF we need a non-pre-multiplied-alpha texture.\r\n  vec4 texColor \x3d texture2D(uSampler, vTextureCoord);\r\n\r\n  // MSDF\r\n  float median \x3d texColor.r + texColor.g + texColor.b -\r\n                  min(texColor.r, min(texColor.g, texColor.b)) -\r\n                  max(texColor.r, max(texColor.g, texColor.b));\r\n  // SDF\r\n  median \x3d min(median, texColor.a);\r\n\r\n  float screenPxDistance \x3d uFWidth * (median - 0.5);\r\n  float alpha \x3d clamp(screenPxDistance + 0.5, 0.0, 1.0);\r\n  if (median \x3c 0.01) {\r\n    alpha \x3d 0.0;\r\n  } else if (median \x3e 0.99) {\r\n    alpha \x3d 1.0;\r\n  }\r\n\r\n  // Gamma correction for coverage-like alpha\r\n  float luma \x3d dot(uColor.rgb, vec3(0.299, 0.587, 0.114));\r\n  float gamma \x3d mix(1.0, 1.0 / 2.2, luma);\r\n  float coverage \x3d pow(uColor.a * alpha, gamma);  \r\n\r\n  // NPM Textures, NPM outputs\r\n  gl_FragColor \x3d vec4(uColor.rgb, coverage);\r\n}\r\n";
};

//# sourceMappingURL=module$node_modules$$pixi$text_bitmap$lib$shader$msdf_frag.js.map
