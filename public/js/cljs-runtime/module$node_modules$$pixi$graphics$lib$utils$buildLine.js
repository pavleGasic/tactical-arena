shadow$provide.module$node_modules$$pixi$graphics$lib$utils$buildLine = function(global, require, module, exports) {
  function square(x, y, nx, ny, innerWeight, outerWeight, clockwise, verts) {
    let exx, eyy;
    clockwise ? (exx = ny, eyy = -nx) : (exx = -ny, eyy = nx);
    return verts.push(x - nx * innerWeight + exx, y - ny * innerWeight + eyy, x + nx * outerWeight + exx, y + ny * outerWeight + eyy), 2;
  }
  function round(cx, cy, sx, sy, ex, ey, verts, clockwise) {
    var cx2p0x = sx - cx, cy2p0y = sy - cy, angle0 = Math.atan2(cx2p0x, cy2p0y);
    let angle1 = Math.atan2(ex - cx, ey - cy);
    clockwise && angle0 < angle1 ? angle0 += 2 * Math.PI : !clockwise && angle0 > angle1 && (angle1 += 2 * Math.PI);
    let startAngle = angle0;
    angle0 = angle1 - angle0;
    cx2p0x = Math.sqrt(cx2p0x * cx2p0x + cy2p0y * cy2p0y);
    cy2p0y = (15 * Math.abs(angle0) * Math.sqrt(cx2p0x) / Math.PI >> 0) + 1;
    angle0 /= cy2p0y;
    if (startAngle += angle0, clockwise) {
      verts.push(cx, cy, sx, sy);
      for (let i = 1, angle = startAngle; i < cy2p0y; i++, angle += angle0) {
        verts.push(cx, cy, cx + Math.sin(angle) * cx2p0x, cy + Math.cos(angle) * cx2p0x);
      }
      verts.push(cx, cy, ex, ey);
    } else {
      verts.push(sx, sy, cx, cy);
      for (let i = 1, angle = startAngle; i < cy2p0y; i++, angle += angle0) {
        verts.push(cx + Math.sin(angle) * cx2p0x, cy + Math.cos(angle) * cx2p0x, cx, cy);
      }
      verts.push(ex, ey, cx, cy);
    }
    return 2 * cy2p0y;
  }
  var core = require("module$node_modules$$pixi$core$lib$index"), _const = require("module$node_modules$$pixi$graphics$lib$const");
  exports.buildLine = function(graphicsData, graphicsGeometry) {
    if (graphicsData.lineStyle.native) {
      var i$jscomp$0, shape = graphicsData.shape, points = graphicsData.points || shape.points;
      shape = shape.type !== core.SHAPES.POLY || shape.closeStroke;
      if (0 !== points.length) {
        graphicsData = graphicsGeometry.points;
        graphicsGeometry = graphicsGeometry.indices;
        var length = points.length / 2, startIndex = graphicsData.length / 2, currentIndex = startIndex;
        graphicsData.push(points[0], points[1]);
        for (i$jscomp$0 = 1; i$jscomp$0 < length; i$jscomp$0++) {
          graphicsData.push(points[2 * i$jscomp$0], points[2 * i$jscomp$0 + 1]), graphicsGeometry.push(currentIndex, currentIndex + 1), currentIndex++;
        }
        shape && graphicsGeometry.push(currentIndex, startIndex);
      }
    } else {
      if (shape = graphicsData.shape, points = graphicsData.points || shape.points.slice(), currentIndex = graphicsGeometry.closePointEps, 0 !== points.length) {
        graphicsData = graphicsData.lineStyle;
        length = new core.Point(points[0], points[1]);
        startIndex = new core.Point(points[points.length - 2], points[points.length - 1]);
        shape = shape.type !== core.SHAPES.POLY || shape.closeStroke;
        currentIndex = Math.abs(length.x - startIndex.x) < currentIndex && Math.abs(length.y - startIndex.y) < currentIndex;
        shape && (points = points.slice(), currentIndex && (points.pop(), points.pop(), startIndex.set(points[points.length - 2], points[points.length - 1])), currentIndex = 0.5 * (length.x + startIndex.x), length = 0.5 * (startIndex.y + length.y), points.unshift(currentIndex, length), points.push(currentIndex, length));
        length = graphicsGeometry.points;
        var length$jscomp$0 = points.length / 2;
        startIndex = points.length;
        currentIndex = length.length / 2;
        var width = graphicsData.width / 2, widthSquared = width * width, miterLimitSquared = graphicsData.miterLimit * graphicsData.miterLimit, x0 = points[0], y0 = points[1];
        i$jscomp$0 = points[2];
        var y1 = points[3], perpx = -(y0 - y1), perpy = x0 - i$jscomp$0, dist = Math.sqrt(perpx * perpx + perpy * perpy);
        perpx = perpx / dist * width;
        perpy = perpy / dist * width;
        i$jscomp$0 = graphicsData.alignment;
        var innerWeight = 2 * (1 - i$jscomp$0), outerWeight = 2 * i$jscomp$0;
        shape || (graphicsData.cap === _const.LINE_CAP.ROUND ? startIndex += round(x0 - perpx * (innerWeight - outerWeight) * 0.5, y0 - perpy * (innerWeight - outerWeight) * 0.5, x0 - perpx * innerWeight, y0 - perpy * innerWeight, x0 + perpx * outerWeight, y0 + perpy * outerWeight, length, !0) + 2 : graphicsData.cap === _const.LINE_CAP.SQUARE && (startIndex += square(x0, y0, perpx, perpy, innerWeight, outerWeight, !0, length)));
        length.push(x0 - perpx * innerWeight, y0 - perpy * innerWeight, x0 + perpx * outerWeight, y0 + perpy * outerWeight);
        for (let i = 1; i < length$jscomp$0 - 1; ++i) {
          x0 = points[2 * (i - 1)];
          y0 = points[2 * (i - 1) + 1];
          i$jscomp$0 = points[2 * i];
          y1 = points[2 * i + 1];
          var x2 = points[2 * (i + 1)];
          var y2 = points[2 * (i + 1) + 1];
          perpx = -(y0 - y1);
          perpy = x0 - i$jscomp$0;
          dist = Math.sqrt(perpx * perpx + perpy * perpy);
          perpx /= dist;
          perpy /= dist;
          perpx *= width;
          perpy *= width;
          var perp1x = -(y1 - y2);
          var perp1y = i$jscomp$0 - x2;
          dist = Math.sqrt(perp1x * perp1x + perp1y * perp1y);
          perp1x /= dist;
          perp1y /= dist;
          perp1x *= width;
          perp1y *= width;
          var dx0 = i$jscomp$0 - x0, dy0 = y0 - y1;
          const dx1 = i$jscomp$0 - x2, dy1 = y2 - y1;
          var dot = dx0 * dx1 + dy0 * dy1, cross = dy0 * dx1 - dy1 * dx0;
          dist = 0 > cross;
          if (Math.abs(cross) < 1e-3 * Math.abs(dot)) {
            length.push(i$jscomp$0 - perpx * innerWeight, y1 - perpy * innerWeight, i$jscomp$0 + perpx * outerWeight, y1 + perpy * outerWeight), 0 <= dot && (graphicsData.join === _const.LINE_JOIN.ROUND ? startIndex += round(i$jscomp$0, y1, i$jscomp$0 - perpx * innerWeight, y1 - perpy * innerWeight, i$jscomp$0 - perp1x * innerWeight, y1 - perp1y * innerWeight, length, !1) + 4 : startIndex += 2, length.push(i$jscomp$0 - perp1x * outerWeight, y1 - perp1y * outerWeight, i$jscomp$0 + perp1x * innerWeight, 
            y1 + perp1y * innerWeight));
          } else {
            if (x0 = (-perpx + x0) * (-perpy + y1) - (-perpx + i$jscomp$0) * (-perpy + y0), y0 = (-perp1x + x2) * (-perp1y + y1) - (-perp1x + i$jscomp$0) * (-perp1y + y2), y2 = (dx0 * y0 - dx1 * x0) / cross, cross = (dy1 * x0 - dy0 * y0) / cross, x0 = (y2 - i$jscomp$0) * (y2 - i$jscomp$0) + (cross - y1) * (cross - y1), y0 = i$jscomp$0 + (y2 - i$jscomp$0) * innerWeight, x2 = y1 + (cross - y1) * innerWeight, y2 = i$jscomp$0 - (y2 - i$jscomp$0) * outerWeight, cross = y1 - (cross - y1) * outerWeight, 
            dot = dist ? innerWeight : outerWeight, dx0 = x0 <= Math.min(dx0 * dx0 + dy0 * dy0, dx1 * dx1 + dy1 * dy1) + dot * dot * widthSquared, dy0 = graphicsData.join, dy0 === _const.LINE_JOIN.MITER && x0 / widthSquared > miterLimitSquared && (dy0 = _const.LINE_JOIN.BEVEL), dx0) {
              switch(dy0) {
                case _const.LINE_JOIN.MITER:
                  length.push(y0, x2, y2, cross);
                  break;
                case _const.LINE_JOIN.BEVEL:
                  dist ? length.push(y0, x2, i$jscomp$0 + perpx * outerWeight, y1 + perpy * outerWeight, y0, x2, i$jscomp$0 + perp1x * outerWeight, y1 + perp1y * outerWeight) : length.push(i$jscomp$0 - perpx * innerWeight, y1 - perpy * innerWeight, y2, cross, i$jscomp$0 - perp1x * innerWeight, y1 - perp1y * innerWeight, y2, cross);
                  startIndex += 2;
                  break;
                case _const.LINE_JOIN.ROUND:
                  dist ? (length.push(y0, x2, i$jscomp$0 + perpx * outerWeight, y1 + perpy * outerWeight), startIndex += round(i$jscomp$0, y1, i$jscomp$0 + perpx * outerWeight, y1 + perpy * outerWeight, i$jscomp$0 + perp1x * outerWeight, y1 + perp1y * outerWeight, length, !0) + 4, length.push(y0, x2, i$jscomp$0 + perp1x * outerWeight, y1 + perp1y * outerWeight)) : (length.push(i$jscomp$0 - perpx * innerWeight, y1 - perpy * innerWeight, y2, cross), startIndex += round(i$jscomp$0, y1, i$jscomp$0 - 
                  perpx * innerWeight, y1 - perpy * innerWeight, i$jscomp$0 - perp1x * innerWeight, y1 - perp1y * innerWeight, length, !1) + 4, length.push(i$jscomp$0 - perp1x * innerWeight, y1 - perp1y * innerWeight, y2, cross));
              }
            } else {
              switch(length.push(i$jscomp$0 - perpx * innerWeight, y1 - perpy * innerWeight, i$jscomp$0 + perpx * outerWeight, y1 + perpy * outerWeight), dy0) {
                case _const.LINE_JOIN.MITER:
                  dist ? length.push(y2, cross, y2, cross) : length.push(y0, x2, y0, x2);
                  startIndex += 2;
                  break;
                case _const.LINE_JOIN.ROUND:
                  dist ? startIndex += round(i$jscomp$0, y1, i$jscomp$0 + perpx * outerWeight, y1 + perpy * outerWeight, i$jscomp$0 + perp1x * outerWeight, y1 + perp1y * outerWeight, length, !0) + 2 : startIndex += round(i$jscomp$0, y1, i$jscomp$0 - perpx * innerWeight, y1 - perpy * innerWeight, i$jscomp$0 - perp1x * innerWeight, y1 - perp1y * innerWeight, length, !1) + 2;
              }
              length.push(i$jscomp$0 - perp1x * innerWeight, y1 - perp1y * innerWeight, i$jscomp$0 + perp1x * outerWeight, y1 + perp1y * outerWeight);
              startIndex += 2;
            }
          }
        }
        x0 = points[2 * (length$jscomp$0 - 2)];
        y0 = points[2 * (length$jscomp$0 - 2) + 1];
        i$jscomp$0 = points[2 * (length$jscomp$0 - 1)];
        y1 = points[2 * (length$jscomp$0 - 1) + 1];
        perpx = -(y0 - y1);
        perpy = x0 - i$jscomp$0;
        dist = Math.sqrt(perpx * perpx + perpy * perpy);
        perpx = perpx / dist * width;
        perpy = perpy / dist * width;
        length.push(i$jscomp$0 - perpx * innerWeight, y1 - perpy * innerWeight, i$jscomp$0 + perpx * outerWeight, y1 + perpy * outerWeight);
        shape || (graphicsData.cap === _const.LINE_CAP.ROUND ? startIndex += round(i$jscomp$0 - perpx * (innerWeight - outerWeight) * 0.5, y1 - perpy * (innerWeight - outerWeight) * 0.5, i$jscomp$0 - perpx * innerWeight, y1 - perpy * innerWeight, i$jscomp$0 + perpx * outerWeight, y1 + perpy * outerWeight, length, !1) + 2 : graphicsData.cap === _const.LINE_CAP.SQUARE && (startIndex += square(i$jscomp$0, y1, perpx, perpy, innerWeight, outerWeight, !1, length)));
        graphicsGeometry = graphicsGeometry.indices;
        points = _const.curves.epsilon * _const.curves.epsilon;
        for (graphicsData = currentIndex; graphicsData < startIndex + currentIndex - 2; ++graphicsData) {
          x0 = length[2 * graphicsData], y0 = length[2 * graphicsData + 1], i$jscomp$0 = length[2 * (graphicsData + 1)], y1 = length[2 * (graphicsData + 1) + 1], x2 = length[2 * (graphicsData + 2)], y2 = length[2 * (graphicsData + 2) + 1], Math.abs(x0 * (y1 - y2) + i$jscomp$0 * (y2 - y0) + x2 * (y0 - y1)) < points || graphicsGeometry.push(graphicsData, graphicsData + 1, graphicsData + 2);
        }
      }
    }
  };
};

//# sourceMappingURL=module$node_modules$$pixi$graphics$lib$utils$buildLine.js.map
