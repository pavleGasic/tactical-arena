shadow$provide.module$node_modules$pixi_DOT_js$lib$assets$loader$parsers$textures$loadVideoTextures = function(global, require, module, exports) {
  function crossOrigin(element, url, crossorigin) {
    void 0 !== crossorigin || url.startsWith("data:") ? !1 !== crossorigin && (element.crossOrigin = "string" === typeof crossorigin ? crossorigin : "anonymous") : element.crossOrigin = determineCrossOrigin(url);
  }
  function preloadVideo(element) {
    return new Promise((resolve, reject) => {
      function loaded() {
        cleanup();
        resolve();
      }
      function error(err) {
        cleanup();
        reject(err);
      }
      function cleanup() {
        element.removeEventListener("canplaythrough", loaded);
        element.removeEventListener("error", error);
      }
      element.addEventListener("canplaythrough", loaded);
      element.addEventListener("error", error);
      element.load();
    });
  }
  function determineCrossOrigin(url, loc = globalThis.location) {
    if (url.startsWith("data:")) {
      return "";
    }
    loc || (loc = globalThis.location);
    url = new URL(url, document.baseURI);
    return url.hostname !== loc.hostname || url.port !== loc.port || url.protocol !== loc.protocol ? "anonymous" : "";
  }
  global = require("module$node_modules$pixi_DOT_js$lib$extensions$Extensions");
  var VideoSource = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$texture$sources$VideoSource"), detectVideoAlphaMode = require("module$node_modules$pixi_DOT_js$lib$utils$browser$detectVideoAlphaMode"), getResolutionOfUrl = require("module$node_modules$pixi_DOT_js$lib$utils$network$getResolutionOfUrl"), checkDataUrl = require("module$node_modules$pixi_DOT_js$lib$assets$utils$checkDataUrl"), checkExtension = require("module$node_modules$pixi_DOT_js$lib$assets$utils$checkExtension"), 
  createTexture = require("module$node_modules$pixi_DOT_js$lib$assets$loader$parsers$textures$utils$createTexture");
  "use strict";
  const validVideoExtensions = ".mp4 .m4v .webm .ogg .ogv .h264 .avi .mov".split(" "), validVideoMIMEs = validVideoExtensions.map(ext => `video/${ext.substring(1)}`);
  require = {name:"loadVideo", extension:{type:global.ExtensionType.LoadParser, name:"loadVideo"}, test(url) {
    const isValidDataUrl = checkDataUrl.checkDataUrl(url, validVideoMIMEs);
    url = checkExtension.checkExtension(url, validVideoExtensions);
    return isValidDataUrl || url;
  }, async load(url, asset, loader) {
    const options = {...VideoSource.VideoSource.defaultOptions, resolution:asset.data?.resolution || getResolutionOfUrl.getResolutionOfUrl(url), alphaMode:asset.data?.alphaMode || await detectVideoAlphaMode.detectVideoAlphaMode(), ...asset.data}, videoElement = document.createElement("video"), attributeMap = {preload:!1 !== options.autoLoad ? "auto" : void 0, "webkit-playsinline":!1 !== options.playsinline ? "" : void 0, playsinline:!1 !== options.playsinline ? "" : void 0, muted:!0 === options.muted ? 
    "" : void 0, loop:!0 === options.loop ? "" : void 0, autoplay:!1 !== options.autoPlay ? "" : void 0};
    Object.keys(attributeMap).forEach(key => {
      const value = attributeMap[key];
      void 0 !== value && videoElement.setAttribute(key, value);
    });
    !0 === options.muted && (videoElement.muted = !0);
    crossOrigin(videoElement, url, options.crossorigin);
    const sourceElement = document.createElement("source");
    if (url.startsWith("data:")) {
      var mime = url.slice(5, url.indexOf(";"));
    } else {
      url.startsWith("blob:") || (mime = url.split("?")[0].slice(url.lastIndexOf(".") + 1).toLowerCase(), mime = VideoSource.VideoSource.MIME_TYPES[mime] || `video/${mime}`);
    }
    sourceElement.src = url;
    mime && (sourceElement.type = mime);
    return new Promise(resolve => {
      const onCanPlay = async() => {
        const base = new VideoSource.VideoSource({...options, resource:videoElement});
        videoElement.removeEventListener("canplay", onCanPlay);
        asset.data.preload && await preloadVideo(videoElement);
        resolve(createTexture.createTexture(base, loader, url));
      };
      videoElement.addEventListener("canplay", onCanPlay);
      videoElement.appendChild(sourceElement);
    });
  }, unload(texture) {
    texture.destroy(!0);
  }};
  exports.crossOrigin = crossOrigin;
  exports.determineCrossOrigin = determineCrossOrigin;
  exports.loadVideoTextures = require;
  exports.preloadVideo = preloadVideo;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$assets$loader$parsers$textures$loadVideoTextures.js.map
