shadow$provide.module$node_modules$pixi_DOT_js$lib$scene$graphics$shared$GraphicsPipe = function(global, require, module, exports) {
  global = require("module$node_modules$pixi_DOT_js$lib$extensions$Extensions");
  var State = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$state$State"), PoolGroup = require("module$node_modules$pixi_DOT_js$lib$utils$pool$PoolGroup"), colorToUniform = require("module$node_modules$pixi_DOT_js$lib$scene$graphics$gpu$colorToUniform"), BatchableGraphics = require("module$node_modules$pixi_DOT_js$lib$scene$graphics$shared$BatchableGraphics");
  "use strict";
  class GraphicsPipe {
    constructor(renderer, adaptor) {
      this.state = State.State.for2d();
      this._graphicsBatchesHash = Object.create(null);
      this._destroyRenderableBound = this.destroyRenderable.bind(this);
      this.renderer = renderer;
      this._adaptor = adaptor;
      this._adaptor.init();
      this.renderer.renderableGC.addManagedHash(this, "_graphicsBatchesHash");
    }
    validateRenderable(graphics) {
      const wasBatched = !!this._graphicsBatchesHash[graphics.uid];
      graphics = this.renderer.graphicsContext.updateGpuContext(graphics.context);
      return graphics.isBatchable || wasBatched !== graphics.isBatchable ? !0 : !1;
    }
    addRenderable(graphics, instructionSet) {
      const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);
      graphics.didViewUpdate && this._rebuild(graphics);
      gpuContext.isBatchable ? this._addToBatcher(graphics, instructionSet) : (this.renderer.renderPipes.batch.break(instructionSet), instructionSet.add(graphics));
    }
    updateRenderable(graphics) {
      if (graphics = this._graphicsBatchesHash[graphics.uid]) {
        for (let i = 0; i < graphics.length; i++) {
          const batch = graphics[i];
          batch._batcher.updateElement(batch);
        }
      }
    }
    destroyRenderable(graphics) {
      this._graphicsBatchesHash[graphics.uid] && this._removeBatchForRenderable(graphics.uid);
      graphics.off("destroyed", this._destroyRenderableBound);
    }
    execute(graphics) {
      if (graphics.isRenderable) {
        var renderer = this.renderer, context = graphics.context;
        renderer.graphicsContext.getGpuContext(context).batches.length && (context = context.customShader || this._adaptor.shader, this.state.blendMode = graphics.groupBlendMode, context = context.resources.localUniforms.uniforms, context.uTransformMatrix = graphics.groupTransform, context.uRound = renderer._roundPixels | graphics._roundPixels, colorToUniform.color32BitToUniform(graphics.groupColorAlpha, context.uColor, 0), this._adaptor.execute(this, graphics));
      }
    }
    _rebuild(graphics) {
      const wasBatched = !!this._graphicsBatchesHash[graphics.uid], gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);
      wasBatched && this._removeBatchForRenderable(graphics.uid);
      gpuContext.isBatchable && this._initBatchesForRenderable(graphics);
      graphics.batched = gpuContext.isBatchable;
    }
    _addToBatcher(graphics, instructionSet) {
      const batchPipe = this.renderer.renderPipes.batch;
      graphics = this._getBatchesForRenderable(graphics);
      for (let i = 0; i < graphics.length; i++) {
        batchPipe.addToBatch(graphics[i], instructionSet);
      }
    }
    _getBatchesForRenderable(graphics) {
      return this._graphicsBatchesHash[graphics.uid] || this._initBatchesForRenderable(graphics);
    }
    _initBatchesForRenderable(graphics) {
      var gpuContext = this.renderer.graphicsContext.getGpuContext(graphics.context);
      const roundPixels = this.renderer._roundPixels | graphics._roundPixels;
      gpuContext = gpuContext.batches.map(batch => {
        const batchClone = PoolGroup.BigPool.get(BatchableGraphics.BatchableGraphics);
        batch.copyTo(batchClone);
        batchClone.renderable = graphics;
        batchClone.roundPixels = roundPixels;
        return batchClone;
      });
      if (void 0 === this._graphicsBatchesHash[graphics.uid]) {
        graphics.on("destroyed", this._destroyRenderableBound);
      }
      return this._graphicsBatchesHash[graphics.uid] = gpuContext;
    }
    _removeBatchForRenderable(graphicsUid) {
      this._graphicsBatchesHash[graphicsUid].forEach(batch => {
        PoolGroup.BigPool.return(batch);
      });
      this._graphicsBatchesHash[graphicsUid] = null;
    }
    destroy() {
      this.renderer = null;
      this._adaptor.destroy();
      this.state = this._adaptor = null;
      for (const i in this._graphicsBatchesHash) {
        this._removeBatchForRenderable(i);
      }
      this._graphicsBatchesHash = null;
    }
  }
  GraphicsPipe.extension = {type:[global.ExtensionType.WebGLPipes, global.ExtensionType.WebGPUPipes, global.ExtensionType.CanvasPipes], name:"graphics"};
  exports.GraphicsPipe = GraphicsPipe;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$scene$graphics$shared$GraphicsPipe.js.map
