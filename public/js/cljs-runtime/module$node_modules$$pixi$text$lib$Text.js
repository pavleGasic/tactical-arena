shadow$provide.module$node_modules$$pixi$text$lib$Text = function(global, require, module, exports) {
  var core = require("module$node_modules$$pixi$core$lib$index"), sprite = require("module$node_modules$$pixi$sprite$lib$index"), _const = require("module$node_modules$$pixi$text$lib$const"), TextMetrics = require("module$node_modules$$pixi$text$lib$TextMetrics"), TextStyle = require("module$node_modules$$pixi$text$lib$TextStyle");
  const defaultDestroyOptions = {texture:!0, children:!1, baseTexture:!0};
  global = (() => {
    const node_modules$$pixi$text$lib$Text$classdecl$var22 = class extends sprite.Sprite {
      constructor(text, style, canvas) {
        let ownCanvas = !1;
        canvas || (canvas = core.settings.ADAPTER.createCanvas(), ownCanvas = !0);
        canvas.width = 3;
        canvas.height = 3;
        const texture = core.Texture.from(canvas);
        texture.orig = new core.Rectangle();
        texture.trim = new core.Rectangle();
        super(texture);
        this._ownCanvas = ownCanvas;
        this.canvas = canvas;
        this.context = canvas.getContext("2d", {willReadFrequently:!0});
        this._resolution = node_modules$$pixi$text$lib$Text$classdecl$var22.defaultResolution ?? core.settings.RESOLUTION;
        this._autoResolution = node_modules$$pixi$text$lib$Text$classdecl$var22.defaultAutoResolution;
        this._styleListener = this._style = this._text = null;
        this._font = "";
        this.text = text;
        this.style = style;
        this.localStyleID = -1;
      }
      static get experimentalLetterSpacing() {
        return TextMetrics.TextMetrics.experimentalLetterSpacing;
      }
      static set experimentalLetterSpacing(value) {
        core.utils.deprecation("7.1.0", "Text.experimentalLetterSpacing is deprecated, use TextMetrics.experimentalLetterSpacing");
        TextMetrics.TextMetrics.experimentalLetterSpacing = value;
      }
      updateText(respectDirty) {
        const style = this._style;
        if (this.localStyleID !== style.styleID && (this.dirty = !0, this.localStyleID = style.styleID), this.dirty || !respectDirty) {
          this._font = this._style.toFontString();
          respectDirty = this.context;
          var measured = TextMetrics.TextMetrics.measureText(this._text || " ", this._style, this._style.wordWrap, this.canvas), height = measured.height, lines = measured.lines, lineHeight = measured.lineHeight, lineWidths = measured.lineWidths, maxLineWidth = measured.maxLineWidth, fontProperties = measured.fontProperties;
          this.canvas.width = Math.ceil(Math.ceil(Math.max(1, measured.width) + 2 * style.padding) * this._resolution);
          this.canvas.height = Math.ceil(Math.ceil(Math.max(1, height) + 2 * style.padding) * this._resolution);
          respectDirty.scale(this._resolution, this._resolution);
          respectDirty.clearRect(0, 0, this.canvas.width, this.canvas.height);
          respectDirty.font = this._font;
          respectDirty.lineWidth = style.strokeThickness;
          respectDirty.textBaseline = style.textBaseline;
          respectDirty.lineJoin = style.lineJoin;
          respectDirty.miterLimit = style.miterLimit;
          var linePositionY, passesCount = style.dropShadow ? 2 : 1;
          for (let i = 0; i < passesCount; ++i) {
            const dsOffsetText = (linePositionY = style.dropShadow && 0 === i) ? Math.ceil(Math.max(1, height) + 2 * style.padding) : 0;
            var linePositionX = dsOffsetText * this._resolution;
            if (linePositionY) {
              respectDirty.fillStyle = "black";
              respectDirty.strokeStyle = "black";
              linePositionY = style.dropShadowBlur * this._resolution;
              var dropShadowDistance = style.dropShadowDistance * this._resolution;
              respectDirty.shadowColor = core.Color.shared.setValue(style.dropShadowColor).setAlpha(style.dropShadowAlpha).toRgbaString();
              respectDirty.shadowBlur = linePositionY;
              respectDirty.shadowOffsetX = Math.cos(style.dropShadowAngle) * dropShadowDistance;
              respectDirty.shadowOffsetY = Math.sin(style.dropShadowAngle) * dropShadowDistance + linePositionX;
            } else {
              respectDirty.fillStyle = this._generateFillStyle(style, lines, measured), respectDirty.strokeStyle = style.stroke, respectDirty.shadowColor = "black", respectDirty.shadowBlur = 0, respectDirty.shadowOffsetX = 0, respectDirty.shadowOffsetY = 0;
            }
            dropShadowDistance = (lineHeight - fontProperties.fontSize) / 2;
            0 > lineHeight - fontProperties.fontSize && (dropShadowDistance = 0);
            for (let i2 = 0; i2 < lines.length; i2++) {
              linePositionX = style.strokeThickness / 2, linePositionY = style.strokeThickness / 2 + i2 * lineHeight + fontProperties.ascent + dropShadowDistance, "right" === style.align ? linePositionX += maxLineWidth - lineWidths[i2] : "center" === style.align && (linePositionX += (maxLineWidth - lineWidths[i2]) / 2), style.stroke && style.strokeThickness && this.drawLetterSpacing(lines[i2], linePositionX + style.padding, linePositionY + style.padding - dsOffsetText, !0), style.fill && this.drawLetterSpacing(lines[i2], 
              linePositionX + style.padding, linePositionY + style.padding - dsOffsetText);
            }
          }
          this.updateTexture();
        }
      }
      drawLetterSpacing(text, x, y, isStroke = !1) {
        const letterSpacing = this._style.letterSpacing;
        var useExperimentalLetterSpacing = !1;
        if (TextMetrics.TextMetrics.experimentalLetterSpacingSupported && (TextMetrics.TextMetrics.experimentalLetterSpacing ? (this.context.letterSpacing = `${letterSpacing}px`, this.context.textLetterSpacing = `${letterSpacing}px`, useExperimentalLetterSpacing = !0) : (this.context.letterSpacing = "0px", this.context.textLetterSpacing = "0px")), 0 === letterSpacing || useExperimentalLetterSpacing) {
          isStroke ? this.context.strokeText(text, x, y) : this.context.fillText(text, x, y);
        } else {
          useExperimentalLetterSpacing = TextMetrics.TextMetrics.graphemeSegmenter(text);
          text = this.context.measureText(text).width;
          for (let i = 0; i < useExperimentalLetterSpacing.length; ++i) {
            var currentWidth = useExperimentalLetterSpacing[i];
            isStroke ? this.context.strokeText(currentWidth, x, y) : this.context.fillText(currentWidth, x, y);
            currentWidth = "";
            for (let j = i + 1; j < useExperimentalLetterSpacing.length; ++j) {
              currentWidth += useExperimentalLetterSpacing[j];
            }
            currentWidth = this.context.measureText(currentWidth).width;
            x += text - currentWidth + letterSpacing;
            text = currentWidth;
          }
        }
      }
      updateTexture() {
        const canvas = this.canvas;
        if (this._style.trim) {
          var trimmed = core.utils.trimCanvas(canvas);
          trimmed.data && (canvas.width = trimmed.width, canvas.height = trimmed.height, this.context.putImageData(trimmed.data, 0, 0));
        }
        trimmed = this._texture;
        var style = this._style;
        style = style.trim ? 0 : style.padding;
        const baseTexture = trimmed.baseTexture;
        trimmed.trim.width = trimmed._frame.width = canvas.width / this._resolution;
        trimmed.trim.height = trimmed._frame.height = canvas.height / this._resolution;
        trimmed.trim.x = -style;
        trimmed.trim.y = -style;
        trimmed.orig.width = trimmed._frame.width - 2 * style;
        trimmed.orig.height = trimmed._frame.height - 2 * style;
        this._onTextureUpdate();
        baseTexture.setRealSize(canvas.width, canvas.height, this._resolution);
        trimmed.updateUvs();
        this.dirty = !1;
      }
      _render(renderer) {
        this._autoResolution && this._resolution !== renderer.resolution && (this._resolution = renderer.resolution, this.dirty = !0);
        this.updateText(!0);
        super._render(renderer);
      }
      updateTransform() {
        this.updateText(!0);
        super.updateTransform();
      }
      getBounds(skipUpdate, rect) {
        return this.updateText(!0), -1 === this._textureID && (skipUpdate = !1), super.getBounds(skipUpdate, rect);
      }
      getLocalBounds(rect) {
        return this.updateText(!0), super.getLocalBounds.call(this, rect);
      }
      _calculateBounds() {
        this.calculateVertices();
        this._bounds.addQuad(this.vertexData);
      }
      _generateFillStyle(style, lines, metrics) {
        var fillStyle = style.fill;
        if (Array.isArray(fillStyle)) {
          if (1 === fillStyle.length) {
            return fillStyle[0];
          }
        } else {
          return fillStyle;
        }
        var dropShadowCorrection = style.dropShadow ? style.dropShadowDistance : 0, padding = style.padding || 0, width = this.canvas.width / this._resolution - dropShadowCorrection - 2 * padding, height = this.canvas.height / this._resolution - dropShadowCorrection - 2 * padding;
        dropShadowCorrection = fillStyle.slice();
        const fillGradientStops = style.fillGradientStops.slice();
        if (!fillGradientStops.length) {
          var lengthPlus1 = dropShadowCorrection.length + 1;
          for (var i = 1; i < lengthPlus1; ++i) {
            fillGradientStops.push(i / lengthPlus1);
          }
        }
        if (dropShadowCorrection.unshift(fillStyle[0]), fillGradientStops.unshift(0), dropShadowCorrection.push(fillStyle[fillStyle.length - 1]), fillGradientStops.push(1), style.fillGradientType === _const.TEXT_GRADIENT.LINEAR_VERTICAL) {
          fillStyle = this.context.createLinearGradient(width / 2, padding, width / 2, height + padding);
          var textHeight = metrics.fontProperties.fontSize + style.strokeThickness;
          for (style = 0; style < lines.length; style++) {
            for (width = metrics.lineHeight * (style - 1) + textHeight, padding = lengthPlus1 = metrics.lineHeight * style, 0 < style && width > lengthPlus1 && (padding = (lengthPlus1 + width) / 2), width = lengthPlus1 + textHeight, lengthPlus1 = metrics.lineHeight * (style + 1), i = width, style + 1 < lines.length && lengthPlus1 < width && (i = (width + lengthPlus1) / 2), width = (i - padding) / height, lengthPlus1 = 0; lengthPlus1 < dropShadowCorrection.length; lengthPlus1++) {
              i = 0, "number" == typeof fillGradientStops[lengthPlus1] ? i = fillGradientStops[lengthPlus1] : i = lengthPlus1 / dropShadowCorrection.length, i = Math.min(1, Math.max(0, padding / height + i * width)), i = Number(i.toFixed(5)), fillStyle.addColorStop(i, dropShadowCorrection[lengthPlus1]);
            }
          }
        } else {
          for (fillStyle = this.context.createLinearGradient(padding, height / 2, width + padding, height / 2), lines = dropShadowCorrection.length + 1, metrics = 1, height = 0; height < dropShadowCorrection.length; height++) {
            "number" == typeof fillGradientStops[height] ? textHeight = fillGradientStops[height] : textHeight = metrics / lines, fillStyle.addColorStop(textHeight, dropShadowCorrection[height]), metrics++;
          }
        }
        return fillStyle;
      }
      destroy(options) {
        "boolean" == typeof options && (options = {children:options});
        options = Object.assign({}, defaultDestroyOptions, options);
        super.destroy(options);
        this._ownCanvas && (this.canvas.height = this.canvas.width = 0);
        this._style = this.canvas = this.context = null;
      }
      get width() {
        return this.updateText(!0), Math.abs(this.scale.x) * this._texture.orig.width;
      }
      set width(value) {
        this.updateText(!0);
        const s = core.utils.sign(this.scale.x) || 1;
        this.scale.x = s * value / this._texture.orig.width;
        this._width = value;
      }
      get height() {
        return this.updateText(!0), Math.abs(this.scale.y) * this._texture.orig.height;
      }
      set height(value) {
        this.updateText(!0);
        const s = core.utils.sign(this.scale.y) || 1;
        this.scale.y = s * value / this._texture.orig.height;
        this._height = value;
      }
      get style() {
        return this._style;
      }
      set style(style) {
        style = style || {};
        style instanceof TextStyle.TextStyle ? this._style = style : this._style = new TextStyle.TextStyle(style);
        this.localStyleID = -1;
        this.dirty = !0;
      }
      get text() {
        return this._text;
      }
      set text(text) {
        text = String(text ?? "");
        this._text !== text && (this._text = text, this.dirty = !0);
      }
      get resolution() {
        return this._resolution;
      }
      set resolution(value) {
        this._autoResolution = !1;
        this._resolution !== value && (this._resolution = value, this.dirty = !0);
      }
    };
    return node_modules$$pixi$text$lib$Text$classdecl$var22;
  })();
  global.defaultAutoResolution = !0;
  exports.Text = global;
};

//# sourceMappingURL=module$node_modules$$pixi$text$lib$Text.js.map
