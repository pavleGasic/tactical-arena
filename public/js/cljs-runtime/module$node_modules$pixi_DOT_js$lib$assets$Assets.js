shadow$provide.module$node_modules$pixi_DOT_js$lib$assets$Assets = function(global, require, module, exports) {
  var Extensions = require("module$node_modules$pixi_DOT_js$lib$extensions$Extensions");
  global = require("module$node_modules$pixi_DOT_js$lib$scene$text_bitmap$asset$loadBitmapFont");
  var warn = require("module$node_modules$pixi_DOT_js$lib$utils$logging$warn"), BackgroundLoader = require("module$node_modules$pixi_DOT_js$lib$assets$BackgroundLoader"), Cache = require("module$node_modules$pixi_DOT_js$lib$assets$cache$Cache");
  module = require("module$node_modules$pixi_DOT_js$lib$assets$cache$parsers$cacheTextureArray");
  var detectAvif = require("module$node_modules$pixi_DOT_js$lib$assets$detections$parsers$detectAvif"), detectDefaults = require("module$node_modules$pixi_DOT_js$lib$assets$detections$parsers$detectDefaults"), detectMp4 = require("module$node_modules$pixi_DOT_js$lib$assets$detections$parsers$detectMp4"), detectOgv = require("module$node_modules$pixi_DOT_js$lib$assets$detections$parsers$detectOgv"), detectWebm = require("module$node_modules$pixi_DOT_js$lib$assets$detections$parsers$detectWebm"), detectWebp = 
  require("module$node_modules$pixi_DOT_js$lib$assets$detections$parsers$detectWebp"), Loader = require("module$node_modules$pixi_DOT_js$lib$assets$loader$Loader"), loadJson = require("module$node_modules$pixi_DOT_js$lib$assets$loader$parsers$loadJson"), loadTxt = require("module$node_modules$pixi_DOT_js$lib$assets$loader$parsers$loadTxt"), loadWebFont = require("module$node_modules$pixi_DOT_js$lib$assets$loader$parsers$loadWebFont"), loadSVG = require("module$node_modules$pixi_DOT_js$lib$assets$loader$parsers$textures$loadSVG"), 
  loadTextures = require("module$node_modules$pixi_DOT_js$lib$assets$loader$parsers$textures$loadTextures"), loadVideoTextures = require("module$node_modules$pixi_DOT_js$lib$assets$loader$parsers$textures$loadVideoTextures"), resolveJsonUrl = require("module$node_modules$pixi_DOT_js$lib$assets$resolver$parsers$resolveJsonUrl"), resolveTextureUrl = require("module$node_modules$pixi_DOT_js$lib$assets$resolver$parsers$resolveTextureUrl"), Resolver = require("module$node_modules$pixi_DOT_js$lib$assets$resolver$Resolver"), 
  convertToList = require("module$node_modules$pixi_DOT_js$lib$assets$utils$convertToList"), isSingleItem = require("module$node_modules$pixi_DOT_js$lib$assets$utils$isSingleItem");
  "use strict";
  class AssetsClass {
    constructor() {
      this._detections = [];
      this._initialized = !1;
      this.resolver = new Resolver.Resolver();
      this.loader = new Loader.Loader();
      this.cache = Cache.Cache;
      this._backgroundLoader = new BackgroundLoader.BackgroundLoader(this.loader);
      this._backgroundLoader.active = !0;
      this.reset();
    }
    async init(options = {}) {
      if (this._initialized) {
        warn.warn("[Assets]AssetManager already initialized, did you load before calling this Assets.init()?");
      } else {
        this._initialized = !0;
        options.defaultSearchParams && this.resolver.setDefaultSearchParams(options.defaultSearchParams);
        options.basePath && (this.resolver.basePath = options.basePath);
        options.bundleIdentifier && this.resolver.setBundleIdentifier(options.bundleIdentifier);
        if (options.manifest) {
          var manifest = options.manifest;
          "string" === typeof manifest && (manifest = await this.load(manifest));
          this.resolver.addManifest(manifest);
        }
        manifest = options.texturePreference?.resolution ?? 1;
        manifest = "number" === typeof manifest ? [manifest] : manifest;
        var formats = await this._detectFormats({preferredFormats:options.texturePreference?.format, skipDetections:options.skipDetections, detections:this._detections});
        this.resolver.prefer({params:{format:formats, resolution:manifest}});
        options.preferences && this.setPreferences(options.preferences);
      }
    }
    add(assets) {
      this.resolver.add(assets);
    }
    async load(urls, onProgress) {
      this._initialized || await this.init();
      const singleAsset = isSingleItem.isSingleItem(urls);
      urls = convertToList.convertToList(urls).map(url => {
        if ("string" !== typeof url) {
          const aliases = this.resolver.getAlias(url);
          aliases.some(alias => !this.resolver.hasKey(alias)) && this.add(url);
          return Array.isArray(aliases) ? aliases[0] : aliases;
        }
        this.resolver.hasKey(url) || this.add({alias:url, src:url});
        return url;
      });
      const resolveResults = this.resolver.resolve(urls);
      onProgress = await this._mapLoadToResolve(resolveResults, onProgress);
      return singleAsset ? onProgress[urls[0]] : onProgress;
    }
    addBundle(bundleId, assets) {
      this.resolver.addBundle(bundleId, assets);
    }
    async loadBundle(bundleIds, onProgress) {
      this._initialized || await this.init();
      let singleAsset = !1;
      "string" === typeof bundleIds && (singleAsset = !0, bundleIds = [bundleIds]);
      const resolveResults = this.resolver.resolveBundle(bundleIds), out = {};
      let count = 0, total = 0;
      const _onProgress = () => {
        onProgress?.(++count / total);
      }, promises = Object.keys(resolveResults).map(bundleId => {
        const resolveResult = resolveResults[bundleId];
        total += Object.keys(resolveResult).length;
        return this._mapLoadToResolve(resolveResult, _onProgress).then(resolveResult2 => {
          out[bundleId] = resolveResult2;
        });
      });
      await Promise.all(promises);
      return singleAsset ? out[bundleIds[0]] : out;
    }
    async backgroundLoad(urls) {
      this._initialized || await this.init();
      "string" === typeof urls && (urls = [urls]);
      urls = this.resolver.resolve(urls);
      this._backgroundLoader.add(Object.values(urls));
    }
    async backgroundLoadBundle(bundleIds) {
      this._initialized || await this.init();
      "string" === typeof bundleIds && (bundleIds = [bundleIds]);
      bundleIds = this.resolver.resolveBundle(bundleIds);
      Object.values(bundleIds).forEach(resolveResult => {
        this._backgroundLoader.add(Object.values(resolveResult));
      });
    }
    reset() {
      this.resolver.reset();
      this.loader.reset();
      this.cache.reset();
      this._initialized = !1;
    }
    get(keys) {
      if ("string" === typeof keys) {
        return Cache.Cache.get(keys);
      }
      const assets = {};
      for (let i = 0; i < keys.length; i++) {
        assets[i] = Cache.Cache.get(keys[i]);
      }
      return assets;
    }
    async _mapLoadToResolve(resolveResults, onProgress) {
      resolveResults = [...(new Set(Object.values(resolveResults)))];
      this._backgroundLoader.active = !1;
      const loadedAssets = await this.loader.load(resolveResults, onProgress);
      this._backgroundLoader.active = !0;
      const out = {};
      resolveResults.forEach(resolveResult => {
        const asset = loadedAssets[resolveResult.src], keys = [resolveResult.src];
        resolveResult.alias && keys.push(...resolveResult.alias);
        keys.forEach(key => {
          out[key] = asset;
        });
        Cache.Cache.set(keys, asset);
      });
      return out;
    }
    async unload(urls) {
      this._initialized || await this.init();
      urls = convertToList.convertToList(urls).map(url => "string" !== typeof url ? url.src : url);
      urls = this.resolver.resolve(urls);
      await this._unloadFromResolved(urls);
    }
    async unloadBundle(bundleIds) {
      this._initialized || await this.init();
      bundleIds = convertToList.convertToList(bundleIds);
      const resolveResults = this.resolver.resolveBundle(bundleIds);
      bundleIds = Object.keys(resolveResults).map(bundleId => this._unloadFromResolved(resolveResults[bundleId]));
      await Promise.all(bundleIds);
    }
    async _unloadFromResolved(resolveResult) {
      resolveResult = Object.values(resolveResult);
      resolveResult.forEach(resolveResult2 => {
        Cache.Cache.remove(resolveResult2.src);
      });
      await this.loader.unload(resolveResult);
    }
    async _detectFormats(options) {
      let formats = [];
      options.preferredFormats && (formats = Array.isArray(options.preferredFormats) ? options.preferredFormats : [options.preferredFormats]);
      for (const detection of options.detections) {
        options.skipDetections || await detection.test() ? formats = await detection.add(formats) : options.skipDetections || (formats = await detection.remove(formats));
      }
      return formats = formats.filter((format, index) => formats.indexOf(format) === index);
    }
    get detections() {
      return this._detections;
    }
    setPreferences(preferences) {
      this.loader.parsers.forEach(parser => {
        parser.config && Object.keys(parser.config).filter(key => key in preferences).forEach(key => {
          parser.config[key] = preferences[key];
        });
      });
    }
  }
  require = new AssetsClass();
  Extensions.extensions.handleByList(Extensions.ExtensionType.LoadParser, require.loader.parsers).handleByList(Extensions.ExtensionType.ResolveParser, require.resolver.parsers).handleByList(Extensions.ExtensionType.CacheParser, require.cache.parsers).handleByList(Extensions.ExtensionType.DetectionParser, require.detections);
  Extensions.extensions.add(module.cacheTextureArray, detectDefaults.detectDefaults, detectAvif.detectAvif, detectWebp.detectWebp, detectMp4.detectMp4, detectOgv.detectOgv, detectWebm.detectWebm, loadJson.loadJson, loadTxt.loadTxt, loadWebFont.loadWebFont, loadSVG.loadSvg, loadTextures.loadTextures, loadVideoTextures.loadVideoTextures, global.loadBitmapFont, global.bitmapFontCachePlugin, resolveTextureUrl.resolveTextureUrl, resolveJsonUrl.resolveJsonUrl);
  const assetKeyMap = {loader:Extensions.ExtensionType.LoadParser, resolver:Extensions.ExtensionType.ResolveParser, cache:Extensions.ExtensionType.CacheParser, detection:Extensions.ExtensionType.DetectionParser};
  Extensions.extensions.handle(Extensions.ExtensionType.Asset, extension => {
    const ref = extension.ref;
    Object.entries(assetKeyMap).filter(([key]) => !!ref[key]).forEach(([key, type]) => Extensions.extensions.add(Object.assign(ref[key], {extension:ref[key].extension ?? type})));
  }, extension => {
    const ref = extension.ref;
    Object.keys(assetKeyMap).filter(key => !!ref[key]).forEach(key => Extensions.extensions.remove(ref[key]));
  });
  exports.Assets = require;
  exports.AssetsClass = AssetsClass;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$assets$Assets.js.map
