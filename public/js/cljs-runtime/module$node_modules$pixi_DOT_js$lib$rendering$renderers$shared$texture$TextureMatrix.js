shadow$provide.module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$texture$TextureMatrix = function(global, require, module, exports) {
  var Matrix = require("module$node_modules$pixi_DOT_js$lib$maths$matrix$Matrix");
  "use strict";
  const tempMat = new Matrix.Matrix();
  class TextureMatrix {
    constructor(texture, clampMargin) {
      this.mapCoord = new Matrix.Matrix();
      this.uClampFrame = new Float32Array(4);
      this.uClampOffset = new Float32Array(2);
      this._textureID = -1;
      this.clampOffset = this._updateID = 0;
      this.clampMargin = "undefined" === typeof clampMargin ? 10 > texture.width ? 0 : 0.5 : clampMargin;
      this.isSimple = !1;
      this.texture = texture;
    }
    get texture() {
      return this._texture;
    }
    set texture(value) {
      this.texture !== value && (this._texture?.removeListener("update", this.update, this), this._texture = value, this._texture.addListener("update", this.update, this), this.update());
    }
    multiplyUvs(uvs, out) {
      void 0 === out && (out = uvs);
      const mat = this.mapCoord;
      for (let i = 0; i < uvs.length; i += 2) {
        const x = uvs[i], y = uvs[i + 1];
        out[i] = x * mat.a + y * mat.c + mat.tx;
        out[i + 1] = x * mat.b + y * mat.d + mat.ty;
      }
      return out;
    }
    update() {
      const tex = this._texture;
      this._updateID++;
      var uvs = tex.uvs;
      this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);
      uvs = tex.orig;
      var trim = tex.trim;
      trim && (tempMat.set(uvs.width / trim.width, 0, 0, uvs.height / trim.height, -trim.x / trim.width, -trim.y / trim.height), this.mapCoord.append(tempMat));
      uvs = tex.source;
      trim = this.uClampFrame;
      const margin = this.clampMargin / uvs._resolution, offset = this.clampOffset / uvs._resolution;
      trim[0] = (tex.frame.x + margin + offset) / uvs.width;
      trim[1] = (tex.frame.y + margin + offset) / uvs.height;
      trim[2] = (tex.frame.x + tex.frame.width - margin + offset) / uvs.width;
      trim[3] = (tex.frame.y + tex.frame.height - margin + offset) / uvs.height;
      this.uClampOffset[0] = this.clampOffset / uvs.pixelWidth;
      this.uClampOffset[1] = this.clampOffset / uvs.pixelHeight;
      this.isSimple = tex.frame.width === uvs.width && tex.frame.height === uvs.height && 0 === tex.rotate;
      return !0;
    }
  }
  exports.TextureMatrix = TextureMatrix;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$texture$TextureMatrix.js.map
