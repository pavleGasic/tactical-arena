shadow$provide.module$node_modules$pixi_DOT_js$lib$scene$particle_container$shared$shader$particles_vert = function(global, require, module, exports) {
  Object.defineProperty(exports, "__esModule", {value:!0});
  exports.default = "attribute vec2 aVertex;\nattribute vec2 aUV;\nattribute vec4 aColor;\n\nattribute vec2 aPosition;\nattribute float aRotation;\n\nuniform mat3 uTranslationMatrix;\nuniform float uRound;\nuniform vec2 uResolution;\nuniform vec4 uColor;\n\nvarying vec2 vUV;\nvarying vec4 vColor;\n\nvec2 roundPixels(vec2 position, vec2 targetSize)\n{       \n    return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n}\n\nvoid main(void){\n    float cosRotation \x3d cos(aRotation);\n    float sinRotation \x3d sin(aRotation);\n    float x \x3d aVertex.x * cosRotation - aVertex.y * sinRotation;\n    float y \x3d aVertex.x * sinRotation + aVertex.y * cosRotation;\n\n    vec2 v \x3d vec2(x, y);\n    v \x3d v + aPosition;\n\n    gl_Position \x3d vec4((uTranslationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\n\n    if(uRound \x3d\x3d 1.0)\n    {\n        gl_Position.xy \x3d roundPixels(gl_Position.xy, uResolution);\n    }\n\n    vUV \x3d aUV;\n    vColor \x3d vec4(aColor.rgb * aColor.a, aColor.a) * uColor;\n}\n";
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$scene$particle_container$shared$shader$particles_vert.js.map
