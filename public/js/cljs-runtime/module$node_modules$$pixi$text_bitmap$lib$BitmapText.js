shadow$provide.module$node_modules$$pixi$text_bitmap$lib$BitmapText = function(global, require, module, exports) {
  var core = require("module$node_modules$$pixi$core$lib$index"), display = require("module$node_modules$$pixi$display$lib$index"), mesh = require("module$node_modules$$pixi$mesh$lib$index"), BitmapFont = require("module$node_modules$$pixi$text_bitmap$lib$BitmapFont"), msdf$1 = require("module$node_modules$$pixi$text_bitmap$lib$shader$msdf_frag"), msdf = require("module$node_modules$$pixi$text_bitmap$lib$shader$msdf_vert");
  require("module$node_modules$$pixi$text_bitmap$lib$utils$index");
  var splitTextToCharacters = require("module$node_modules$$pixi$text_bitmap$lib$utils$splitTextToCharacters"), extractCharCode = require("module$node_modules$$pixi$text_bitmap$lib$utils$extractCharCode");
  const pageMeshDataDefaultPageMeshData = [], pageMeshDataMSDFPageMeshData = [], charRenderDataPool = [];
  global = (() => {
    const node_modules$$pixi$text_bitmap$lib$BitmapText$classdecl$var26 = class extends display.Container {
      constructor(text, style = {}) {
        super();
        const {align, tint, maxWidth, letterSpacing, fontName, fontSize} = Object.assign({}, node_modules$$pixi$text_bitmap$lib$BitmapText$classdecl$var26.styleDefaults, style);
        if (!BitmapFont.BitmapFont.available[fontName]) {
          throw Error(`Missing BitmapFont "${fontName}"`);
        }
        this._activePagesMeshData = [];
        this._textHeight = this._textWidth = 0;
        this._align = align;
        this._tintColor = new core.Color(tint);
        this._font = void 0;
        this._fontName = fontName;
        this._fontSize = fontSize;
        this.text = text;
        this._maxWidth = maxWidth;
        this._maxLineHeight = 0;
        this._letterSpacing = letterSpacing;
        this._anchor = new core.ObservablePoint(() => {
          this.dirty = !0;
        }, this, 0, 0);
        this._roundPixels = core.settings.ROUND_PIXELS;
        this.dirty = !0;
        this._resolution = core.settings.RESOLUTION;
        this._autoResolution = !0;
        this._textureCache = {};
      }
      updateText() {
        const data = BitmapFont.BitmapFont.available[this._fontName];
        var fontSize = this.fontSize, scale = fontSize / data.size, pos = new core.Point();
        const chars = [];
        var lineWidths = [], lineSpaces = [], text = this._text.replace(/(?:\r\n|\r)/g, "\n") || " ", charsInput = splitTextToCharacters.splitTextToCharacters(text), maxWidth = this._maxWidth * data.size / fontSize, pageMeshDataPool = "none" === data.distanceFieldType ? pageMeshDataDefaultPageMeshData : pageMeshDataMSDFPageMeshData;
        let prevCharCode = null;
        var lastLineWidth = 0, line = text = 0, lastBreakPos = -1, lastBreakWidth = 0, spacesRemoved = 0, spaceCount = fontSize = 0;
        for (let i = 0; i < charsInput.length; i++) {
          var char = charsInput[i];
          const charCode = extractCharCode.extractCharCode(char);
          if (/(?:\s)/.test(char) && (lastBreakPos = i, lastBreakWidth = lastLineWidth, spaceCount++), "\r" === char || "\n" === char) {
            lineWidths.push(lastLineWidth), lineSpaces.push(-1), text = Math.max(text, lastLineWidth), ++line, ++spacesRemoved, pos.x = 0, pos.y += data.lineHeight, prevCharCode = null, spaceCount = 0;
          } else {
            if (char = data.chars[charCode]) {
              prevCharCode && char.kerning[prevCharCode] && (pos.x += char.kerning[prevCharCode]), lastLineWidth = charRenderDataPool.pop() || {texture:core.Texture.EMPTY, line:0, charCode:0, prevSpaces:0, position:new core.Point()}, lastLineWidth.texture = char.texture, lastLineWidth.line = line, lastLineWidth.charCode = charCode, lastLineWidth.position.x = Math.round(pos.x + char.xOffset + this._letterSpacing / 2), lastLineWidth.position.y = Math.round(pos.y + char.yOffset), lastLineWidth.prevSpaces = 
              spaceCount, chars.push(lastLineWidth), lastLineWidth = lastLineWidth.position.x + Math.max(char.xAdvance - char.xOffset, char.texture.orig.width), pos.x += char.xAdvance + this._letterSpacing, fontSize = Math.max(fontSize, char.yOffset + char.texture.height), prevCharCode = charCode, -1 !== lastBreakPos && 0 < maxWidth && pos.x > maxWidth && (++spacesRemoved, core.utils.removeItems(chars, 1 + lastBreakPos - spacesRemoved, 1 + i - lastBreakPos), i = lastBreakPos, lastBreakPos = -1, lineWidths.push(lastBreakWidth), 
              lineSpaces.push(0 < chars.length ? chars[chars.length - 1].prevSpaces : 0), text = Math.max(text, lastBreakWidth), line++, pos.x = 0, pos.y += data.lineHeight, prevCharCode = null, spaceCount = 0);
            }
          }
        }
        charsInput = charsInput[charsInput.length - 1];
        "\r" !== charsInput && "\n" !== charsInput && (/(?:\s)/.test(charsInput) && (lastLineWidth = lastBreakWidth), lineWidths.push(lastLineWidth), text = Math.max(text, lastLineWidth), lineSpaces.push(-1));
        charsInput = [];
        for (lastBreakWidth = 0; lastBreakWidth <= line; lastBreakWidth++) {
          maxWidth = 0, "right" === this._align ? maxWidth = text - lineWidths[lastBreakWidth] : "center" === this._align ? maxWidth = (text - lineWidths[lastBreakWidth]) / 2 : "justify" === this._align && (maxWidth = 0 > lineSpaces[lastBreakWidth] ? 0 : (text - lineWidths[lastBreakWidth]) / lineSpaces[lastBreakWidth]), charsInput.push(maxWidth);
        }
        lineSpaces = chars.length;
        lineWidths = {};
        line = [];
        lastBreakWidth = this._activePagesMeshData;
        pageMeshDataPool.push(...lastBreakWidth);
        for (maxWidth = 0; maxWidth < lineSpaces; maxWidth++) {
          lastLineWidth = chars[maxWidth].texture;
          lastBreakPos = lastLineWidth.baseTexture.uid;
          if (!lineWidths[lastBreakPos]) {
            spacesRemoved = pageMeshDataPool.pop();
            if (!spacesRemoved) {
              spacesRemoved = new mesh.MeshGeometry();
              var material = void 0, meshBlendMode = void 0;
              "none" === data.distanceFieldType ? (material = new mesh.MeshMaterial(core.Texture.EMPTY), meshBlendMode = core.BLEND_MODES.NORMAL) : (material = new mesh.MeshMaterial(core.Texture.EMPTY, {program:core.Program.from(msdf.default, msdf$1.default), uniforms:{uFWidth:0}}), meshBlendMode = core.BLEND_MODES.NORMAL_NPM);
              spacesRemoved = new mesh.Mesh(spacesRemoved, material);
              spacesRemoved.blendMode = meshBlendMode;
              spacesRemoved = {index:0, indexCount:0, vertexCount:0, uvsCount:0, total:0, mesh:spacesRemoved, vertices:null, uvs:null, indices:null};
            }
            spacesRemoved.index = 0;
            spacesRemoved.indexCount = 0;
            spacesRemoved.vertexCount = 0;
            spacesRemoved.uvsCount = 0;
            spacesRemoved.total = 0;
            ({_textureCache:spaceCount} = this);
            spaceCount[lastBreakPos] = spaceCount[lastBreakPos] || new core.Texture(lastLineWidth.baseTexture);
            spacesRemoved.mesh.texture = spaceCount[lastBreakPos];
            spacesRemoved.mesh.tint = this._tintColor.value;
            line.push(spacesRemoved);
            lineWidths[lastBreakPos] = spacesRemoved;
          }
          lineWidths[lastBreakPos].total++;
        }
        for (material = 0; material < lastBreakWidth.length; material++) {
          line.includes(lastBreakWidth[material]) || this.removeChild(lastBreakWidth[material].mesh);
        }
        for (material = 0; material < line.length; material++) {
          line[material].mesh.parent !== this && this.addChild(line[material].mesh);
        }
        this._activePagesMeshData = line;
        for (var i$jscomp$0 in lineWidths) {
          material = lineWidths[i$jscomp$0];
          meshBlendMode = material.total;
          if (!(material.indices?.length > 6 * meshBlendMode) || material.vertices.length < 2 * mesh.Mesh.BATCHABLE_SIZE) {
            material.vertices = new Float32Array(8 * meshBlendMode), material.uvs = new Float32Array(8 * meshBlendMode), material.indices = new Uint16Array(6 * meshBlendMode);
          } else {
            for (line = material.total, pageMeshDataPool = material.vertices, line *= 8; line < pageMeshDataPool.length; line++) {
              pageMeshDataPool[line] = 0;
            }
          }
          material.mesh.size = 6 * meshBlendMode;
        }
        for (i$jscomp$0 = 0; i$jscomp$0 < lineSpaces; i$jscomp$0++) {
          pageMeshDataPool = chars[i$jscomp$0], material = pageMeshDataPool.position.x + charsInput[pageMeshDataPool.line] * ("justify" === this._align ? pageMeshDataPool.prevSpaces : 1), this._roundPixels && (material = Math.round(material)), material *= scale, meshBlendMode = pageMeshDataPool.position.y * scale, lastBreakWidth = pageMeshDataPool.texture, pageMeshDataPool = lineWidths[lastBreakWidth.baseTexture.uid], line = lastBreakWidth.frame, lastBreakWidth = lastBreakWidth._uvs, maxWidth = pageMeshDataPool.index++, 
          pageMeshDataPool.indices[6 * maxWidth] = 4 * maxWidth, pageMeshDataPool.indices[6 * maxWidth + 1] = 1 + 4 * maxWidth, pageMeshDataPool.indices[6 * maxWidth + 2] = 2 + 4 * maxWidth, pageMeshDataPool.indices[6 * maxWidth + 3] = 4 * maxWidth, pageMeshDataPool.indices[6 * maxWidth + 4] = 2 + 4 * maxWidth, pageMeshDataPool.indices[6 * maxWidth + 5] = 3 + 4 * maxWidth, pageMeshDataPool.vertices[8 * maxWidth] = material, pageMeshDataPool.vertices[8 * maxWidth + 1] = meshBlendMode, pageMeshDataPool.vertices[8 * 
          maxWidth + 2] = material + line.width * scale, pageMeshDataPool.vertices[8 * maxWidth + 3] = meshBlendMode, pageMeshDataPool.vertices[8 * maxWidth + 4] = material + line.width * scale, pageMeshDataPool.vertices[8 * maxWidth + 5] = meshBlendMode + line.height * scale, pageMeshDataPool.vertices[8 * maxWidth + 6] = material, pageMeshDataPool.vertices[8 * maxWidth + 7] = meshBlendMode + line.height * scale, pageMeshDataPool.uvs[8 * maxWidth] = lastBreakWidth.x0, pageMeshDataPool.uvs[8 * maxWidth + 
          1] = lastBreakWidth.y0, pageMeshDataPool.uvs[8 * maxWidth + 2] = lastBreakWidth.x1, pageMeshDataPool.uvs[8 * maxWidth + 3] = lastBreakWidth.y1, pageMeshDataPool.uvs[8 * maxWidth + 4] = lastBreakWidth.x2, pageMeshDataPool.uvs[8 * maxWidth + 5] = lastBreakWidth.y2, pageMeshDataPool.uvs[8 * maxWidth + 6] = lastBreakWidth.x3, pageMeshDataPool.uvs[8 * maxWidth + 7] = lastBreakWidth.y3;
        }
        this._textWidth = text * scale;
        this._textHeight = (pos.y + data.lineHeight) * scale;
        for (const i in lineWidths) {
          pos = lineWidths[i];
          if (0 !== this.anchor.x || 0 !== this.anchor.y) {
            for (text = 0, i$jscomp$0 = this._textWidth * this.anchor.x, charsInput = this._textHeight * this.anchor.y, material = 0; material < pos.total; material++) {
              pos.vertices[text++] -= i$jscomp$0, pos.vertices[text++] -= charsInput, pos.vertices[text++] -= i$jscomp$0, pos.vertices[text++] -= charsInput, pos.vertices[text++] -= i$jscomp$0, pos.vertices[text++] -= charsInput, pos.vertices[text++] -= i$jscomp$0, pos.vertices[text++] -= charsInput;
            }
          }
          this._maxLineHeight = fontSize * scale;
          text = pos.mesh.geometry.getBuffer("aVertexPosition");
          i$jscomp$0 = pos.mesh.geometry.getBuffer("aTextureCoord");
          charsInput = pos.mesh.geometry.getIndex();
          text.data = pos.vertices;
          i$jscomp$0.data = pos.uvs;
          charsInput.data = pos.indices;
          text.update();
          i$jscomp$0.update();
          charsInput.update();
        }
        for (scale = 0; scale < chars.length; scale++) {
          charRenderDataPool.push(chars[scale]);
        }
        this._font = data;
        this.dirty = !1;
      }
      updateTransform() {
        this.validate();
        this.containerUpdateTransform();
      }
      _render(renderer) {
        this._autoResolution && this._resolution !== renderer.resolution && (this._resolution = renderer.resolution, this.dirty = !0);
        const {distanceFieldRange, distanceFieldType, size} = BitmapFont.BitmapFont.available[this._fontName];
        if ("none" !== distanceFieldType) {
          const {a, b, c, d} = this.worldTransform, worldScale = (Math.abs(Math.sqrt(a * a + b * b)) + Math.abs(Math.sqrt(c * c + d * d))) / 2, fontScale = this.fontSize / size, resolution = renderer._view.resolution;
          for (const mesh2 of this._activePagesMeshData) {
            mesh2.mesh.shader.uniforms.uFWidth = worldScale * distanceFieldRange * fontScale * resolution;
          }
        }
        super._render(renderer);
      }
      getLocalBounds() {
        return this.validate(), super.getLocalBounds();
      }
      validate() {
        const font = BitmapFont.BitmapFont.available[this._fontName];
        if (!font) {
          throw Error(`Missing BitmapFont "${this._fontName}"`);
        }
        this._font !== font && (this.dirty = !0);
        this.dirty && this.updateText();
      }
      get tint() {
        return this._tintColor.value;
      }
      set tint(value) {
        if (this.tint !== value) {
          this._tintColor.setValue(value);
          for (let i = 0; i < this._activePagesMeshData.length; i++) {
            this._activePagesMeshData[i].mesh.tint = value;
          }
        }
      }
      get align() {
        return this._align;
      }
      set align(value) {
        this._align !== value && (this._align = value, this.dirty = !0);
      }
      get fontName() {
        return this._fontName;
      }
      set fontName(value) {
        if (!BitmapFont.BitmapFont.available[value]) {
          throw Error(`Missing BitmapFont "${value}"`);
        }
        this._fontName !== value && (this._fontName = value, this.dirty = !0);
      }
      get fontSize() {
        return this._fontSize ?? BitmapFont.BitmapFont.available[this._fontName].size;
      }
      set fontSize(value) {
        this._fontSize !== value && (this._fontSize = value, this.dirty = !0);
      }
      get anchor() {
        return this._anchor;
      }
      set anchor(value) {
        "number" == typeof value ? this._anchor.set(value) : this._anchor.copyFrom(value);
      }
      get text() {
        return this._text;
      }
      set text(text) {
        text = String(text ?? "");
        this._text !== text && (this._text = text, this.dirty = !0);
      }
      get maxWidth() {
        return this._maxWidth;
      }
      set maxWidth(value) {
        this._maxWidth !== value && (this._maxWidth = value, this.dirty = !0);
      }
      get maxLineHeight() {
        return this.validate(), this._maxLineHeight;
      }
      get textWidth() {
        return this.validate(), this._textWidth;
      }
      get letterSpacing() {
        return this._letterSpacing;
      }
      set letterSpacing(value) {
        this._letterSpacing !== value && (this._letterSpacing = value, this.dirty = !0);
      }
      get roundPixels() {
        return this._roundPixels;
      }
      set roundPixels(value) {
        value !== this._roundPixels && (this._roundPixels = value, this.dirty = !0);
      }
      get textHeight() {
        return this.validate(), this._textHeight;
      }
      get resolution() {
        return this._resolution;
      }
      set resolution(value) {
        this._autoResolution = !1;
        this._resolution !== value && (this._resolution = value, this.dirty = !0);
      }
      destroy(options) {
        const {_textureCache} = this, pageMeshDataPool = "none" === BitmapFont.BitmapFont.available[this._fontName].distanceFieldType ? pageMeshDataDefaultPageMeshData : pageMeshDataMSDFPageMeshData;
        pageMeshDataPool.push(...this._activePagesMeshData);
        for (const pageMeshData of this._activePagesMeshData) {
          this.removeChild(pageMeshData.mesh);
        }
        this._activePagesMeshData = [];
        pageMeshDataPool.filter(page => _textureCache[page.mesh.texture.baseTexture.uid]).forEach(page => {
          page.mesh.texture = core.Texture.EMPTY;
        });
        for (const id in _textureCache) {
          _textureCache[id].destroy(), delete _textureCache[id];
        }
        this._textureCache = this._tintColor = this._font = null;
        super.destroy(options);
      }
    };
    return node_modules$$pixi$text_bitmap$lib$BitmapText$classdecl$var26;
  })();
  global.styleDefaults = {align:"left", tint:16777215, maxWidth:0, letterSpacing:0};
  exports.BitmapText = global;
};

//# sourceMappingURL=module$node_modules$$pixi$text_bitmap$lib$BitmapText.js.map
