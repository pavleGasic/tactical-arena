shadow$provide.module$node_modules$pixi_DOT_js$lib$scene$graphics$shared$utils$buildGeometryFromPath = function(global, require, module, exports) {
  var buildUvs = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$geometry$utils$buildUvs"), transformVertices = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$geometry$utils$transformVertices"), MeshGeometry = require("module$node_modules$pixi_DOT_js$lib$scene$mesh$shared$MeshGeometry");
  global = require("module$node_modules$pixi_DOT_js$lib$scene$graphics$shared$buildCommands$buildCircle");
  module = require("module$node_modules$pixi_DOT_js$lib$scene$graphics$shared$buildCommands$buildPolygon");
  var buildRectangle = require("module$node_modules$pixi_DOT_js$lib$scene$graphics$shared$buildCommands$buildRectangle"), buildTriangle = require("module$node_modules$pixi_DOT_js$lib$scene$graphics$shared$buildCommands$buildTriangle"), GraphicsPath = require("module$node_modules$pixi_DOT_js$lib$scene$graphics$shared$path$GraphicsPath");
  "use strict";
  const buildMap = {rectangle:buildRectangle.buildRectangle, polygon:module.buildPolygon, triangle:buildTriangle.buildTriangle, circle:global.buildCircle, ellipse:global.buildCircle, roundedRectangle:global.buildCircle};
  exports.buildGeometryFromPath = function(options) {
    options instanceof GraphicsPath.GraphicsPath && (options = {path:options, textureMatrix:null, out:null});
    const vertices = [], uvs = [], indices = [], textureMatrix = options.textureMatrix;
    options.path.shapePath.shapePrimitives.forEach(({shape, transform:matrix}) => {
      const indexOffset = indices.length, vertOffset = vertices.length / 2, points = [], build = buildMap[shape.type];
      build.build(shape, points);
      matrix && transformVertices.transformVertices(points, matrix);
      build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);
      shape = uvs.length / 2;
      textureMatrix ? (matrix && textureMatrix.append(matrix.clone().invert()), buildUvs.buildUvs(vertices, 2, vertOffset, uvs, shape, 2, vertices.length / 2 - vertOffset, textureMatrix)) : buildUvs.buildSimpleUvs(uvs, shape, 2, vertices.length / 2 - vertOffset);
    });
    return (options = options.out) ? (options.positions = new Float32Array(vertices), options.uvs = new Float32Array(uvs), options.indices = new Uint32Array(indices), options) : new MeshGeometry.MeshGeometry({positions:new Float32Array(vertices), uvs:new Float32Array(uvs), indices:new Uint32Array(indices)});
  };
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$scene$graphics$shared$utils$buildGeometryFromPath.js.map
