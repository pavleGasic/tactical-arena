shadow$provide.module$node_modules$$pixi$core$lib$geometry$Geometry = function(global, require, module, exports) {
  var constants = require("module$node_modules$$pixi$constants$lib$index"), runner = require("module$node_modules$$pixi$runner$lib$index"), utils = require("module$node_modules$$pixi$utils$lib$index"), Attribute = require("module$node_modules$$pixi$core$lib$geometry$Attribute"), Buffer = require("module$node_modules$$pixi$core$lib$geometry$Buffer"), interleaveTypedArrays = require("module$node_modules$$pixi$core$lib$geometry$utils$interleaveTypedArrays");
  const byteSizeMap = {5126:4, 5123:2, 5121:1};
  let UID = 0;
  const map = {Float32Array, Uint32Array, Int32Array, Uint8Array, Uint16Array};
  class Geometry {
    constructor(buffers = [], attributes = {}) {
      this.buffers = buffers;
      this.indexBuffer = null;
      this.attributes = attributes;
      this.glVertexArrayObjects = {};
      this.id = UID++;
      this.instanced = !1;
      this.instanceCount = 1;
      this.disposeRunner = new runner.Runner("disposeGeometry");
      this.refCount = 0;
    }
    addAttribute(id, buffer, size = 0, normalized = !1, type, stride, start, instance = !1) {
      if (!buffer) {
        throw Error("You must pass a buffer when creating an attribute");
      }
      buffer instanceof Buffer.Buffer || (buffer instanceof Array && (buffer = new Float32Array(buffer)), buffer = new Buffer.Buffer(buffer));
      var ids = id.split("|");
      if (1 < ids.length) {
        for (id = 0; id < ids.length; id++) {
          this.addAttribute(ids[id], buffer, size, normalized, type);
        }
        return this;
      }
      ids = this.buffers.indexOf(buffer);
      return -1 === ids && (this.buffers.push(buffer), ids = this.buffers.length - 1), this.attributes[id] = new Attribute.Attribute(ids, size, normalized, type, stride, start, instance), this.instanced = this.instanced || instance, this;
    }
    getAttribute(id) {
      return this.attributes[id];
    }
    getBuffer(id) {
      return this.buffers[this.getAttribute(id).buffer];
    }
    addIndex(buffer) {
      return buffer instanceof Buffer.Buffer || (buffer instanceof Array && (buffer = new Uint16Array(buffer)), buffer = new Buffer.Buffer(buffer)), buffer.type = constants.BUFFER_TYPE.ELEMENT_ARRAY_BUFFER, this.indexBuffer = buffer, this.buffers.includes(buffer) || this.buffers.push(buffer), this;
    }
    getIndex() {
      return this.indexBuffer;
    }
    interleave() {
      if (1 === this.buffers.length || 2 === this.buffers.length && this.indexBuffer) {
        return this;
      }
      const arrays = [], sizes = [], interleavedBuffer = new Buffer.Buffer();
      let i;
      for (i in this.attributes) {
        const attribute = this.attributes[i];
        arrays.push(this.buffers[attribute.buffer].data);
        sizes.push(attribute.size * byteSizeMap[attribute.type] / 4);
        attribute.buffer = 0;
      }
      interleavedBuffer.data = interleaveTypedArrays.interleaveTypedArrays(arrays, sizes);
      for (i = 0; i < this.buffers.length; i++) {
        this.buffers[i] !== this.indexBuffer && this.buffers[i].destroy();
      }
      return this.buffers = [interleavedBuffer], this.indexBuffer && this.buffers.push(this.indexBuffer), this;
    }
    getSize() {
      for (var i in this.attributes) {
        return i = this.attributes[i], this.buffers[i.buffer].data.length / (i.stride / 4 || i.size);
      }
      return 0;
    }
    dispose() {
      this.disposeRunner.emit(this, !1);
    }
    destroy() {
      this.dispose();
      this.attributes = this.indexBuffer = this.buffers = null;
    }
    clone() {
      const geometry = new Geometry();
      for (var i$jscomp$0 = 0; i$jscomp$0 < this.buffers.length; i$jscomp$0++) {
        geometry.buffers[i$jscomp$0] = new Buffer.Buffer(this.buffers[i$jscomp$0].data.slice(0));
      }
      for (const i in this.attributes) {
        i$jscomp$0 = this.attributes[i], geometry.attributes[i] = new Attribute.Attribute(i$jscomp$0.buffer, i$jscomp$0.size, i$jscomp$0.normalized, i$jscomp$0.type, i$jscomp$0.stride, i$jscomp$0.start, i$jscomp$0.instance);
      }
      return this.indexBuffer && (geometry.indexBuffer = geometry.buffers[this.buffers.indexOf(this.indexBuffer)], geometry.indexBuffer.type = constants.BUFFER_TYPE.ELEMENT_ARRAY_BUFFER), geometry;
    }
    static merge(geometries) {
      const geometryOut = new Geometry();
      var arrays = [], sizes = [], offsets = [];
      for (var i = 0; i < geometries.length; i++) {
        var geometry = geometries[i];
        for (var j = 0; j < geometry.buffers.length; j++) {
          sizes[j] = sizes[j] || 0, sizes[j] += geometry.buffers[j].data.length, offsets[j] = 0;
        }
      }
      for (i = 0; i < geometry.buffers.length; i++) {
        arrays[i] = new (map[utils.getBufferType(geometry.buffers[i].data)])(sizes[i]), geometryOut.buffers[i] = new Buffer.Buffer(arrays[i]);
      }
      for (sizes = 0; sizes < geometries.length; sizes++) {
        for (geometry = geometries[sizes], i = 0; i < geometry.buffers.length; i++) {
          arrays[i].set(geometry.buffers[i].data, offsets[i]), offsets[i] += geometry.buffers[i].data.length;
        }
      }
      if (geometryOut.attributes = geometry.attributes, geometry.indexBuffer) {
        geometryOut.indexBuffer = geometryOut.buffers[geometry.buffers.indexOf(geometry.indexBuffer)];
        geometryOut.indexBuffer.type = constants.BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
        i = sizes = offsets = arrays = 0;
        for (j = 0; j < geometry.buffers.length; j++) {
          if (geometry.buffers[j] !== geometry.indexBuffer) {
            i = j;
            break;
          }
        }
        for (var i$jscomp$0 in geometry.attributes) {
          j = geometry.attributes[i$jscomp$0], (j.buffer | 0) === i && (offsets += j.size * byteSizeMap[j.type] / 4);
        }
        for (geometry = 0; geometry < geometries.length; geometry++) {
          i$jscomp$0 = geometries[geometry].indexBuffer.data;
          for (j = 0; j < i$jscomp$0.length; j++) {
            geometryOut.indexBuffer.data[j + sizes] += arrays;
          }
          arrays += geometries[geometry].buffers[i].data.length / offsets;
          sizes += i$jscomp$0.length;
        }
      }
      return geometryOut;
    }
  }
  exports.Geometry = Geometry;
};

//# sourceMappingURL=module$node_modules$$pixi$core$lib$geometry$Geometry.js.map
