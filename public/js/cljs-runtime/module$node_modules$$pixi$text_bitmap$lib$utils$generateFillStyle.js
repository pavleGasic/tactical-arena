shadow$provide.module$node_modules$$pixi$text_bitmap$lib$utils$generateFillStyle = function(global, require, module, exports) {
  var text = require("module$node_modules$$pixi$text$lib$index");
  exports.generateFillStyle = function(canvas, context, style, resolution, lines, metrics) {
    var fillStyle = style.fill;
    if (Array.isArray(fillStyle)) {
      if (1 === fillStyle.length) {
        return fillStyle[0];
      }
    } else {
      return fillStyle;
    }
    var dropShadowCorrection = style.dropShadow ? style.dropShadowDistance : 0, padding = style.padding || 0, width = canvas.width / resolution - dropShadowCorrection - 2 * padding;
    dropShadowCorrection = canvas.height / resolution - dropShadowCorrection - 2 * padding;
    canvas = fillStyle.slice();
    resolution = style.fillGradientStops.slice();
    if (!resolution.length) {
      var lengthPlus1 = canvas.length + 1;
      for (let i = 1; i < lengthPlus1; ++i) {
        resolution.push(i / lengthPlus1);
      }
    }
    if (canvas.unshift(fillStyle[0]), resolution.unshift(0), canvas.push(fillStyle[fillStyle.length - 1]), resolution.push(1), style.fillGradientType === text.TEXT_GRADIENT.LINEAR_VERTICAL) {
      context = context.createLinearGradient(width / 2, padding, width / 2, dropShadowCorrection + padding);
      var lastIterationStop = 0;
      style = (metrics.fontProperties.fontSize + style.strokeThickness) / dropShadowCorrection;
      for (fillStyle = 0; fillStyle < lines.length; fillStyle++) {
        for (padding = metrics.lineHeight * fillStyle, width = 0; width < canvas.length; width++) {
          lengthPlus1 = 0, "number" == typeof resolution[width] ? lengthPlus1 = resolution[width] : lengthPlus1 = width / canvas.length, lastIterationStop = Math.max(lastIterationStop, padding / dropShadowCorrection + lengthPlus1 * style), lastIterationStop = Math.min(lastIterationStop, 1), context.addColorStop(lastIterationStop, canvas[width]);
        }
      }
    } else {
      for (context = context.createLinearGradient(padding, dropShadowCorrection / 2, width + padding, dropShadowCorrection / 2), lines = canvas.length + 1, metrics = 1, dropShadowCorrection = 0; dropShadowCorrection < canvas.length; dropShadowCorrection++) {
        "number" == typeof resolution[dropShadowCorrection] ? lastIterationStop = resolution[dropShadowCorrection] : lastIterationStop = metrics / lines, context.addColorStop(lastIterationStop, canvas[dropShadowCorrection]), metrics++;
      }
    }
    return context;
  };
};

//# sourceMappingURL=module$node_modules$$pixi$text_bitmap$lib$utils$generateFillStyle.js.map
