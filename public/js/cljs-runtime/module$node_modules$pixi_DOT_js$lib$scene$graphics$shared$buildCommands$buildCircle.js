shadow$provide.module$node_modules$pixi_DOT_js$lib$scene$graphics$shared$buildCommands$buildCircle = function(global, require, module, exports) {
  global = require("module$node_modules$pixi_DOT_js$lib$extensions$Extensions");
  "use strict";
  global = {extension:{type:global.ExtensionType.ShapeBuilder, name:"circle"}, build(shape, points) {
    let y;
    let dy, rx;
    if ("circle" === shape.type) {
      var x = shape.x;
      y = shape.y;
      rx = shape = shape.radius;
      var dx = dy = 0;
    } else if ("ellipse" === shape.type) {
      x = shape.x, y = shape.y, rx = shape.halfWidth, shape = shape.halfHeight, dx = dy = 0;
    } else {
      dx = shape.width / 2;
      var halfHeight = shape.height / 2;
      x = shape.x + dx;
      y = shape.y + halfHeight;
      rx = shape = Math.max(0, Math.min(shape.radius, Math.min(dx, halfHeight)));
      dx -= rx;
      dy = halfHeight - shape;
    }
    if (!(0 <= rx && 0 <= shape && 0 <= dx && 0 <= dy)) {
      return points;
    }
    const n = Math.ceil(2.3 * Math.sqrt(rx + shape));
    var m = 8 * n + (dx ? 4 : 0) + (dy ? 4 : 0);
    if (0 === m) {
      return points;
    }
    if (0 === n) {
      return points[0] = points[6] = x + dx, points[1] = points[3] = y + dy, points[2] = points[4] = x - dx, points[5] = points[7] = y - dy, points;
    }
    halfHeight = 0;
    let j2 = 4 * n + (dx ? 2 : 0) + 2, j3 = j2;
    var x0 = dx + rx, y0 = dy, x1 = x + x0;
    x0 = x - x0;
    var y1 = y + y0;
    points[halfHeight++] = x1;
    points[halfHeight++] = y1;
    points[--j2] = y1;
    points[--j2] = x0;
    dy && (y0 = y - y0, points[j3++] = x0, points[j3++] = y0, points[--m] = y0, points[--m] = x1);
    for (x1 = 1; x1 < n; x1++) {
      x0 = Math.PI / 2 * (x1 / n);
      y1 = dx + Math.cos(x0) * rx;
      y0 = dy + Math.sin(x0) * shape;
      x0 = x + y1;
      y1 = x - y1;
      const y12 = y + y0;
      y0 = y - y0;
      points[halfHeight++] = x0;
      points[halfHeight++] = y12;
      points[--j2] = y12;
      points[--j2] = y1;
      points[j3++] = y1;
      points[j3++] = y0;
      points[--m] = y0;
      points[--m] = x0;
    }
    x0 = dx;
    y0 = dy + shape;
    x1 = x + x0;
    x0 = x - x0;
    y1 = y + y0;
    x = y - y0;
    points[halfHeight++] = x1;
    points[halfHeight++] = y1;
    points[--m] = x;
    points[--m] = x1;
    dx && (points[halfHeight++] = x0, points[halfHeight++] = y1, points[--m] = x, points[--m] = x0);
    return points;
  }, triangulate(points, vertices, verticesStride, verticesOffset, indices, indicesOffset) {
    if (0 !== points.length) {
      var centerX = 0, centerY = 0;
      for (let i = 0; i < points.length; i += 2) {
        centerX += points[i], centerY += points[i + 1];
      }
      centerX /= points.length / 2;
      centerY /= points.length / 2;
      vertices[verticesOffset * verticesStride] = centerX;
      vertices[verticesOffset * verticesStride + 1] = centerY;
      centerX = verticesOffset++;
      for (centerY = 0; centerY < points.length; centerY += 2) {
        vertices[verticesOffset * verticesStride] = points[centerY], vertices[verticesOffset * verticesStride + 1] = points[centerY + 1], 0 < centerY && (indices[indicesOffset++] = verticesOffset, indices[indicesOffset++] = centerX, indices[indicesOffset++] = verticesOffset - 1), verticesOffset++;
      }
      indices[indicesOffset++] = centerX + 1;
      indices[indicesOffset++] = centerX;
      indices[indicesOffset++] = verticesOffset - 1;
    }
  }};
  require = {...global, extension:{...global.extension, name:"ellipse"}};
  module = {...global, extension:{...global.extension, name:"roundedRectangle"}};
  exports.buildCircle = global;
  exports.buildEllipse = require;
  exports.buildRoundedRectangle = module;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$scene$graphics$shared$buildCommands$buildCircle.js.map
