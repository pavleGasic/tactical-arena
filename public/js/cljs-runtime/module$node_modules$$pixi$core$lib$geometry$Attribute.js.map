{
"version":3,
"file":"module$node_modules$$pixi$core$lib$geometry$Attribute.js",
"lineCount":23,
"mappings":"AAAAA,cAAA,CAAA,qDAAA,GAA0E,QAAQ,CAACC,MAAD,EAAQC,OAAR,EAAgBC,MAAhB,EAAuBC,OAAvB,CAAgC;AAElH,MAAIC,YAAYH,OAAA,CAAQ,+CAAR,CAAhB;AACA,OAAMI,UAAN;AAWEC,eAAW,CAACC,MAAD,EAASC,IAAA,GAAO,CAAhB,EAAmBC,UAAA,GAAa,CAAA,CAAhC,EAAoCC,IAAA,GAAON,SAAUO,CAAAA,KAAMC,CAAAA,KAA3D,EAAkEC,MAAlE,EAA0EC,KAA1E,EAAiFC,QAAjF,EAA2FC,OAAA,GAAU,CAArG,CAAwG;AACjH,UAAKT,CAAAA,MAAL,GAAcA,MAAd;AAAsB,UAAKC,CAAAA,IAAL,GAAYA,IAAZ;AAAkB,UAAKC,CAAAA,UAAL,GAAkBA,UAAlB;AAA8B,UAAKC,CAAAA,IAAL,GAAYA,IAAZ;AAAkB,UAAKG,CAAAA,MAAL,GAAcA,MAAd;AAAsB,UAAKC,CAAAA,KAAL,GAAaA,KAAb;AAAoB,UAAKC,CAAAA,QAAL,GAAgBA,QAAhB;AAA0B,UAAKC,CAAAA,OAAL,GAAeA,OAAf;AAD3C;AAInHC,WAAO,EAAG;AACR,UAAKV,CAAAA,MAAL,GAAc,IAAd;AADQ;AAYHW,eAAI,CAACX,MAAD,EAASC,IAAT,EAAeC,UAAf,EAA2BC,IAA3B,EAAiCG,MAAjC,CAAyC;AAClD,aAAO,IAAIR,SAAJ,CAAcE,MAAd,EAAsBC,IAAtB,EAA4BC,UAA5B,EAAwCC,IAAxC,EAA8CG,MAA9C,CAAP;AADkD;AA3BtD;AA+BAV,SAAQE,CAAAA,SAAR,GAAoBA,SAApB;AAlCkH,CAAlH;;",
"sources":["node_modules/@pixi/core/lib/geometry/Attribute.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$$pixi$core$lib$geometry$Attribute\"] = function(global,require,module,exports) {\n\"use strict\";\nvar constants = require(\"@pixi/constants\");\nclass Attribute {\n  /**\n   * @param buffer - the id of the buffer that this attribute will look for\n   * @param size - the size of the attribute. If you have 2 floats per vertex (eg position x and y) this would be 2.\n   * @param normalized - should the data be normalized.\n   * @param {PIXI.TYPES} [type=PIXI.TYPES.FLOAT] - what type of number is the attribute. Check {@link PIXI.TYPES} to see the ones available\n   * @param [stride=0] - How far apart, in bytes, the start of each value is. (used for interleaving data)\n   * @param [start=0] - How far into the array to start reading values (used for interleaving data)\n   * @param [instance=false] - Whether the geometry is instanced.\n   * @param [divisor=1] - Divisor to use when doing instanced rendering\n   */\n  constructor(buffer, size = 0, normalized = !1, type = constants.TYPES.FLOAT, stride, start, instance, divisor = 1) {\n    this.buffer = buffer, this.size = size, this.normalized = normalized, this.type = type, this.stride = stride, this.start = start, this.instance = instance, this.divisor = divisor;\n  }\n  /** Destroys the Attribute. */\n  destroy() {\n    this.buffer = null;\n  }\n  /**\n   * Helper function that creates an Attribute based on the information provided\n   * @param buffer - the id of the buffer that this attribute will look for\n   * @param [size=0] - the size of the attribute. If you have 2 floats per vertex (eg position x and y) this would be 2\n   * @param [normalized=false] - should the data be normalized.\n   * @param [type=PIXI.TYPES.FLOAT] - what type of number is the attribute. Check {@link PIXI.TYPES} to see the ones available\n   * @param [stride=0] - How far apart, in bytes, the start of each value is. (used for interleaving data)\n   * @returns - A new {@link PIXI.Attribute} based on the information provided\n   */\n  static from(buffer, size, normalized, type, stride) {\n    return new Attribute(buffer, size, normalized, type, stride);\n  }\n}\nexports.Attribute = Attribute;\n//# sourceMappingURL=Attribute.js.map\n\n};"],
"names":["shadow$provide","global","require","module","exports","constants","Attribute","constructor","buffer","size","normalized","type","TYPES","FLOAT","stride","start","instance","divisor","destroy","from"]
}
