shadow$provide.module$node_modules$pixi_DOT_js$lib$scene$mesh$shared$MeshGeometry = function(global, require, module, exports) {
  var Buffer = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$buffer$Buffer"), _const = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$buffer$const");
  global = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$geometry$Geometry");
  var deprecation = require("module$node_modules$pixi_DOT_js$lib$utils$logging$deprecation");
  "use strict";
  const node_modules$pixi_DOT_js$lib$scene$mesh$shared$MeshGeometry$classdecl$var19 = class extends global.Geometry {
    constructor(...args) {
      let options = args[0] ?? {};
      options instanceof Float32Array && (deprecation.deprecation(deprecation.v8_0_0, "use new MeshGeometry({ positions, uvs, indices }) instead"), options = {positions:options, uvs:args[1], indices:args[2]});
      options = {...node_modules$pixi_DOT_js$lib$scene$mesh$shared$MeshGeometry$classdecl$var19.defaultOptions, ...options};
      var positions = options.positions || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]), uvs = options.uvs;
      uvs || (uvs = options.positions ? new Float32Array(positions.length) : new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]));
      args = options.indices || new Uint32Array([0, 1, 2, 0, 2, 3]);
      const shrinkToFit = options.shrinkBuffersToFit;
      positions = new Buffer.Buffer({data:positions, label:"attribute-mesh-positions", shrinkToFit, usage:_const.BufferUsage.VERTEX | _const.BufferUsage.COPY_DST});
      uvs = new Buffer.Buffer({data:uvs, label:"attribute-mesh-uvs", shrinkToFit, usage:_const.BufferUsage.VERTEX | _const.BufferUsage.COPY_DST});
      args = new Buffer.Buffer({data:args, label:"index-mesh-buffer", shrinkToFit, usage:_const.BufferUsage.INDEX | _const.BufferUsage.COPY_DST});
      super({attributes:{aPosition:{buffer:positions, format:"float32x2", stride:8, offset:0}, aUV:{buffer:uvs, format:"float32x2", stride:8, offset:0}}, indexBuffer:args, topology:options.topology});
      this.batchMode = "auto";
    }
    get positions() {
      return this.attributes.aPosition.buffer.data;
    }
    set positions(value) {
      this.attributes.aPosition.buffer.data = value;
    }
    get uvs() {
      return this.attributes.aUV.buffer.data;
    }
    set uvs(value) {
      this.attributes.aUV.buffer.data = value;
    }
    get indices() {
      return this.indexBuffer.data;
    }
    set indices(value) {
      this.indexBuffer.data = value;
    }
  };
  require = node_modules$pixi_DOT_js$lib$scene$mesh$shared$MeshGeometry$classdecl$var19;
  require.defaultOptions = {topology:"triangle-list", shrinkBuffersToFit:!1};
  exports.MeshGeometry = require;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$scene$mesh$shared$MeshGeometry.js.map
