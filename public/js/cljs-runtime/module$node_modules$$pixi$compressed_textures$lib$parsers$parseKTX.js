shadow$provide.module$node_modules$$pixi$compressed_textures$lib$parsers$parseKTX = function(global, require, module, exports) {
  function validate(url, dataView) {
    for (let i = 0; i < FILE_IDENTIFIER.length; i++) {
      if (dataView.getUint8(i) !== FILE_IDENTIFIER[i]) {
        return console.error(`${url} is not a valid *.ktx file!`), !1;
      }
    }
    return !0;
  }
  function convertFormatToInteger(format) {
    switch(format) {
      case core.FORMATS.RGBA:
        return core.FORMATS.RGBA_INTEGER;
      case core.FORMATS.RGB:
        return core.FORMATS.RGB_INTEGER;
      case core.FORMATS.RG:
        return core.FORMATS.RG_INTEGER;
      case core.FORMATS.RED:
        return core.FORMATS.RED_INTEGER;
      default:
        return format;
    }
  }
  function parseKvData(dataView, bytesOfKeyValueData, littleEndian) {
    const kvData = new Map();
    let bytesIntoKeyValueData = 0;
    for (; bytesIntoKeyValueData < bytesOfKeyValueData;) {
      const keyAndValueByteSize = dataView.getUint32(64 + bytesIntoKeyValueData, littleEndian);
      var keyAndValueByteOffset = 64 + bytesIntoKeyValueData + 4;
      const valuePadding = 3 - (keyAndValueByteSize + 3) % 4;
      if (0 === keyAndValueByteSize || keyAndValueByteSize > bytesOfKeyValueData - bytesIntoKeyValueData) {
        console.error("KTXLoader: keyAndValueByteSize out of bounds");
        break;
      }
      let keyNulByte = 0;
      for (; keyNulByte < keyAndValueByteSize && 0 !== dataView.getUint8(keyAndValueByteOffset + keyNulByte); keyNulByte++) {
      }
      if (-1 === keyNulByte) {
        console.error("KTXLoader: Failed to find null byte terminating kvData key");
        break;
      }
      const key = (new TextDecoder()).decode(new Uint8Array(dataView.buffer, keyAndValueByteOffset, keyNulByte));
      keyAndValueByteOffset = new DataView(dataView.buffer, keyAndValueByteOffset + keyNulByte + 1, keyAndValueByteSize - keyNulByte - 1);
      kvData.set(key, keyAndValueByteOffset);
      bytesIntoKeyValueData += 4 + keyAndValueByteSize + valuePadding;
    }
    return kvData;
  }
  var core = require("module$node_modules$$pixi$core$lib$index"), _const = require("module$node_modules$$pixi$compressed_textures$lib$const");
  require("module$node_modules$$pixi$compressed_textures$lib$resources$index");
  var CompressedTextureResource = require("module$node_modules$$pixi$compressed_textures$lib$resources$CompressedTextureResource");
  const FILE_IDENTIFIER = [171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10], TYPES_TO_BYTES_PER_COMPONENT = {[core.TYPES.UNSIGNED_BYTE]:1, [core.TYPES.UNSIGNED_SHORT]:2, [core.TYPES.INT]:4, [core.TYPES.UNSIGNED_INT]:4, [core.TYPES.FLOAT]:4, [core.TYPES.HALF_FLOAT]:8}, FORMATS_TO_COMPONENTS = {[core.FORMATS.RGBA]:4, [core.FORMATS.RGB]:3, [core.FORMATS.RG]:2, [core.FORMATS.RED]:1, [core.FORMATS.LUMINANCE]:1, [core.FORMATS.LUMINANCE_ALPHA]:2, [core.FORMATS.ALPHA]:1}, TYPES_TO_BYTES_PER_PIXEL = {[core.TYPES.UNSIGNED_SHORT_4_4_4_4]:2, 
  [core.TYPES.UNSIGNED_SHORT_5_5_5_1]:2, [core.TYPES.UNSIGNED_SHORT_5_6_5]:2};
  exports.FORMATS_TO_COMPONENTS = FORMATS_TO_COMPONENTS;
  exports.TYPES_TO_BYTES_PER_COMPONENT = TYPES_TO_BYTES_PER_COMPONENT;
  exports.TYPES_TO_BYTES_PER_PIXEL = TYPES_TO_BYTES_PER_PIXEL;
  exports.parseKTX = function(url, arrayBuffer, loadKeyValueData = !1) {
    const dataView = new DataView(arrayBuffer);
    if (!validate(url, dataView)) {
      return null;
    }
    url = 67305985 === dataView.getUint32(12, !0);
    const glType = dataView.getUint32(16, url), glFormat = dataView.getUint32(24, url), glInternalFormat = dataView.getUint32(28, url), pixelWidth = dataView.getUint32(36, url), pixelHeight = dataView.getUint32(40, url) || 1;
    var pixelDepth = dataView.getUint32(44, url) || 1;
    const numberOfArrayElements = dataView.getUint32(48, url) || 1;
    var numberOfFaces = dataView.getUint32(52, url);
    const numberOfMipmapLevels = dataView.getUint32(56, url);
    var bytesOfKeyValueData = dataView.getUint32(60, url);
    if (0 === pixelHeight || 1 !== pixelDepth) {
      throw Error("Only 2D textures are supported");
    }
    if (1 !== numberOfFaces) {
      throw Error("CubeTextures are not supported by KTXLoader yet!");
    }
    if (1 !== numberOfArrayElements) {
      throw Error("WebGL does not support array textures");
    }
    var alignedWidth = pixelWidth + 3 & -4, alignedHeight = pixelHeight + 3 & -4;
    pixelDepth = Array(numberOfArrayElements);
    numberOfFaces = pixelWidth * pixelHeight;
    0 === glType && (numberOfFaces = alignedWidth * alignedHeight);
    let imagePixelByteSize;
    if (0 !== glType ? TYPES_TO_BYTES_PER_COMPONENT[glType] ? imagePixelByteSize = TYPES_TO_BYTES_PER_COMPONENT[glType] * FORMATS_TO_COMPONENTS[glFormat] : imagePixelByteSize = TYPES_TO_BYTES_PER_PIXEL[glType] : imagePixelByteSize = _const.INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[glInternalFormat], void 0 === imagePixelByteSize) {
      throw Error("Unable to resolve the pixel format stored in the *.ktx file!");
    }
    loadKeyValueData = loadKeyValueData ? parseKvData(dataView, bytesOfKeyValueData, url) : null;
    numberOfFaces *= imagePixelByteSize;
    let mipWidth = pixelWidth, mipHeight = pixelHeight;
    bytesOfKeyValueData = 64 + bytesOfKeyValueData;
    for (let mipmapLevel = 0; mipmapLevel < numberOfMipmapLevels; mipmapLevel++) {
      const imageSize = dataView.getUint32(bytesOfKeyValueData, url);
      let elementOffset = bytesOfKeyValueData + 4;
      for (let arrayElement = 0; arrayElement < numberOfArrayElements; arrayElement++) {
        let mips = pixelDepth[arrayElement];
        mips || (mips = pixelDepth[arrayElement] = Array(numberOfMipmapLevels));
        mips[mipmapLevel] = {levelID:mipmapLevel, levelWidth:1 < numberOfMipmapLevels || 0 !== glType ? mipWidth : alignedWidth, levelHeight:1 < numberOfMipmapLevels || 0 !== glType ? mipHeight : alignedHeight, levelBuffer:new Uint8Array(arrayBuffer, elementOffset, numberOfFaces)};
        elementOffset += numberOfFaces;
      }
      bytesOfKeyValueData += imageSize + 4;
      bytesOfKeyValueData = 0 !== bytesOfKeyValueData % 4 ? bytesOfKeyValueData + 4 - bytesOfKeyValueData % 4 : bytesOfKeyValueData;
      mipWidth = mipWidth >> 1 || 1;
      mipHeight = mipHeight >> 1 || 1;
      alignedWidth = mipWidth + 4 - 1 & -4;
      alignedHeight = mipHeight + 4 - 1 & -4;
      numberOfFaces = alignedWidth * alignedHeight * imagePixelByteSize;
    }
    return 0 !== glType ? {uncompressed:pixelDepth.map(levelBuffers => {
      let buffer = levelBuffers[0].levelBuffer, convertToInt = !1;
      return glType === core.TYPES.FLOAT ? buffer = new Float32Array(levelBuffers[0].levelBuffer.buffer, levelBuffers[0].levelBuffer.byteOffset, levelBuffers[0].levelBuffer.byteLength / 4) : glType === core.TYPES.UNSIGNED_INT ? (convertToInt = !0, buffer = new Uint32Array(levelBuffers[0].levelBuffer.buffer, levelBuffers[0].levelBuffer.byteOffset, levelBuffers[0].levelBuffer.byteLength / 4)) : glType === core.TYPES.INT && (convertToInt = !0, buffer = new Int32Array(levelBuffers[0].levelBuffer.buffer, 
      levelBuffers[0].levelBuffer.byteOffset, levelBuffers[0].levelBuffer.byteLength / 4)), {resource:new core.BufferResource(buffer, {width:levelBuffers[0].levelWidth, height:levelBuffers[0].levelHeight}), type:glType, format:convertToInt ? convertFormatToInteger(glFormat) : glFormat};
    }), kvData:loadKeyValueData} : {compressed:pixelDepth.map(levelBuffers => new CompressedTextureResource.CompressedTextureResource(null, {format:glInternalFormat, width:pixelWidth, height:pixelHeight, levels:numberOfMipmapLevels, levelBuffers})), kvData:loadKeyValueData};
  };
};

//# sourceMappingURL=module$node_modules$$pixi$compressed_textures$lib$parsers$parseKTX.js.map
