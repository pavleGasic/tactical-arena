shadow$provide.module$node_modules$pixi_DOT_js$lib$scene$graphics$shared$buildCommands$buildAdaptiveQuadratic = function(global, require, module, exports) {
  function recursive(points, x1, y1, x2, y2, x3, y3, distanceTolerance, level) {
    if (!(8 < level)) {
      var x12 = (x1 + x2) / 2, y12 = (y1 + y2) / 2, x23 = (x2 + x3) / 2, y23 = (y2 + y3) / 2, x123 = (x12 + x23) / 2, y123 = (y12 + y23) / 2, dx = x3 - x1, dy = y3 - y1;
      x2 = Math.abs((x2 - x3) * dy - (y2 - y3) * dx);
      if (11920929e-14 < x2) {
        if (x2 * x2 <= distanceTolerance * (dx * dx + dy * dy)) {
          points.push(x123, y123);
          return;
        }
      } else {
        if (dx = x123 - (x1 + x3) / 2, dy = y123 - (y1 + y3) / 2, dx * dx + dy * dy <= distanceTolerance) {
          points.push(x123, y123);
          return;
        }
      }
      recursive(points, x1, y1, x12, y12, x123, y123, distanceTolerance, level + 1);
      recursive(points, x123, y123, x23, y23, x3, y3, distanceTolerance, level + 1);
    }
  }
  var GraphicsContextSystem = require("module$node_modules$pixi_DOT_js$lib$scene$graphics$shared$GraphicsContextSystem");
  "use strict";
  exports.buildAdaptiveQuadratic = function(points, sX, sY, cp1x, cp1y, eX, eY, smoothness) {
    smoothness = 1 - Math.min(0.99, Math.max(0, smoothness ?? GraphicsContextSystem.GraphicsContextSystem.defaultOptions.bezierSmoothness));
    recursive(points, sX, sY, cp1x, cp1y, eX, eY, smoothness * smoothness, 0);
    points.push(eX, eY);
    return points;
  };
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$scene$graphics$shared$buildCommands$buildAdaptiveQuadratic.js.map
