shadow$provide.module$node_modules$pixi_DOT_js$lib$scene$particle_container$shared$shader$particles_wgsl = function(global, require, module, exports) {
  Object.defineProperty(exports, "__esModule", {value:!0});
  exports.default = "\nstruct ParticleUniforms {\n  uProjectionMatrix:mat3x3\x3cf32\x3e,\n  uColor:vec4\x3cf32\x3e,\n  uResolution:vec2\x3cf32\x3e,\n  uRoundPixels:f32,\n};\n\n@group(0) @binding(0) var\x3cuniform\x3e uniforms: ParticleUniforms;\n\n@group(1) @binding(0) var uTexture: texture_2d\x3cf32\x3e;\n@group(1) @binding(1) var uSampler : sampler;\n\nstruct VSOutput {\n    @builtin(position) position: vec4\x3cf32\x3e,\n    @location(0) uv : vec2\x3cf32\x3e,\n    @location(1) color : vec4\x3cf32\x3e,\n  };\n@vertex\nfn mainVertex(\n  @location(0) aVertex: vec2\x3cf32\x3e,\n  @location(1) aPosition: vec2\x3cf32\x3e,\n  @location(2) aUV: vec2\x3cf32\x3e,\n  @location(3) aColor: vec4\x3cf32\x3e,\n  @location(4) aRotation: f32,\n) -\x3e VSOutput {\n  \n   let v \x3d vec2(\n       aVertex.x * cos(aRotation) - aVertex.y * sin(aRotation),\n       aVertex.x * sin(aRotation) + aVertex.y * cos(aRotation)\n   ) + aPosition;\n\n   let position \x3d vec4((uniforms.uProjectionMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\n\n    let vColor \x3d vec4(aColor.rgb * aColor.a, aColor.a) * uniforms.uColor;\n\n  return VSOutput(\n   position,\n   aUV,\n   vColor,\n  );\n}\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2\x3cf32\x3e,\n  @location(1) color: vec4\x3cf32\x3e,\n  @builtin(position) position: vec4\x3cf32\x3e,\n) -\x3e @location(0) vec4\x3cf32\x3e {\n\n    var sample \x3d textureSample(uTexture, uSampler, uv) * color;\n   \n    return sample;\n}";
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$scene$particle_container$shared$shader$particles_wgsl.js.map
