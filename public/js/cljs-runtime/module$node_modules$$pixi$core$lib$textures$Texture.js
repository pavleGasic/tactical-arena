shadow$provide.module$node_modules$$pixi$core$lib$textures$Texture = function(global, require, module, exports) {
  function removeAllHandlers(tex) {
    tex.destroy = function() {
    };
    tex.on = function() {
    };
    tex.once = function() {
    };
    tex.emit = function() {
    };
  }
  var math = require("module$node_modules$$pixi$math$lib$index"), settings = require("module$node_modules$$pixi$settings$lib$index"), utils = require("module$node_modules$$pixi$utils$lib$index"), BaseTexture = require("module$node_modules$$pixi$core$lib$textures$BaseTexture"), ImageResource = require("module$node_modules$$pixi$core$lib$textures$resources$ImageResource"), TextureUvs = require("module$node_modules$$pixi$core$lib$textures$TextureUvs");
  const DEFAULT_UVS = new TextureUvs.TextureUvs();
  class Texture extends utils.EventEmitter {
    constructor(baseTexture, frame, orig, trim, rotate, anchor, borders) {
      if (super(), this.noFrame = !1, frame || (this.noFrame = !0, frame = new math.Rectangle(0, 0, 1, 1)), baseTexture instanceof Texture && (baseTexture = baseTexture.baseTexture), this.baseTexture = baseTexture, this._frame = frame, this.trim = trim, this.valid = !1, this.destroyed = !1, this._uvs = DEFAULT_UVS, this.uvMatrix = null, this.orig = orig || frame, this._rotate = Number(rotate || 0), !0 === rotate) {
        this._rotate = 2;
      } else if (0 !== this._rotate % 2) {
        throw Error("attempt to use diamond-shaped UVs. If you are sure, set rotation manually");
      }
      this.defaultAnchor = anchor ? new math.Point(anchor.x, anchor.y) : new math.Point(0, 0);
      this.defaultBorders = borders;
      this._updateID = 0;
      this.textureCacheIds = [];
      baseTexture.valid ? this.noFrame ? baseTexture.valid && this.onBaseTextureUpdated(baseTexture) : this.frame = frame : baseTexture.once("loaded", this.onBaseTextureUpdated, this);
      this.noFrame && baseTexture.on("update", this.onBaseTextureUpdated, this);
    }
    update() {
      this.baseTexture.resource && this.baseTexture.resource.update();
    }
    onBaseTextureUpdated(baseTexture) {
      if (this.noFrame) {
        if (!this.baseTexture.valid) {
          return;
        }
        this._frame.width = baseTexture.width;
        this._frame.height = baseTexture.height;
        this.valid = !0;
        this.updateUvs();
      } else {
        this.frame = this._frame;
      }
      this.emit("update", this);
    }
    destroy(destroyBase) {
      this.baseTexture && (destroyBase && ({resource:destroyBase} = this.baseTexture, destroyBase?.url && utils.TextureCache[destroyBase.url] && Texture.removeFromCache(destroyBase.url), this.baseTexture.destroy()), this.baseTexture.off("loaded", this.onBaseTextureUpdated, this), this.baseTexture.off("update", this.onBaseTextureUpdated, this), this.baseTexture = null);
      this.orig = this.trim = this._uvs = this._frame = null;
      this.valid = !1;
      Texture.removeFromCache(this);
      this.textureCacheIds = null;
      this.destroyed = !0;
      this.emit("destroyed", this);
      this.removeAllListeners();
    }
    clone() {
      const clonedFrame = this._frame.clone();
      var clonedOrig = this._frame === this.orig ? clonedFrame : this.orig.clone();
      clonedOrig = new Texture(this.baseTexture, !this.noFrame && clonedFrame, clonedOrig, this.trim?.clone(), this.rotate, this.defaultAnchor, this.defaultBorders);
      return this.noFrame && (clonedOrig._frame = clonedFrame), clonedOrig;
    }
    updateUvs() {
      this._uvs === DEFAULT_UVS && (this._uvs = new TextureUvs.TextureUvs());
      this._uvs.set(this._frame, this.baseTexture, this.rotate);
      this._updateID++;
    }
    static from(source, options = {}, strict = settings.settings.STRICT_TEXTURE_CACHE) {
      const isFrame = "string" == typeof source;
      let cacheId;
      isFrame ? cacheId = source : source instanceof BaseTexture.BaseTexture ? (source.cacheId || (source.cacheId = `${options?.pixiIdPrefix || "pixiid"}-${utils.uid()}`, BaseTexture.BaseTexture.addToCache(source, source.cacheId)), cacheId = source.cacheId) : (source._pixiId || (source._pixiId = `${options?.pixiIdPrefix || "pixiid"}_${utils.uid()}`), cacheId = source._pixiId);
      let texture = utils.TextureCache[cacheId];
      if (isFrame && strict && !texture) {
        throw Error(`The cacheId "${cacheId}" does not exist in TextureCache.`);
      }
      return texture || source instanceof BaseTexture.BaseTexture ? !texture && source instanceof BaseTexture.BaseTexture && (texture = new Texture(source), Texture.addToCache(texture, cacheId)) : (options.resolution || (options.resolution = utils.getResolutionOfUrl(source)), texture = new Texture(new BaseTexture.BaseTexture(source, options)), texture.baseTexture.cacheId = cacheId, BaseTexture.BaseTexture.addToCache(texture.baseTexture, cacheId), Texture.addToCache(texture, cacheId)), texture;
    }
    static fromURL(url, options) {
      const resourceOptions = Object.assign({autoLoad:!1}, options?.resourceOptions), texture = Texture.from(url, Object.assign({resourceOptions}, options), !1);
      url = texture.baseTexture.resource;
      return texture.baseTexture.valid ? Promise.resolve(texture) : url.load().then(() => Promise.resolve(texture));
    }
    static fromBuffer(buffer, width, height, options) {
      return new Texture(BaseTexture.BaseTexture.fromBuffer(buffer, width, height, options));
    }
    static fromLoader(source, imageUrl, name, options) {
      source = new BaseTexture.BaseTexture(source, Object.assign({scaleMode:BaseTexture.BaseTexture.defaultOptions.scaleMode, resolution:utils.getResolutionOfUrl(imageUrl)}, options));
      ({resource:options} = source);
      options instanceof ImageResource.ImageResource && (options.url = imageUrl);
      const texture = new Texture(source);
      return name || (name = imageUrl), BaseTexture.BaseTexture.addToCache(texture.baseTexture, name), Texture.addToCache(texture, name), name !== imageUrl && (BaseTexture.BaseTexture.addToCache(texture.baseTexture, imageUrl), Texture.addToCache(texture, imageUrl)), texture.baseTexture.valid ? Promise.resolve(texture) : new Promise(resolve => {
        texture.baseTexture.once("loaded", () => resolve(texture));
      });
    }
    static addToCache(texture, id) {
      id && (texture.textureCacheIds.includes(id) || texture.textureCacheIds.push(id), utils.TextureCache[id] && utils.TextureCache[id] !== texture && console.warn(`Texture added to the cache with an id [${id}] that already had an entry`), utils.TextureCache[id] = texture);
    }
    static removeFromCache(texture) {
      if ("string" == typeof texture) {
        var textureFromCache = utils.TextureCache[texture];
        if (textureFromCache) {
          const index = textureFromCache.textureCacheIds.indexOf(texture);
          return -1 < index && textureFromCache.textureCacheIds.splice(index, 1), delete utils.TextureCache[texture], textureFromCache;
        }
      } else if (texture?.textureCacheIds) {
        for (textureFromCache = 0; textureFromCache < texture.textureCacheIds.length; ++textureFromCache) {
          utils.TextureCache[texture.textureCacheIds[textureFromCache]] === texture && delete utils.TextureCache[texture.textureCacheIds[textureFromCache]];
        }
        return texture.textureCacheIds.length = 0, texture;
      }
      return null;
    }
    get resolution() {
      return this.baseTexture.resolution;
    }
    get frame() {
      return this._frame;
    }
    set frame(frame) {
      this._frame = frame;
      this.noFrame = !1;
      const {x, y, width, height} = frame, xNotFit = x + width > this.baseTexture.width, yNotFit = y + height > this.baseTexture.height;
      if (xNotFit || yNotFit) {
        throw Error(`Texture Error: frame does not fit inside the base Texture dimensions: ${`X: ${x} + ${width} = ${x + width} > ${this.baseTexture.width}`} ${xNotFit && yNotFit ? "and" : "or"} ${`Y: ${y} + ${height} = ${y + height} > ${this.baseTexture.height}`}`);
      }
      this.valid = width && height && this.baseTexture.valid;
      this.trim || this.rotate || (this.orig = frame);
      this.valid && this.updateUvs();
    }
    get rotate() {
      return this._rotate;
    }
    set rotate(rotate) {
      this._rotate = rotate;
      this.valid && this.updateUvs();
    }
    get width() {
      return this.orig.width;
    }
    get height() {
      return this.orig.height;
    }
    castToBaseTexture() {
      return this.baseTexture;
    }
    static get EMPTY() {
      return Texture._EMPTY || (Texture._EMPTY = new Texture(new BaseTexture.BaseTexture()), removeAllHandlers(Texture._EMPTY), removeAllHandlers(Texture._EMPTY.baseTexture)), Texture._EMPTY;
    }
    static get WHITE() {
      if (!Texture._WHITE) {
        const canvas = settings.settings.ADAPTER.createCanvas(16, 16), context = canvas.getContext("2d");
        canvas.width = 16;
        canvas.height = 16;
        context.fillStyle = "white";
        context.fillRect(0, 0, 16, 16);
        Texture._WHITE = new Texture(BaseTexture.BaseTexture.from(canvas));
        removeAllHandlers(Texture._WHITE);
        removeAllHandlers(Texture._WHITE.baseTexture);
      }
      return Texture._WHITE;
    }
  }
  exports.Texture = Texture;
};

//# sourceMappingURL=module$node_modules$$pixi$core$lib$textures$Texture.js.map
