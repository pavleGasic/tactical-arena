shadow$provide.module$node_modules$$pixi$assets$lib$resolver$Resolver = function(global, require, module, exports) {
  var core = require("module$node_modules$$pixi$core$lib$index"), convertToList = require("module$node_modules$$pixi$assets$lib$utils$convertToList"), createStringVariations = require("module$node_modules$$pixi$assets$lib$utils$createStringVariations"), isSingleItem = require("module$node_modules$$pixi$assets$lib$utils$isSingleItem");
  class Resolver {
    constructor() {
      this._defaultBundleIdentifierOptions = {connector:"-", createBundleAssetId:(bundleId, assetId) => `${bundleId}${this._bundleIdConnector}${assetId}`, extractAssetIdFromBundle:(bundleId, assetBundleId) => assetBundleId.replace(`${bundleId}${this._bundleIdConnector}`, "")};
      this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector;
      this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId;
      this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle;
      this._assetMap = {};
      this._preferredOrder = [];
      this._parsers = [];
      this._resolverHash = {};
      this._bundles = {};
    }
    setBundleIdentifier(bundleIdentifier) {
      if (this._bundleIdConnector = bundleIdentifier.connector ?? this._bundleIdConnector, this._createBundleAssetId = bundleIdentifier.createBundleAssetId ?? this._createBundleAssetId, this._extractAssetIdFromBundle = bundleIdentifier.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle, "bar" !== this._extractAssetIdFromBundle("foo", this._createBundleAssetId("foo", "bar"))) {
        throw Error("[Resolver] GenerateBundleAssetId are not working correctly");
      }
    }
    prefer(...preferOrders) {
      preferOrders.forEach(prefer => {
        this._preferredOrder.push(prefer);
        prefer.priority || (prefer.priority = Object.keys(prefer.params));
      });
      this._resolverHash = {};
    }
    set basePath(basePath) {
      this._basePath = basePath;
    }
    get basePath() {
      return this._basePath;
    }
    set rootPath(rootPath) {
      this._rootPath = rootPath;
    }
    get rootPath() {
      return this._rootPath;
    }
    get parsers() {
      return this._parsers;
    }
    reset() {
      this.setBundleIdentifier(this._defaultBundleIdentifierOptions);
      this._assetMap = {};
      this._preferredOrder = [];
      this._resolverHash = {};
      this._manifest = this._basePath = this._rootPath = null;
      this._bundles = {};
      this._defaultSearchParams = null;
    }
    setDefaultSearchParams(searchParams) {
      this._defaultSearchParams = "string" == typeof searchParams ? searchParams : Object.keys(searchParams).map(key => `${encodeURIComponent(key)}=${encodeURIComponent(searchParams[key])}`).join("\x26");
    }
    getAlias(asset) {
      const {alias, name, src, srcs} = asset;
      return convertToList.convertToList(alias || name || src || srcs, value => "string" == typeof value ? value : Array.isArray(value) ? value.map(v => v?.src ?? v?.srcs ?? v) : value?.src || value?.srcs ? value.src ?? value.srcs : value, !0);
    }
    addManifest(manifest) {
      this._manifest && console.warn("[Resolver] Manifest already exists, this will be overwritten");
      this._manifest = manifest;
      manifest.bundles.forEach(bundle => {
        this.addBundle(bundle.name, bundle.assets);
      });
    }
    addBundle(bundleId, assets) {
      const assetNames = [];
      Array.isArray(assets) ? assets.forEach(asset => {
        const srcs = asset.src ?? asset.srcs;
        var aliases = asset.alias ?? asset.name;
        if ("string" == typeof aliases) {
          var bundleAssetId = this._createBundleAssetId(bundleId, aliases);
          assetNames.push(bundleAssetId);
          aliases = [aliases, bundleAssetId];
        } else {
          bundleAssetId = aliases.map(name => this._createBundleAssetId(bundleId, name)), assetNames.push(...bundleAssetId), aliases = [...aliases, ...bundleAssetId];
        }
        this.add({...asset, alias:aliases, src:srcs});
      }) : Object.keys(assets).forEach(key => {
        const aliases = [key, this._createBundleAssetId(bundleId, key)];
        if ("string" == typeof assets[key]) {
          this.add({alias:aliases, src:assets[key]});
        } else if (Array.isArray(assets[key])) {
          this.add({alias:aliases, src:assets[key]});
        } else {
          key = assets[key];
          const assetSrc = key.src ?? key.srcs;
          this.add({...key, alias:aliases, src:Array.isArray(assetSrc) ? assetSrc : [assetSrc]});
        }
        assetNames.push(...aliases);
      });
      this._bundles[bundleId] = assetNames;
    }
    add(aliases, srcs, data, format, loadParser) {
      const assets = [];
      "string" == typeof aliases || Array.isArray(aliases) && "string" == typeof aliases[0] ? (core.utils.deprecation("7.2.0", "Assets.add now uses an object instead of individual parameters.\nPlease use Assets.add({ alias, src, data, format, loadParser }) instead."), assets.push({alias:aliases, src:srcs, data, format, loadParser})) : Array.isArray(aliases) ? assets.push(...aliases) : assets.push(aliases);
      let keyCheck;
      keyCheck = key => {
        this.hasKey(key) && console.warn(`[Resolver] already has key: ${key} overwriting`);
      };
      convertToList.convertToList(assets).forEach(asset => {
        const {src, srcs:srcs2} = asset;
        let {data:data2, format:format2, loadParser:loadParser2} = asset;
        const srcsToUse = convertToList.convertToList(src || srcs2).map(src2 => "string" == typeof src2 ? createStringVariations.createStringVariations(src2) : Array.isArray(src2) ? src2 : [src2]), aliasesToUse = this.getAlias(asset);
        Array.isArray(aliasesToUse) ? aliasesToUse.forEach(keyCheck) : keyCheck(aliasesToUse);
        const resolvedAssets = [];
        srcsToUse.forEach(srcs3 => {
          srcs3.forEach(src2 => {
            let formattedAsset = {};
            if ("object" != typeof src2) {
              formattedAsset.src = src2;
              for (let i = 0; i < this._parsers.length; i++) {
                const parser = this._parsers[i];
                if (parser.test(src2)) {
                  formattedAsset = parser.parse(src2);
                  break;
                }
              }
            } else {
              data2 = src2.data ?? data2, format2 = src2.format ?? format2, loadParser2 = src2.loadParser ?? loadParser2, formattedAsset = {...formattedAsset, ...src2};
            }
            if (!aliasesToUse) {
              throw Error(`[Resolver] alias is undefined for this asset: ${formattedAsset.src}`);
            }
            formattedAsset = this.buildResolvedAsset(formattedAsset, {aliases:aliasesToUse, data:data2, format:format2, loadParser:loadParser2});
            resolvedAssets.push(formattedAsset);
          });
        });
        aliasesToUse.forEach(alias => {
          this._assetMap[alias] = resolvedAssets;
        });
      });
    }
    resolveBundle(bundleIds) {
      const singleAsset = isSingleItem.isSingleItem(bundleIds);
      bundleIds = convertToList.convertToList(bundleIds);
      const out = {};
      return bundleIds.forEach(bundleId => {
        var assetNames = this._bundles[bundleId];
        if (assetNames) {
          assetNames = this.resolve(assetNames);
          const assets = {};
          for (const key in assetNames) {
            const asset = assetNames[key];
            assets[this._extractAssetIdFromBundle(bundleId, key)] = asset;
          }
          out[bundleId] = assets;
        }
      }), singleAsset ? out[bundleIds[0]] : out;
    }
    resolveUrl(key) {
      const result = this.resolve(key);
      if ("string" != typeof key) {
        key = {};
        for (const i in result) {
          key[i] = result[i].src;
        }
        return key;
      }
      return result.src;
    }
    resolve(keys) {
      const singleAsset = isSingleItem.isSingleItem(keys);
      keys = convertToList.convertToList(keys);
      const result = {};
      return keys.forEach(key => {
        if (!this._resolverHash[key]) {
          if (this._assetMap[key]) {
            let assets = this._assetMap[key];
            const bestAsset = assets[0], preferredOrder = this._getPreferredOrder(assets);
            preferredOrder?.priority.forEach(priorityKey => {
              preferredOrder.params[priorityKey].forEach(value => {
                const filteredAssets = assets.filter(asset => asset[priorityKey] ? asset[priorityKey] === value : !1);
                filteredAssets.length && (assets = filteredAssets);
              });
            });
            this._resolverHash[key] = assets[0] ?? bestAsset;
          } else {
            this._resolverHash[key] = this.buildResolvedAsset({alias:[key], src:key}, {});
          }
        }
        result[key] = this._resolverHash[key];
      }), singleAsset ? result[keys[0]] : result;
    }
    hasKey(key) {
      return !!this._assetMap[key];
    }
    hasBundle(key) {
      return !!this._bundles[key];
    }
    _getPreferredOrder(assets) {
      for (let i = 0; i < assets.length; i++) {
        const asset = assets[0], preferred = this._preferredOrder.find(preference => preference.params.format.includes(asset.format));
        if (preferred) {
          return preferred;
        }
      }
      return this._preferredOrder[0];
    }
    _appendDefaultSearchParams(url) {
      if (!this._defaultSearchParams) {
        return url;
      }
      const paramConnector = /\?/.test(url) ? "\x26" : "?";
      return `${url}${paramConnector}${this._defaultSearchParams}`;
    }
    buildResolvedAsset(formattedAsset, data) {
      const {aliases, data:assetData, loadParser, format} = data;
      return (this._basePath || this._rootPath) && (formattedAsset.src = core.utils.path.toAbsolute(formattedAsset.src, this._basePath, this._rootPath)), formattedAsset.alias = aliases ?? formattedAsset.alias ?? [formattedAsset.src], formattedAsset.src = this._appendDefaultSearchParams(formattedAsset.src), formattedAsset.data = {...(assetData || {}), ...formattedAsset.data}, formattedAsset.loadParser = loadParser ?? formattedAsset.loadParser, formattedAsset.format = format ?? formattedAsset.format ?? 
      core.utils.path.extname(formattedAsset.src).slice(1), formattedAsset.srcs = formattedAsset.src, formattedAsset.name = formattedAsset.alias, formattedAsset;
    }
  }
  exports.Resolver = Resolver;
};

//# sourceMappingURL=module$node_modules$$pixi$assets$lib$resolver$Resolver.js.map
