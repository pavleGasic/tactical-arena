shadow$provide.module$node_modules$pixi_DOT_js$lib$rendering$renderers$gpu$renderTarget$GpuRenderTargetAdaptor = function(global, require, module, exports) {
  var _const = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$gl$const"), CanvasSource = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$texture$sources$CanvasSource"), TextureSource = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$texture$sources$TextureSource"), GpuRenderTarget = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$gpu$renderTarget$GpuRenderTarget");
  "use strict";
  class GpuRenderTargetAdaptor {
    init(renderer, renderTargetSystem) {
      this._renderer = renderer;
      this._renderTargetSystem = renderTargetSystem;
    }
    copyToTexture(sourceRenderSurfaceTexture, destinationTexture, originSrc, size, originDest) {
      const renderer = this._renderer;
      sourceRenderSurfaceTexture = this._getGpuColorTexture(sourceRenderSurfaceTexture);
      const backGpuTexture = renderer.texture.getGpuSource(destinationTexture.source);
      renderer.encoder.commandEncoder.copyTextureToTexture({texture:sourceRenderSurfaceTexture, origin:originSrc}, {texture:backGpuTexture, origin:originDest}, size);
      return destinationTexture;
    }
    startRenderPass(renderTarget, clear = !0, clearColor, viewport) {
      const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);
      renderTarget = this.getDescriptor(renderTarget, clear, clearColor);
      gpuRenderTarget.descriptor = renderTarget;
      this._renderer.pipeline.setRenderTarget(gpuRenderTarget);
      this._renderer.encoder.beginRenderPass(gpuRenderTarget);
      this._renderer.encoder.setViewport(viewport);
    }
    finishRenderPass() {
      this._renderer.encoder.endRenderPass();
    }
    _getGpuColorTexture(renderTarget) {
      const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);
      return gpuRenderTarget.contexts[0] ? gpuRenderTarget.contexts[0].getCurrentTexture() : this._renderer.texture.getGpuSource(renderTarget.colorTextures[0].source);
    }
    getDescriptor(renderTarget, clear, clearValue) {
      "boolean" === typeof clear && (clear = clear ? _const.CLEAR.ALL : _const.CLEAR.NONE);
      const renderTargetSystem = this._renderTargetSystem, gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget), colorAttachments = renderTarget.colorTextures.map((texture, i) => {
        const context = gpuRenderTarget.contexts[i];
        let resolveTarget;
        texture = context ? context.getCurrentTexture().createView() : this._renderer.texture.getGpuSource(texture).createView({mipLevelCount:1});
        gpuRenderTarget.msaaTextures[i] && (resolveTarget = texture, texture = this._renderer.texture.getTextureView(gpuRenderTarget.msaaTextures[i]));
        i = clear & _const.CLEAR.COLOR ? "clear" : "load";
        clearValue ?? (clearValue = renderTargetSystem.defaultClearColor);
        return {view:texture, resolveTarget, clearValue, storeOp:"store", loadOp:i};
      });
      !renderTarget.stencil && !renderTarget.depth || renderTarget.depthStencilTexture || (renderTarget.ensureDepthStencilTexture(), renderTarget.depthStencilTexture.source.sampleCount = gpuRenderTarget.msaa ? 4 : 1);
      if (renderTarget.depthStencilTexture) {
        var depthStencilAttachment = clear & _const.CLEAR.STENCIL ? "clear" : "load";
        const depthLoadOp = clear & _const.CLEAR.DEPTH ? "clear" : "load";
        depthStencilAttachment = {view:this._renderer.texture.getGpuSource(renderTarget.depthStencilTexture.source).createView(), stencilStoreOp:"store", stencilLoadOp:depthStencilAttachment, depthClearValue:1, depthLoadOp, depthStoreOp:"store"};
      }
      return {colorAttachments, depthStencilAttachment};
    }
    clear(renderTarget, clear = !0, clearColor, viewport) {
      if (clear) {
        var {gpu, encoder} = this._renderer, device = gpu.device;
        if (null === encoder.commandEncoder) {
          const commandEncoder = device.createCommandEncoder();
          renderTarget = this.getDescriptor(renderTarget, clear, clearColor);
          renderTarget = commandEncoder.beginRenderPass(renderTarget);
          renderTarget.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);
          renderTarget.end();
          viewport = commandEncoder.finish();
          device.queue.submit([viewport]);
        } else {
          this.startRenderPass(renderTarget, clear, clearColor, viewport);
        }
      }
    }
    initGpuRenderTarget(renderTarget) {
      renderTarget.isRoot = !0;
      const gpuRenderTarget = new GpuRenderTarget.GpuRenderTarget();
      renderTarget.colorTextures.forEach((colorTexture, i) => {
        if (CanvasSource.CanvasSource.test(colorTexture.resource)) {
          const context = colorTexture.resource.getContext("webgpu"), alphaMode = colorTexture.transparent ? "premultiplied" : "opaque";
          try {
            context.configure({device:this._renderer.gpu.device, usage:GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC, format:"bgra8unorm", alphaMode});
          } catch (e) {
            console.error(e);
          }
          gpuRenderTarget.contexts[i] = context;
        }
        if (gpuRenderTarget.msaa = colorTexture.source.antialias) {
          colorTexture = new TextureSource.TextureSource({width:0, height:0, sampleCount:4}), gpuRenderTarget.msaaTextures[i] = colorTexture;
        }
      });
      gpuRenderTarget.msaa && (gpuRenderTarget.msaaSamples = 4, renderTarget.depthStencilTexture && (renderTarget.depthStencilTexture.source.sampleCount = 4));
      return gpuRenderTarget;
    }
    destroyGpuRenderTarget(gpuRenderTarget) {
      gpuRenderTarget.contexts.forEach(context => {
        context.unconfigure();
      });
      gpuRenderTarget.msaaTextures.forEach(texture => {
        texture.destroy();
      });
      gpuRenderTarget.msaaTextures.length = 0;
      gpuRenderTarget.contexts.length = 0;
    }
    ensureDepthStencilTexture(renderTarget) {
      const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);
      renderTarget.depthStencilTexture && gpuRenderTarget.msaa && (renderTarget.depthStencilTexture.source.sampleCount = 4);
    }
    resizeGpuRenderTarget(renderTarget) {
      const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);
      gpuRenderTarget.width = renderTarget.width;
      gpuRenderTarget.height = renderTarget.height;
      gpuRenderTarget.msaa && renderTarget.colorTextures.forEach((colorTexture, i) => {
        gpuRenderTarget.msaaTextures[i]?.resize(colorTexture.source.width, colorTexture.source.height, colorTexture.source._resolution);
      });
    }
  }
  exports.GpuRenderTargetAdaptor = GpuRenderTargetAdaptor;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$rendering$renderers$gpu$renderTarget$GpuRenderTargetAdaptor.js.map
