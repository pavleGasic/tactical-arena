shadow$provide.module$node_modules$$pixi$text_bitmap$lib$BitmapFont = function(global, require, module, exports) {
  var core = require("module$node_modules$$pixi$core$lib$index"), text = require("module$node_modules$$pixi$text$lib$index"), BitmapFontData = require("module$node_modules$$pixi$text_bitmap$lib$BitmapFontData"), index = require("module$node_modules$$pixi$text_bitmap$lib$formats$index");
  require("module$node_modules$$pixi$text_bitmap$lib$utils$index");
  var resolveCharacters = require("module$node_modules$$pixi$text_bitmap$lib$utils$resolveCharacters"), drawGlyph = require("module$node_modules$$pixi$text_bitmap$lib$utils$drawGlyph"), extractCharCode = require("module$node_modules$$pixi$text_bitmap$lib$utils$extractCharCode");
  const node_modules$$pixi$text_bitmap$lib$BitmapFont$classdecl$var25 = class {
    constructor(data, textures, ownsTextures) {
      const [info] = data.info, [common] = data.common;
      var [page] = data.page;
      const [distanceField] = data.distanceField;
      page = core.utils.getResolutionOfUrl(page.file);
      var pageTextures = {};
      this._ownsTextures = ownsTextures;
      this.font = info.face;
      this.size = info.size;
      this.lineHeight = common.lineHeight / page;
      this.chars = {};
      this.pageTextures = pageTextures;
      for (ownsTextures = 0; ownsTextures < data.page.length; ownsTextures++) {
        const {id, file} = data.page[ownsTextures];
        pageTextures[id] = textures instanceof Array ? textures[ownsTextures] : textures[file];
        distanceField?.fieldType && "none" !== distanceField.fieldType && (pageTextures[id].baseTexture.alphaMode = core.ALPHA_MODES.NO_PREMULTIPLIED_ALPHA, pageTextures[id].baseTexture.mipmap = core.MIPMAP_MODES.OFF);
      }
      for (textures = 0; textures < data.char.length; textures++) {
        const {id, page:page2} = data.char[textures];
        let {x, y, width, height, xoffset, yoffset, xadvance} = data.char[textures];
        x /= page;
        y /= page;
        width /= page;
        height /= page;
        xoffset /= page;
        yoffset /= page;
        xadvance /= page;
        ownsTextures = new core.Rectangle(x + pageTextures[page2].frame.x / page, y + pageTextures[page2].frame.y / page, width, height);
        this.chars[id] = {xOffset:xoffset, yOffset:yoffset, xAdvance:xadvance, kerning:{}, texture:new core.Texture(pageTextures[page2].baseTexture, ownsTextures), page:page2};
      }
      for (pageTextures = 0; pageTextures < data.kerning.length; pageTextures++) {
        let {first, second, amount} = data.kerning[pageTextures];
        first /= page;
        second /= page;
        amount /= page;
        this.chars[second] && (this.chars[second].kerning[first] = amount);
      }
      this.distanceFieldRange = distanceField?.distanceRange;
      this.distanceFieldType = distanceField?.fieldType?.toLowerCase() ?? "none";
    }
    destroy() {
      for (const id in this.chars) {
        this.chars[id].texture.destroy(), this.chars[id].texture = null;
      }
      for (const id in this.pageTextures) {
        this._ownsTextures && this.pageTextures[id].destroy(!0), this.pageTextures[id] = null;
      }
      this.pageTextures = this.chars = null;
    }
    static install(data, textures, ownsTextures) {
      if (!(data instanceof BitmapFontData.BitmapFontData)) {
        const format = index.autoDetectFormat(data);
        if (!format) {
          throw Error("Unrecognized data format for font.");
        }
        data = format.parse(data);
      }
      textures instanceof core.Texture && (textures = [textures]);
      textures = new node_modules$$pixi$text_bitmap$lib$BitmapFont$classdecl$var25(data, textures, ownsTextures);
      return node_modules$$pixi$text_bitmap$lib$BitmapFont$classdecl$var25.available[textures.font] = textures, textures;
    }
    static uninstall(name) {
      const font = node_modules$$pixi$text_bitmap$lib$BitmapFont$classdecl$var25.available[name];
      if (!font) {
        throw Error(`No font found named '${name}'`);
      }
      font.destroy();
      delete node_modules$$pixi$text_bitmap$lib$BitmapFont$classdecl$var25.available[name];
    }
    static from(name, textStyle, options) {
      if (!name) {
        throw Error("[BitmapFont] Property `name` is required.");
      }
      const {chars, padding, resolution, textureWidth, textureHeight, ...baseOptions} = Object.assign({}, node_modules$$pixi$text_bitmap$lib$BitmapFont$classdecl$var25.defaultOptions, options);
      var charsList = resolveCharacters.resolveCharacters(chars), style = textStyle instanceof text.TextStyle ? textStyle : new text.TextStyle(textStyle);
      textStyle = new BitmapFontData.BitmapFontData();
      textStyle.info[0] = {face:style.fontFamily, size:style.fontSize};
      textStyle.common[0] = {lineHeight:style.fontSize};
      var positionX = 0;
      let positionY = 0;
      var canvas;
      let context;
      var baseTexture;
      let maxCharHeight = 0;
      const baseTextures = [], textures = [];
      for (let i = 0; i < charsList.length; i++) {
        canvas || (canvas = core.settings.ADAPTER.createCanvas(), canvas.width = textureWidth, canvas.height = textureHeight, context = canvas.getContext("2d"), baseTexture = new core.BaseTexture(canvas, {resolution, ...baseOptions}), baseTextures.push(baseTexture), textures.push(new core.Texture(baseTexture)), textStyle.page.push({id:textures.length - 1, file:""}));
        var character = charsList[i];
        const metrics = text.TextMetrics.measureText(character, style, !1, canvas), width = metrics.width, height = Math.ceil(metrics.height), textureGlyphWidth = Math.ceil(("italic" === style.fontStyle ? 2 : 1) * width);
        if (positionY >= textureHeight - height * resolution) {
          if (0 === positionY) {
            throw Error(`[BitmapFont] textureHeight ${textureHeight}px is too small (fontFamily: '${style.fontFamily}', fontSize: ${style.fontSize}px, char: '${character}')`);
          }
          --i;
          baseTexture = context = canvas = null;
          maxCharHeight = positionX = positionY = 0;
        } else {
          if (maxCharHeight = Math.max(height + metrics.fontProperties.descent, maxCharHeight), textureGlyphWidth * resolution + positionX >= textureWidth) {
            if (0 === positionX) {
              throw Error(`[BitmapFont] textureWidth ${textureWidth}px is too small (fontFamily: '${style.fontFamily}', fontSize: ${style.fontSize}px, char: '${character}')`);
            }
            --i;
            positionY += maxCharHeight * resolution;
            positionY = Math.ceil(positionY);
            maxCharHeight = positionX = 0;
          } else {
            drawGlyph.drawGlyph(canvas, context, metrics, positionX, positionY, resolution, style), character = extractCharCode.extractCharCode(metrics.text), textStyle.char.push({id:character, page:textures.length - 1, x:positionX / resolution, y:positionY / resolution, width:textureGlyphWidth, height, xoffset:0, yoffset:0, xadvance:width - (style.dropShadow ? style.dropShadowDistance : 0) - (style.stroke ? style.strokeThickness : 0)}), positionX += (textureGlyphWidth + 2 * padding) * resolution, 
            positionX = Math.ceil(positionX);
          }
        }
      }
      if (!options?.skipKerning) {
        for (let i = 0, len = charsList.length; i < len; i++) {
          for (options = charsList[i], canvas = 0; canvas < len; canvas++) {
            baseTexture = charsList[canvas], style = context.measureText(options).width, positionX = context.measureText(baseTexture).width, (style = context.measureText(options + baseTexture).width - (style + positionX)) && textStyle.kerning.push({first:extractCharCode.extractCharCode(options), second:extractCharCode.extractCharCode(baseTexture), amount:style});
          }
        }
      }
      charsList = new node_modules$$pixi$text_bitmap$lib$BitmapFont$classdecl$var25(textStyle, textures, !0);
      return void 0 !== node_modules$$pixi$text_bitmap$lib$BitmapFont$classdecl$var25.available[name] && node_modules$$pixi$text_bitmap$lib$BitmapFont$classdecl$var25.uninstall(name), node_modules$$pixi$text_bitmap$lib$BitmapFont$classdecl$var25.available[name] = charsList, charsList;
    }
  };
  global = node_modules$$pixi$text_bitmap$lib$BitmapFont$classdecl$var25;
  global.ALPHA = [["a", "z"], ["A", "Z"], " "];
  global.NUMERIC = [["0", "9"]];
  global.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "];
  global.ASCII = [[" ", "~"]];
  global.defaultOptions = {resolution:1, textureWidth:512, textureHeight:512, padding:4, chars:global.ALPHANUMERIC};
  global.available = {};
  exports.BitmapFont = global;
};

//# sourceMappingURL=module$node_modules$$pixi$text_bitmap$lib$BitmapFont.js.map
