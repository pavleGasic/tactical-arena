shadow$provide.module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$system$AbstractRenderer = function(global, require, module, exports) {
  var Color = require("module$node_modules$pixi_DOT_js$lib$color$Color"), autoDetectEnvironment = require("module$node_modules$pixi_DOT_js$lib$environment$autoDetectEnvironment"), Container = require("module$node_modules$pixi_DOT_js$lib$scene$container$Container"), unsafeEvalSupported = require("module$node_modules$pixi_DOT_js$lib$utils$browser$unsafeEvalSupported"), deprecation = require("module$node_modules$pixi_DOT_js$lib$utils$logging$deprecation");
  require("module$node_modules$pixi_DOT_js$lib$utils$utils");
  var _const = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$gl$const"), SystemRunner = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$system$SystemRunner");
  global = require("module$node_modules$eventemitter3$index");
  "use strict";
  const defaultRunners = "init destroy contextChange resolutionChange resetState renderEnd renderStart render update postrender prerender".split(" "), node_modules$pixi_DOT_js$lib$rendering$renderers$shared$system$AbstractRenderer$classdecl$var23 = class extends global {
    constructor(config) {
      super();
      this.runners = Object.create(null);
      this.renderPipes = Object.create(null);
      this._initOptions = {};
      this._systemsHash = Object.create(null);
      this.type = config.type;
      this.name = config.name;
      this.config = config;
      config = [...defaultRunners, ...(this.config.runners ?? [])];
      this._addRunners(...config);
      this._unsafeEvalCheck();
    }
    async init(options = {}) {
      await autoDetectEnvironment.loadEnvironmentExtensions(!0 === options.skipExtensionImports ? !0 : !1 === options.manageImports);
      this._addSystems(this.config.systems);
      this._addPipes(this.config.renderPipes, this.config.renderPipeAdaptors);
      for (var systemName in this._systemsHash) {
        options = {...this._systemsHash[systemName].constructor.defaultOptions, ...options};
      }
      options = {...node_modules$pixi_DOT_js$lib$rendering$renderers$shared$system$AbstractRenderer$classdecl$var23.defaultOptions, ...options};
      this._roundPixels = options.roundPixels ? 1 : 0;
      for (systemName = 0; systemName < this.runners.init.items.length; systemName++) {
        await this.runners.init.items[systemName].init(options);
      }
      this._initOptions = options;
    }
    render(args, deprecated) {
      args instanceof Container.Container && (args = {container:args}, deprecated && (deprecation.deprecation(deprecation.v8_0_0, "passing a second argument is deprecated, please use render options instead"), args.target = deprecated.renderTexture));
      args.target || (args.target = this.view.renderTarget);
      args.target === this.view.renderTarget && (this._lastObjectRendered = args.container, args.clearColor ?? (args.clearColor = this.background.colorRgba), args.clear ?? (args.clear = this.background.clearBeforeRender));
      args.clearColor && (deprecated = Array.isArray(args.clearColor) && 4 === args.clearColor.length, args.clearColor = deprecated ? args.clearColor : Color.Color.shared.setValue(args.clearColor).toArray());
      args.transform || (args.container.updateLocalTransform(), args.transform = args.container.localTransform);
      args.container.enableRenderGroup();
      this.runners.prerender.emit(args);
      this.runners.renderStart.emit(args);
      this.runners.render.emit(args);
      this.runners.renderEnd.emit(args);
      this.runners.postrender.emit(args);
    }
    resize(desiredScreenWidth, desiredScreenHeight, resolution) {
      const previousResolution = this.view.resolution;
      this.view.resize(desiredScreenWidth, desiredScreenHeight, resolution);
      this.emit("resize", this.view.screen.width, this.view.screen.height, this.view.resolution);
      void 0 !== resolution && resolution !== previousResolution && this.runners.resolutionChange.emit(resolution);
    }
    clear(options = {}) {
      options.target || (options.target = this.renderTarget.renderTarget);
      options.clearColor || (options.clearColor = this.background.colorRgba);
      options.clear ?? (options.clear = _const.CLEAR.ALL);
      const {clear, clearColor, target} = options;
      Color.Color.shared.setValue(clearColor ?? this.background.colorRgba);
      this.renderTarget.clear(target, clear, Color.Color.shared.toArray());
    }
    get resolution() {
      return this.view.resolution;
    }
    set resolution(value) {
      this.view.resolution = value;
      this.runners.resolutionChange.emit(value);
    }
    get width() {
      return this.view.texture.frame.width;
    }
    get height() {
      return this.view.texture.frame.height;
    }
    get canvas() {
      return this.view.canvas;
    }
    get lastObjectRendered() {
      return this._lastObjectRendered;
    }
    get renderingToScreen() {
      return this.renderTarget.renderingToScreen;
    }
    get screen() {
      return this.view.screen;
    }
    _addRunners(...runnerIds) {
      runnerIds.forEach(runnerId => {
        this.runners[runnerId] = new SystemRunner.SystemRunner(runnerId);
      });
    }
    _addSystems(systems) {
      let i;
      for (i in systems) {
        const val = systems[i];
        this._addSystem(val.value, val.name);
      }
    }
    _addSystem(ClassRef, name) {
      ClassRef = new ClassRef(this);
      if (this[name]) {
        throw Error(`Whoops! The name "${name}" is already in use`);
      }
      this[name] = ClassRef;
      this._systemsHash[name] = ClassRef;
      for (const i in this.runners) {
        this.runners[i].add(ClassRef);
      }
      return this;
    }
    _addPipes(pipes, pipeAdaptors) {
      const adaptors = pipeAdaptors.reduce((acc, adaptor) => {
        acc[adaptor.name] = adaptor.value;
        return acc;
      }, {});
      pipes.forEach(pipe => {
        const name = pipe.name, Adaptor = adaptors[name];
        this.renderPipes[name] = new pipe.value(this, Adaptor ? new Adaptor() : null);
      });
    }
    destroy(options = !1) {
      this.runners.destroy.items.reverse();
      this.runners.destroy.emit(options);
      Object.values(this.runners).forEach(runner => {
        runner.destroy();
      });
      this.renderPipes = this._systemsHash = null;
    }
    generateTexture(options) {
      return this.textureGenerator.generateTexture(options);
    }
    get roundPixels() {
      return !!this._roundPixels;
    }
    _unsafeEvalCheck() {
      if (!unsafeEvalSupported.unsafeEvalSupported()) {
        throw Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.");
      }
    }
    resetState() {
      this.runners.resetState.emit();
    }
  };
  global = node_modules$pixi_DOT_js$lib$rendering$renderers$shared$system$AbstractRenderer$classdecl$var23;
  global.defaultOptions = {resolution:1, failIfMajorPerformanceCaveat:!1, roundPixels:!1};
  exports.AbstractRenderer = global;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$system$AbstractRenderer.js.map
