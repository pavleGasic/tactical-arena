shadow$provide.module$node_modules$pixi_DOT_js$lib$scene$text_html$HTMLTextPipe = function(global, require, module, exports) {
  global = require("module$node_modules$pixi_DOT_js$lib$extensions$Extensions");
  var Texture = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$texture$Texture"), PoolGroup = require("module$node_modules$pixi_DOT_js$lib$utils$pool$PoolGroup"), BatchableSprite = require("module$node_modules$pixi_DOT_js$lib$scene$sprite$BatchableSprite"), updateTextBounds = require("module$node_modules$pixi_DOT_js$lib$scene$text$utils$updateTextBounds");
  "use strict";
  class HTMLTextPipe {
    constructor(renderer) {
      this._gpuText = Object.create(null);
      this._destroyRenderableBound = this.destroyRenderable.bind(this);
      this._renderer = renderer;
      this._renderer.runners.resolutionChange.add(this);
      this._renderer.renderableGC.addManagedHash(this, "_gpuText");
    }
    resolutionChange() {
      for (const i in this._gpuText) {
        var gpuText = this._gpuText[i];
        gpuText && (gpuText = gpuText.batchableSprite.renderable, gpuText._autoResolution && (gpuText._resolution = this._renderer.resolution, gpuText.onViewUpdate()));
      }
    }
    validateRenderable(htmlText) {
      const gpuText = this._getGpuText(htmlText);
      htmlText = htmlText._getKey();
      return gpuText.textureNeedsUploading ? (gpuText.textureNeedsUploading = !1, !0) : gpuText.currentKey !== htmlText ? !0 : !1;
    }
    addRenderable(htmlText, instructionSet) {
      const batchableSprite = this._getGpuText(htmlText).batchableSprite;
      htmlText._didTextUpdate && this._updateText(htmlText);
      this._renderer.renderPipes.batch.addToBatch(batchableSprite, instructionSet);
    }
    updateRenderable(htmlText) {
      const batchableSprite = this._getGpuText(htmlText).batchableSprite;
      htmlText._didTextUpdate && this._updateText(htmlText);
      batchableSprite._batcher.updateElement(batchableSprite);
    }
    destroyRenderable(htmlText) {
      htmlText.off("destroyed", this._destroyRenderableBound);
      this._destroyRenderableById(htmlText.uid);
    }
    _destroyRenderableById(htmlTextUid) {
      const gpuText = this._gpuText[htmlTextUid];
      this._renderer.htmlText.decreaseReferenceCount(gpuText.currentKey);
      PoolGroup.BigPool.return(gpuText.batchableSprite);
      this._gpuText[htmlTextUid] = null;
    }
    _updateText(htmlText) {
      const newKey = htmlText._getKey(), gpuText = this._getGpuText(htmlText), batchableSprite = gpuText.batchableSprite;
      gpuText.currentKey !== newKey && this._updateGpuText(htmlText).catch(e => {
        console.error(e);
      });
      htmlText._didTextUpdate = !1;
      updateTextBounds.updateTextBounds(batchableSprite, htmlText);
    }
    async _updateGpuText(htmlText) {
      htmlText._didTextUpdate = !1;
      const gpuText = this._getGpuText(htmlText);
      if (!gpuText.generatingTexture) {
        var newKey = htmlText._getKey();
        this._renderer.htmlText.decreaseReferenceCount(gpuText.currentKey);
        gpuText.generatingTexture = !0;
        gpuText.currentKey = newKey;
        newKey = await this._renderer.htmlText.getManagedTexture(htmlText.text, htmlText.resolution ?? this._renderer.resolution, htmlText._style, htmlText._getKey());
        var batchableSprite = gpuText.batchableSprite;
        batchableSprite.texture = gpuText.texture = newKey;
        gpuText.generatingTexture = !1;
        gpuText.textureNeedsUploading = !0;
        htmlText.onViewUpdate();
        updateTextBounds.updateTextBounds(batchableSprite, htmlText);
      }
    }
    _getGpuText(htmlText) {
      return this._gpuText[htmlText.uid] || this.initGpuText(htmlText);
    }
    initGpuText(htmlText) {
      const gpuTextData = {texture:Texture.Texture.EMPTY, currentKey:"--", batchableSprite:PoolGroup.BigPool.get(BatchableSprite.BatchableSprite), textureNeedsUploading:!1, generatingTexture:!1}, batchableSprite = gpuTextData.batchableSprite;
      batchableSprite.renderable = htmlText;
      batchableSprite.transform = htmlText.groupTransform;
      batchableSprite.texture = Texture.Texture.EMPTY;
      batchableSprite.bounds = {minX:0, maxX:1, minY:0, maxY:0};
      batchableSprite.roundPixels = this._renderer._roundPixels | htmlText._roundPixels;
      htmlText._resolution = htmlText._autoResolution ? this._renderer.resolution : htmlText.resolution;
      this._gpuText[htmlText.uid] = gpuTextData;
      htmlText.on("destroyed", this._destroyRenderableBound);
      return gpuTextData;
    }
    destroy() {
      for (const i in this._gpuText) {
        this._destroyRenderableById(i);
      }
      this._renderer = this._gpuText = null;
    }
  }
  HTMLTextPipe.extension = {type:[global.ExtensionType.WebGLPipes, global.ExtensionType.WebGPUPipes, global.ExtensionType.CanvasPipes], name:"htmlText"};
  exports.HTMLTextPipe = HTMLTextPipe;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$scene$text_html$HTMLTextPipe.js.map
