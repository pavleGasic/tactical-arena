shadow$provide.module$node_modules$earcut$src$earcut = function(global, require, module, exports) {
  function earcut(data, holeIndices, dim) {
    dim = dim || 2;
    var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, !0), triangles = [];
    if (!outerNode || outerNode.next === outerNode.prev) {
      return triangles;
    }
    var maxX;
    if (hasHoles) {
      var outerNode$jscomp$0 = outerNode;
      var y = dim;
      outerNode = [];
      var len;
      hasHoles = 0;
      for (len = holeIndices.length; hasHoles < len; hasHoles++) {
        var start = holeIndices[hasHoles] * y;
        var end = hasHoles < len - 1 ? holeIndices[hasHoles + 1] * y : data.length;
        start = linkedList(data, start, end, y, !1);
        start === start.next && (start.steiner = !0);
        end = outerNode;
        var JSCompiler_temp_const = end.push, p = start, leftmost = start;
        do {
          if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) {
            leftmost = p;
          }
          p = p.next;
        } while (p !== start);
        JSCompiler_temp_const.call(end, leftmost);
      }
      outerNode.sort(compareX);
      for (hasHoles = 0; hasHoles < outerNode.length; hasHoles++) {
        y = void 0;
        holeIndices = outerNode[hasHoles];
        b: {
          len = outerNode$jscomp$0;
          start = holeIndices.x;
          end = holeIndices.y;
          JSCompiler_temp_const = -Infinity;
          do {
            if (end <= len.y && end >= len.next.y && len.next.y !== len.y && (p = len.x + (end - len.y) * (len.next.x - len.x) / (len.next.y - len.y), p <= start && p > JSCompiler_temp_const && (JSCompiler_temp_const = p, y = len.x < len.next.x ? len : len.next, p === start))) {
              break b;
            }
            len = len.next;
          } while (len !== outerNode$jscomp$0);
          if (y) {
            leftmost = y;
            var mx = y.x, my = y.y, tanMin = Infinity;
            len = y;
            do {
              if (start >= len.x && len.x >= mx && start !== len.x && pointInTriangle(end < my ? start : JSCompiler_temp_const, end, mx, my, end < my ? JSCompiler_temp_const : start, end, len.x, len.y)) {
                p = Math.abs(end - len.y) / (start - len.x);
                var JSCompiler_temp;
                if ((JSCompiler_temp = locallyInside(len, holeIndices)) && !(JSCompiler_temp = p < tanMin) && (JSCompiler_temp = p === tanMin) && !(JSCompiler_temp = len.x > y.x) && (JSCompiler_temp = len.x === y.x)) {
                  JSCompiler_temp = y;
                  var p$jscomp$0 = len;
                  JSCompiler_temp = 0 > area(JSCompiler_temp.prev, JSCompiler_temp, p$jscomp$0.prev) && 0 > area(p$jscomp$0.next, JSCompiler_temp, JSCompiler_temp.next);
                }
                JSCompiler_temp && (y = len, tanMin = p);
              }
              len = len.next;
            } while (len !== leftmost);
          } else {
            y = null;
          }
        }
        y && (holeIndices = splitPolygon(y, holeIndices), filterPoints(holeIndices, holeIndices.next), outerNode$jscomp$0 = filterPoints(y, y.next));
      }
      outerNode = outerNode$jscomp$0;
    }
    if (data.length > 80 * dim) {
      var minX = maxX = data[0];
      var minY = hasHoles = data[1];
      for (outerNode$jscomp$0 = dim; outerNode$jscomp$0 < outerLen; outerNode$jscomp$0 += dim) {
        holeIndices = data[outerNode$jscomp$0], y = data[outerNode$jscomp$0 + 1], holeIndices < minX && (minX = holeIndices), y < minY && (minY = y), holeIndices > maxX && (maxX = holeIndices), y > hasHoles && (hasHoles = y);
      }
      maxX = Math.max(maxX - minX, hasHoles - minY);
      maxX = 0 !== maxX ? 32767 / maxX : 0;
    }
    earcutLinked(outerNode, triangles, dim, minX, minY, maxX, 0);
    return triangles;
  }
  function linkedList(data, start, end, dim, clockwise) {
    if (clockwise === 0 < signedArea(data, start, end, dim)) {
      for (clockwise = start; clockwise < end; clockwise += dim) {
        var last = insertNode(clockwise, data[clockwise], data[clockwise + 1], last);
      }
    } else {
      for (clockwise = end - dim; clockwise >= start; clockwise -= dim) {
        last = insertNode(clockwise, data[clockwise], data[clockwise + 1], last);
      }
    }
    last && equals(last, last.next) && (removeNode(last), last = last.next);
    return last;
  }
  function filterPoints(start, end) {
    if (!start) {
      return start;
    }
    end || (end = start);
    do {
      var again = !1;
      if (start.steiner || !equals(start, start.next) && 0 !== area(start.prev, start, start.next)) {
        start = start.next;
      } else {
        removeNode(start);
        start = end = start.prev;
        if (start === start.next) {
          break;
        }
        again = !0;
      }
    } while (again || start !== end);
    return end;
  }
  function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (ear) {
      if (!pass && invSize) {
        var start = ear, p = start;
        do {
          0 === p.z && (p.z = zOrder(p.x, p.y, minX, minY, invSize)), p.prevZ = p.prev, p = p.nextZ = p.next;
        } while (p !== start);
        p.prevZ.nextZ = null;
        p.prevZ = null;
        start = p;
        var i, numMerges, pSize, qSize, inSize = 1;
        do {
          p = start;
          var tail = start = null;
          for (numMerges = 0; p;) {
            numMerges++;
            var q = p;
            for (i = pSize = 0; i < inSize && (pSize++, q = q.nextZ, q); i++) {
            }
            for (qSize = inSize; 0 < pSize || 0 < qSize && q;) {
              0 !== pSize && (0 === qSize || !q || p.z <= q.z) ? (i = p, p = p.nextZ, pSize--) : (i = q, q = q.nextZ, qSize--), tail ? tail.nextZ = i : start = i, i.prevZ = tail, tail = i;
            }
            p = q;
          }
          tail.nextZ = null;
          inSize *= 2;
        } while (1 < numMerges);
      }
      for (start = ear; ear.prev !== ear.next;) {
        p = ear.prev;
        q = ear.next;
        if (invSize) {
          tail = isEarHashed(ear, minX, minY, invSize);
        } else {
          a: {
            tail = ear.prev;
            var b = ear;
            qSize = ear.next;
            if (0 <= area(tail, b, qSize)) {
              tail = !1;
            } else {
              numMerges = tail.x;
              pSize = b.x;
              inSize = qSize.x;
              i = tail.y;
              b = b.y;
              var cy = qSize.y, x0 = numMerges < pSize ? numMerges < inSize ? numMerges : inSize : pSize < inSize ? pSize : inSize, y0 = i < b ? i < cy ? i : cy : b < cy ? b : cy, x1 = numMerges > pSize ? numMerges > inSize ? numMerges : inSize : pSize > inSize ? pSize : inSize, y1 = i > b ? i > cy ? i : cy : b > cy ? b : cy;
              for (qSize = qSize.next; qSize !== tail;) {
                if (qSize.x >= x0 && qSize.x <= x1 && qSize.y >= y0 && qSize.y <= y1 && pointInTriangle(numMerges, i, pSize, b, inSize, cy, qSize.x, qSize.y) && 0 <= area(qSize.prev, qSize, qSize.next)) {
                  tail = !1;
                  break a;
                }
                qSize = qSize.next;
              }
              tail = !0;
            }
          }
        }
        if (tail) {
          triangles.push(p.i / dim | 0), triangles.push(ear.i / dim | 0), triangles.push(q.i / dim | 0), removeNode(ear), start = ear = q.next;
        } else {
          if (ear = q, ear === start) {
            if (!pass) {
              earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
            } else if (1 === pass) {
              ear = filterPoints(ear);
              pass = triangles;
              start = dim;
              p = ear;
              do {
                q = p.prev, tail = p.next.next, !equals(q, tail) && intersects(q, p, p.next, tail) && locallyInside(q, tail) && locallyInside(tail, q) && (pass.push(q.i / start | 0), pass.push(p.i / start | 0), pass.push(tail.i / start | 0), removeNode(p), removeNode(p.next), p = ear = tail), p = p.next;
              } while (p !== ear);
              ear = filterPoints(p);
              earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
            } else if (2 === pass) {
              a: {
                pass = ear;
                do {
                  for (start = pass.next.next; start !== pass.prev;) {
                    if (p = pass.i !== start.i) {
                      p = pass;
                      q = start;
                      if (tail = p.next.i !== q.i && p.prev.i !== q.i) {
                        b: {
                          tail = p;
                          do {
                            if (tail.i !== p.i && tail.next.i !== p.i && tail.i !== q.i && tail.next.i !== q.i && intersects(tail, tail.next, p, q)) {
                              tail = !0;
                              break b;
                            }
                            tail = tail.next;
                          } while (tail !== p);
                          tail = !1;
                        }
                        tail = !tail;
                      }
                      if (tail) {
                        if (tail = locallyInside(p, q) && locallyInside(q, p)) {
                          tail = p;
                          numMerges = !1;
                          pSize = (p.x + q.x) / 2;
                          inSize = (p.y + q.y) / 2;
                          do {
                            tail.y > inSize !== tail.next.y > inSize && tail.next.y !== tail.y && pSize < (tail.next.x - tail.x) * (inSize - tail.y) / (tail.next.y - tail.y) + tail.x && (numMerges = !numMerges), tail = tail.next;
                          } while (tail !== p);
                          tail = numMerges;
                        }
                        tail = tail && (area(p.prev, p, q.prev) || area(p, q.prev, q)) || equals(p, q) && 0 < area(p.prev, p, p.next) && 0 < area(q.prev, q, q.next);
                      }
                      p = tail;
                    }
                    if (p) {
                      ear = splitPolygon(pass, start);
                      pass = filterPoints(pass, pass.next);
                      ear = filterPoints(ear, ear.next);
                      earcutLinked(pass, triangles, dim, minX, minY, invSize, 0);
                      earcutLinked(ear, triangles, dim, minX, minY, invSize, 0);
                      break a;
                    }
                    start = start.next;
                  }
                  pass = pass.next;
                } while (pass !== ear);
              }
            }
            break;
          }
        }
      }
    }
  }
  function isEarHashed(ear, minX, minY, invSize) {
    var a = ear.prev, c = ear.next;
    if (0 <= area(a, ear, c)) {
      return !1;
    }
    var ax = a.x, bx = ear.x, cx = c.x, ay = a.y, by = ear.y, cy = c.y, x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy, minZ = zOrder(x0, y0, minX, minY, invSize);
    minX = zOrder(x1, y1, minX, minY, invSize);
    minY = ear.prevZ;
    for (ear = ear.nextZ; minY && minY.z >= minZ && ear && ear.z <= minX;) {
      if (minY.x >= x0 && minY.x <= x1 && minY.y >= y0 && minY.y <= y1 && minY !== a && minY !== c && pointInTriangle(ax, ay, bx, by, cx, cy, minY.x, minY.y) && 0 <= area(minY.prev, minY, minY.next)) {
        return !1;
      }
      minY = minY.prevZ;
      if (ear.x >= x0 && ear.x <= x1 && ear.y >= y0 && ear.y <= y1 && ear !== a && ear !== c && pointInTriangle(ax, ay, bx, by, cx, cy, ear.x, ear.y) && 0 <= area(ear.prev, ear, ear.next)) {
        return !1;
      }
      ear = ear.nextZ;
    }
    for (; minY && minY.z >= minZ;) {
      if (minY.x >= x0 && minY.x <= x1 && minY.y >= y0 && minY.y <= y1 && minY !== a && minY !== c && pointInTriangle(ax, ay, bx, by, cx, cy, minY.x, minY.y) && 0 <= area(minY.prev, minY, minY.next)) {
        return !1;
      }
      minY = minY.prevZ;
    }
    for (; ear && ear.z <= minX;) {
      if (ear.x >= x0 && ear.x <= x1 && ear.y >= y0 && ear.y <= y1 && ear !== a && ear !== c && pointInTriangle(ax, ay, bx, by, cx, cy, ear.x, ear.y) && 0 <= area(ear.prev, ear, ear.next)) {
        return !1;
      }
      ear = ear.nextZ;
    }
    return !0;
  }
  function compareX(a, b) {
    return a.x - b.x;
  }
  function zOrder(x, y, minX, minY, invSize) {
    x = (x - minX) * invSize | 0;
    y = (y - minY) * invSize | 0;
    x = (x | x << 8) & 16711935;
    x = (x | x << 4) & 252645135;
    x = (x | x << 2) & 858993459;
    y = (y | y << 8) & 16711935;
    y = (y | y << 4) & 252645135;
    y = (y | y << 2) & 858993459;
    return (x | x << 1) & 1431655765 | ((y | y << 1) & 1431655765) << 1;
  }
  function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);
  }
  function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
  }
  function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
  }
  function intersects(p1, q1, p2, q2) {
    var o1 = sign(area(p1, q1, p2)), o2 = sign(area(p1, q1, q2)), o3 = sign(area(p2, q2, p1)), o4 = sign(area(p2, q2, q1));
    return o1 !== o2 && o3 !== o4 || 0 === o1 && onSegment(p1, p2, q1) || 0 === o2 && onSegment(p1, q2, q1) || 0 === o3 && onSegment(p2, p1, q2) || 0 === o4 && onSegment(p2, q1, q2) ? !0 : !1;
  }
  function onSegment(p, q, r) {
    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
  }
  function sign(num) {
    return 0 < num ? 1 : 0 > num ? -1 : 0;
  }
  function locallyInside(a, b) {
    return 0 > area(a.prev, a, a.next) ? 0 <= area(a, b, a.next) && 0 <= area(a, a.prev, b) : 0 > area(a, b, a.prev) || 0 > area(a, a.next, b);
  }
  function splitPolygon(a, b) {
    var a2 = new Node(a.i, a.x, a.y), b2 = new Node(b.i, b.x, b.y), an = a.next, bp = b.prev;
    a.next = b;
    b.prev = a;
    a2.next = an;
    an.prev = a2;
    b2.next = a2;
    a2.prev = b2;
    bp.next = b2;
    b2.prev = bp;
    return b2;
  }
  function insertNode(i, x, y, last) {
    i = new Node(i, x, y);
    last ? (i.next = last.next, i.prev = last, last.next.prev = i, last.next = i) : (i.prev = i, i.next = i);
    return i;
  }
  function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;
    p.prevZ && (p.prevZ.nextZ = p.nextZ);
    p.nextZ && (p.nextZ.prevZ = p.prevZ);
  }
  function Node(i, x, y) {
    this.i = i;
    this.x = x;
    this.y = y;
    this.next = this.prev = null;
    this.z = 0;
    this.nextZ = this.prevZ = null;
    this.steiner = !1;
  }
  function signedArea(data, start, end, dim) {
    for (var sum = 0, j = end - dim; start < end; start += dim) {
      sum += (data[j] - data[start]) * (data[start + 1] + data[j + 1]), j = start;
    }
    return sum;
  }
  module.exports = earcut;
  module.exports.default = earcut;
  earcut.deviation = function(data, holeIndices, dim, triangles) {
    var hasHoles = holeIndices && holeIndices.length, polygonArea = Math.abs(signedArea(data, 0, hasHoles ? holeIndices[0] * dim : data.length, dim));
    if (hasHoles) {
      hasHoles = 0;
      for (var len = holeIndices.length; hasHoles < len; hasHoles++) {
        polygonArea -= Math.abs(signedArea(data, holeIndices[hasHoles] * dim, hasHoles < len - 1 ? holeIndices[hasHoles + 1] * dim : data.length, dim));
      }
    }
    for (hasHoles = holeIndices = 0; hasHoles < triangles.length; hasHoles += 3) {
      len = triangles[hasHoles] * dim;
      var b = triangles[hasHoles + 1] * dim, c = triangles[hasHoles + 2] * dim;
      holeIndices += Math.abs((data[len] - data[c]) * (data[b + 1] - data[len + 1]) - (data[len] - data[b]) * (data[c + 1] - data[len + 1]));
    }
    return 0 === polygonArea && 0 === holeIndices ? 0 : Math.abs((holeIndices - polygonArea) / polygonArea);
  };
  earcut.flatten = function(data) {
    for (var dim = data[0][0].length, result = {vertices:[], holes:[], dimensions:dim}, holeIndex = 0, i = 0; i < data.length; i++) {
      for (var j = 0; j < data[i].length; j++) {
        for (var d = 0; d < dim; d++) {
          result.vertices.push(data[i][j][d]);
        }
      }
      0 < i && (holeIndex += data[i - 1].length, result.holes.push(holeIndex));
    }
    return result;
  };
};

//# sourceMappingURL=module$node_modules$earcut$src$earcut.js.map
