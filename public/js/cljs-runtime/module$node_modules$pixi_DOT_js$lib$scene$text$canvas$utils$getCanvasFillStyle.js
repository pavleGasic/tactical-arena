shadow$provide.module$node_modules$pixi_DOT_js$lib$scene$text$canvas$utils$getCanvasFillStyle = function(global, require, module, exports) {
  var Color = require("module$node_modules$pixi_DOT_js$lib$color$Color"), Matrix = require("module$node_modules$pixi_DOT_js$lib$maths$matrix$Matrix"), Texture = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$texture$Texture"), warn = require("module$node_modules$pixi_DOT_js$lib$utils$logging$warn"), FillGradient = require("module$node_modules$pixi_DOT_js$lib$scene$graphics$shared$fill$FillGradient"), FillPattern = require("module$node_modules$pixi_DOT_js$lib$scene$graphics$shared$fill$FillPattern");
  "use strict";
  exports.getCanvasFillStyle = function(fillStyle, context, textMetrics, padding = 0) {
    if (fillStyle.texture !== Texture.Texture.WHITE || fillStyle.fill) {
      if (fillStyle.fill) {
        if (fillStyle.fill instanceof FillPattern.FillPattern) {
          return textMetrics = fillStyle.fill, context = context.createPattern(textMetrics.texture.source.resource, "repeat"), padding = textMetrics.transform.copyTo(Matrix.Matrix.shared), padding.scale(textMetrics.texture.frame.width, textMetrics.texture.frame.height), context.setTransform(padding), context;
        }
        if (fillStyle.fill instanceof FillGradient.FillGradient) {
          fillStyle = fillStyle.fill;
          const isLinear = "linear" === fillStyle.type, isLocal = "local" === fillStyle.textureSpace;
          let width = 1, height = 1;
          isLocal && textMetrics && (width = textMetrics.width + padding, height = textMetrics.height + padding);
          let gradient, isNearlyVertical = !1;
          if (isLinear) {
            const {start, end} = fillStyle;
            gradient = context.createLinearGradient(start.x * width, start.y * height, end.x * width, end.y * height);
            isNearlyVertical = Math.abs(end.x - start.x) < Math.abs(0.1 * (end.y - start.y));
          } else {
            const {center, innerRadius, outerCenter, outerRadius} = fillStyle;
            gradient = context.createRadialGradient(center.x * width, center.y * height, innerRadius * width, outerCenter.x * width, outerCenter.y * height, outerRadius * width);
          }
          if (isNearlyVertical && isLocal && textMetrics) {
            const ratio = textMetrics.lineHeight / height;
            for (context = 0; context < textMetrics.lines.length; context++) {
              const start = (context * textMetrics.lineHeight + padding / 2) / height;
              fillStyle.colorStops.forEach(stop => {
                gradient.addColorStop(Math.floor(1e5 * (start + stop.offset * ratio)) / 1e5, Color.Color.shared.setValue(stop.color).toHex());
              });
            }
          } else {
            fillStyle.colorStops.forEach(stop => {
              gradient.addColorStop(stop.offset, Color.Color.shared.setValue(stop.color).toHex());
            });
          }
          return gradient;
        }
      } else {
        return context = context.createPattern(fillStyle.texture.source.resource, "repeat"), textMetrics = fillStyle.matrix.copyTo(Matrix.Matrix.shared), textMetrics.scale(fillStyle.texture.frame.width, fillStyle.texture.frame.height), context.setTransform(textMetrics), context;
      }
    } else {
      return Color.Color.shared.setValue(fillStyle.color).setAlpha(fillStyle.alpha ?? 1).toHexa();
    }
    warn.warn("FillStyle not recognised", fillStyle);
    return "red";
  };
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$scene$text$canvas$utils$getCanvasFillStyle.js.map
