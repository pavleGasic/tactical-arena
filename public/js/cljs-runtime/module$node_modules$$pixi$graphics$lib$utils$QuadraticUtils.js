shadow$provide.module$node_modules$$pixi$graphics$lib$utils$QuadraticUtils = function(global, require, module, exports) {
  var _const = require("module$node_modules$$pixi$graphics$lib$const");
  class QuadraticUtils {
    static curveLength(fromX, fromY, cpX, cpY, toX, toY) {
      toX = fromX - 2 * cpX + toX;
      toY = fromY - 2 * cpY + toY;
      fromX = 2 * cpX - 2 * fromX;
      cpY = 2 * cpY - 2 * fromY;
      fromY = 4 * (toX * toX + toY * toY);
      toX = 4 * (toX * fromX + toY * cpY);
      cpY = fromX * fromX + cpY * cpY;
      toY = 2 * Math.sqrt(fromY + toX + cpY);
      fromX = Math.sqrt(fromY);
      cpX = 2 * fromY * fromX;
      const c2 = 2 * Math.sqrt(cpY), ba = toX / fromX;
      return (cpX * toY + fromX * toX * (toY - c2) + (4 * cpY * fromY - toX * toX) * Math.log((2 * fromX + ba + toY) / (ba + c2))) / (4 * cpX);
    }
    static curveTo(cpX, cpY, toX, toY, points) {
      const fromX = points[points.length - 2], fromY = points[points.length - 1], n = _const.curves._segmentsCount(QuadraticUtils.curveLength(fromX, fromY, cpX, cpY, toX, toY));
      let xa, ya;
      for (let i = 1; i <= n; ++i) {
        const j = i / n;
        xa = fromX + (cpX - fromX) * j;
        ya = fromY + (cpY - fromY) * j;
        points.push(xa + (cpX + (toX - cpX) * j - xa) * j, ya + (cpY + (toY - cpY) * j - ya) * j);
      }
    }
  }
  exports.QuadraticUtils = QuadraticUtils;
};

//# sourceMappingURL=module$node_modules$$pixi$graphics$lib$utils$QuadraticUtils.js.map
