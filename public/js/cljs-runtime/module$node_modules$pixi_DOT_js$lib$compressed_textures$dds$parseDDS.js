shadow$provide.module$node_modules$pixi_DOT_js$lib$compressed_textures$dds$parseDDS = function(global, require, module, exports) {
  function getUncompressedTextureFormat(header) {
    const bitCount = header[_const.DDS.HEADER_FIELDS.RGB_BITCOUNT], rBitMask = header[_const.DDS.HEADER_FIELDS.R_BIT_MASK], gBitMask = header[_const.DDS.HEADER_FIELDS.G_BIT_MASK], bBitMask = header[_const.DDS.HEADER_FIELDS.B_BIT_MASK];
    header = header[_const.DDS.HEADER_FIELDS.A_BIT_MASK];
    switch(bitCount) {
      case 32:
        if (255 === rBitMask && 65280 === gBitMask && 16711680 === bBitMask && 4278190080 === header) {
          return _const.DXGI_TO_TEXTURE_FORMAT[_const.DDS.DXGI_FORMAT.DXGI_FORMAT_R8G8B8A8_UNORM];
        }
        if (16711680 === rBitMask && 65280 === gBitMask && 255 === bBitMask && 4278190080 === header) {
          return _const.DXGI_TO_TEXTURE_FORMAT[_const.DDS.DXGI_FORMAT.DXGI_FORMAT_B8G8R8A8_UNORM];
        }
        if (1072693248 === rBitMask && 1047552 === gBitMask && 1023 === bBitMask && 3221225472 === header) {
          return _const.DXGI_TO_TEXTURE_FORMAT[_const.DDS.DXGI_FORMAT.DXGI_FORMAT_R10G10B10A2_UNORM];
        }
        if (65535 === rBitMask && 4294901760 === gBitMask && 0 === bBitMask && 0 === header) {
          return _const.DXGI_TO_TEXTURE_FORMAT[_const.DDS.DXGI_FORMAT.DXGI_FORMAT_R16G16_UNORM];
        }
        if (4294967295 === rBitMask && 0 === gBitMask && 0 === bBitMask && 0 === header) {
          return _const.DXGI_TO_TEXTURE_FORMAT[_const.DDS.DXGI_FORMAT.DXGI_FORMAT_R32_FLOAT];
        }
        break;
      case 16:
        if (31744 === rBitMask && 992 === gBitMask && 31 === bBitMask && 32768 === header) {
          return _const.DXGI_TO_TEXTURE_FORMAT[_const.DDS.DXGI_FORMAT.DXGI_FORMAT_B5G5R5A1_UNORM];
        }
        if (63488 === rBitMask && 2016 === gBitMask && 31 === bBitMask && 0 === header) {
          return _const.DXGI_TO_TEXTURE_FORMAT[_const.DDS.DXGI_FORMAT.DXGI_FORMAT_B5G6R5_UNORM];
        }
        if (3840 === rBitMask && 240 === gBitMask && 15 === bBitMask && 61440 === header) {
          return _const.DXGI_TO_TEXTURE_FORMAT[_const.DDS.DXGI_FORMAT.DXGI_FORMAT_B4G4R4A4_UNORM];
        }
        if (255 === rBitMask && 0 === gBitMask && 0 === bBitMask && 65280 === header) {
          return _const.DXGI_TO_TEXTURE_FORMAT[_const.DDS.DXGI_FORMAT.DXGI_FORMAT_R8G8_UNORM];
        }
        if (65535 === rBitMask && 0 === gBitMask && 0 === bBitMask && 0 === header) {
          return _const.DXGI_TO_TEXTURE_FORMAT[_const.DDS.DXGI_FORMAT.DXGI_FORMAT_R16_UNORM];
        }
        break;
      case 8:
        if (255 === rBitMask && 0 === gBitMask && 0 === bBitMask && 0 === header) {
          return _const.DXGI_TO_TEXTURE_FORMAT[_const.DDS.DXGI_FORMAT.DXGI_FORMAT_R8_UNORM];
        }
    }
    throw Error(`DDSParser does not support uncompressed texture with configuration:
                bitCount = ${bitCount}, rBitMask = ${rBitMask}, gBitMask = ${gBitMask}, aBitMask = ${header}`);
  }
  var _const = require("module$node_modules$pixi_DOT_js$lib$compressed_textures$dds$const");
  "use strict";
  exports.parseDDS = function(arrayBuffer, supportedFormats) {
    var header = new Uint32Array(arrayBuffer, 0, _const.DDS.HEADER_SIZE / Uint32Array.BYTES_PER_ELEMENT);
    if (header[_const.DDS.HEADER_FIELDS.MAGIC] !== _const.DDS.MAGIC_VALUE) {
      throw Error("Invalid magic number in DDS header");
    }
    var height = header[_const.DDS.HEADER_FIELDS.HEIGHT], width = header[_const.DDS.HEADER_FIELDS.WIDTH], mipmapCount$jscomp$0 = Math.max(1, header[_const.DDS.HEADER_FIELDS.MIPMAP_COUNT]), fourCC$jscomp$0 = header[_const.DDS.HEADER_FIELDS.FOURCC];
    a: {
      var flags = header[_const.DDS.HEADER_FIELDS.PF_FLAGS];
      if (flags & _const.DDS.PIXEL_FORMAT_FLAGS.FOURCC) {
        if (fourCC$jscomp$0 === _const.DDS.D3DFMT.DX10) {
          header = new Uint32Array(arrayBuffer, _const.DDS.MAGIC_SIZE + _const.DDS.HEADER_SIZE, _const.DDS.HEADER_DX10_SIZE / Uint32Array.BYTES_PER_ELEMENT);
          if (header[_const.DDS.HEADER_DX10_FIELDS.MISC_FLAG] === _const.DDS.RESOURCE_MISC_TEXTURECUBE) {
            throw Error("DDSParser does not support cubemap textures");
          }
          if (header[_const.DDS.HEADER_DX10_FIELDS.RESOURCE_DIMENSION] === _const.DDS.D3D10_RESOURCE_DIMENSION.DDS_DIMENSION_TEXTURE3D) {
            throw Error("DDSParser does not supported 3D texture data");
          }
          header = header[_const.DDS.HEADER_DX10_FIELDS.DXGI_FORMAT];
          if (header in _const.DXGI_TO_TEXTURE_FORMAT) {
            header = _const.DXGI_TO_TEXTURE_FORMAT[header];
            break a;
          }
          throw Error(`DDSParser cannot parse texture data with DXGI format ${header}`);
        }
        if (fourCC$jscomp$0 in _const.FOURCC_TO_TEXTURE_FORMAT) {
          header = _const.FOURCC_TO_TEXTURE_FORMAT[fourCC$jscomp$0];
          break a;
        }
        throw Error(`DDSParser cannot parse texture data with fourCC format ${fourCC$jscomp$0}`);
      }
      if (flags & _const.DDS.PIXEL_FORMAT_FLAGS.RGB || flags & _const.DDS.PIXEL_FORMAT_FLAGS.RGBA) {
        header = getUncompressedTextureFormat(header);
      } else {
        if (flags & _const.DDS.PIXEL_FORMAT_FLAGS.YUV) {
          throw Error("DDSParser does not supported YUV uncompressed texture data.");
        }
        if (flags & _const.DDS.PIXEL_FORMAT_FLAGS.LUMINANCE || flags & _const.DDS.PIXEL_FORMAT_FLAGS.LUMINANCEA) {
          throw Error("DDSParser does not support single-channel (lumninance) texture data!");
        }
        if (flags & _const.DDS.PIXEL_FORMAT_FLAGS.ALPHA || flags & _const.DDS.PIXEL_FORMAT_FLAGS.ALPHAPIXELS) {
          throw Error("DDSParser does not support single-channel (alpha) texture data!");
        }
        throw Error("DDSParser failed to load a texture file due to an unknown reason!");
      }
    }
    const {format, fourCC, width:width$jscomp$0, height:height$jscomp$0, dataOffset, mipmapCount} = {format:header, fourCC:fourCC$jscomp$0, width, height, dataOffset:_const.DDS.MAGIC_SIZE + _const.DDS.HEADER_SIZE + (fourCC$jscomp$0 === _const.DDS.D3DFMT.DX10 ? _const.DDS.HEADER_DX10_SIZE : 0), mipmapCount:mipmapCount$jscomp$0};
    if (!supportedFormats.includes(format)) {
      throw Error(`Unsupported texture format: ${fourCC} ${format}, supported: ${supportedFormats}`);
    }
    if (1 >= mipmapCount) {
      return {format, width:width$jscomp$0, height:height$jscomp$0, resource:[new Uint8Array(arrayBuffer, dataOffset)], alphaMode:"no-premultiply-alpha"};
    }
    supportedFormats = [];
    height = _const.TEXTURE_FORMAT_BLOCK_SIZE[format];
    width = width$jscomp$0;
    mipmapCount$jscomp$0 = height$jscomp$0;
    fourCC$jscomp$0 = dataOffset;
    for (header = 0; header < mipmapCount; ++header) {
      flags = 4 * Math.ceil(Math.max(4, width) / 4);
      var alignedHeight = 4 * Math.ceil(Math.max(4, mipmapCount$jscomp$0) / 4);
      flags = height ? flags / 4 * alignedHeight / 4 * height : width * mipmapCount$jscomp$0 * 4;
      alignedHeight = new Uint8Array(arrayBuffer, fourCC$jscomp$0, flags);
      supportedFormats.push(alignedHeight);
      fourCC$jscomp$0 += flags;
      width = Math.max(width >> 1, 1);
      mipmapCount$jscomp$0 = Math.max(mipmapCount$jscomp$0 >> 1, 1);
    }
    return {format, width:width$jscomp$0, height:height$jscomp$0, resource:supportedFormats, alphaMode:"no-premultiply-alpha"};
  };
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$compressed_textures$dds$parseDDS.js.map
