shadow$provide.module$node_modules$$pixi$sprite_tiling$lib$TilingSprite = function(global, require, module, exports) {
  var core = require("module$node_modules$$pixi$core$lib$index");
  global = require("module$node_modules$$pixi$sprite$lib$index");
  const tempPoint = new core.Point();
  class TilingSprite extends global.Sprite {
    constructor(texture, width = 100, height = 100) {
      super(texture);
      this.tileTransform = new core.Transform();
      this._width = width;
      this._height = height;
      this.uvMatrix = this.texture.uvMatrix || new core.TextureMatrix(texture);
      this.pluginName = "tilingSprite";
      this.uvRespectAnchor = !1;
    }
    get clampMargin() {
      return this.uvMatrix.clampMargin;
    }
    set clampMargin(value) {
      this.uvMatrix.clampMargin = value;
      this.uvMatrix.update(!0);
    }
    get tileScale() {
      return this.tileTransform.scale;
    }
    set tileScale(value) {
      this.tileTransform.scale.copyFrom(value);
    }
    get tilePosition() {
      return this.tileTransform.position;
    }
    set tilePosition(value) {
      this.tileTransform.position.copyFrom(value);
    }
    _onTextureUpdate() {
      this.uvMatrix && (this.uvMatrix.texture = this._texture);
      this._cachedTint = 16777215;
    }
    _render(renderer) {
      const texture = this._texture;
      texture && texture.valid && (this.tileTransform.updateLocalTransform(), this.uvMatrix.update(), renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]), renderer.plugins[this.pluginName].render(this));
    }
    _calculateBounds() {
      this._bounds.addFrame(this.transform, this._width * -this._anchor._x, this._height * -this._anchor._y, this._width * (1 - this._anchor._x), this._height * (1 - this._anchor._y));
    }
    getLocalBounds(rect) {
      return 0 === this.children.length ? (this._bounds.minX = this._width * -this._anchor._x, this._bounds.minY = this._height * -this._anchor._y, this._bounds.maxX = this._width * (1 - this._anchor._x), this._bounds.maxY = this._height * (1 - this._anchor._y), rect || (this._localBoundsRect || (this._localBoundsRect = new core.Rectangle()), rect = this._localBoundsRect), this._bounds.getRectangle(rect)) : super.getLocalBounds.call(this, rect);
    }
    containsPoint(point) {
      this.worldTransform.applyInverse(point, tempPoint);
      var width = this._width;
      point = this._height;
      const x1 = -width * this.anchor._x;
      return tempPoint.x >= x1 && tempPoint.x < x1 + width && (width = -point * this.anchor._y, tempPoint.y >= width && tempPoint.y < width + point) ? !0 : !1;
    }
    destroy(options) {
      super.destroy(options);
      this.uvMatrix = this.tileTransform = null;
    }
    static from(source, options) {
      source = source instanceof core.Texture ? source : core.Texture.from(source, options);
      return new TilingSprite(source, options.width, options.height);
    }
    get width() {
      return this._width;
    }
    set width(value) {
      this._width = value;
    }
    get height() {
      return this._height;
    }
    set height(value) {
      this._height = value;
    }
  }
  exports.TilingSprite = TilingSprite;
};

//# sourceMappingURL=module$node_modules$$pixi$sprite_tiling$lib$TilingSprite.js.map
