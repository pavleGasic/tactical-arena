shadow$provide.module$node_modules$pixi_DOT_js$lib$rendering$renderers$gpu$GpuEncoderSystem = function(global, require, module, exports) {
  global = require("module$node_modules$pixi_DOT_js$lib$extensions$Extensions");
  "use strict";
  class GpuEncoderSystem {
    constructor(renderer) {
      this._boundBindGroup = Object.create(null);
      this._boundVertexBuffer = Object.create(null);
      this._renderer = renderer;
    }
    renderStart() {
      this.commandFinished = new Promise(resolve => {
        this._resolveCommandFinished = resolve;
      });
      this.commandEncoder = this._renderer.gpu.device.createCommandEncoder();
    }
    beginRenderPass(gpuRenderTarget) {
      this.endRenderPass();
      this._clearCache();
      this.renderPassEncoder = this.commandEncoder.beginRenderPass(gpuRenderTarget.descriptor);
    }
    endRenderPass() {
      this.renderPassEncoder && this.renderPassEncoder.end();
      this.renderPassEncoder = null;
    }
    setViewport(viewport) {
      this.renderPassEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);
    }
    setPipelineFromGeometryProgramAndState(geometry, program, state, topology) {
      geometry = this._renderer.pipeline.getPipeline(geometry, program, state, topology);
      this.setPipeline(geometry);
    }
    setPipeline(pipeline) {
      this._boundPipeline !== pipeline && (this._boundPipeline = pipeline, this.renderPassEncoder.setPipeline(pipeline));
    }
    _setVertexBuffer(index, buffer) {
      this._boundVertexBuffer[index] !== buffer && (this._boundVertexBuffer[index] = buffer, this.renderPassEncoder.setVertexBuffer(index, this._renderer.buffer.updateBuffer(buffer)));
    }
    _setIndexBuffer(buffer) {
      if (this._boundIndexBuffer !== buffer) {
        this._boundIndexBuffer = buffer;
        var indexFormat = 2 === buffer.data.BYTES_PER_ELEMENT ? "uint16" : "uint32";
        this.renderPassEncoder.setIndexBuffer(this._renderer.buffer.updateBuffer(buffer), indexFormat);
      }
    }
    resetBindGroup(index) {
      this._boundBindGroup[index] = null;
    }
    setBindGroup(index, bindGroup, program) {
      this._boundBindGroup[index] !== bindGroup && (this._boundBindGroup[index] = bindGroup, bindGroup._touch(this._renderer.textureGC.count), bindGroup = this._renderer.bindGroup.getBindGroup(bindGroup, program, index), this.renderPassEncoder.setBindGroup(index, bindGroup));
    }
    setGeometry(geometry, program) {
      program = this._renderer.pipeline.getBufferNamesToBind(geometry, program);
      for (const i in program) {
        this._setVertexBuffer(i, geometry.attributes[program[i]].buffer);
      }
      geometry.indexBuffer && this._setIndexBuffer(geometry.indexBuffer);
    }
    _setShaderBindGroups(shader, skipSync) {
      for (const i in shader.groups) {
        const bindGroup = shader.groups[i];
        skipSync || this._syncBindGroup(bindGroup);
        this.setBindGroup(i, bindGroup, shader.gpuProgram);
      }
    }
    _syncBindGroup(bindGroup) {
      for (const j in bindGroup.resources) {
        const resource = bindGroup.resources[j];
        resource.isUniformGroup && this._renderer.ubo.updateUniformGroup(resource);
      }
    }
    draw(options) {
      const {geometry, shader, state, topology, size, start, instanceCount, skipSync} = options;
      this.setPipelineFromGeometryProgramAndState(geometry, shader.gpuProgram, state, topology);
      this.setGeometry(geometry, shader.gpuProgram);
      this._setShaderBindGroups(shader, skipSync);
      geometry.indexBuffer ? this.renderPassEncoder.drawIndexed(size || geometry.indexBuffer.data.length, instanceCount ?? geometry.instanceCount, start || 0) : this.renderPassEncoder.draw(size || geometry.getSize(), instanceCount ?? geometry.instanceCount, start || 0);
    }
    finishRenderPass() {
      this.renderPassEncoder && (this.renderPassEncoder.end(), this.renderPassEncoder = null);
    }
    postrender() {
      this.finishRenderPass();
      this._gpu.device.queue.submit([this.commandEncoder.finish()]);
      this._resolveCommandFinished();
      this.commandEncoder = null;
    }
    restoreRenderPass() {
      var descriptor = this._renderer.renderTarget.adaptor.getDescriptor(this._renderer.renderTarget.renderTarget, !1, [0, 0, 0, 1]);
      this.renderPassEncoder = this.commandEncoder.beginRenderPass(descriptor);
      descriptor = this._boundPipeline;
      const boundVertexBuffer = {...this._boundVertexBuffer}, boundIndexBuffer = this._boundIndexBuffer, boundBindGroup = {...this._boundBindGroup};
      this._clearCache();
      const viewport = this._renderer.renderTarget.viewport;
      this.renderPassEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);
      this.setPipeline(descriptor);
      for (const i in boundVertexBuffer) {
        this._setVertexBuffer(i, boundVertexBuffer[i]);
      }
      for (const i in boundBindGroup) {
        this.setBindGroup(i, boundBindGroup[i], null);
      }
      this._setIndexBuffer(boundIndexBuffer);
    }
    _clearCache() {
      for (let i = 0; 16 > i; i++) {
        this._boundBindGroup[i] = null, this._boundVertexBuffer[i] = null;
      }
      this._boundPipeline = this._boundIndexBuffer = null;
    }
    destroy() {
      this._boundPipeline = this._boundIndexBuffer = this._boundVertexBuffer = this._boundBindGroup = this._gpu = this._renderer = null;
    }
    contextChange(gpu) {
      this._gpu = gpu;
    }
  }
  GpuEncoderSystem.extension = {type:[global.ExtensionType.WebGPUSystem], name:"encoder", priority:1};
  exports.GpuEncoderSystem = GpuEncoderSystem;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$rendering$renderers$gpu$GpuEncoderSystem.js.map
