shadow$provide.module$node_modules$pixi_DOT_js$lib$compressed_textures$ktx$loadKTX = function(global, require, module, exports) {
  global = require("module$node_modules$pixi_DOT_js$lib$assets$loader$parsers$LoaderParser");
  var createTexture = require("module$node_modules$pixi_DOT_js$lib$assets$loader$parsers$textures$utils$createTexture"), checkExtension = require("module$node_modules$pixi_DOT_js$lib$assets$utils$checkExtension");
  module = require("module$node_modules$pixi_DOT_js$lib$extensions$Extensions");
  var CompressedSource = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$texture$sources$CompressedSource"), getSupportedTextureFormats = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$texture$utils$getSupportedTextureFormats"), parseKTX = require("module$node_modules$pixi_DOT_js$lib$compressed_textures$ktx$parseKTX");
  "use strict";
  exports.loadKTX = {extension:{type:module.ExtensionType.LoadParser, priority:global.LoaderParserPriority.High, name:"loadKTX"}, name:"loadKTX", test(url) {
    return checkExtension.checkExtension(url, ".ktx");
  }, async load(url, _asset, loader) {
    _asset = await getSupportedTextureFormats.getSupportedTextureFormats();
    const ktxArrayBuffer = await (await fetch(url)).arrayBuffer();
    _asset = parseKTX.parseKTX(ktxArrayBuffer, _asset);
    _asset = new CompressedSource.CompressedSource(_asset);
    return createTexture.createTexture(_asset, loader, url);
  }, unload(texture) {
    Array.isArray(texture) ? texture.forEach(t => t.destroy(!0)) : texture.destroy(!0);
  }};
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$compressed_textures$ktx$loadKTX.js.map
