shadow$provide.module$node_modules$pixi_DOT_js$lib$filters$mask$mask_wgsl = function(global, require, module, exports) {
  Object.defineProperty(exports, "__esModule", {value:!0});
  exports.default = "struct GlobalFilterUniforms {\n  uInputSize:vec4\x3cf32\x3e,\n  uInputPixel:vec4\x3cf32\x3e,\n  uInputClamp:vec4\x3cf32\x3e,\n  uOutputFrame:vec4\x3cf32\x3e,\n  uGlobalFrame:vec4\x3cf32\x3e,\n  uOutputTexture:vec4\x3cf32\x3e,\n};\n\nstruct MaskUniforms {\n  uFilterMatrix:mat3x3\x3cf32\x3e,\n  uMaskClamp:vec4\x3cf32\x3e,\n  uAlpha:f32,\n  uInverse:f32,\n};\n\n@group(0) @binding(0) var\x3cuniform\x3e gfu: GlobalFilterUniforms;\n@group(0) @binding(1) var uTexture: texture_2d\x3cf32\x3e;\n@group(0) @binding(2) var uSampler : sampler;\n\n@group(1) @binding(0) var\x3cuniform\x3e filterUniforms : MaskUniforms;\n@group(1) @binding(1) var uMaskTexture: texture_2d\x3cf32\x3e;\n\nstruct VSOutput {\n    @builtin(position) position: vec4\x3cf32\x3e,\n    @location(0) uv : vec2\x3cf32\x3e,\n    @location(1) filterUv : vec2\x3cf32\x3e,\n};\n\nfn filterVertexPosition(aPosition:vec2\x3cf32\x3e) -\x3e vec4\x3cf32\x3e\n{\n    var position \x3d aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\n\n    position.x \x3d position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\n    position.y \x3d position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\n\n    return vec4(position, 0.0, 1.0);\n}\n\nfn filterTextureCoord( aPosition:vec2\x3cf32\x3e ) -\x3e vec2\x3cf32\x3e\n{\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\n}\n\nfn globalTextureCoord( aPosition:vec2\x3cf32\x3e ) -\x3e vec2\x3cf32\x3e\n{\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);\n}\n\nfn getFilterCoord(aPosition:vec2\x3cf32\x3e ) -\x3e vec2\x3cf32\x3e\n{\n  return ( filterUniforms.uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\n}\n\nfn getSize() -\x3e vec2\x3cf32\x3e\n{\n  return gfu.uGlobalFrame.zw;\n}\n\n@vertex\nfn mainVertex(\n  @location(0) aPosition : vec2\x3cf32\x3e,\n) -\x3e VSOutput {\n  return VSOutput(\n   filterVertexPosition(aPosition),\n   filterTextureCoord(aPosition),\n   getFilterCoord(aPosition)\n  );\n}\n\n@fragment\nfn mainFragment(\n  @location(0) uv: vec2\x3cf32\x3e,\n  @location(1) filterUv: vec2\x3cf32\x3e,\n  @builtin(position) position: vec4\x3cf32\x3e\n) -\x3e @location(0) vec4\x3cf32\x3e {\n\n    var maskClamp \x3d filterUniforms.uMaskClamp;\n    var uAlpha \x3d filterUniforms.uAlpha;\n\n    var clip \x3d step(3.5,\n      step(maskClamp.x, filterUv.x) +\n      step(maskClamp.y, filterUv.y) +\n      step(filterUv.x, maskClamp.z) +\n      step(filterUv.y, maskClamp.w));\n\n    var mask \x3d textureSample(uMaskTexture, uSampler, filterUv);\n    var source \x3d textureSample(uTexture, uSampler, uv);\n    var alphaMul \x3d 1.0 - uAlpha * (1.0 - mask.a);\n\n    var a: f32 \x3d alphaMul * mask.r * uAlpha * clip;\n\n    if (filterUniforms.uInverse \x3d\x3d 1.0) {\n        a \x3d 1.0 - a;\n    }\n\n    return source * a;\n}\n";
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$filters$mask$mask_wgsl.js.map
