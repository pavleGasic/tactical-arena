shadow$provide.module$node_modules$$pixi$compressed_textures$lib$loaders$loadKTX = function(global, require, module, exports) {
  var assets = require("module$node_modules$$pixi$assets$lib$index"), core = require("module$node_modules$$pixi$core$lib$index");
  require("module$node_modules$$pixi$compressed_textures$lib$parsers$index");
  var parseKTX = require("module$node_modules$$pixi$compressed_textures$lib$parsers$parseKTX");
  global = {extension:{type:core.ExtensionType.LoadParser, priority:assets.LoaderParserPriority.High}, name:"loadKTX", test(url) {
    return assets.checkExtension(url, ".ktx");
  }, async load(url, asset, loader) {
    const arrayBuffer = await (await core.settings.ADAPTER.fetch(url)).arrayBuffer(), {compressed, uncompressed, kvData} = parseKTX.parseKTX(url, arrayBuffer), resources = compressed ?? uncompressed, options = {mipmap:core.MIPMAP_MODES.OFF, alphaMode:core.ALPHA_MODES.NO_PREMULTIPLIED_ALPHA, resolution:core.utils.getResolutionOfUrl(url), ...asset.data};
    asset = resources.map(resource => {
      resources === uncompressed && Object.assign(options, {type:resource.type, format:resource.format});
      resource = new core.BaseTexture(resource.resource ?? resource, options);
      return resource.ktxKeyValueData = kvData, assets.createTexture(resource, loader, url);
    });
    return 1 === asset.length ? asset[0] : asset;
  }, unload(texture) {
    Array.isArray(texture) ? texture.forEach(t => t.destroy(!0)) : texture.destroy(!0);
  }};
  core.extensions.add(global);
  exports.loadKTX = global;
};

//# sourceMappingURL=module$node_modules$$pixi$compressed_textures$lib$loaders$loadKTX.js.map
