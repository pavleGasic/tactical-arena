shadow$provide.module$node_modules$$pixi$events$lib$EventBoundary = function(global, require, module, exports) {
  var core = require("module$node_modules$$pixi$core$lib$index"), EventTicker = require("module$node_modules$$pixi$events$lib$EventTicker"), FederatedMouseEvent = require("module$node_modules$$pixi$events$lib$FederatedMouseEvent"), FederatedPointerEvent = require("module$node_modules$$pixi$events$lib$FederatedPointerEvent"), FederatedWheelEvent = require("module$node_modules$$pixi$events$lib$FederatedWheelEvent");
  const tempHitLocation = new core.Point(), tempLocalMapping = new core.Point();
  class EventBoundary {
    constructor(rootTarget) {
      this.dispatch = new core.utils.EventEmitter();
      this.moveOnAll = !1;
      this.enableGlobalMoveEvents = !0;
      this.mappingState = {trackingData:{}};
      this.eventPool = new Map();
      this._allInteractiveElements = [];
      this._hitElements = [];
      this._isPointerMoveEvent = !1;
      this.rootTarget = rootTarget;
      this.hitPruneFn = this.hitPruneFn.bind(this);
      this.hitTestFn = this.hitTestFn.bind(this);
      this.mapPointerDown = this.mapPointerDown.bind(this);
      this.mapPointerMove = this.mapPointerMove.bind(this);
      this.mapPointerOut = this.mapPointerOut.bind(this);
      this.mapPointerOver = this.mapPointerOver.bind(this);
      this.mapPointerUp = this.mapPointerUp.bind(this);
      this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this);
      this.mapWheel = this.mapWheel.bind(this);
      this.mappingTable = {};
      this.addEventMapping("pointerdown", this.mapPointerDown);
      this.addEventMapping("pointermove", this.mapPointerMove);
      this.addEventMapping("pointerout", this.mapPointerOut);
      this.addEventMapping("pointerleave", this.mapPointerOut);
      this.addEventMapping("pointerover", this.mapPointerOver);
      this.addEventMapping("pointerup", this.mapPointerUp);
      this.addEventMapping("pointerupoutside", this.mapPointerUpOutside);
      this.addEventMapping("wheel", this.mapWheel);
    }
    addEventMapping(type, fn) {
      this.mappingTable[type] || (this.mappingTable[type] = []);
      this.mappingTable[type].push({fn, priority:0});
      this.mappingTable[type].sort((a, b) => a.priority - b.priority);
    }
    dispatchEvent(e, type) {
      e.propagationStopped = !1;
      e.propagationImmediatelyStopped = !1;
      this.propagate(e, type);
      this.dispatch.emit(type || e.type, e);
    }
    mapEvent(e) {
      if (this.rootTarget) {
        var mappers = this.mappingTable[e.type];
        if (mappers) {
          for (let i = 0, j = mappers.length; i < j; i++) {
            mappers[i].fn(e);
          }
        } else {
          console.warn(`[EventBoundary]: Event mapping not defined for ${e.type}`);
        }
      }
    }
    hitTest(x, y) {
      EventTicker.EventsTicker.pauseUpdate = !0;
      return (x = this[this._isPointerMoveEvent && this.enableGlobalMoveEvents ? "hitTestMoveRecursive" : "hitTestRecursive"](this.rootTarget, this.rootTarget.eventMode, tempHitLocation.set(x, y), this.hitTestFn, this.hitPruneFn)) && x[0];
    }
    propagate(e, type) {
      if (e.target) {
        var composedPath = e.composedPath();
        e.eventPhase = e.CAPTURING_PHASE;
        for (let i = 0, j = composedPath.length - 1; i < j; i++) {
          if (e.currentTarget = composedPath[i], this.notifyTarget(e, type), e.propagationStopped || e.propagationImmediatelyStopped) {
            return;
          }
        }
        if (e.eventPhase = e.AT_TARGET, e.currentTarget = e.target, this.notifyTarget(e, type), !e.propagationStopped && !e.propagationImmediatelyStopped) {
          e.eventPhase = e.BUBBLING_PHASE;
          for (let i = composedPath.length - 2; 0 <= i && (e.currentTarget = composedPath[i], this.notifyTarget(e, type), !e.propagationStopped && !e.propagationImmediatelyStopped); i--) {
          }
        }
      }
    }
    all(e, type, targets = this._allInteractiveElements) {
      if (0 !== targets.length) {
        e.eventPhase = e.BUBBLING_PHASE;
        type = Array.isArray(type) ? type : [type];
        for (let i = targets.length - 1; 0 <= i; i--) {
          type.forEach(event => {
            e.currentTarget = targets[i];
            this.notifyTarget(e, event);
          });
        }
      }
    }
    propagationPath(target) {
      const propagationPath = [target];
      for (let i = 0; 2048 > i && target !== this.rootTarget; i++) {
        if (!target.parent) {
          throw Error("Cannot find propagation path to disconnected target");
        }
        propagationPath.push(target.parent);
        target = target.parent;
      }
      return propagationPath.reverse(), propagationPath;
    }
    hitTestMoveRecursive(currentTarget, eventMode, location, testFn, pruneFn, ignore = !1) {
      var shouldReturn = !1;
      if (this._interactivePrune(currentTarget)) {
        return null;
      }
      if (("dynamic" === currentTarget.eventMode || "dynamic" === eventMode) && (EventTicker.EventsTicker.pauseUpdate = !1), currentTarget.interactiveChildren && currentTarget.children) {
        var children = currentTarget.children;
        for (let i = children.length - 1; 0 <= i; i--) {
          var child = children[i];
          !(child = this.hitTestMoveRecursive(child, this._isInteractive(eventMode) ? eventMode : child.eventMode, location, testFn, pruneFn, ignore || pruneFn(currentTarget, location))) || 0 < child.length && !child[child.length - 1].parent || (shouldReturn = currentTarget.isInteractive(), (0 < child.length || shouldReturn) && (shouldReturn && this._allInteractiveElements.push(currentTarget), child.push(currentTarget)), 0 === this._hitElements.length && (this._hitElements = child), shouldReturn = 
          !0);
        }
      }
      eventMode = this._isInteractive(eventMode);
      children = currentTarget.isInteractive();
      return eventMode && children && this._allInteractiveElements.push(currentTarget), ignore || 0 < this._hitElements.length ? null : shouldReturn ? this._hitElements : eventMode && !pruneFn(currentTarget, location) && testFn(currentTarget, location) ? children ? [currentTarget] : [] : null;
    }
    hitTestRecursive(currentTarget, eventMode, location, testFn, pruneFn) {
      if (this._interactivePrune(currentTarget) || pruneFn(currentTarget, location)) {
        return null;
      }
      if (("dynamic" === currentTarget.eventMode || "dynamic" === eventMode) && (EventTicker.EventsTicker.pauseUpdate = !1), currentTarget.interactiveChildren && currentTarget.children) {
        const children = currentTarget.children;
        for (let i = children.length - 1; 0 <= i; i--) {
          var child = children[i];
          if ((child = this.hitTestRecursive(child, this._isInteractive(eventMode) ? eventMode : child.eventMode, location, testFn, pruneFn)) && (!(0 < child.length) || child[child.length - 1].parent)) {
            return location = currentTarget.isInteractive(), (0 < child.length || location) && child.push(currentTarget), child;
          }
        }
      }
      eventMode = this._isInteractive(eventMode);
      pruneFn = currentTarget.isInteractive();
      return eventMode && testFn(currentTarget, location) ? pruneFn ? [currentTarget] : [] : null;
    }
    _isInteractive(int) {
      return "static" === int || "dynamic" === int;
    }
    _interactivePrune(displayObject) {
      return !(displayObject && !displayObject.isMask && displayObject.visible && displayObject.renderable && "none" !== displayObject.eventMode && ("passive" !== displayObject.eventMode || displayObject.interactiveChildren) && !displayObject.isMask);
    }
    hitPruneFn(displayObject, location) {
      return displayObject.hitArea && (displayObject.worldTransform.applyInverse(location, tempLocalMapping), !displayObject.hitArea.contains(tempLocalMapping.x, tempLocalMapping.y)) || displayObject._mask && (displayObject = displayObject._mask.isMaskData ? displayObject._mask.maskObject : displayObject._mask) && !displayObject.containsPoint?.(location) ? !0 : !1;
    }
    hitTestFn(displayObject, location) {
      return "passive" === displayObject.eventMode ? !1 : displayObject.hitArea ? !0 : displayObject.containsPoint ? displayObject.containsPoint(location) : !1;
    }
    notifyTarget(e, type) {
      type = type ?? e.type;
      e.currentTarget[`on${type}`]?.(e);
      this.notifyListeners(e, e.eventPhase === e.CAPTURING_PHASE || e.eventPhase === e.AT_TARGET ? `${type}capture` : type);
      e.eventPhase === e.AT_TARGET && this.notifyListeners(e, type);
    }
    mapPointerDown(from) {
      if (from instanceof FederatedPointerEvent.FederatedPointerEvent) {
        var e = this.createPointerEvent(from);
        (this.dispatchEvent(e, "pointerdown"), "touch" === e.pointerType) ? this.dispatchEvent(e, "touchstart") : ("mouse" === e.pointerType || "pen" === e.pointerType) && this.dispatchEvent(e, 2 === e.button ? "rightdown" : "mousedown");
        this.trackingData(from.pointerId).pressTargetsByButton[from.button] = e.composedPath();
        this.freeEvent(e);
      } else {
        console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
      }
    }
    mapPointerMove(from) {
      if (from instanceof FederatedPointerEvent.FederatedPointerEvent) {
        this._allInteractiveElements.length = 0;
        this._hitElements.length = 0;
        this._isPointerMoveEvent = !0;
        var e = this.createPointerEvent(from);
        this._isPointerMoveEvent = !1;
        var isMouse = "mouse" === e.pointerType || "pen" === e.pointerType, trackingData = this.trackingData(from.pointerId), outTarget = this.findMountedTarget(trackingData.overTargets);
        if (0 < trackingData.overTargets?.length && outTarget !== e.target) {
          var outEvent = this.createPointerEvent(from, "mousemove" === from.type ? "mouseout" : "pointerout", outTarget);
          if (this.dispatchEvent(outEvent, "pointerout"), isMouse && this.dispatchEvent(outEvent, "mouseout"), !e.composedPath().includes(outTarget)) {
            const leaveEvent = this.createPointerEvent(from, "pointerleave", outTarget);
            for (leaveEvent.eventPhase = leaveEvent.AT_TARGET; leaveEvent.target && !e.composedPath().includes(leaveEvent.target);) {
              leaveEvent.currentTarget = leaveEvent.target, this.notifyTarget(leaveEvent), isMouse && this.notifyTarget(leaveEvent, "mouseleave"), leaveEvent.target = leaveEvent.target.parent;
            }
            this.freeEvent(leaveEvent);
          }
          this.freeEvent(outEvent);
        }
        if (outTarget !== e.target) {
          from = this.clonePointerEvent(e, "mousemove" === from.type ? "mouseover" : "pointerover");
          this.dispatchEvent(from, "pointerover");
          isMouse && this.dispatchEvent(from, "mouseover");
          for (outEvent = outTarget?.parent; outEvent && outEvent !== this.rootTarget.parent && outEvent !== e.target;) {
            outEvent = outEvent.parent;
          }
          if (!outEvent || outEvent === this.rootTarget.parent) {
            outEvent = this.clonePointerEvent(e, "pointerenter");
            for (outEvent.eventPhase = outEvent.AT_TARGET; outEvent.target && outEvent.target !== outTarget && outEvent.target !== this.rootTarget.parent;) {
              outEvent.currentTarget = outEvent.target, this.notifyTarget(outEvent), isMouse && this.notifyTarget(outEvent, "mouseenter"), outEvent.target = outEvent.target.parent;
            }
            this.freeEvent(outEvent);
          }
          this.freeEvent(from);
        }
        outTarget = [];
        from = this.enableGlobalMoveEvents ?? !0;
        this.moveOnAll ? outTarget.push("pointermove") : this.dispatchEvent(e, "pointermove");
        from && outTarget.push("globalpointermove");
        "touch" === e.pointerType && (this.moveOnAll ? outTarget.splice(1, 0, "touchmove") : this.dispatchEvent(e, "touchmove"), from && outTarget.push("globaltouchmove"));
        isMouse && (this.moveOnAll ? outTarget.splice(1, 0, "mousemove") : this.dispatchEvent(e, "mousemove"), from && outTarget.push("globalmousemove"), this.cursor = e.target?.cursor);
        0 < outTarget.length && this.all(e, outTarget);
        this._allInteractiveElements.length = 0;
        this._hitElements.length = 0;
        trackingData.overTargets = e.composedPath();
        this.freeEvent(e);
      } else {
        console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
      }
    }
    mapPointerOver(from) {
      if (from instanceof FederatedPointerEvent.FederatedPointerEvent) {
        var trackingData = this.trackingData(from.pointerId);
        from = this.createPointerEvent(from);
        var isMouse = "mouse" === from.pointerType || "pen" === from.pointerType;
        this.dispatchEvent(from, "pointerover");
        isMouse && this.dispatchEvent(from, "mouseover");
        "mouse" === from.pointerType && (this.cursor = from.target?.cursor);
        var enterEvent = this.clonePointerEvent(from, "pointerenter");
        for (enterEvent.eventPhase = enterEvent.AT_TARGET; enterEvent.target && enterEvent.target !== this.rootTarget.parent;) {
          enterEvent.currentTarget = enterEvent.target, this.notifyTarget(enterEvent), isMouse && this.notifyTarget(enterEvent, "mouseenter"), enterEvent.target = enterEvent.target.parent;
        }
        trackingData.overTargets = from.composedPath();
        this.freeEvent(from);
        this.freeEvent(enterEvent);
      } else {
        console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
      }
    }
    mapPointerOut(from) {
      if (from instanceof FederatedPointerEvent.FederatedPointerEvent) {
        var trackingData = this.trackingData(from.pointerId);
        if (trackingData.overTargets) {
          const isMouse = "mouse" === from.pointerType || "pen" === from.pointerType, outTarget = this.findMountedTarget(trackingData.overTargets), outEvent = this.createPointerEvent(from, "pointerout", outTarget);
          this.dispatchEvent(outEvent);
          isMouse && this.dispatchEvent(outEvent, "mouseout");
          from = this.createPointerEvent(from, "pointerleave", outTarget);
          for (from.eventPhase = from.AT_TARGET; from.target && from.target !== this.rootTarget.parent;) {
            from.currentTarget = from.target, this.notifyTarget(from), isMouse && this.notifyTarget(from, "mouseleave"), from.target = from.target.parent;
          }
          trackingData.overTargets = null;
          this.freeEvent(outEvent);
          this.freeEvent(from);
        }
        this.cursor = null;
      } else {
        console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
      }
    }
    mapPointerUp(from) {
      if (from instanceof FederatedPointerEvent.FederatedPointerEvent) {
        var now = performance.now(), e = this.createPointerEvent(from);
        (this.dispatchEvent(e, "pointerup"), "touch" === e.pointerType) ? this.dispatchEvent(e, "touchend") : ("mouse" === e.pointerType || "pen" === e.pointerType) && this.dispatchEvent(e, 2 === e.button ? "rightup" : "mouseup");
        var trackingData = this.trackingData(from.pointerId), pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]), clickTarget = pressTarget;
        if (pressTarget && !e.composedPath().includes(pressTarget)) {
          for (clickTarget = pressTarget; clickTarget && !e.composedPath().includes(clickTarget);) {
            (e.currentTarget = clickTarget, this.notifyTarget(e, "pointerupoutside"), "touch" === e.pointerType) ? this.notifyTarget(e, "touchendoutside") : ("mouse" === e.pointerType || "pen" === e.pointerType) && this.notifyTarget(e, 2 === e.button ? "rightupoutside" : "mouseupoutside"), clickTarget = clickTarget.parent;
          }
          delete trackingData.pressTargetsByButton[from.button];
        }
        clickTarget && (pressTarget = this.clonePointerEvent(e, "click"), pressTarget.target = clickTarget, pressTarget.path = null, trackingData.clicksByButton[from.button] || (trackingData.clicksByButton[from.button] = {clickCount:0, target:pressTarget.target, timeStamp:now}), from = trackingData.clicksByButton[from.button], (from.target === pressTarget.target && 200 > now - from.timeStamp ? ++from.clickCount : from.clickCount = 1, from.target = pressTarget.target, from.timeStamp = now, pressTarget.detail = 
        from.clickCount, "mouse" === pressTarget.pointerType) ? this.dispatchEvent(pressTarget, 2 === pressTarget.button ? "rightclick" : "click") : "touch" === pressTarget.pointerType && this.dispatchEvent(pressTarget, "tap"), this.dispatchEvent(pressTarget, "pointertap"), this.freeEvent(pressTarget));
        this.freeEvent(e);
      } else {
        console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
      }
    }
    mapPointerUpOutside(from) {
      if (from instanceof FederatedPointerEvent.FederatedPointerEvent) {
        var trackingData = this.trackingData(from.pointerId), pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]), e = this.createPointerEvent(from);
        if (pressTarget) {
          for (; pressTarget;) {
            e.currentTarget = pressTarget, this.notifyTarget(e, "pointerupoutside"), "touch" === e.pointerType ? this.notifyTarget(e, "touchendoutside") : ("mouse" === e.pointerType || "pen" === e.pointerType) && this.notifyTarget(e, 2 === e.button ? "rightupoutside" : "mouseupoutside"), pressTarget = pressTarget.parent;
          }
          delete trackingData.pressTargetsByButton[from.button];
        }
        this.freeEvent(e);
      } else {
        console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
      }
    }
    mapWheel(from) {
      from instanceof FederatedWheelEvent.FederatedWheelEvent ? (from = this.createWheelEvent(from), this.dispatchEvent(from), this.freeEvent(from)) : console.warn("EventBoundary cannot map a non-wheel event as a wheel event");
    }
    findMountedTarget(propagationPath) {
      if (!propagationPath) {
        return null;
      }
      let currentTarget = propagationPath[0];
      for (let i = 1; i < propagationPath.length && propagationPath[i].parent === currentTarget; i++) {
        currentTarget = propagationPath[i];
      }
      return currentTarget;
    }
    createPointerEvent(from, type, target) {
      const event = this.allocateEvent(FederatedPointerEvent.FederatedPointerEvent);
      return this.copyPointerData(from, event), this.copyMouseData(from, event), this.copyData(from, event), event.nativeEvent = from.nativeEvent, event.originalEvent = from, event.target = target ?? this.hitTest(event.global.x, event.global.y) ?? this._hitElements[0], "string" == typeof type && (event.type = type), event;
    }
    createWheelEvent(from) {
      const event = this.allocateEvent(FederatedWheelEvent.FederatedWheelEvent);
      return this.copyWheelData(from, event), this.copyMouseData(from, event), this.copyData(from, event), event.nativeEvent = from.nativeEvent, event.originalEvent = from, event.target = this.hitTest(event.global.x, event.global.y), event;
    }
    clonePointerEvent(from, type) {
      const event = this.allocateEvent(FederatedPointerEvent.FederatedPointerEvent);
      return event.nativeEvent = from.nativeEvent, event.originalEvent = from.originalEvent, this.copyPointerData(from, event), this.copyMouseData(from, event), this.copyData(from, event), event.target = from.target, event.path = from.composedPath().slice(), event.type = type ?? event.type, event;
    }
    copyWheelData(from, to) {
      to.deltaMode = from.deltaMode;
      to.deltaX = from.deltaX;
      to.deltaY = from.deltaY;
      to.deltaZ = from.deltaZ;
    }
    copyPointerData(from, to) {
      from instanceof FederatedPointerEvent.FederatedPointerEvent && to instanceof FederatedPointerEvent.FederatedPointerEvent && (to.pointerId = from.pointerId, to.width = from.width, to.height = from.height, to.isPrimary = from.isPrimary, to.pointerType = from.pointerType, to.pressure = from.pressure, to.tangentialPressure = from.tangentialPressure, to.tiltX = from.tiltX, to.tiltY = from.tiltY, to.twist = from.twist);
    }
    copyMouseData(from, to) {
      from instanceof FederatedMouseEvent.FederatedMouseEvent && to instanceof FederatedMouseEvent.FederatedMouseEvent && (to.altKey = from.altKey, to.button = from.button, to.buttons = from.buttons, to.client.copyFrom(from.client), to.ctrlKey = from.ctrlKey, to.metaKey = from.metaKey, to.movement.copyFrom(from.movement), to.screen.copyFrom(from.screen), to.shiftKey = from.shiftKey, to.global.copyFrom(from.global));
    }
    copyData(from, to) {
      to.isTrusted = from.isTrusted;
      to.srcElement = from.srcElement;
      to.timeStamp = performance.now();
      to.type = from.type;
      to.detail = from.detail;
      to.view = from.view;
      to.which = from.which;
      to.layer.copyFrom(from.layer);
      to.page.copyFrom(from.page);
    }
    trackingData(id) {
      return this.mappingState.trackingData[id] || (this.mappingState.trackingData[id] = {pressTargetsByButton:{}, clicksByButton:{}, overTarget:null}), this.mappingState.trackingData[id];
    }
    allocateEvent(constructor) {
      this.eventPool.has(constructor) || this.eventPool.set(constructor, []);
      constructor = this.eventPool.get(constructor).pop() || new constructor(this);
      return constructor.eventPhase = constructor.NONE, constructor.currentTarget = null, constructor.path = null, constructor.target = null, constructor;
    }
    freeEvent(event) {
      if (event.manager !== this) {
        throw Error("It is illegal to free an event not managed by this EventBoundary!");
      }
      const constructor = event.constructor;
      this.eventPool.has(constructor) || this.eventPool.set(constructor, []);
      this.eventPool.get(constructor).push(event);
    }
    notifyListeners(e, type) {
      const listeners = e.currentTarget._events[type];
      if (listeners && e.currentTarget.isInteractive()) {
        if ("fn" in listeners) {
          listeners.once && e.currentTarget.removeListener(type, listeners.fn, void 0, !0), listeners.fn.call(listeners.context, e);
        } else {
          for (let i = 0, j = listeners.length; i < j && !e.propagationImmediatelyStopped; i++) {
            listeners[i].once && e.currentTarget.removeListener(type, listeners[i].fn, void 0, !0), listeners[i].fn.call(listeners[i].context, e);
          }
        }
      }
    }
  }
  exports.EventBoundary = EventBoundary;
};

//# sourceMappingURL=module$node_modules$$pixi$events$lib$EventBoundary.js.map
