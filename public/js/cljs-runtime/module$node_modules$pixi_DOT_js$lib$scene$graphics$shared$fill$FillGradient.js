shadow$provide.module$node_modules$pixi_DOT_js$lib$scene$graphics$shared$fill$FillGradient = function(global, require, module, exports) {
  function addColorStops(gradient, colorStops) {
    for (let i = 0; i < colorStops.length; i++) {
      const stop = colorStops[i];
      gradient.addColorStop(stop.offset, stop.color);
    }
  }
  function getCanvas(width, height) {
    width = adapter.DOMAdapter.get().createCanvas(width, height);
    height = width.getContext("2d");
    return {canvas:width, context:height};
  }
  function ensureGradientOptions(args) {
    let options = args[0] ?? {};
    if ("number" === typeof options || args[1]) {
      deprecation.deprecation("8.5.2", "use options object instead"), options = {type:"linear", start:{x:args[0], y:args[1]}, end:{x:args[2], y:args[3]}, textureSpace:args[4], textureSize:args[5] ?? FillGradient.defaultLinearOptions.textureSize};
    }
    return options;
  }
  var Color = require("module$node_modules$pixi_DOT_js$lib$color$Color"), adapter = require("module$node_modules$pixi_DOT_js$lib$environment$adapter"), Matrix = require("module$node_modules$pixi_DOT_js$lib$maths$matrix$Matrix"), ImageSource = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$texture$sources$ImageSource"), Texture = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$texture$Texture"), uid = require("module$node_modules$pixi_DOT_js$lib$utils$data$uid"), 
  deprecation = require("module$node_modules$pixi_DOT_js$lib$utils$logging$deprecation"), definedProps = require("module$node_modules$pixi_DOT_js$lib$scene$container$utils$definedProps");
  "use strict";
  const emptyColorStops = [{offset:0, color:"white"}, {offset:1, color:"black"}], node_modules$pixi_DOT_js$lib$scene$graphics$shared$fill$FillGradient$classdecl$var12 = class {
    constructor(...args) {
      this.uid = uid.uid("fillGradient");
      this.type = "linear";
      this.colorStops = [];
      args = ensureGradientOptions(args);
      args = {...("radial" === args.type ? node_modules$pixi_DOT_js$lib$scene$graphics$shared$fill$FillGradient$classdecl$var12.defaultRadialOptions : node_modules$pixi_DOT_js$lib$scene$graphics$shared$fill$FillGradient$classdecl$var12.defaultLinearOptions), ...definedProps.definedProps(args)};
      this._textureSize = args.textureSize;
      this._wrapMode = args.wrapMode;
      "radial" === args.type ? (this.center = args.center, this.outerCenter = args.outerCenter ?? this.center, this.innerRadius = args.innerRadius, this.outerRadius = args.outerRadius, this.scale = args.scale, this.rotation = args.rotation) : (this.start = args.start, this.end = args.end);
      this.textureSpace = args.textureSpace;
      this.type = args.type;
      args.colorStops.forEach(stop => {
        this.addColorStop(stop.offset, stop.color);
      });
    }
    addColorStop(offset, color) {
      this.colorStops.push({offset, color:Color.Color.shared.setValue(color).toHexa()});
      return this;
    }
    buildLinearGradient() {
      if (!this.texture) {
        var {x:x0, y:y0} = this.start, {x:x1, y:y1} = this.end, dx = x1 - x0, dy = y1 - y0, flip = 0 > dx || 0 > dy;
        "clamp-to-edge" === this._wrapMode && (0 > dx && (x0 = x1, dx *= -1), 0 > dy && (y0 = y1, dy *= -1));
        var colorStops = this.colorStops.length ? this.colorStops : emptyColorStops, defaultSize = this._textureSize, {canvas, context} = getCanvas(defaultSize, 1);
        flip = flip ? context.createLinearGradient(this._textureSize, 0, 0, 0) : context.createLinearGradient(0, 0, this._textureSize, 0);
        addColorStops(flip, colorStops);
        context.fillStyle = flip;
        context.fillRect(0, 0, defaultSize, 1);
        this.texture = new Texture.Texture({source:new ImageSource.ImageSource({resource:canvas, addressMode:this._wrapMode})});
        colorStops = Math.sqrt(dx * dx + dy * dy);
        dx = Math.atan2(dy, dx);
        dy = new Matrix.Matrix();
        dy.scale(colorStops / defaultSize, 1);
        dy.rotate(dx);
        dy.translate(x0, y0);
        "local" === this.textureSpace && dy.scale(defaultSize, defaultSize);
        this.transform = dy;
      }
    }
    buildGradient() {
      "linear" === this.type ? this.buildLinearGradient() : this.buildRadialGradient();
    }
    buildRadialGradient() {
      if (!this.texture) {
        var colorStops = this.colorStops.length ? this.colorStops : emptyColorStops, defaultSize = this._textureSize, {canvas, context} = getCanvas(defaultSize, defaultSize), {x:x0, y:y0} = this.center, {x:x1, y:y1} = this.outerCenter, r1 = this.outerRadius, ox = x1 - r1, oy = y1 - r1, scale = defaultSize / (2 * r1), cx = (x0 - ox) * scale, cy = (y0 - oy) * scale;
        r1 = context.createRadialGradient(cx, cy, this.innerRadius * scale, (x1 - ox) * scale, (y1 - oy) * scale, r1 * scale);
        addColorStops(r1, colorStops);
        context.fillStyle = colorStops[colorStops.length - 1].color;
        context.fillRect(0, 0, defaultSize, defaultSize);
        context.fillStyle = r1;
        context.translate(cx, cy);
        context.rotate(this.rotation);
        context.scale(1, this.scale);
        context.translate(-cx, -cy);
        context.fillRect(0, 0, defaultSize, defaultSize);
        this.texture = new Texture.Texture({source:new ImageSource.ImageSource({resource:canvas, addressMode:this._wrapMode})});
        colorStops = new Matrix.Matrix();
        colorStops.scale(1 / scale, 1 / scale);
        colorStops.translate(ox, oy);
        "local" === this.textureSpace && colorStops.scale(defaultSize, defaultSize);
        this.transform = colorStops;
      }
    }
    get styleKey() {
      return this.uid;
    }
    destroy() {
      this.texture?.destroy(!0);
      this.texture = null;
    }
  };
  global = node_modules$pixi_DOT_js$lib$scene$graphics$shared$fill$FillGradient$classdecl$var12;
  global.defaultLinearOptions = {start:{x:0, y:0}, end:{x:0, y:1}, colorStops:[], textureSpace:"local", type:"linear", textureSize:256, wrapMode:"clamp-to-edge"};
  global.defaultRadialOptions = {center:{x:0.5, y:0.5}, innerRadius:0, outerRadius:0.5, colorStops:[], scale:1, textureSpace:"local", type:"radial", textureSize:256, wrapMode:"clamp-to-edge"};
  let FillGradient = global;
  exports.FillGradient = FillGradient;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$scene$graphics$shared$fill$FillGradient.js.map
