shadow$provide.module$node_modules$$pixi$core$lib$textures$BaseTexture = function(global, require, module, exports) {
  var constants = require("module$node_modules$$pixi$constants$lib$index"), settings = require("module$node_modules$$pixi$settings$lib$index"), utils = require("module$node_modules$$pixi$utils$lib$index"), autoDetectResource = require("module$node_modules$$pixi$core$lib$textures$resources$autoDetectResource"), BufferResource = require("module$node_modules$$pixi$core$lib$textures$resources$BufferResource"), Resource = require("module$node_modules$$pixi$core$lib$textures$resources$Resource");
  const defaultBufferOptions = {scaleMode:constants.SCALE_MODES.NEAREST, alphaMode:constants.ALPHA_MODES.NPM};
  global = (() => {
    const node_modules$$pixi$core$lib$textures$BaseTexture$classdecl$var1 = class extends utils.EventEmitter {
      constructor(resource = null, options = null) {
        super();
        options = Object.assign({}, node_modules$$pixi$core$lib$textures$BaseTexture$classdecl$var1.defaultOptions, options);
        const {alphaMode, mipmap, anisotropicLevel, scaleMode, width, height, wrapMode, format, type, target, resolution, resourceOptions} = options;
        resource && !(resource instanceof Resource.Resource) && (resource = autoDetectResource.autoDetectResource(resource, resourceOptions), resource.internal = !0);
        this.resolution = resolution || settings.settings.RESOLUTION;
        this.width = Math.round((width || 0) * this.resolution) / this.resolution;
        this.height = Math.round((height || 0) * this.resolution) / this.resolution;
        this._mipmap = mipmap;
        this.anisotropicLevel = anisotropicLevel;
        this._wrapMode = wrapMode;
        this._scaleMode = scaleMode;
        this.format = format;
        this.type = type;
        this.target = target;
        this.alphaMode = alphaMode;
        this.uid = utils.uid();
        this.touched = 0;
        this.isPowerOfTwo = !1;
        this._refreshPOT();
        this._glTextures = {};
        this.dirtyStyleId = this.dirtyId = 0;
        this.cacheId = null;
        this.valid = 0 < width && 0 < height;
        this.textureCacheIds = [];
        this.destroyed = !1;
        this.resource = null;
        this._batchLocation = this._batchEnabled = 0;
        this.parentTextureArray = null;
        this.setResource(resource);
      }
      get realWidth() {
        return Math.round(this.width * this.resolution);
      }
      get realHeight() {
        return Math.round(this.height * this.resolution);
      }
      get mipmap() {
        return this._mipmap;
      }
      set mipmap(value) {
        this._mipmap !== value && (this._mipmap = value, this.dirtyStyleId++);
      }
      get scaleMode() {
        return this._scaleMode;
      }
      set scaleMode(value) {
        this._scaleMode !== value && (this._scaleMode = value, this.dirtyStyleId++);
      }
      get wrapMode() {
        return this._wrapMode;
      }
      set wrapMode(value) {
        this._wrapMode !== value && (this._wrapMode = value, this.dirtyStyleId++);
      }
      setStyle(scaleMode, mipmap) {
        let dirty;
        return void 0 !== scaleMode && scaleMode !== this.scaleMode && (this.scaleMode = scaleMode, dirty = !0), void 0 !== mipmap && mipmap !== this.mipmap && (this.mipmap = mipmap, dirty = !0), dirty && this.dirtyStyleId++, this;
      }
      setSize(desiredWidth, desiredHeight, resolution) {
        return resolution = resolution || this.resolution, this.setRealSize(desiredWidth * resolution, desiredHeight * resolution, resolution);
      }
      setRealSize(realWidth, realHeight, resolution) {
        return this.resolution = resolution || this.resolution, this.width = Math.round(realWidth) / this.resolution, this.height = Math.round(realHeight) / this.resolution, this._refreshPOT(), this.update(), this;
      }
      _refreshPOT() {
        this.isPowerOfTwo = utils.isPow2(this.realWidth) && utils.isPow2(this.realHeight);
      }
      setResolution(resolution) {
        const oldResolution = this.resolution;
        return oldResolution === resolution ? this : (this.resolution = resolution, this.valid && (this.width = Math.round(this.width * oldResolution) / resolution, this.height = Math.round(this.height * oldResolution) / resolution, this.emit("update", this)), this._refreshPOT(), this);
      }
      setResource(resource) {
        if (this.resource === resource) {
          return this;
        }
        if (this.resource) {
          throw Error("Resource can be set only once");
        }
        return resource.bind(this), this.resource = resource, this;
      }
      update() {
        this.valid ? (this.dirtyId++, this.dirtyStyleId++, this.emit("update", this)) : 0 < this.width && 0 < this.height && (this.valid = !0, this.emit("loaded", this), this.emit("update", this));
      }
      onError(event) {
        this.emit("error", this, event);
      }
      destroy() {
        this.resource && (this.resource.unbind(this), this.resource.internal && this.resource.destroy(), this.resource = null);
        this.cacheId && (delete utils.BaseTextureCache[this.cacheId], delete utils.TextureCache[this.cacheId], this.cacheId = null);
        this.valid = !1;
        this.dispose();
        node_modules$$pixi$core$lib$textures$BaseTexture$classdecl$var1.removeFromCache(this);
        this.textureCacheIds = null;
        this.destroyed = !0;
        this.emit("destroyed", this);
        this.removeAllListeners();
      }
      dispose() {
        this.emit("dispose", this);
      }
      castToBaseTexture() {
        return this;
      }
      static from(source, options, strict = settings.settings.STRICT_TEXTURE_CACHE) {
        const isFrame = "string" == typeof source;
        let cacheId;
        isFrame ? cacheId = source : (source._pixiId || (source._pixiId = `${options?.pixiIdPrefix || "pixiid"}_${utils.uid()}`), cacheId = source._pixiId);
        let baseTexture = utils.BaseTextureCache[cacheId];
        if (isFrame && strict && !baseTexture) {
          throw Error(`The cacheId "${cacheId}" does not exist in BaseTextureCache.`);
        }
        return baseTexture || (baseTexture = new node_modules$$pixi$core$lib$textures$BaseTexture$classdecl$var1(source, options), baseTexture.cacheId = cacheId, node_modules$$pixi$core$lib$textures$BaseTexture$classdecl$var1.addToCache(baseTexture, cacheId)), baseTexture;
      }
      static fromBuffer(buffer, width, height, options) {
        buffer = buffer || new Float32Array(width * height * 4);
        width = new BufferResource.BufferResource(buffer, {width, height, ...options?.resourceOptions});
        let format, type;
        return buffer instanceof Float32Array ? (format = constants.FORMATS.RGBA, type = constants.TYPES.FLOAT) : buffer instanceof Int32Array ? (format = constants.FORMATS.RGBA_INTEGER, type = constants.TYPES.INT) : buffer instanceof Uint32Array ? (format = constants.FORMATS.RGBA_INTEGER, type = constants.TYPES.UNSIGNED_INT) : buffer instanceof Int16Array ? (format = constants.FORMATS.RGBA_INTEGER, type = constants.TYPES.SHORT) : buffer instanceof Uint16Array ? (format = constants.FORMATS.RGBA_INTEGER, 
        type = constants.TYPES.UNSIGNED_SHORT) : buffer instanceof Int8Array ? (format = constants.FORMATS.RGBA, type = constants.TYPES.BYTE) : (format = constants.FORMATS.RGBA, type = constants.TYPES.UNSIGNED_BYTE), width.internal = !0, new node_modules$$pixi$core$lib$textures$BaseTexture$classdecl$var1(width, Object.assign({}, defaultBufferOptions, {type, format}, options));
      }
      static addToCache(baseTexture, id) {
        id && (baseTexture.textureCacheIds.includes(id) || baseTexture.textureCacheIds.push(id), utils.BaseTextureCache[id] && utils.BaseTextureCache[id] !== baseTexture && console.warn(`BaseTexture added to the cache with an id [${id}] that already had an entry`), utils.BaseTextureCache[id] = baseTexture);
      }
      static removeFromCache(baseTexture) {
        if ("string" == typeof baseTexture) {
          var baseTextureFromCache = utils.BaseTextureCache[baseTexture];
          if (baseTextureFromCache) {
            const index = baseTextureFromCache.textureCacheIds.indexOf(baseTexture);
            return -1 < index && baseTextureFromCache.textureCacheIds.splice(index, 1), delete utils.BaseTextureCache[baseTexture], baseTextureFromCache;
          }
        } else if (baseTexture?.textureCacheIds) {
          for (baseTextureFromCache = 0; baseTextureFromCache < baseTexture.textureCacheIds.length; ++baseTextureFromCache) {
            delete utils.BaseTextureCache[baseTexture.textureCacheIds[baseTextureFromCache]];
          }
          return baseTexture.textureCacheIds.length = 0, baseTexture;
        }
        return null;
      }
    };
    return node_modules$$pixi$core$lib$textures$BaseTexture$classdecl$var1;
  })();
  global.defaultOptions = {mipmap:constants.MIPMAP_MODES.POW2, anisotropicLevel:0, scaleMode:constants.SCALE_MODES.LINEAR, wrapMode:constants.WRAP_MODES.CLAMP, alphaMode:constants.ALPHA_MODES.UNPACK, target:constants.TARGETS.TEXTURE_2D, format:constants.FORMATS.RGBA, type:constants.TYPES.UNSIGNED_BYTE};
  global._globalBatch = 0;
  exports.BaseTexture = global;
};

//# sourceMappingURL=module$node_modules$$pixi$core$lib$textures$BaseTexture.js.map
