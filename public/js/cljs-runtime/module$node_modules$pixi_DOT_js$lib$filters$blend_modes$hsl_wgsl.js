shadow$provide.module$node_modules$pixi_DOT_js$lib$filters$blend_modes$hsl_wgsl = function(global, require, module, exports) {
  Object.defineProperty(exports, "__esModule", {value:!0});
  exports.default = "fn getLuminosity(c: vec3\x3cf32\x3e) -\x3e f32 {\n  return 0.3 * c.r + 0.59 * c.g + 0.11 * c.b;\n}\n\nfn setLuminosity(c: vec3\x3cf32\x3e, lum: f32) -\x3e vec3\x3cf32\x3e {\n  let d: f32 \x3d lum - getLuminosity(c);\n  let newColor: vec3\x3cf32\x3e \x3d c.rgb + vec3\x3cf32\x3e(d, d, d);\n\n  // clip back into legal range\n  let newLum: f32 \x3d getLuminosity(newColor);\n  let cMin: f32 \x3d min(newColor.r, min(newColor.g, newColor.b));\n  let cMax: f32 \x3d max(newColor.r, max(newColor.g, newColor.b));\n\n  let t1: f32 \x3d newLum / (newLum - cMin);\n  let t2: f32 \x3d (1.0 - newLum) / (cMax - newLum);\n\n  let finalColor \x3d mix(vec3\x3cf32\x3e(newLum, newLum, newLum), newColor, select(select(1.0, t2, cMax \x3e 1.0), t1, cMin \x3c 0.0));\n\n  return finalColor;\n}\n\nfn getSaturation(c: vec3\x3cf32\x3e) -\x3e f32 {\n  return max(c.r, max(c.g, c.b)) - min(c.r, min(c.g, c.b));\n}\n\n// Set saturation if color components are sorted in ascending order.\nfn setSaturationMinMidMax(cSorted: vec3\x3cf32\x3e, s: f32) -\x3e vec3\x3cf32\x3e {\n  var result: vec3\x3cf32\x3e;\n  if (cSorted.z \x3e cSorted.x) {\n    let newY \x3d (((cSorted.y - cSorted.x) * s) / (cSorted.z - cSorted.x));\n    result \x3d vec3\x3cf32\x3e(0.0, newY, s);\n  } else {\n    result \x3d vec3\x3cf32\x3e(0.0, 0.0, 0.0);\n  }\n  return vec3\x3cf32\x3e(result.x, result.y, result.z);\n}\n\nfn setSaturation(c: vec3\x3cf32\x3e, s: f32) -\x3e vec3\x3cf32\x3e {\n    var result: vec3\x3cf32\x3e \x3d c;\n\n    if (c.r \x3c\x3d c.g \x26\x26 c.r \x3c\x3d c.b) {\n        if (c.g \x3c\x3d c.b) {\n            result \x3d setSaturationMinMidMax(result, s);\n        } else {\n            var temp: vec3\x3cf32\x3e \x3d vec3\x3cf32\x3e(result.r, result.b, result.g);\n            temp \x3d setSaturationMinMidMax(temp, s);\n            result \x3d vec3\x3cf32\x3e(temp.r, temp.b, temp.g);\n        }\n    } else if (c.g \x3c\x3d c.r \x26\x26 c.g \x3c\x3d c.b) {\n        if (c.r \x3c\x3d c.b) {\n            var temp: vec3\x3cf32\x3e \x3d vec3\x3cf32\x3e(result.g, result.r, result.b);\n            temp \x3d setSaturationMinMidMax(temp, s);\n            result \x3d vec3\x3cf32\x3e(temp.g, temp.r, temp.b);\n        } else {\n            var temp: vec3\x3cf32\x3e \x3d vec3\x3cf32\x3e(result.g, result.b, result.r);\n            temp \x3d setSaturationMinMidMax(temp, s);\n            result \x3d vec3\x3cf32\x3e(temp.g, temp.b, temp.r);\n        }\n    } else {\n        if (c.r \x3c\x3d c.g) {\n            var temp: vec3\x3cf32\x3e \x3d vec3\x3cf32\x3e(result.b, result.r, result.g);\n            temp \x3d setSaturationMinMidMax(temp, s);\n            result \x3d vec3\x3cf32\x3e(temp.b, temp.r, temp.g);\n        } else {\n            var temp: vec3\x3cf32\x3e \x3d vec3\x3cf32\x3e(result.b, result.g, result.r);\n            temp \x3d setSaturationMinMidMax(temp, s);\n            result \x3d vec3\x3cf32\x3e(temp.b, temp.g, temp.r);\n        }\n    }\n\n    return result;\n}";
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$filters$blend_modes$hsl_wgsl.js.map
