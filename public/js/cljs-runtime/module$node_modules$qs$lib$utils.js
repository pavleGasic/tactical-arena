shadow$provide.module$node_modules$qs$lib$utils = function(global, require, module, exports) {
  var formats = require("module$node_modules$qs$lib$formats"), has = Object.prototype.hasOwnProperty, isArray = Array.isArray, hexTable = function() {
    for (var array = [], i = 0; 256 > i; ++i) {
      array.push("%" + ((16 > i ? "0" : "") + i.toString(16)).toUpperCase());
    }
    return array;
  }(), arrayToObject = function(source, options) {
    options = options && options.plainObjects ? {__proto__:null} : {};
    for (var i = 0; i < source.length; ++i) {
      "undefined" !== typeof source[i] && (options[i] = source[i]);
    }
    return options;
  };
  module.exports = {arrayToObject, assign:function(target, source) {
    return Object.keys(source).reduce(function(acc, key) {
      acc[key] = source[key];
      return acc;
    }, target);
  }, combine:function(a, b) {
    return [].concat(a, b);
  }, compact:function(value) {
    for (var queue = [{obj:{o:value}, prop:"o"}], refs = [], i = 0; i < queue.length; ++i) {
      var item = queue[i];
      item = item.obj[item.prop];
      for (var keys = Object.keys(item), j = 0; j < keys.length; ++j) {
        var key = keys[j], val = item[key];
        "object" === typeof val && null !== val && -1 === refs.indexOf(val) && (queue.push({obj:item, prop:key}), refs.push(val));
      }
    }
    for (; 1 < queue.length;) {
      if (refs = queue.pop(), i = refs.obj[refs.prop], isArray(i)) {
        item = [];
        for (keys = 0; keys < i.length; ++keys) {
          "undefined" !== typeof i[keys] && item.push(i[keys]);
        }
        refs.obj[refs.prop] = item;
      }
    }
    return value;
  }, decode:function(str, defaultDecoder, charset) {
    str = str.replace(/\+/g, " ");
    if ("iso-8859-1" === charset) {
      return str.replace(/%[0-9a-f]{2}/gi, unescape);
    }
    try {
      return decodeURIComponent(str);
    } catch (e) {
      return str;
    }
  }, encode:function(str, defaultEncoder, charset, kind, format) {
    if (0 === str.length) {
      return str;
    }
    defaultEncoder = str;
    "symbol" === typeof str ? defaultEncoder = Symbol.prototype.toString.call(str) : "string" !== typeof str && (defaultEncoder = String(str));
    if ("iso-8859-1" === charset) {
      return escape(defaultEncoder).replace(/%u[0-9a-f]{4}/gi, function($0) {
        return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
      });
    }
    str = "";
    for (charset = 0; charset < defaultEncoder.length; charset += 1024) {
      kind = 1024 <= defaultEncoder.length ? defaultEncoder.slice(charset, charset + 1024) : defaultEncoder;
      for (var arr = [], i = 0; i < kind.length; ++i) {
        var c = kind.charCodeAt(i);
        45 === c || 46 === c || 95 === c || 126 === c || 48 <= c && 57 >= c || 65 <= c && 90 >= c || 97 <= c && 122 >= c || format === formats.RFC1738 && (40 === c || 41 === c) ? arr[arr.length] = kind.charAt(i) : 128 > c ? arr[arr.length] = hexTable[c] : 2048 > c ? arr[arr.length] = hexTable[192 | c >> 6] + hexTable[128 | c & 63] : 55296 > c || 57344 <= c ? arr[arr.length] = hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63] : (i += 1, c = 65536 + ((c & 1023) << 10 | 
        kind.charCodeAt(i) & 1023), arr[arr.length] = hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63]);
      }
      str += arr.join("");
    }
    return str;
  }, isBuffer:function(obj) {
    return obj && "object" === typeof obj ? !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj)) : !1;
  }, isRegExp:function(obj) {
    return "[object RegExp]" === Object.prototype.toString.call(obj);
  }, maybeMap:function(val, fn) {
    if (isArray(val)) {
      for (var mapped = [], i = 0; i < val.length; i += 1) {
        mapped.push(fn(val[i]));
      }
      return mapped;
    }
    return fn(val);
  }, merge:function merge(target, source, options) {
    if (!source) {
      return target;
    }
    if ("object" !== typeof source && "function" !== typeof source) {
      if (isArray(target)) {
        target.push(source);
      } else if (target && "object" === typeof target) {
        if (options && (options.plainObjects || options.allowPrototypes) || !has.call(Object.prototype, source)) {
          target[source] = !0;
        }
      } else {
        return [target, source];
      }
      return target;
    }
    if (!target || "object" !== typeof target) {
      return [target].concat(source);
    }
    var mergeTarget = target;
    isArray(target) && !isArray(source) && (mergeTarget = arrayToObject(target, options));
    return isArray(target) && isArray(source) ? (source.forEach(function(item, i) {
      if (has.call(target, i)) {
        var targetItem = target[i];
        targetItem && "object" === typeof targetItem && item && "object" === typeof item ? target[i] = merge(targetItem, item, options) : target.push(item);
      } else {
        target[i] = item;
      }
    }), target) : Object.keys(source).reduce(function(acc, key) {
      var value = source[key];
      has.call(acc, key) ? acc[key] = merge(acc[key], value, options) : acc[key] = value;
      return acc;
    }, mergeTarget);
  }};
};

//# sourceMappingURL=module$node_modules$qs$lib$utils.js.map
