{
"version":3,
"file":"module$node_modules$pixi_DOT_js$lib$scene$mesh$shared$MeshGeometry.js",
"lineCount":44,
"mappings":"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",
"sources":["node_modules/pixi_DOT_js/lib/scene/mesh/shared/MeshGeometry.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$pixi_DOT_js$lib$scene$mesh$shared$MeshGeometry\"] = function(global,require,module,exports) {\n'use strict';\n\nvar Buffer = require('../../../rendering/renderers/shared/buffer/Buffer.js');\nvar _const = require('../../../rendering/renderers/shared/buffer/const.js');\nvar Geometry = require('../../../rendering/renderers/shared/geometry/Geometry.js');\nvar deprecation = require('../../../utils/logging/deprecation.js');\n\n\"use strict\";\nconst _MeshGeometry = class _MeshGeometry extends Geometry.Geometry {\n  constructor(...args) {\n    let options = args[0] ?? {};\n    if (options instanceof Float32Array) {\n      deprecation.deprecation(deprecation.v8_0_0, \"use new MeshGeometry({ positions, uvs, indices }) instead\");\n      options = {\n        positions: options,\n        uvs: args[1],\n        indices: args[2]\n      };\n    }\n    options = { ..._MeshGeometry.defaultOptions, ...options };\n    const positions = options.positions || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);\n    let uvs = options.uvs;\n    if (!uvs) {\n      if (options.positions) {\n        uvs = new Float32Array(positions.length);\n      } else {\n        uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);\n      }\n    }\n    const indices = options.indices || new Uint32Array([0, 1, 2, 0, 2, 3]);\n    const shrinkToFit = options.shrinkBuffersToFit;\n    const positionBuffer = new Buffer.Buffer({\n      data: positions,\n      label: \"attribute-mesh-positions\",\n      shrinkToFit,\n      usage: _const.BufferUsage.VERTEX | _const.BufferUsage.COPY_DST\n    });\n    const uvBuffer = new Buffer.Buffer({\n      data: uvs,\n      label: \"attribute-mesh-uvs\",\n      shrinkToFit,\n      usage: _const.BufferUsage.VERTEX | _const.BufferUsage.COPY_DST\n    });\n    const indexBuffer = new Buffer.Buffer({\n      data: indices,\n      label: \"index-mesh-buffer\",\n      shrinkToFit,\n      usage: _const.BufferUsage.INDEX | _const.BufferUsage.COPY_DST\n    });\n    super({\n      attributes: {\n        aPosition: {\n          buffer: positionBuffer,\n          format: \"float32x2\",\n          stride: 2 * 4,\n          offset: 0\n        },\n        aUV: {\n          buffer: uvBuffer,\n          format: \"float32x2\",\n          stride: 2 * 4,\n          offset: 0\n        }\n      },\n      indexBuffer,\n      topology: options.topology\n    });\n    this.batchMode = \"auto\";\n  }\n  /** The positions of the mesh. */\n  get positions() {\n    return this.attributes.aPosition.buffer.data;\n  }\n  /**\n   * Set the positions of the mesh.\n   * When setting the positions, its important that the uvs array is at least as long as the positions array.\n   * otherwise the geometry will not be valid.\n   * @param {Float32Array} value - The positions of the mesh.\n   */\n  set positions(value) {\n    this.attributes.aPosition.buffer.data = value;\n  }\n  /** The UVs of the mesh. */\n  get uvs() {\n    return this.attributes.aUV.buffer.data;\n  }\n  /**\n   * Set the UVs of the mesh.\n   * Its important that the uvs array you set is at least as long as the positions array.\n   * otherwise the geometry will not be valid.\n   * @param {Float32Array} value - The UVs of the mesh.\n   */\n  set uvs(value) {\n    this.attributes.aUV.buffer.data = value;\n  }\n  /** The indices of the mesh. */\n  get indices() {\n    return this.indexBuffer.data;\n  }\n  set indices(value) {\n    this.indexBuffer.data = value;\n  }\n};\n_MeshGeometry.defaultOptions = {\n  topology: \"triangle-list\",\n  shrinkBuffersToFit: false\n};\nlet MeshGeometry = _MeshGeometry;\n\nexports.MeshGeometry = MeshGeometry;\n//# sourceMappingURL=MeshGeometry.js.map\n\n};"],
"names":["shadow$provide","global","require","module","exports","Buffer","_const","Geometry","deprecation","constructor","args","options","Float32Array","v8_0_0","positions","uvs","indices","_MeshGeometry","defaultOptions","length","Uint32Array","shrinkToFit","shrinkBuffersToFit","positionBuffer","data","label","usage","BufferUsage","VERTEX","COPY_DST","uvBuffer","indexBuffer","INDEX","attributes","aPosition","buffer","format","stride","offset","aUV","topology","batchMode","value","MeshGeometry"]
}
