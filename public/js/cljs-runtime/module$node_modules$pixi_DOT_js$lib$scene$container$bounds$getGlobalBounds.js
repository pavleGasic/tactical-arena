shadow$provide.module$node_modules$pixi_DOT_js$lib$scene$container$bounds$getGlobalBounds = function(global, require, module, exports) {
  function _getGlobalBounds(target, bounds, parentTransform, skipUpdateTransform) {
    if (target.visible && target.measurable) {
      if (skipUpdateTransform) {
        var worldTransform = target.worldTransform;
      } else {
        target.updateLocalTransform(), worldTransform = matrixAndBoundsPool.matrixPool.get(), worldTransform.appendFrom(target.localTransform, parentTransform);
      }
      parentTransform = bounds;
      var preserveBounds = !!target.effects.length;
      preserveBounds && (bounds = matrixAndBoundsPool.boundsPool.get().clear());
      if (target.boundsArea) {
        bounds.addRect(target.boundsArea, worldTransform);
      } else {
        target.bounds && (bounds.matrix = worldTransform, bounds.addBounds(target.bounds));
        for (let i = 0; i < target.children.length; i++) {
          _getGlobalBounds(target.children[i], bounds, worldTransform, skipUpdateTransform);
        }
      }
      if (preserveBounds) {
        for (preserveBounds = 0; preserveBounds < target.effects.length; preserveBounds++) {
          target.effects[preserveBounds].addBounds?.(bounds);
        }
        parentTransform.addBounds(bounds, Matrix.Matrix.IDENTITY);
        matrixAndBoundsPool.boundsPool.return(bounds);
      }
      skipUpdateTransform || matrixAndBoundsPool.matrixPool.return(worldTransform);
    }
  }
  function updateTransformBackwards(target, parentTransform) {
    if (target = target.parent) {
      updateTransformBackwards(target, parentTransform), target.updateLocalTransform(), parentTransform.append(target.localTransform);
    }
    return parentTransform;
  }
  var Matrix = require("module$node_modules$pixi_DOT_js$lib$maths$matrix$Matrix"), matrixAndBoundsPool = require("module$node_modules$pixi_DOT_js$lib$scene$container$bounds$utils$matrixAndBoundsPool");
  "use strict";
  exports._getGlobalBounds = _getGlobalBounds;
  exports.getGlobalBounds = function(target, skipUpdateTransform, bounds) {
    bounds.clear();
    let parentTransform, pooledMatrix;
    target.parent ? skipUpdateTransform ? parentTransform = target.parent.worldTransform : (pooledMatrix = matrixAndBoundsPool.matrixPool.get().identity(), parentTransform = updateTransformBackwards(target, pooledMatrix)) : parentTransform = Matrix.Matrix.IDENTITY;
    _getGlobalBounds(target, bounds, parentTransform, skipUpdateTransform);
    pooledMatrix && matrixAndBoundsPool.matrixPool.return(pooledMatrix);
    bounds.isValid || bounds.set(0, 0, 0, 0);
    return bounds;
  };
  exports.updateTransformBackwards = updateTransformBackwards;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$scene$container$bounds$getGlobalBounds.js.map
