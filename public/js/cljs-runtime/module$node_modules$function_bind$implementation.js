shadow$provide.module$node_modules$function_bind$implementation = function(global, require, module, exports) {
  var toStr = Object.prototype.toString, max = Math.max, concatty = function(a, b) {
    for (var arr = [], i = 0; i < a.length; i += 1) {
      arr[i] = a[i];
    }
    for (i = 0; i < b.length; i += 1) {
      arr[i + a.length] = b[i];
    }
    return arr;
  }, slicy = function(arrLike, offset) {
    var arr = [];
    offset = offset || 0;
    for (var j = 0; offset < arrLike.length; offset += 1, j += 1) {
      arr[j] = arrLike[offset];
    }
    return arr;
  }, joiny = function(arr, joiner) {
    for (var str = "", i = 0; i < arr.length; i += 1) {
      str += arr[i], i + 1 < arr.length && (str += joiner);
    }
    return str;
  };
  module.exports = function(that) {
    var target = this;
    if ("function" !== typeof target || "[object Function]" !== toStr.apply(target)) {
      throw new TypeError("Function.prototype.bind called on incompatible " + target);
    }
    for (var args = slicy(arguments, 1), bound, boundLength = max(0, target.length - args.length), boundArgs = [], i = 0; i < boundLength; i++) {
      boundArgs[i] = "$" + i;
    }
    bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(function() {
      if (this instanceof bound) {
        var result = target.apply(this, concatty(args, arguments));
        return Object(result) === result ? result : this;
      }
      return target.apply(that, concatty(args, arguments));
    });
    target.prototype && (boundLength = function() {
    }, boundLength.prototype = target.prototype, bound.prototype = new boundLength(), boundLength.prototype = null);
    return bound;
  };
};

//# sourceMappingURL=module$node_modules$function_bind$implementation.js.map
