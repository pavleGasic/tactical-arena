shadow$provide.module$node_modules$$xmldom$xmldom$lib$sax = function(global, require, module, exports) {
  function ParseError(message, locator) {
    this.message = message;
    this.locator = locator;
    Error.captureStackTrace && Error.captureStackTrace(this, ParseError);
  }
  function XMLReader() {
  }
  function parse(source, defaultNSMapCopy, entityMap, domBuilder, errorHandler) {
    function entityReplacer(a) {
      var k = a.slice(1, -1);
      if (Object.hasOwnProperty.call(entityMap, k)) {
        return entityMap[k];
      }
      if ("#" === k.charAt(0)) {
        return a = parseInt(k.substr(1).replace("x", "0x")), 65535 < a ? (a -= 65536, a = String.fromCharCode(55296 + (a >> 10), 56320 + (a & 1023))) : a = String.fromCharCode(a), a;
      }
      errorHandler.error("entity not found:" + a);
      return a;
    }
    function appendText(end) {
      if (end > start) {
        var xt = source.substring(start, end).replace(/&#?\w+;/g, entityReplacer);
        locator && position(start);
        domBuilder.characters(xt, 0, end - start);
        start = end;
      }
    }
    function position(p, m) {
      for (; p >= lineEnd && (m = linePattern.exec(source));) {
        lineStart = m.index, lineEnd = lineStart + m[0].length, locator.lineNumber++;
      }
      locator.columnNumber = p - lineStart + 1;
    }
    var lineStart = 0, lineEnd = 0, linePattern = /.*(?:\r\n?|\n)|.*$/g, locator = domBuilder.locator;
    defaultNSMapCopy = [{currentNSMap:defaultNSMapCopy}];
    for (var closeMap = {}, start = 0;;) {
      try {
        var tagStart = source.indexOf("\x3c", start);
        if (0 > tagStart) {
          if (!source.substr(start).match(/^\s*$/)) {
            var doc = domBuilder.doc, text = doc.createTextNode(source.substr(start));
            doc.appendChild(text);
            domBuilder.currentElement = text;
          }
          break;
        }
        tagStart > start && appendText(tagStart);
        switch(source.charAt(tagStart + 1)) {
          case "/":
            var end = source.indexOf("\x3e", tagStart + 3), tagName = source.substring(tagStart + 2, end).replace(/[ \t\n\r]+$/g, ""), config = defaultNSMapCopy.pop();
            0 > end ? (tagName = source.substring(tagStart + 2).replace(/[\s<].*/, ""), errorHandler.error("end tag name: " + tagName + " is not complete:" + config.tagName), end = tagStart + 1 + tagName.length) : tagName.match(/\s</) && (tagName = tagName.replace(/[\s<].*/, ""), errorHandler.error("end tag name: " + tagName + " maybe not complete"), end = tagStart + 1 + tagName.length);
            var localNSMap = config.localNSMap, endMatch = config.tagName == tagName;
            if (endMatch || config.tagName && config.tagName.toLowerCase() == tagName.toLowerCase()) {
              domBuilder.endElement(config.uri, config.localName, tagName);
              if (localNSMap) {
                for (var prefix in localNSMap) {
                  Object.prototype.hasOwnProperty.call(localNSMap, prefix) && domBuilder.endPrefixMapping(prefix);
                }
              }
              endMatch || errorHandler.fatalError("end tag name: " + tagName + " is not match the current start tagName:" + config.tagName);
            } else {
              defaultNSMapCopy.push(config);
            }
            end++;
            break;
          case "?":
            locator && position(tagStart);
            end = parseInstruction(source, tagStart, domBuilder);
            break;
          case "!":
            locator && position(tagStart);
            end = parseDCC(source, tagStart, domBuilder, errorHandler);
            break;
          default:
            locator && position(tagStart);
            var el = new ElementAttributes(), currentNSMap = defaultNSMapCopy[defaultNSMapCopy.length - 1].currentNSMap;
            end = parseElementStartPart(source, tagStart, el, currentNSMap, entityReplacer, errorHandler);
            var len = el.length;
            !el.closed && fixSelfClosed(source, end, el.tagName, closeMap) && (el.closed = !0, entityMap.nbsp || errorHandler.warning("unclosed xml attribute"));
            if (locator && len) {
              for (var locator2 = copyLocator(locator, {}), i = 0; i < len; i++) {
                var a = el[i];
                position(a.offset);
                a.locator = copyLocator(locator, {});
              }
              domBuilder.locator = locator2;
              appendElement(el, domBuilder, currentNSMap) && defaultNSMapCopy.push(el);
              domBuilder.locator = locator;
            } else {
              appendElement(el, domBuilder, currentNSMap) && defaultNSMapCopy.push(el);
            }
            NAMESPACE.isHTML(el.uri) && !el.closed ? end = parseHtmlSpecialContent(source, end, el.tagName, entityReplacer, domBuilder) : end++;
        }
      } catch (e) {
        if (e instanceof ParseError) {
          throw e;
        }
        errorHandler.error("element parse error: " + e);
        end = -1;
      }
      end > start ? start = end : appendText(Math.max(tagStart, start) + 1);
    }
  }
  function copyLocator(f, t) {
    t.lineNumber = f.lineNumber;
    t.columnNumber = f.columnNumber;
    return t;
  }
  function parseElementStartPart(source, start, el, currentNSMap, entityReplacer, errorHandler) {
    function addAttribute(qname, value, startIndex) {
      el.attributeNames.hasOwnProperty(qname) && errorHandler.fatalError("Attribute " + qname + " redefined");
      el.addValue(qname, value.replace(/[\t\n\r]/g, " ").replace(/&#?\w+;/g, entityReplacer), startIndex);
    }
    for (var attrName, value, p = ++start, s = 0;;) {
      var c = source.charAt(p);
      switch(c) {
        case "\x3d":
          if (1 === s) {
            attrName = source.slice(start, p), s = 3;
          } else if (2 === s) {
            s = 3;
          } else {
            throw Error("attribute equal must after attrName");
          }
          break;
        case "'":
        case '"':
          if (3 === s || 1 === s) {
            if (1 === s && (errorHandler.warning('attribute value must after "\x3d"'), attrName = source.slice(start, p)), start = p + 1, p = source.indexOf(c, start), 0 < p) {
              value = source.slice(start, p), addAttribute(attrName, value, start - 1), s = 5;
            } else {
              throw Error("attribute value no end '" + c + "' match");
            }
          } else if (4 == s) {
            value = source.slice(start, p), addAttribute(attrName, value, start), errorHandler.warning('attribute "' + attrName + '" missed start quot(' + c + ")!!"), start = p + 1, s = 5;
          } else {
            throw Error('attribute value must after "\x3d"');
          }
          break;
        case "/":
          switch(s) {
            case 0:
              el.setTagName(source.slice(start, p));
            case 5:
            case 6:
            case 7:
              s = 7, el.closed = !0;
            case 4:
            case 1:
              break;
            case 2:
              el.closed = !0;
              break;
            default:
              throw Error("attribute invalid close char('/')");
          }break;
        case "":
          return errorHandler.error("unexpected end of input"), 0 == s && el.setTagName(source.slice(start, p)), p;
        case "\x3e":
          switch(s) {
            case 0:
              el.setTagName(source.slice(start, p));
            case 5:
            case 6:
            case 7:
              break;
            case 4:
            case 1:
              value = source.slice(start, p), "/" === value.slice(-1) && (el.closed = !0, value = value.slice(0, -1));
            case 2:
              2 === s && (value = attrName);
              4 == s ? (errorHandler.warning('attribute "' + value + '" missed quot(")!'), addAttribute(attrName, value, start)) : (NAMESPACE.isHTML(currentNSMap[""]) && value.match(/^(?:disabled|checked|selected)$/i) || errorHandler.warning('attribute "' + value + '" missed value!! "' + value + '" instead!!'), addAttribute(value, value, start));
              break;
            case 3:
              throw Error("attribute value missed!!");
          }return p;
        case "Â€":
          c = " ";
        default:
          if (" " >= c) {
            switch(s) {
              case 0:
                el.setTagName(source.slice(start, p));
                s = 6;
                break;
              case 1:
                attrName = source.slice(start, p);
                s = 2;
                break;
              case 4:
                value = source.slice(start, p), errorHandler.warning('attribute "' + value + '" missed quot(")!!'), addAttribute(attrName, value, start);
              case 5:
                s = 6;
            }
          } else {
            switch(s) {
              case 2:
                NAMESPACE.isHTML(currentNSMap[""]) && attrName.match(/^(?:disabled|checked|selected)$/i) || errorHandler.warning('attribute "' + attrName + '" missed value!! "' + attrName + '" instead2!!');
                addAttribute(attrName, attrName, start);
                start = p;
                s = 1;
                break;
              case 5:
                errorHandler.warning('attribute space is required"' + attrName + '"!!');
              case 6:
                s = 1;
                start = p;
                break;
              case 3:
                s = 4;
                start = p;
                break;
              case 7:
                throw Error("elements closed character '/' and '\x3e' must be connected to");
            }
          }
      }
      p++;
    }
  }
  function appendElement(el, domBuilder, currentNSMap) {
    for (var tagName = el.tagName, localNSMap = null, i = el.length; i--;) {
      var a = el[i], qName = a.qName, value = a.value, nsp = qName.indexOf(":");
      if (0 < nsp) {
        var prefix = a.prefix = qName.slice(0, nsp);
        nsp = qName.slice(nsp + 1);
        prefix = "xmlns" === prefix && nsp;
      } else {
        nsp = qName, prefix = "xmlns" === qName && "";
      }
      a.localName = nsp;
      !1 !== prefix && (null == localNSMap && (localNSMap = {}, _copy(currentNSMap, currentNSMap = {})), currentNSMap[prefix] = localNSMap[prefix] = value, a.uri = NAMESPACE.XMLNS, domBuilder.startPrefixMapping(prefix, value));
    }
    for (i = el.length; i--;) {
      if (a = el[i], prefix = a.prefix) {
        "xml" === prefix && (a.uri = NAMESPACE.XML), "xmlns" !== prefix && (a.uri = currentNSMap[prefix || ""]);
      }
    }
    nsp = tagName.indexOf(":");
    0 < nsp ? (prefix = el.prefix = tagName.slice(0, nsp), nsp = el.localName = tagName.slice(nsp + 1)) : (prefix = null, nsp = el.localName = tagName);
    i = el.uri = currentNSMap[prefix || ""];
    domBuilder.startElement(i, nsp, tagName, el);
    if (el.closed) {
      if (domBuilder.endElement(i, nsp, tagName), localNSMap) {
        for (prefix in localNSMap) {
          Object.prototype.hasOwnProperty.call(localNSMap, prefix) && domBuilder.endPrefixMapping(prefix);
        }
      }
    } else {
      return el.currentNSMap = currentNSMap, el.localNSMap = localNSMap, !0;
    }
  }
  function parseHtmlSpecialContent(source, elStartEnd, tagName, entityReplacer, domBuilder) {
    if (/^(?:script|textarea)$/i.test(tagName)) {
      var elEndStart = source.indexOf("\x3c/" + tagName + "\x3e", elStartEnd);
      source = source.substring(elStartEnd + 1, elEndStart);
      if (/[&<]/.test(source)) {
        if (/^script$/i.test(tagName)) {
          return domBuilder.characters(source, 0, source.length), elEndStart;
        }
        source = source.replace(/&#?\w+;/g, entityReplacer);
        domBuilder.characters(source, 0, source.length);
        return elEndStart;
      }
    }
    return elStartEnd + 1;
  }
  function fixSelfClosed(source, elStartEnd, tagName, closeMap) {
    var pos = closeMap[tagName];
    null == pos && (pos = source.lastIndexOf("\x3c/" + tagName + "\x3e"), pos < elStartEnd && (pos = source.lastIndexOf("\x3c/" + tagName)), closeMap[tagName] = pos);
    return pos < elStartEnd;
  }
  function _copy(source, target) {
    for (var n in source) {
      Object.prototype.hasOwnProperty.call(source, n) && (target[n] = source[n]);
    }
  }
  function parseDCC(source, start, domBuilder, errorHandler) {
    switch(source.charAt(start + 2)) {
      case "-":
        if ("-" === source.charAt(start + 3)) {
          var end = source.indexOf("--\x3e", start + 4);
          if (end > start) {
            return domBuilder.comment(source, start + 4, end - start - 4), end + 3;
          }
          errorHandler.error("Unclosed comment");
        }
        break;
      default:
        if ("CDATA[" == source.substr(start + 3, 6)) {
          return end = source.indexOf("]]\x3e", start + 9), domBuilder.startCDATA(), domBuilder.characters(source, start + 9, end - start - 9), domBuilder.endCDATA(), end + 3;
        }
        a: {
          errorHandler = [];
          end = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
          end.lastIndex = start;
          for (end.exec(source); start = end.exec(source);) {
            if (errorHandler.push(start), start[1]) {
              end = errorHandler;
              break a;
            }
          }
          end = void 0;
        }
        var len = end.length;
        if (1 < len && /!doctype/i.test(end[0][0])) {
          return source = end[1][0], errorHandler = start = !1, 3 < len && (/^public$/i.test(end[2][0]) ? (start = end[3][0], errorHandler = 4 < len && end[4][0]) : /^system$/i.test(end[2][0]) && (errorHandler = end[3][0])), end = end[len - 1], domBuilder.startDTD(source, start, errorHandler), domBuilder.endDTD(), end.index + end[0].length;
        }
    }
    return -1;
  }
  function parseInstruction(source, start, domBuilder) {
    var end = source.indexOf("?\x3e", start);
    return end && (source = source.substring(start, end).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/)) ? (domBuilder.processingInstruction(source[1], source[2]), end + 2) : -1;
  }
  function ElementAttributes() {
    this.attributeNames = {};
  }
  var NAMESPACE = require("module$node_modules$$xmldom$xmldom$lib$conventions").NAMESPACE;
  global = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
  require = new RegExp("[\\-\\.0-9" + global.source.slice(1, -1) + "\\u00B7\\u0300-\\u036F\\u203F-\\u2040]");
  var tagNamePattern = new RegExp("^" + global.source + require.source + "*(?::" + global.source + require.source + "*)?$");
  ParseError.prototype = Error();
  ParseError.prototype.name = ParseError.name;
  XMLReader.prototype = {parse:function(source, defaultNSMap, entityMap) {
    var domBuilder = this.domBuilder;
    domBuilder.startDocument();
    _copy(defaultNSMap, defaultNSMap = {});
    parse(source, defaultNSMap, entityMap, domBuilder, this.errorHandler);
    domBuilder.endDocument();
  }};
  ElementAttributes.prototype = {setTagName:function(tagName) {
    if (!tagNamePattern.test(tagName)) {
      throw Error("invalid tagName:" + tagName);
    }
    this.tagName = tagName;
  }, addValue:function(qName, value, offset) {
    if (!tagNamePattern.test(qName)) {
      throw Error("invalid attribute:" + qName);
    }
    this.attributeNames[qName] = this.length;
    this[this.length++] = {qName, value, offset};
  }, length:0, getLocalName:function(i) {
    return this[i].localName;
  }, getLocator:function(i) {
    return this[i].locator;
  }, getQName:function(i) {
    return this[i].qName;
  }, getURI:function(i) {
    return this[i].uri;
  }, getValue:function(i) {
    return this[i].value;
  }};
  exports.XMLReader = XMLReader;
  exports.ParseError = ParseError;
};

//# sourceMappingURL=module$node_modules$$xmldom$xmldom$lib$sax.js.map
