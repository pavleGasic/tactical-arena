shadow$provide.module$node_modules$pixi_DOT_js$lib$scene$particle_container$shared$ParticleContainerPipe = function(global, require, module, exports) {
  var Matrix = require("module$node_modules$pixi_DOT_js$lib$maths$matrix$Matrix"), UniformGroup = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$shader$UniformGroup"), getAdjustedBlendModeBlend = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$state$getAdjustedBlendModeBlend"), State = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$state$State"), colorToUniform = require("module$node_modules$pixi_DOT_js$lib$scene$graphics$gpu$colorToUniform"), 
  ParticleBuffer = require("module$node_modules$pixi_DOT_js$lib$scene$particle_container$shared$ParticleBuffer"), ParticleShader = require("module$node_modules$pixi_DOT_js$lib$scene$particle_container$shared$shader$ParticleShader");
  "use strict";
  class ParticleContainerPipe {
    constructor(renderer, adaptor) {
      this.state = State.State.for2d();
      this._gpuBufferHash = Object.create(null);
      this._destroyRenderableBound = this.destroyRenderable.bind(this);
      this.localUniforms = new UniformGroup.UniformGroup({uTranslationMatrix:{value:new Matrix.Matrix(), type:"mat3x3\x3cf32\x3e"}, uColor:{value:new Float32Array(4), type:"vec4\x3cf32\x3e"}, uRound:{value:1, type:"f32"}, uResolution:{value:[0, 0], type:"vec2\x3cf32\x3e"}});
      this.renderer = renderer;
      this.adaptor = adaptor;
      this.defaultShader = new ParticleShader.ParticleShader();
      this.state = State.State.for2d();
    }
    validateRenderable(_renderable) {
      return !1;
    }
    addRenderable(renderable, instructionSet) {
      this.renderer.renderPipes.batch.break(instructionSet);
      instructionSet.add(renderable);
    }
    getBuffers(renderable) {
      return this._gpuBufferHash[renderable.uid] || this._initBuffer(renderable);
    }
    _initBuffer(renderable) {
      this._gpuBufferHash[renderable.uid] = new ParticleBuffer.ParticleBuffer({size:renderable.particleChildren.length, properties:renderable._properties});
      renderable.on("destroyed", this._destroyRenderableBound);
      return this._gpuBufferHash[renderable.uid];
    }
    updateRenderable(_renderable) {
    }
    destroyRenderable(renderable) {
      this._gpuBufferHash[renderable.uid].destroy();
      this._gpuBufferHash[renderable.uid] = null;
      renderable.off("destroyed", this._destroyRenderableBound);
    }
    execute(container) {
      var children = container.particleChildren;
      if (0 !== children.length) {
        var renderer = this.renderer, buffer = this.getBuffers(container);
        container.texture || (container.texture = children[0].texture);
        var state = this.state;
        buffer.update(children, container._childrenDirty);
        container._childrenDirty = !1;
        state.blendMode = getAdjustedBlendModeBlend.getAdjustedBlendModeBlend(container.blendMode, container.texture._source);
        children = this.localUniforms.uniforms;
        buffer = children.uTranslationMatrix;
        container.worldTransform.copyTo(buffer);
        buffer.prepend(renderer.globalUniforms.globalUniformData.projectionMatrix);
        children.uResolution = renderer.globalUniforms.globalUniformData.resolution;
        children.uRound = renderer._roundPixels | container._roundPixels;
        colorToUniform.color32BitToUniform(container.groupColorAlpha, children.uColor, 0);
        this.adaptor.execute(this, container);
      }
    }
    destroy() {
      this.defaultShader && (this.defaultShader.destroy(), this.defaultShader = null);
    }
  }
  exports.ParticleContainerPipe = ParticleContainerPipe;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$scene$particle_container$shared$ParticleContainerPipe.js.map
