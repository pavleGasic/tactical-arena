shadow$provide.module$node_modules$$pixi$text$lib$TextMetrics = function(global, require, module, exports) {
  var core = require("module$node_modules$$pixi$core$lib$index");
  const contextSettings = {willReadFrequently:!0};
  global = (() => {
    const node_modules$$pixi$text$lib$TextMetrics$classdecl$var20 = class {
      static get experimentalLetterSpacingSupported() {
        var result = node_modules$$pixi$text$lib$TextMetrics$classdecl$var20._experimentalLetterSpacingSupported;
        void 0 !== result && (result = core.settings.ADAPTER.getCanvasRenderingContext2D().prototype, result = node_modules$$pixi$text$lib$TextMetrics$classdecl$var20._experimentalLetterSpacingSupported = "letterSpacing" in result || "textLetterSpacing" in result);
        return result;
      }
      constructor(text, style, width, height, lines, lineWidths, lineHeight, maxLineWidth, fontProperties) {
        this.text = text;
        this.style = style;
        this.width = width;
        this.height = height;
        this.lines = lines;
        this.lineWidths = lineWidths;
        this.lineHeight = lineHeight;
        this.maxLineWidth = maxLineWidth;
        this.fontProperties = fontProperties;
      }
      static measureText(text, style, wordWrap, canvas = node_modules$$pixi$text$lib$TextMetrics$classdecl$var20._canvas) {
        wordWrap = wordWrap ?? style.wordWrap;
        var font = style.toFontString();
        const fontProperties = node_modules$$pixi$text$lib$TextMetrics$classdecl$var20.measureFont(font);
        0 === fontProperties.fontSize && (fontProperties.fontSize = style.fontSize, fontProperties.ascent = style.fontSize);
        var context = canvas.getContext("2d", contextSettings);
        context.font = font;
        wordWrap = (wordWrap ? node_modules$$pixi$text$lib$TextMetrics$classdecl$var20.wordWrap(text, style, canvas) : text).split(/(?:\r\n|\r|\n)/);
        canvas = Array(wordWrap.length);
        font = 0;
        for (var i = 0; i < wordWrap.length; i++) {
          var lineWidth = node_modules$$pixi$text$lib$TextMetrics$classdecl$var20._measureText(wordWrap[i], style.letterSpacing, context);
          canvas[i] = lineWidth;
          font = Math.max(font, lineWidth);
        }
        context = font + style.strokeThickness;
        style.dropShadow && (context += style.dropShadowDistance);
        i = style.lineHeight || fontProperties.fontSize + style.strokeThickness;
        lineWidth = Math.max(i, fontProperties.fontSize + 2 * style.strokeThickness) + style.leading + (wordWrap.length - 1) * (i + style.leading);
        return style.dropShadow && (lineWidth += style.dropShadowDistance), new node_modules$$pixi$text$lib$TextMetrics$classdecl$var20(text, style, context, lineWidth, wordWrap, canvas, i + style.leading, font, fontProperties);
      }
      static _measureText(text, letterSpacing, context) {
        let useExperimentalLetterSpacing = !1;
        node_modules$$pixi$text$lib$TextMetrics$classdecl$var20.experimentalLetterSpacingSupported && (node_modules$$pixi$text$lib$TextMetrics$classdecl$var20.experimentalLetterSpacing ? (context.letterSpacing = `${letterSpacing}px`, context.textLetterSpacing = `${letterSpacing}px`, useExperimentalLetterSpacing = !0) : (context.letterSpacing = "0px", context.textLetterSpacing = "0px"));
        context = context.measureText(text).width;
        return 0 < context && (useExperimentalLetterSpacing ? context -= letterSpacing : context += (node_modules$$pixi$text$lib$TextMetrics$classdecl$var20.graphemeSegmenter(text).length - 1) * letterSpacing), context;
      }
      static wordWrap(text, style, canvas = node_modules$$pixi$text$lib$TextMetrics$classdecl$var20._canvas) {
        canvas = canvas.getContext("2d", contextSettings);
        let width = 0, line = "", lines = "";
        const cache = Object.create(null), {letterSpacing, whiteSpace} = style, collapseSpaces = node_modules$$pixi$text$lib$TextMetrics$classdecl$var20.collapseSpaces(whiteSpace), collapseNewlines = node_modules$$pixi$text$lib$TextMetrics$classdecl$var20.collapseNewlines(whiteSpace);
        let canPrependSpaces = !collapseSpaces;
        const wordWrapWidth = style.wordWrapWidth + letterSpacing;
        text = node_modules$$pixi$text$lib$TextMetrics$classdecl$var20.tokenize(text);
        for (let i = 0; i < text.length; i++) {
          let token = text[i];
          if (node_modules$$pixi$text$lib$TextMetrics$classdecl$var20.isNewline(token)) {
            if (!collapseNewlines) {
              lines += node_modules$$pixi$text$lib$TextMetrics$classdecl$var20.addLine(line);
              canPrependSpaces = !collapseSpaces;
              line = "";
              width = 0;
              continue;
            }
            token = " ";
          }
          if (collapseSpaces) {
            var currIsBreakingSpace = node_modules$$pixi$text$lib$TextMetrics$classdecl$var20.isBreakingSpace(token), lastIsBreakingSpace = node_modules$$pixi$text$lib$TextMetrics$classdecl$var20.isBreakingSpace(line[line.length - 1]);
            if (currIsBreakingSpace && lastIsBreakingSpace) {
              continue;
            }
          }
          currIsBreakingSpace = node_modules$$pixi$text$lib$TextMetrics$classdecl$var20.getFromCache(token, letterSpacing, cache, canvas);
          if (currIsBreakingSpace > wordWrapWidth) {
            if ("" !== line && (lines += node_modules$$pixi$text$lib$TextMetrics$classdecl$var20.addLine(line), line = "", width = 0), node_modules$$pixi$text$lib$TextMetrics$classdecl$var20.canBreakWords(token, style.breakWords)) {
              for (currIsBreakingSpace = node_modules$$pixi$text$lib$TextMetrics$classdecl$var20.wordWrapSplit(token), lastIsBreakingSpace = 0; lastIsBreakingSpace < currIsBreakingSpace.length; lastIsBreakingSpace++) {
                let char = currIsBreakingSpace[lastIsBreakingSpace];
                var lastChar = char;
                let k = 1;
                for (; currIsBreakingSpace[lastIsBreakingSpace + k];) {
                  const nextChar = currIsBreakingSpace[lastIsBreakingSpace + k];
                  if (node_modules$$pixi$text$lib$TextMetrics$classdecl$var20.canBreakChars(lastChar, nextChar, token, lastIsBreakingSpace, style.breakWords)) {
                    break;
                  } else {
                    char += nextChar;
                  }
                  lastChar = nextChar;
                  k++;
                }
                lastIsBreakingSpace += k - 1;
                lastChar = node_modules$$pixi$text$lib$TextMetrics$classdecl$var20.getFromCache(char, letterSpacing, cache, canvas);
                lastChar + width > wordWrapWidth && (lines += node_modules$$pixi$text$lib$TextMetrics$classdecl$var20.addLine(line), canPrependSpaces = !1, line = "", width = 0);
                line += char;
                width += lastChar;
              }
            } else {
              0 < line.length && (lines += node_modules$$pixi$text$lib$TextMetrics$classdecl$var20.addLine(line)), lines += node_modules$$pixi$text$lib$TextMetrics$classdecl$var20.addLine(token, i !== text.length - 1), canPrependSpaces = !1, line = "", width = 0;
            }
          } else {
            currIsBreakingSpace + width > wordWrapWidth && (canPrependSpaces = !1, lines += node_modules$$pixi$text$lib$TextMetrics$classdecl$var20.addLine(line), line = "", width = 0), (0 < line.length || !node_modules$$pixi$text$lib$TextMetrics$classdecl$var20.isBreakingSpace(token) || canPrependSpaces) && (line += token, width += currIsBreakingSpace);
          }
        }
        return lines += node_modules$$pixi$text$lib$TextMetrics$classdecl$var20.addLine(line, !1), lines;
      }
      static addLine(line, newLine = !0) {
        return line = node_modules$$pixi$text$lib$TextMetrics$classdecl$var20.trimRight(line), line = newLine ? `${line}
` : line, line;
      }
      static getFromCache(key, letterSpacing, cache, context) {
        let width = cache[key];
        return "number" != typeof width && (width = node_modules$$pixi$text$lib$TextMetrics$classdecl$var20._measureText(key, letterSpacing, context) + letterSpacing, cache[key] = width), width;
      }
      static collapseSpaces(whiteSpace) {
        return "normal" === whiteSpace || "pre-line" === whiteSpace;
      }
      static collapseNewlines(whiteSpace) {
        return "normal" === whiteSpace;
      }
      static trimRight(text) {
        if ("string" != typeof text) {
          return "";
        }
        for (let i = text.length - 1; 0 <= i && node_modules$$pixi$text$lib$TextMetrics$classdecl$var20.isBreakingSpace(text[i]); i--) {
          text = text.slice(0, -1);
        }
        return text;
      }
      static isNewline(char) {
        return "string" != typeof char ? !1 : node_modules$$pixi$text$lib$TextMetrics$classdecl$var20._newlines.includes(char.charCodeAt(0));
      }
      static isBreakingSpace(char, _nextChar) {
        return "string" != typeof char ? !1 : node_modules$$pixi$text$lib$TextMetrics$classdecl$var20._breakingSpaces.includes(char.charCodeAt(0));
      }
      static tokenize(text) {
        const tokens = [];
        let token = "";
        if ("string" != typeof text) {
          return tokens;
        }
        for (let i = 0; i < text.length; i++) {
          const char = text[i];
          node_modules$$pixi$text$lib$TextMetrics$classdecl$var20.isBreakingSpace(char, text[i + 1]) || node_modules$$pixi$text$lib$TextMetrics$classdecl$var20.isNewline(char) ? ("" !== token && (tokens.push(token), token = ""), tokens.push(char)) : token += char;
        }
        return "" !== token && tokens.push(token), tokens;
      }
      static canBreakWords(_token, breakWords) {
        return breakWords;
      }
      static canBreakChars(_char, _nextChar, _token, _index, _breakWords) {
        return !0;
      }
      static wordWrapSplit(token) {
        return node_modules$$pixi$text$lib$TextMetrics$classdecl$var20.graphemeSegmenter(token);
      }
      static measureFont(font) {
        if (node_modules$$pixi$text$lib$TextMetrics$classdecl$var20._fonts[font]) {
          return node_modules$$pixi$text$lib$TextMetrics$classdecl$var20._fonts[font];
        }
        const properties = {ascent:0, descent:0, fontSize:0};
        var canvas = node_modules$$pixi$text$lib$TextMetrics$classdecl$var20._canvas, context = node_modules$$pixi$text$lib$TextMetrics$classdecl$var20._context;
        context.font = font;
        var metricsString = node_modules$$pixi$text$lib$TextMetrics$classdecl$var20.METRICS_STRING + node_modules$$pixi$text$lib$TextMetrics$classdecl$var20.BASELINE_SYMBOL, width = Math.ceil(context.measureText(metricsString).width);
        let baseline = Math.ceil(context.measureText(node_modules$$pixi$text$lib$TextMetrics$classdecl$var20.BASELINE_SYMBOL).width);
        var height = Math.ceil(node_modules$$pixi$text$lib$TextMetrics$classdecl$var20.HEIGHT_MULTIPLIER * baseline);
        if (baseline = baseline * node_modules$$pixi$text$lib$TextMetrics$classdecl$var20.BASELINE_MULTIPLIER | 0, 0 === width || 0 === height) {
          return node_modules$$pixi$text$lib$TextMetrics$classdecl$var20._fonts[font] = properties, properties;
        }
        canvas.width = width;
        canvas.height = height;
        context.fillStyle = "#f00";
        context.fillRect(0, 0, width, height);
        context.font = font;
        context.textBaseline = "alphabetic";
        context.fillStyle = "#000";
        context.fillText(metricsString, 0, baseline);
        canvas = context.getImageData(0, 0, width, height).data;
        context = canvas.length;
        width *= 4;
        let idx = 0, stop = !1;
        for (metricsString = 0; metricsString < baseline; ++metricsString) {
          for (let j = 0; j < width; j += 4) {
            if (255 !== canvas[idx + j]) {
              stop = !0;
              break;
            }
          }
          if (stop) {
            break;
          } else {
            idx += width;
          }
        }
        properties.ascent = baseline - metricsString;
        idx = context - width;
        stop = !1;
        for (metricsString = height; metricsString > baseline; --metricsString) {
          for (height = 0; height < width; height += 4) {
            if (255 !== canvas[idx + height]) {
              stop = !0;
              break;
            }
          }
          if (stop) {
            break;
          } else {
            idx -= width;
          }
        }
        return properties.descent = metricsString - baseline, properties.fontSize = properties.ascent + properties.descent, node_modules$$pixi$text$lib$TextMetrics$classdecl$var20._fonts[font] = properties, properties;
      }
      static clearMetrics(font = "") {
        font ? delete node_modules$$pixi$text$lib$TextMetrics$classdecl$var20._fonts[font] : node_modules$$pixi$text$lib$TextMetrics$classdecl$var20._fonts = {};
      }
      static get _canvas() {
        if (!node_modules$$pixi$text$lib$TextMetrics$classdecl$var20.__canvas) {
          let canvas;
          try {
            const c = new OffscreenCanvas(0, 0);
            if (c.getContext("2d", contextSettings)?.measureText) {
              return node_modules$$pixi$text$lib$TextMetrics$classdecl$var20.__canvas = c, c;
            }
            canvas = core.settings.ADAPTER.createCanvas();
          } catch {
            canvas = core.settings.ADAPTER.createCanvas();
          }
          canvas.width = canvas.height = 10;
          node_modules$$pixi$text$lib$TextMetrics$classdecl$var20.__canvas = canvas;
        }
        return node_modules$$pixi$text$lib$TextMetrics$classdecl$var20.__canvas;
      }
      static get _context() {
        return node_modules$$pixi$text$lib$TextMetrics$classdecl$var20.__context || (node_modules$$pixi$text$lib$TextMetrics$classdecl$var20.__context = node_modules$$pixi$text$lib$TextMetrics$classdecl$var20._canvas.getContext("2d", contextSettings)), node_modules$$pixi$text$lib$TextMetrics$classdecl$var20.__context;
      }
    };
    return node_modules$$pixi$text$lib$TextMetrics$classdecl$var20;
  })();
  global.METRICS_STRING = "|ÉqÅ";
  global.BASELINE_SYMBOL = "M";
  global.BASELINE_MULTIPLIER = 1.4;
  global.HEIGHT_MULTIPLIER = 2;
  global.graphemeSegmenter = (() => {
    if ("function" == typeof Intl?.Segmenter) {
      const segmenter = new Intl.Segmenter();
      return s => [...segmenter.segment(s)].map(x => x.segment);
    }
    return s => [...s];
  })();
  global.experimentalLetterSpacing = !1;
  global._fonts = {};
  global._newlines = [10, 13];
  global._breakingSpaces = [9, 32, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8200, 8201, 8202, 8287, 12288];
  exports.TextMetrics = global;
};

//# sourceMappingURL=module$node_modules$$pixi$text$lib$TextMetrics.js.map
