shadow$provide.module$node_modules$$pixi$core$lib$renderTexture$RenderTexture = function(global, require, module, exports) {
  global = require("module$node_modules$$pixi$core$lib$textures$Texture");
  var BaseRenderTexture = require("module$node_modules$$pixi$core$lib$renderTexture$BaseRenderTexture");
  class RenderTexture extends global.Texture {
    constructor(baseRenderTexture, frame) {
      super(baseRenderTexture, frame);
      this.valid = !0;
      this.filterPoolKey = this.filterFrame = null;
      this.updateUvs();
    }
    get framebuffer() {
      return this.baseTexture.framebuffer;
    }
    get multisample() {
      return this.framebuffer.multisample;
    }
    set multisample(value) {
      this.framebuffer.multisample = value;
    }
    resize(desiredWidth, desiredHeight, resizeBaseTexture = !0) {
      const resolution = this.baseTexture.resolution;
      desiredWidth = Math.round(desiredWidth * resolution) / resolution;
      desiredHeight = Math.round(desiredHeight * resolution) / resolution;
      this.valid = 0 < desiredWidth && 0 < desiredHeight;
      this._frame.width = this.orig.width = desiredWidth;
      this._frame.height = this.orig.height = desiredHeight;
      resizeBaseTexture && this.baseTexture.resize(desiredWidth, desiredHeight);
      this.updateUvs();
    }
    setResolution(resolution) {
      const {baseTexture} = this;
      baseTexture.resolution !== resolution && (baseTexture.setResolution(resolution), this.resize(baseTexture.width, baseTexture.height, !1));
    }
    static create(options) {
      return new RenderTexture(new BaseRenderTexture.BaseRenderTexture(options));
    }
  }
  exports.RenderTexture = RenderTexture;
};

//# sourceMappingURL=module$node_modules$$pixi$core$lib$renderTexture$RenderTexture.js.map
