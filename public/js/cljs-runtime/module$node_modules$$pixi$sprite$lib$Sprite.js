shadow$provide.module$node_modules$$pixi$sprite$lib$Sprite = function(global, require, module, exports) {
  var core = require("module$node_modules$$pixi$core$lib$index"), display = require("module$node_modules$$pixi$display$lib$index");
  const tempPoint = new core.Point(), indices = new Uint16Array([0, 1, 2, 0, 2, 3]);
  class Sprite extends display.Container {
    constructor(texture) {
      super();
      this._anchor = new core.ObservablePoint(this._onAnchorUpdate, this, texture ? texture.defaultAnchor.x : 0, texture ? texture.defaultAnchor.y : 0);
      this._texture = null;
      this._height = this._width = 0;
      this._tintColor = new core.Color(16777215);
      this._tintRGB = null;
      this.tint = 16777215;
      this.blendMode = core.BLEND_MODES.NORMAL;
      this._cachedTint = 16777215;
      this.uvs = null;
      this.texture = texture || core.Texture.EMPTY;
      this.vertexData = new Float32Array(8);
      this.vertexTrimmedData = null;
      this._textureTrimmedID = this._transformTrimmedID = this._textureID = this._transformID = -1;
      this.indices = indices;
      this.pluginName = "batch";
      this.isSprite = !0;
      this._roundPixels = core.settings.ROUND_PIXELS;
    }
    _onTextureUpdate() {
      this._textureTrimmedID = this._textureID = -1;
      this._cachedTint = 16777215;
      this._width && (this.scale.x = core.utils.sign(this.scale.x) * this._width / this._texture.orig.width);
      this._height && (this.scale.y = core.utils.sign(this.scale.y) * this._height / this._texture.orig.height);
    }
    _onAnchorUpdate() {
      this._transformTrimmedID = this._transformID = -1;
    }
    calculateVertices() {
      var texture = this._texture;
      if (this._transformID !== this.transform._worldID || this._textureID !== texture._updateID) {
        this._textureID !== texture._updateID && (this.uvs = this._texture._uvs.uvsFloat32);
        this._transformID = this.transform._worldID;
        this._textureID = texture._updateID;
        var wt = this.transform.worldTransform, a = wt.a, b = wt.b, c = wt.c, d = wt.d, tx = wt.tx, ty = wt.ty;
        wt = this.vertexData;
        var trim = texture.trim;
        texture = texture.orig;
        var anchor = this._anchor, w0 = 0, w1 = 0, h0 = 0, h1 = 0;
        if (trim ? (w1 = trim.x - anchor._x * texture.width, w0 = w1 + trim.width, h1 = trim.y - anchor._y * texture.height, h0 = h1 + trim.height) : (w1 = -anchor._x * texture.width, w0 = w1 + texture.width, h1 = -anchor._y * texture.height, h0 = h1 + texture.height), wt[0] = a * w1 + c * h1 + tx, wt[1] = d * h1 + b * w1 + ty, wt[2] = a * w0 + c * h1 + tx, wt[3] = d * h1 + b * w0 + ty, wt[4] = a * w0 + c * h0 + tx, wt[5] = d * h0 + b * w0 + ty, wt[6] = a * w1 + c * h0 + tx, wt[7] = d * h0 + b * 
        w1 + ty, this._roundPixels) {
          for (a = core.settings.RESOLUTION, b = 0; b < wt.length; ++b) {
            wt[b] = Math.round(wt[b] * a) / a;
          }
        }
      }
    }
    calculateTrimmedVertices() {
      if (!this.vertexTrimmedData) {
        this.vertexTrimmedData = new Float32Array(8);
      } else if (this._transformTrimmedID === this.transform._worldID && this._textureTrimmedID === this._texture._updateID) {
        return;
      }
      this._transformTrimmedID = this.transform._worldID;
      this._textureTrimmedID = this._texture._updateID;
      const vertexData = this.vertexTrimmedData;
      var orig = this._texture.orig, anchor = this._anchor, wt = this.transform.worldTransform, a = wt.a, b = wt.b;
      const c = wt.c, d = wt.d, tx = wt.tx;
      wt = wt.ty;
      const w1 = -anchor._x * orig.width, w0 = w1 + orig.width;
      anchor = -anchor._y * orig.height;
      orig = anchor + orig.height;
      if (vertexData[0] = a * w1 + c * anchor + tx, vertexData[1] = d * anchor + b * w1 + wt, vertexData[2] = a * w0 + c * anchor + tx, vertexData[3] = d * anchor + b * w0 + wt, vertexData[4] = a * w0 + c * orig + tx, vertexData[5] = d * orig + b * w0 + wt, vertexData[6] = a * w1 + c * orig + tx, vertexData[7] = d * orig + b * w1 + wt, this._roundPixels) {
        for (a = core.settings.RESOLUTION, b = 0; b < vertexData.length; ++b) {
          vertexData[b] = Math.round(vertexData[b] * a) / a;
        }
      }
    }
    _render(renderer) {
      this.calculateVertices();
      renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);
      renderer.plugins[this.pluginName].render(this);
    }
    _calculateBounds() {
      const trim = this._texture.trim, orig = this._texture.orig;
      !trim || trim.width === orig.width && trim.height === orig.height ? (this.calculateVertices(), this._bounds.addQuad(this.vertexData)) : (this.calculateTrimmedVertices(), this._bounds.addQuad(this.vertexTrimmedData));
    }
    getLocalBounds(rect) {
      return 0 === this.children.length ? (this._localBounds || (this._localBounds = new display.Bounds()), this._localBounds.minX = this._texture.orig.width * -this._anchor._x, this._localBounds.minY = this._texture.orig.height * -this._anchor._y, this._localBounds.maxX = this._texture.orig.width * (1 - this._anchor._x), this._localBounds.maxY = this._texture.orig.height * (1 - this._anchor._y), rect || (this._localBoundsRect || (this._localBoundsRect = new core.Rectangle()), rect = this._localBoundsRect), 
      this._localBounds.getRectangle(rect)) : super.getLocalBounds.call(this, rect);
    }
    containsPoint(point) {
      this.worldTransform.applyInverse(point, tempPoint);
      point = this._texture.orig.width;
      const height = this._texture.orig.height, x1 = -point * this.anchor.x;
      let y1 = 0;
      return tempPoint.x >= x1 && tempPoint.x < x1 + point && (y1 = -height * this.anchor.y, tempPoint.y >= y1 && tempPoint.y < y1 + height);
    }
    destroy(options) {
      (super.destroy(options), this._texture.off("update", this._onTextureUpdate, this), this._anchor = null, "boolean" == typeof options ? options : options?.texture) && this._texture.destroy(!("boolean" == typeof options ? !options : !options?.baseTexture));
      this._texture = null;
    }
    static from(source, options) {
      source = source instanceof core.Texture ? source : core.Texture.from(source, options);
      return new Sprite(source);
    }
    set roundPixels(value) {
      this._roundPixels !== value && (this._transformID = -1, this._transformTrimmedID = -1);
      this._roundPixels = value;
    }
    get roundPixels() {
      return this._roundPixels;
    }
    get width() {
      return Math.abs(this.scale.x) * this._texture.orig.width;
    }
    set width(value) {
      const s = core.utils.sign(this.scale.x) || 1;
      this.scale.x = s * value / this._texture.orig.width;
      this._width = value;
    }
    get height() {
      return Math.abs(this.scale.y) * this._texture.orig.height;
    }
    set height(value) {
      const s = core.utils.sign(this.scale.y) || 1;
      this.scale.y = s * value / this._texture.orig.height;
      this._height = value;
    }
    get anchor() {
      return this._anchor;
    }
    set anchor(value) {
      this._anchor.copyFrom(value);
    }
    get tint() {
      return this._tintColor.value;
    }
    set tint(value) {
      this._tintColor.setValue(value);
      this._tintRGB = this._tintColor.toLittleEndianNumber();
    }
    get tintValue() {
      return this._tintColor.toNumber();
    }
    get texture() {
      return this._texture;
    }
    set texture(value) {
      this._texture !== value && (this._texture && this._texture.off("update", this._onTextureUpdate, this), this._texture = value || core.Texture.EMPTY, this._cachedTint = 16777215, this._textureID = -1, this._textureTrimmedID = -1, value && (value.baseTexture.valid ? this._onTextureUpdate() : value.once("update", this._onTextureUpdate, this)));
    }
  }
  exports.Sprite = Sprite;
};

//# sourceMappingURL=module$node_modules$$pixi$sprite$lib$Sprite.js.map
