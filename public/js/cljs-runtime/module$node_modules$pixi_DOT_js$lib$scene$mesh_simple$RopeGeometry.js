shadow$provide.module$node_modules$pixi_DOT_js$lib$scene$mesh_simple$RopeGeometry = function(global, require, module, exports) {
  global = require("module$node_modules$pixi_DOT_js$lib$scene$mesh$shared$MeshGeometry");
  "use strict";
  const node_modules$pixi_DOT_js$lib$scene$mesh_simple$RopeGeometry$classdecl$var43 = class extends global.MeshGeometry {
    constructor(options) {
      const {width, points, textureScale} = {...node_modules$pixi_DOT_js$lib$scene$mesh_simple$RopeGeometry$classdecl$var43.defaultOptions, ...options};
      super({positions:new Float32Array(4 * points.length), uvs:new Float32Array(4 * points.length), indices:new Uint32Array(6 * (points.length - 1))});
      this.points = points;
      this._width = width;
      this.textureScale = textureScale;
      this._build();
    }
    get width() {
      return this._width;
    }
    _build() {
      var points = this.points;
      if (points) {
        var vertexBuffer = this.getBuffer("aPosition"), uvBuffer = this.getBuffer("aUV"), indexBuffer = this.getIndex();
        if (!(1 > points.length)) {
          vertexBuffer.data.length / 4 !== points.length && (vertexBuffer.data = new Float32Array(4 * points.length), uvBuffer.data = new Float32Array(4 * points.length), indexBuffer.data = new Uint16Array(6 * (points.length - 1)));
          var uvs = uvBuffer.data;
          vertexBuffer = indexBuffer.data;
          uvs[0] = 0;
          uvs[1] = 0;
          uvs[2] = 0;
          uvs[3] = 1;
          var amount = 0, prev = points[0], textureWidth = this._width * this.textureScale, total = points.length;
          for (let i = 0; i < total; i++) {
            const index = 4 * i;
            if (0 < this.textureScale) {
              var dx = prev.x - points[i].x;
              prev = prev.y - points[i].y;
              dx = Math.sqrt(dx * dx + prev * prev);
              prev = points[i];
              amount += dx / textureWidth;
            } else {
              amount = i / (total - 1);
            }
            uvs[index] = amount;
            uvs[index + 1] = 0;
            uvs[index + 2] = amount;
            uvs[index + 3] = 1;
          }
          points = 0;
          for (uvs = 0; uvs < total - 1; uvs++) {
            amount = 2 * uvs, vertexBuffer[points++] = amount, vertexBuffer[points++] = amount + 1, vertexBuffer[points++] = amount + 2, vertexBuffer[points++] = amount + 2, vertexBuffer[points++] = amount + 1, vertexBuffer[points++] = amount + 3;
          }
          uvBuffer.update();
          indexBuffer.update();
          this.updateVertices();
        }
      }
    }
    updateVertices() {
      const points = this.points;
      if (!(1 > points.length)) {
        var lastPoint = points[0], vertices = this.buffers[0].data, total = points.length, halfWidth = 0 < this.textureScale ? this.textureScale * this._width / 2 : this._width / 2;
        for (let i = 0; i < total; i++) {
          const point = points[i], index = 4 * i;
          var nextPoint = i < points.length - 1 ? points[i + 1] : point;
          var perpY = -(nextPoint.x - lastPoint.x);
          lastPoint = nextPoint.y - lastPoint.y;
          nextPoint = Math.sqrt(lastPoint * lastPoint + perpY * perpY);
          1e-6 > nextPoint ? perpY = lastPoint = 0 : (lastPoint /= nextPoint, perpY /= nextPoint, lastPoint *= halfWidth, perpY *= halfWidth);
          vertices[index] = point.x + lastPoint;
          vertices[index + 1] = point.y + perpY;
          vertices[index + 2] = point.x - lastPoint;
          vertices[index + 3] = point.y - perpY;
          lastPoint = point;
        }
        this.buffers[0].update();
      }
    }
    update() {
      0 < this.textureScale ? this._build() : this.updateVertices();
    }
  };
  global = node_modules$pixi_DOT_js$lib$scene$mesh_simple$RopeGeometry$classdecl$var43;
  global.defaultOptions = {width:200, points:[], textureScale:0};
  exports.RopeGeometry = global;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$scene$mesh_simple$RopeGeometry.js.map
