shadow$provide.module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$texture$TexturePool = function(global, require, module, exports) {
  var pow2 = require("module$node_modules$pixi_DOT_js$lib$maths$misc$pow2"), TextureSource = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$texture$sources$TextureSource"), Texture = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$texture$Texture");
  "use strict";
  let count = 0;
  class TexturePoolClass {
    constructor(textureOptions) {
      this._poolKeyHash = Object.create(null);
      this._texturePool = {};
      this.textureOptions = textureOptions || {};
      this.enableFullScreen = !1;
    }
    createTexture(pixelWidth, pixelHeight, antialias) {
      pixelWidth = new TextureSource.TextureSource({...this.textureOptions, width:pixelWidth, height:pixelHeight, resolution:1, antialias, autoGarbageCollect:!1});
      return new Texture.Texture({source:pixelWidth, label:`texturePool_${count++}`});
    }
    getOptimalTexture(frameWidth, frameHeight, resolution = 1, antialias) {
      let po2Width = Math.ceil(frameWidth * resolution - 1e-6), po2Height = Math.ceil(frameHeight * resolution - 1e-6);
      po2Width = pow2.nextPow2(po2Width);
      po2Height = pow2.nextPow2(po2Height);
      const key = (po2Width << 17) + (po2Height << 1) + (antialias ? 1 : 0);
      this._texturePool[key] || (this._texturePool[key] = []);
      let texture = this._texturePool[key].pop();
      texture || (texture = this.createTexture(po2Width, po2Height, antialias));
      texture.source._resolution = resolution;
      texture.source.width = po2Width / resolution;
      texture.source.height = po2Height / resolution;
      texture.source.pixelWidth = po2Width;
      texture.source.pixelHeight = po2Height;
      texture.frame.x = 0;
      texture.frame.y = 0;
      texture.frame.width = frameWidth;
      texture.frame.height = frameHeight;
      texture.updateUvs();
      this._poolKeyHash[texture.uid] = key;
      return texture;
    }
    getSameSizeTexture(texture, antialias = !1) {
      return this.getOptimalTexture(texture.width, texture.height, texture.source._resolution, antialias);
    }
    returnTexture(renderTexture) {
      this._texturePool[this._poolKeyHash[renderTexture.uid]].push(renderTexture);
    }
    clear(destroyTextures) {
      if (!1 !== destroyTextures) {
        for (const i in this._texturePool) {
          if (destroyTextures = this._texturePool[i]) {
            for (let j = 0; j < destroyTextures.length; j++) {
              destroyTextures[j].destroy(!0);
            }
          }
        }
      }
      this._texturePool = {};
    }
  }
  global = new TexturePoolClass();
  exports.TexturePool = global;
  exports.TexturePoolClass = TexturePoolClass;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$texture$TexturePool.js.map
