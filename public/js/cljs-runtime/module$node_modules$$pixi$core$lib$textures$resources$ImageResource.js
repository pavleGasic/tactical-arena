shadow$provide.module$node_modules$$pixi$core$lib$textures$resources$ImageResource = function(global, require, module, exports) {
  var constants = require("module$node_modules$$pixi$constants$lib$index"), settings = require("module$node_modules$$pixi$settings$lib$index"), BaseImageResource = require("module$node_modules$$pixi$core$lib$textures$resources$BaseImageResource");
  class ImageResource extends BaseImageResource.BaseImageResource {
    constructor(source, options) {
      if (options = options || {}, "string" == typeof source) {
        const imageElement = new Image();
        BaseImageResource.BaseImageResource.crossOrigin(imageElement, source, options.crossorigin);
        imageElement.src = source;
        source = imageElement;
      }
      super(source);
      !source.complete && this._width && this._height && (this._width = 0, this._height = 0);
      this.url = source.src;
      this._process = null;
      this.preserveBitmap = !1;
      this.createBitmap = (options.createBitmap ?? settings.settings.CREATE_IMAGE_BITMAP) && !!globalThis.createImageBitmap;
      this.alphaMode = "number" == typeof options.alphaMode ? options.alphaMode : null;
      this._load = this.bitmap = null;
      !1 !== options.autoLoad && this.load();
    }
    load(createBitmap) {
      return this._load ? this._load : (void 0 !== createBitmap && (this.createBitmap = createBitmap), this._load = new Promise((resolve, reject) => {
        const source = this.source;
        this.url = source.src;
        const completed = () => {
          this.destroyed || (source.onload = null, source.onerror = null, this.update(), this._load = null, this.createBitmap ? resolve(this.process()) : resolve(this));
        };
        source.complete && source.src ? completed() : (source.onload = completed, source.onerror = event => {
          reject(event);
          this.onError.emit(event);
        });
      }), this._load);
    }
    process() {
      const source = this.source;
      if (null !== this._process) {
        return this._process;
      }
      if (null !== this.bitmap || !globalThis.createImageBitmap) {
        return Promise.resolve(this);
      }
      const createImageBitmap = globalThis.createImageBitmap;
      return this._process = fetch(source.src, {mode:source.crossOrigin && "anonymous" !== source.crossOrigin ? "no-cors" : "cors"}).then(r => r.blob()).then(blob => createImageBitmap(blob, 0, 0, source.width, source.height, {premultiplyAlpha:null === this.alphaMode || this.alphaMode === constants.ALPHA_MODES.UNPACK ? "premultiply" : "none"})).then(bitmap => this.destroyed ? Promise.reject() : (this.bitmap = bitmap, this.update(), this._process = null, Promise.resolve(this))), this._process;
    }
    upload(renderer, baseTexture, glTexture) {
      if ("number" == typeof this.alphaMode && (baseTexture.alphaMode = this.alphaMode), !this.createBitmap) {
        return super.upload(renderer, baseTexture, glTexture);
      }
      if (!this.bitmap && (this.process(), !this.bitmap)) {
        return !1;
      }
      if (super.upload(renderer, baseTexture, glTexture, this.bitmap), !this.preserveBitmap) {
        renderer = !0;
        const glTextures = baseTexture._glTextures;
        for (const key in glTextures) {
          const otherTex = glTextures[key];
          if (otherTex !== glTexture && otherTex.dirtyId !== baseTexture.dirtyId) {
            renderer = !1;
            break;
          }
        }
        renderer && (this.bitmap.close && this.bitmap.close(), this.bitmap = null);
      }
      return !0;
    }
    dispose() {
      this.source.onload = null;
      this.source.onerror = null;
      super.dispose();
      this.bitmap && (this.bitmap.close(), this.bitmap = null);
      this._load = this._process = null;
    }
    static test(source) {
      return "u" > typeof HTMLImageElement && ("string" == typeof source || source instanceof HTMLImageElement);
    }
  }
  exports.ImageResource = ImageResource;
};

//# sourceMappingURL=module$node_modules$$pixi$core$lib$textures$resources$ImageResource.js.map
