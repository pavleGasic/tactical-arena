shadow$provide.module$node_modules$$pixi$spritesheet$lib$Spritesheet = function(global, require, module, exports) {
  var core = require("module$node_modules$$pixi$core$lib$index");
  const node_modules$$pixi$spritesheet$lib$Spritesheet$classdecl$var24 = class {
    constructor(optionsOrTexture, arg1, arg2) {
      this.linkedSheets = [];
      (optionsOrTexture instanceof core.BaseTexture || optionsOrTexture instanceof core.Texture) && (optionsOrTexture = {texture:optionsOrTexture, data:arg1, resolutionFilename:arg2});
      const {texture, data, resolutionFilename = null, cachePrefix = ""} = optionsOrTexture;
      this.cachePrefix = cachePrefix;
      this._texture = texture instanceof core.Texture ? texture : null;
      this.baseTexture = texture instanceof core.BaseTexture ? texture : this._texture.baseTexture;
      this.textures = {};
      this.animations = {};
      this.data = data;
      optionsOrTexture = this.baseTexture.resource;
      this.resolution = this._updateResolution(resolutionFilename || (optionsOrTexture ? optionsOrTexture.url : null));
      this._frames = this.data.frames;
      this._frameKeys = Object.keys(this._frames);
      this._batchIndex = 0;
      this._callback = null;
    }
    _updateResolution(resolutionFilename = null) {
      const {scale} = this.data.meta;
      resolutionFilename = core.utils.getResolutionOfUrl(resolutionFilename, null);
      return null === resolutionFilename && (resolutionFilename = "number" == typeof scale ? scale : parseFloat(scale ?? "1")), 1 !== resolutionFilename && this.baseTexture.setResolution(resolutionFilename), resolutionFilename;
    }
    parse() {
      return new Promise(resolve => {
        this._callback = resolve;
        this._batchIndex = 0;
        this._frameKeys.length <= node_modules$$pixi$spritesheet$lib$Spritesheet$classdecl$var24.BATCH_SIZE ? (this._processFrames(0), this._processAnimations(), this._parseComplete()) : this._nextBatch();
      });
    }
    _processFrames(initialFrameIndex) {
      let frameIndex = initialFrameIndex;
      const maxFrames = node_modules$$pixi$spritesheet$lib$Spritesheet$classdecl$var24.BATCH_SIZE;
      for (; frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length;) {
        const i = this._frameKeys[frameIndex], data = this._frames[i], rect = data.frame;
        if (rect) {
          let frame = null, trim = null;
          var sourceSize = !1 !== data.trimmed && data.sourceSize ? data.sourceSize : data.frame;
          sourceSize = new core.Rectangle(0, 0, Math.floor(sourceSize.w) / this.resolution, Math.floor(sourceSize.h) / this.resolution);
          data.rotated ? frame = new core.Rectangle(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.h) / this.resolution, Math.floor(rect.w) / this.resolution) : frame = new core.Rectangle(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);
          !1 !== data.trimmed && data.spriteSourceSize && (trim = new core.Rectangle(Math.floor(data.spriteSourceSize.x) / this.resolution, Math.floor(data.spriteSourceSize.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution));
          this.textures[i] = new core.Texture(this.baseTexture, frame, sourceSize, trim, data.rotated ? 2 : 0, data.anchor, data.borders);
          core.Texture.addToCache(this.textures[i], this.cachePrefix + i.toString());
        }
        frameIndex++;
      }
    }
    _processAnimations() {
      const animations = this.data.animations || {};
      for (const animName in animations) {
        this.animations[animName] = [];
        for (let i = 0; i < animations[animName].length; i++) {
          this.animations[animName].push(this.textures[animations[animName][i]]);
        }
      }
    }
    _parseComplete() {
      const callback = this._callback;
      this._callback = null;
      this._batchIndex = 0;
      callback.call(this, this.textures);
    }
    _nextBatch() {
      this._processFrames(this._batchIndex * node_modules$$pixi$spritesheet$lib$Spritesheet$classdecl$var24.BATCH_SIZE);
      this._batchIndex++;
      setTimeout(() => {
        this._batchIndex * node_modules$$pixi$spritesheet$lib$Spritesheet$classdecl$var24.BATCH_SIZE < this._frameKeys.length ? this._nextBatch() : (this._processAnimations(), this._parseComplete());
      }, 0);
    }
    destroy(destroyBase = !1) {
      for (const i in this.textures) {
        this.textures[i].destroy();
      }
      this.textures = this.data = this._frameKeys = this._frames = null;
      destroyBase && (this._texture?.destroy(), this.baseTexture.destroy());
      this.baseTexture = this._texture = null;
      this.linkedSheets = [];
    }
  };
  global = node_modules$$pixi$spritesheet$lib$Spritesheet$classdecl$var24;
  global.BATCH_SIZE = 1e3;
  exports.Spritesheet = global;
};

//# sourceMappingURL=module$node_modules$$pixi$spritesheet$lib$Spritesheet.js.map
