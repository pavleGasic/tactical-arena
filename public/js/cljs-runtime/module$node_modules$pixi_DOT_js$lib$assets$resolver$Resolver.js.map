{
"version":3,
"file":"module$node_modules$pixi_DOT_js$lib$assets$resolver$Resolver.js",
"lineCount":223,
"mappings":"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",
"sources":["node_modules/pixi_DOT_js/lib/assets/resolver/Resolver.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$pixi_DOT_js$lib$assets$resolver$Resolver\"] = function(global,require,module,exports) {\n'use strict';\n\nvar warn = require('../../utils/logging/warn.js');\nvar path = require('../../utils/path.js');\nvar convertToList = require('../utils/convertToList.js');\nvar createStringVariations = require('../utils/createStringVariations.js');\nvar isSingleItem = require('../utils/isSingleItem.js');\n\n\"use strict\";\nclass Resolver {\n  constructor() {\n    this._defaultBundleIdentifierOptions = {\n      connector: \"-\",\n      createBundleAssetId: (bundleId, assetId) => `${bundleId}${this._bundleIdConnector}${assetId}`,\n      extractAssetIdFromBundle: (bundleId, assetBundleId) => assetBundleId.replace(`${bundleId}${this._bundleIdConnector}`, \"\")\n    };\n    /** The character that is used to connect the bundleId and the assetId when generating a bundle asset id key */\n    this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector;\n    /**\n     * A function that generates a bundle asset id key from a bundleId and an assetId\n     * @param bundleId - the bundleId\n     * @param assetId  - the assetId\n     * @returns the bundle asset id key\n     */\n    this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId;\n    /**\n     * A function that generates an assetId from a bundle asset id key. This is the reverse of generateBundleAssetId\n     * @param bundleId - the bundleId\n     * @param assetBundleId - the bundle asset id key\n     * @returns the assetId\n     */\n    this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle;\n    this._assetMap = {};\n    this._preferredOrder = [];\n    this._parsers = [];\n    this._resolverHash = {};\n    this._bundles = {};\n  }\n  /**\n   * Override how the resolver deals with generating bundle ids.\n   * must be called before any bundles are added\n   * @param bundleIdentifier - the bundle identifier options\n   */\n  setBundleIdentifier(bundleIdentifier) {\n    this._bundleIdConnector = bundleIdentifier.connector ?? this._bundleIdConnector;\n    this._createBundleAssetId = bundleIdentifier.createBundleAssetId ?? this._createBundleAssetId;\n    this._extractAssetIdFromBundle = bundleIdentifier.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle;\n    if (this._extractAssetIdFromBundle(\"foo\", this._createBundleAssetId(\"foo\", \"bar\")) !== \"bar\") {\n      throw new Error(\"[Resolver] GenerateBundleAssetId are not working correctly\");\n    }\n  }\n  /**\n   * Let the resolver know which assets you prefer to use when resolving assets.\n   * Multiple prefer user defined rules can be added.\n   * @example\n   * resolver.prefer({\n   *     // first look for something with the correct format, and then then correct resolution\n   *     priority: ['format', 'resolution'],\n   *     params:{\n   *         format:'webp', // prefer webp images\n   *         resolution: 2, // prefer a resolution of 2\n   *     }\n   * })\n   * resolver.add('foo', ['bar@2x.webp', 'bar@2x.png', 'bar.webp', 'bar.png']);\n   * resolver.resolveUrl('foo') // => 'bar@2x.webp'\n   * @param preferOrders - the prefer options\n   */\n  prefer(...preferOrders) {\n    preferOrders.forEach((prefer) => {\n      this._preferredOrder.push(prefer);\n      if (!prefer.priority) {\n        prefer.priority = Object.keys(prefer.params);\n      }\n    });\n    this._resolverHash = {};\n  }\n  /**\n   * Set the base path to prepend to all urls when resolving\n   * @example\n   * resolver.basePath = 'https://home.com/';\n   * resolver.add('foo', 'bar.ong');\n   * resolver.resolveUrl('foo', 'bar.png'); // => 'https://home.com/bar.png'\n   * @param basePath - the base path to use\n   */\n  set basePath(basePath) {\n    this._basePath = basePath;\n  }\n  get basePath() {\n    return this._basePath;\n  }\n  /**\n   * Set the root path for root-relative URLs. By default the `basePath`'s root is used. If no `basePath` is set, then the\n   * default value for browsers is `window.location.origin`\n   * @example\n   * // Application hosted on https://home.com/some-path/index.html\n   * resolver.basePath = 'https://home.com/some-path/';\n   * resolver.rootPath = 'https://home.com/';\n   * resolver.add('foo', '/bar.png');\n   * resolver.resolveUrl('foo', '/bar.png'); // => 'https://home.com/bar.png'\n   * @param rootPath - the root path to use\n   */\n  set rootPath(rootPath) {\n    this._rootPath = rootPath;\n  }\n  get rootPath() {\n    return this._rootPath;\n  }\n  /**\n   * All the active URL parsers that help the parser to extract information and create\n   * an asset object-based on parsing the URL itself.\n   *\n   * Can be added using the extensions API\n   * @example\n   * resolver.add('foo', [\n   *     {\n   *         resolution: 2,\n   *         format: 'png',\n   *         src: 'image@2x.png',\n   *     },\n   *     {\n   *         resolution:1,\n   *         format:'png',\n   *         src: 'image.png',\n   *     },\n   * ]);\n   *\n   * // With a url parser the information such as resolution and file format could extracted from the url itself:\n   * extensions.add({\n   *     extension: ExtensionType.ResolveParser,\n   *     test: loadTextures.test, // test if url ends in an image\n   *     parse: (value: string) =>\n   *     ({\n   *         resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? '1'),\n   *         format: value.split('.').pop(),\n   *         src: value,\n   *     }),\n   * });\n   *\n   * // Now resolution and format can be extracted from the url\n   * resolver.add('foo', [\n   *     'image@2x.png',\n   *     'image.png',\n   * ]);\n   */\n  get parsers() {\n    return this._parsers;\n  }\n  /** Used for testing, this resets the resolver to its initial state */\n  reset() {\n    this.setBundleIdentifier(this._defaultBundleIdentifierOptions);\n    this._assetMap = {};\n    this._preferredOrder = [];\n    this._resolverHash = {};\n    this._rootPath = null;\n    this._basePath = null;\n    this._manifest = null;\n    this._bundles = {};\n    this._defaultSearchParams = null;\n  }\n  /**\n   * Sets the default URL search parameters for the URL resolver. The urls can be specified as a string or an object.\n   * @param searchParams - the default url parameters to append when resolving urls\n   */\n  setDefaultSearchParams(searchParams) {\n    if (typeof searchParams === \"string\") {\n      this._defaultSearchParams = searchParams;\n    } else {\n      const queryValues = searchParams;\n      this._defaultSearchParams = Object.keys(queryValues).map((key) => `${encodeURIComponent(key)}=${encodeURIComponent(queryValues[key])}`).join(\"&\");\n    }\n  }\n  /**\n   * Returns the aliases for a given asset\n   * @param asset - the asset to get the aliases for\n   */\n  getAlias(asset) {\n    const { alias, src } = asset;\n    const aliasesToUse = convertToList.convertToList(\n      alias || src,\n      (value) => {\n        if (typeof value === \"string\")\n          return value;\n        if (Array.isArray(value))\n          return value.map((v) => v?.src ?? v);\n        if (value?.src)\n          return value.src;\n        return value;\n      },\n      true\n    );\n    return aliasesToUse;\n  }\n  /**\n   * Add a manifest to the asset resolver. This is a nice way to add all the asset information in one go.\n   * generally a manifest would be built using a tool.\n   * @param manifest - the manifest to add to the resolver\n   */\n  addManifest(manifest) {\n    if (this._manifest) {\n      warn.warn(\"[Resolver] Manifest already exists, this will be overwritten\");\n    }\n    this._manifest = manifest;\n    manifest.bundles.forEach((bundle) => {\n      this.addBundle(bundle.name, bundle.assets);\n    });\n  }\n  /**\n   * This adds a bundle of assets in one go so that you can resolve them as a group.\n   * For example you could add a bundle for each screen in you pixi app\n   * @example\n   * resolver.addBundle('animals', [\n   *  { alias: 'bunny', src: 'bunny.png' },\n   *  { alias: 'chicken', src: 'chicken.png' },\n   *  { alias: 'thumper', src: 'thumper.png' },\n   * ]);\n   * // or\n   * resolver.addBundle('animals', {\n   *     bunny: 'bunny.png',\n   *     chicken: 'chicken.png',\n   *     thumper: 'thumper.png',\n   * });\n   *\n   * const resolvedAssets = await resolver.resolveBundle('animals');\n   * @param bundleId - The id of the bundle to add\n   * @param assets - A record of the asset or assets that will be chosen from when loading via the specified key\n   */\n  addBundle(bundleId, assets) {\n    const assetNames = [];\n    let convertedAssets = assets;\n    if (!Array.isArray(assets)) {\n      convertedAssets = Object.entries(assets).map(([alias, src]) => {\n        if (typeof src === \"string\" || Array.isArray(src)) {\n          return { alias, src };\n        }\n        return { alias, ...src };\n      });\n    }\n    convertedAssets.forEach((asset) => {\n      const srcs = asset.src;\n      const aliases = asset.alias;\n      let ids;\n      if (typeof aliases === \"string\") {\n        const bundleAssetId = this._createBundleAssetId(bundleId, aliases);\n        assetNames.push(bundleAssetId);\n        ids = [aliases, bundleAssetId];\n      } else {\n        const bundleIds = aliases.map((name) => this._createBundleAssetId(bundleId, name));\n        assetNames.push(...bundleIds);\n        ids = [...aliases, ...bundleIds];\n      }\n      this.add({\n        ...asset,\n        ...{\n          alias: ids,\n          src: srcs\n        }\n      });\n    });\n    this._bundles[bundleId] = assetNames;\n  }\n  /**\n   * Tells the resolver what keys are associated with witch asset.\n   * The most important thing the resolver does\n   * @example\n   * // Single key, single asset:\n   * resolver.add({alias: 'foo', src: 'bar.png');\n   * resolver.resolveUrl('foo') // => 'bar.png'\n   *\n   * // Multiple keys, single asset:\n   * resolver.add({alias: ['foo', 'boo'], src: 'bar.png'});\n   * resolver.resolveUrl('foo') // => 'bar.png'\n   * resolver.resolveUrl('boo') // => 'bar.png'\n   *\n   * // Multiple keys, multiple assets:\n   * resolver.add({alias: ['foo', 'boo'], src: ['bar.png', 'bar.webp']});\n   * resolver.resolveUrl('foo') // => 'bar.png'\n   *\n   * // Add custom data attached to the resolver\n   * Resolver.add({\n   *     alias: 'bunnyBooBooSmooth',\n   *     src: 'bunny{png,webp}',\n   *     data: { scaleMode:SCALE_MODES.NEAREST }, // Base texture options\n   * });\n   *\n   * resolver.resolve('bunnyBooBooSmooth') // => { src: 'bunny.png', data: { scaleMode: SCALE_MODES.NEAREST } }\n   * @param aliases - the UnresolvedAsset or array of UnresolvedAssets to add to the resolver\n   */\n  add(aliases) {\n    const assets = [];\n    if (Array.isArray(aliases)) {\n      assets.push(...aliases);\n    } else {\n      assets.push(aliases);\n    }\n    let keyCheck;\n    keyCheck = (key) => {\n      if (this.hasKey(key)) {\n        warn.warn(`[Resolver] already has key: ${key} overwriting`);\n      }\n    };\n    const assetArray = convertToList.convertToList(assets);\n    assetArray.forEach((asset) => {\n      const { src } = asset;\n      let { data, format, loadParser } = asset;\n      const srcsToUse = convertToList.convertToList(src).map((src2) => {\n        if (typeof src2 === \"string\") {\n          return createStringVariations.createStringVariations(src2);\n        }\n        return Array.isArray(src2) ? src2 : [src2];\n      });\n      const aliasesToUse = this.getAlias(asset);\n      Array.isArray(aliasesToUse) ? aliasesToUse.forEach(keyCheck) : keyCheck(aliasesToUse);\n      const resolvedAssets = [];\n      srcsToUse.forEach((srcs) => {\n        srcs.forEach((src2) => {\n          let formattedAsset = {};\n          if (typeof src2 !== \"object\") {\n            formattedAsset.src = src2;\n            for (let i = 0; i < this._parsers.length; i++) {\n              const parser = this._parsers[i];\n              if (parser.test(src2)) {\n                formattedAsset = parser.parse(src2);\n                break;\n              }\n            }\n          } else {\n            data = src2.data ?? data;\n            format = src2.format ?? format;\n            loadParser = src2.loadParser ?? loadParser;\n            formattedAsset = {\n              ...formattedAsset,\n              ...src2\n            };\n          }\n          if (!aliasesToUse) {\n            throw new Error(`[Resolver] alias is undefined for this asset: ${formattedAsset.src}`);\n          }\n          formattedAsset = this._buildResolvedAsset(formattedAsset, {\n            aliases: aliasesToUse,\n            data,\n            format,\n            loadParser\n          });\n          resolvedAssets.push(formattedAsset);\n        });\n      });\n      aliasesToUse.forEach((alias) => {\n        this._assetMap[alias] = resolvedAssets;\n      });\n    });\n  }\n  // TODO: this needs an overload like load did in Assets\n  /**\n   * If the resolver has had a manifest set via setManifest, this will return the assets urls for\n   * a given bundleId or bundleIds.\n   * @example\n   * // Manifest Example\n   * const manifest = {\n   *     bundles: [\n   *         {\n   *             name: 'load-screen',\n   *             assets: [\n   *                 {\n   *                     alias: 'background',\n   *                     src: 'sunset.png',\n   *                 },\n   *                 {\n   *                     alias: 'bar',\n   *                     src: 'load-bar.{png,webp}',\n   *                 },\n   *             ],\n   *         },\n   *         {\n   *             name: 'game-screen',\n   *             assets: [\n   *                 {\n   *                     alias: 'character',\n   *                     src: 'robot.png',\n   *                 },\n   *                 {\n   *                     alias: 'enemy',\n   *                     src: 'bad-guy.png',\n   *                 },\n   *             ],\n   *         },\n   *     ]\n   * };\n   *\n   * resolver.setManifest(manifest);\n   * const resolved = resolver.resolveBundle('load-screen');\n   * @param bundleIds - The bundle ids to resolve\n   * @returns All the bundles assets or a hash of assets for each bundle specified\n   */\n  resolveBundle(bundleIds) {\n    const singleAsset = isSingleItem.isSingleItem(bundleIds);\n    bundleIds = convertToList.convertToList(bundleIds);\n    const out = {};\n    bundleIds.forEach((bundleId) => {\n      const assetNames = this._bundles[bundleId];\n      if (assetNames) {\n        const results = this.resolve(assetNames);\n        const assets = {};\n        for (const key in results) {\n          const asset = results[key];\n          assets[this._extractAssetIdFromBundle(bundleId, key)] = asset;\n        }\n        out[bundleId] = assets;\n      }\n    });\n    return singleAsset ? out[bundleIds[0]] : out;\n  }\n  /**\n   * Does exactly what resolve does, but returns just the URL rather than the whole asset object\n   * @param key - The key or keys to resolve\n   * @returns - The URLs associated with the key(s)\n   */\n  resolveUrl(key) {\n    const result = this.resolve(key);\n    if (typeof key !== \"string\") {\n      const out = {};\n      for (const i in result) {\n        out[i] = result[i].src;\n      }\n      return out;\n    }\n    return result.src;\n  }\n  resolve(keys) {\n    const singleAsset = isSingleItem.isSingleItem(keys);\n    keys = convertToList.convertToList(keys);\n    const result = {};\n    keys.forEach((key) => {\n      if (!this._resolverHash[key]) {\n        if (this._assetMap[key]) {\n          let assets = this._assetMap[key];\n          const preferredOrder = this._getPreferredOrder(assets);\n          preferredOrder?.priority.forEach((priorityKey) => {\n            preferredOrder.params[priorityKey].forEach((value) => {\n              const filteredAssets = assets.filter((asset) => {\n                if (asset[priorityKey]) {\n                  return asset[priorityKey] === value;\n                }\n                return false;\n              });\n              if (filteredAssets.length) {\n                assets = filteredAssets;\n              }\n            });\n          });\n          this._resolverHash[key] = assets[0];\n        } else {\n          this._resolverHash[key] = this._buildResolvedAsset({\n            alias: [key],\n            src: key\n          }, {});\n        }\n      }\n      result[key] = this._resolverHash[key];\n    });\n    return singleAsset ? result[keys[0]] : result;\n  }\n  /**\n   * Checks if an asset with a given key exists in the resolver\n   * @param key - The key of the asset\n   */\n  hasKey(key) {\n    return !!this._assetMap[key];\n  }\n  /**\n   * Checks if a bundle with the given key exists in the resolver\n   * @param key - The key of the bundle\n   */\n  hasBundle(key) {\n    return !!this._bundles[key];\n  }\n  /**\n   * Internal function for figuring out what prefer criteria an asset should use.\n   * @param assets\n   */\n  _getPreferredOrder(assets) {\n    for (let i = 0; i < assets.length; i++) {\n      const asset = assets[i];\n      const preferred = this._preferredOrder.find((preference) => preference.params.format.includes(asset.format));\n      if (preferred) {\n        return preferred;\n      }\n    }\n    return this._preferredOrder[0];\n  }\n  /**\n   * Appends the default url parameters to the url\n   * @param url - The url to append the default parameters to\n   * @returns - The url with the default parameters appended\n   */\n  _appendDefaultSearchParams(url) {\n    if (!this._defaultSearchParams)\n      return url;\n    const paramConnector = /\\?/.test(url) ? \"&\" : \"?\";\n    return `${url}${paramConnector}${this._defaultSearchParams}`;\n  }\n  _buildResolvedAsset(formattedAsset, data) {\n    const { aliases, data: assetData, loadParser, format } = data;\n    if (this._basePath || this._rootPath) {\n      formattedAsset.src = path.path.toAbsolute(formattedAsset.src, this._basePath, this._rootPath);\n    }\n    formattedAsset.alias = aliases ?? formattedAsset.alias ?? [formattedAsset.src];\n    formattedAsset.src = this._appendDefaultSearchParams(formattedAsset.src);\n    formattedAsset.data = { ...assetData || {}, ...formattedAsset.data };\n    formattedAsset.loadParser = loadParser ?? formattedAsset.loadParser;\n    formattedAsset.format = format ?? formattedAsset.format ?? getUrlExtension(formattedAsset.src);\n    return formattedAsset;\n  }\n}\n/**\n * The prefix that denotes a URL is for a retina asset.\n * @static\n * @name RETINA_PREFIX\n * @type {RegExp}\n * @default /@([0-9\\.]+)x/\n * @example `@2x`\n */\nResolver.RETINA_PREFIX = /@([0-9\\.]+)x/;\nfunction getUrlExtension(url) {\n  return url.split(\".\").pop().split(\"?\").shift().split(\"#\").shift();\n}\n\nexports.Resolver = Resolver;\nexports.getUrlExtension = getUrlExtension;\n//# sourceMappingURL=Resolver.js.map\n\n};"],
"names":["shadow$provide","global","require","module","exports","getUrlExtension","url","split","pop","shift","warn","path","convertToList","createStringVariations","isSingleItem","Resolver","constructor","_defaultBundleIdentifierOptions","connector","createBundleAssetId","bundleId","assetId","_bundleIdConnector","extractAssetIdFromBundle","assetBundleId","replace","_createBundleAssetId","_extractAssetIdFromBundle","_assetMap","_preferredOrder","_parsers","_resolverHash","_bundles","setBundleIdentifier","bundleIdentifier","Error","prefer","preferOrders","forEach","push","priority","Object","keys","params","basePath","_basePath","rootPath","_rootPath","reset","_manifest","_defaultSearchParams","setDefaultSearchParams","searchParams","map","key","encodeURIComponent","join","getAlias","asset","alias","src","aliasesToUse","value","Array","isArray","v","addManifest","manifest","bundles","bundle","addBundle","name","assets","assetNames","convertedAssets","entries","srcs","aliases","bundleAssetId","ids","bundleIds","add","keyCheck","hasKey","assetArray","data","format","loadParser","srcsToUse","src2","resolvedAssets","formattedAsset","i","length","parser","test","parse","_buildResolvedAsset","resolveBundle","singleAsset","out","results","resolve","resolveUrl","result","preferredOrder","_getPreferredOrder","priorityKey","filteredAssets","filter","hasBundle","preferred","find","preference","includes","_appendDefaultSearchParams","paramConnector","assetData","toAbsolute","RETINA_PREFIX"]
}
