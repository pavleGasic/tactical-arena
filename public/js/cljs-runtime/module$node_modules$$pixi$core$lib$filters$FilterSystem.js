shadow$provide.module$node_modules$$pixi$core$lib$filters$FilterSystem = function(global, require, module, exports) {
  var constants = require("module$node_modules$$pixi$constants$lib$index");
  global = require("module$node_modules$$pixi$extensions$lib$index");
  var math = require("module$node_modules$$pixi$math$lib$index"), RenderTexturePool = require("module$node_modules$$pixi$core$lib$renderTexture$RenderTexturePool"), UniformGroup = require("module$node_modules$$pixi$core$lib$shader$UniformGroup"), Quad = require("module$node_modules$$pixi$core$lib$utils$Quad"), QuadUv = require("module$node_modules$$pixi$core$lib$utils$QuadUv"), FilterState = require("module$node_modules$$pixi$core$lib$filters$FilterState");
  const tempPoints = [new math.Point(), new math.Point(), new math.Point(), new math.Point()], tempMatrix = new math.Matrix();
  class FilterSystem {
    constructor(renderer) {
      this.renderer = renderer;
      this.defaultFilterStack = [{}];
      this.texturePool = new RenderTexturePool.RenderTexturePool();
      this.statePool = [];
      this.quad = new Quad.Quad();
      this.quadUv = new QuadUv.QuadUv();
      this.tempRect = new math.Rectangle();
      this.activeState = {};
      this.globalUniforms = new UniformGroup.UniformGroup({outputFrame:new math.Rectangle(), inputSize:new Float32Array(4), inputPixel:new Float32Array(4), inputClamp:new Float32Array(4), resolution:1, filterArea:new Float32Array(4), filterClamp:new Float32Array(4)}, !0);
      this.useMaxPadding = this.forceClear = !1;
    }
    init() {
      this.texturePool.setScreenSize(this.renderer.view);
    }
    push(target, filters) {
      const renderer = this.renderer, filterStack = this.defaultFilterStack, state = this.statePool.pop() || new FilterState.FilterState(), renderTextureSystem = renderer.renderTexture;
      let currentResolution, currentMultisample;
      if (renderTextureSystem.current) {
        var renderTexture = renderTextureSystem.current;
        currentResolution = renderTexture.resolution;
        currentMultisample = renderTexture.multisample;
      } else {
        currentResolution = renderer.resolution, currentMultisample = renderer.multisample;
      }
      renderTexture = filters[0].resolution || currentResolution;
      let multisample = filters[0].multisample ?? currentMultisample, padding = filters[0].padding, autoFit = filters[0].autoFit, legacy = filters[0].legacy ?? !0;
      for (let i = 1; i < filters.length; i++) {
        const filter = filters[i];
        renderTexture = Math.min(renderTexture, filter.resolution || currentResolution);
        multisample = Math.min(multisample, filter.multisample ?? currentMultisample);
        padding = this.useMaxPadding ? Math.max(padding, filter.padding) : padding + filter.padding;
        autoFit = autoFit && filter.autoFit;
        legacy = legacy || (filter.legacy ?? !0);
      }
      1 === filterStack.length && (this.defaultFilterStack[0].renderTexture = renderTextureSystem.current);
      filterStack.push(state);
      state.resolution = renderTexture;
      state.multisample = multisample;
      state.legacy = legacy;
      state.target = target;
      state.sourceFrame.copyFrom(target.filterArea || target.getBounds(!0));
      state.sourceFrame.pad(padding);
      target = this.tempRect.copyFrom(renderTextureSystem.sourceFrame);
      renderer.projection.transform && this.transformAABB(tempMatrix.copyFrom(renderer.projection.transform).invert(), target);
      autoFit ? (state.sourceFrame.fit(target), (0 >= state.sourceFrame.width || 0 >= state.sourceFrame.height) && (state.sourceFrame.width = 0, state.sourceFrame.height = 0)) : state.sourceFrame.intersects(target) || (state.sourceFrame.width = 0, state.sourceFrame.height = 0);
      this.roundFrame(state.sourceFrame, renderTextureSystem.current ? renderTextureSystem.current.resolution : renderer.resolution, renderTextureSystem.sourceFrame, renderTextureSystem.destinationFrame, renderer.projection.transform);
      state.renderTexture = this.getOptimalFilterTexture(state.sourceFrame.width, state.sourceFrame.height, renderTexture, multisample);
      state.filters = filters;
      state.destinationFrame.width = state.renderTexture.width;
      state.destinationFrame.height = state.renderTexture.height;
      filters = this.tempRect;
      filters.x = 0;
      filters.y = 0;
      filters.width = state.sourceFrame.width;
      filters.height = state.sourceFrame.height;
      state.renderTexture.filterFrame = state.sourceFrame;
      state.bindingSourceFrame.copyFrom(renderTextureSystem.sourceFrame);
      state.bindingDestinationFrame.copyFrom(renderTextureSystem.destinationFrame);
      state.transform = renderer.projection.transform;
      renderer.projection.transform = null;
      renderTextureSystem.bind(state.renderTexture, state.sourceFrame, filters);
      renderer.framebuffer.clear(0, 0, 0, 0);
    }
    pop() {
      var filterStack = this.defaultFilterStack;
      const state = filterStack.pop(), filters = state.filters;
      this.activeState = state;
      var globalUniforms = this.globalUniforms.uniforms;
      globalUniforms.outputFrame = state.sourceFrame;
      globalUniforms.resolution = state.resolution;
      var inputSize = globalUniforms.inputSize, inputPixel = globalUniforms.inputPixel, inputClamp = globalUniforms.inputClamp;
      if (inputSize[0] = state.destinationFrame.width, inputSize[1] = state.destinationFrame.height, inputSize[2] = 1 / inputSize[0], inputSize[3] = 1 / inputSize[1], inputPixel[0] = Math.round(inputSize[0] * state.resolution), inputPixel[1] = Math.round(inputSize[1] * state.resolution), inputPixel[2] = 1 / inputPixel[0], inputPixel[3] = 1 / inputPixel[1], inputClamp[0] = 0.5 * inputPixel[2], inputClamp[1] = 0.5 * inputPixel[3], inputClamp[2] = state.sourceFrame.width * inputSize[2] - 0.5 * inputPixel[2], 
      inputClamp[3] = state.sourceFrame.height * inputSize[3] - 0.5 * inputPixel[3], state.legacy) {
        inputSize = globalUniforms.filterArea, inputSize[0] = state.destinationFrame.width, inputSize[1] = state.destinationFrame.height, inputSize[2] = state.sourceFrame.x, inputSize[3] = state.sourceFrame.y, globalUniforms.filterClamp = globalUniforms.inputClamp;
      }
      this.globalUniforms.update();
      filterStack = filterStack[filterStack.length - 1];
      if (this.renderer.framebuffer.blit(), 1 === filters.length) {
        filters[0].apply(this, state.renderTexture, filterStack.renderTexture, constants.CLEAR_MODES.BLEND, state), this.returnFilterTexture(state.renderTexture);
      } else {
        globalUniforms = state.renderTexture;
        inputSize = this.getOptimalFilterTexture(globalUniforms.width, globalUniforms.height, state.resolution);
        inputSize.filterFrame = globalUniforms.filterFrame;
        for (inputPixel = 0; inputPixel < filters.length - 1; ++inputPixel) {
          1 === inputPixel && 1 < state.multisample && (inputSize = this.getOptimalFilterTexture(globalUniforms.width, globalUniforms.height, state.resolution), inputSize.filterFrame = globalUniforms.filterFrame), filters[inputPixel].apply(this, globalUniforms, inputSize, constants.CLEAR_MODES.CLEAR, state), inputClamp = globalUniforms, globalUniforms = inputSize, inputSize = inputClamp;
        }
        filters[inputPixel].apply(this, globalUniforms, filterStack.renderTexture, constants.CLEAR_MODES.BLEND, state);
        1 < inputPixel && 1 < state.multisample && this.returnFilterTexture(state.renderTexture);
        this.returnFilterTexture(globalUniforms);
        this.returnFilterTexture(inputSize);
      }
      state.clear();
      this.statePool.push(state);
    }
    bindAndClear(filterTexture, clearMode = constants.CLEAR_MODES.CLEAR) {
      const {renderTexture:renderTextureSystem, state:stateSystem} = this.renderer;
      if (filterTexture === this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? this.renderer.projection.transform = this.activeState.transform : this.renderer.projection.transform = null, filterTexture?.filterFrame) {
        const destinationFrame = this.tempRect;
        destinationFrame.x = 0;
        destinationFrame.y = 0;
        destinationFrame.width = filterTexture.filterFrame.width;
        destinationFrame.height = filterTexture.filterFrame.height;
        renderTextureSystem.bind(filterTexture, filterTexture.filterFrame, destinationFrame);
      } else {
        filterTexture !== this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? renderTextureSystem.bind(filterTexture) : this.renderer.renderTexture.bind(filterTexture, this.activeState.bindingSourceFrame, this.activeState.bindingDestinationFrame);
      }
      filterTexture = stateSystem.stateId & 1 || this.forceClear;
      (clearMode === constants.CLEAR_MODES.CLEAR || clearMode === constants.CLEAR_MODES.BLIT && filterTexture) && this.renderer.framebuffer.clear(0, 0, 0, 0);
    }
    applyFilter(filter, input, output, clearMode) {
      const renderer = this.renderer;
      renderer.state.set(filter.state);
      this.bindAndClear(output, clearMode);
      filter.uniforms.uSampler = input;
      filter.uniforms.filterGlobals = this.globalUniforms;
      renderer.shader.bind(filter);
      filter.legacy = !!filter.program.attributeData.aTextureCoord;
      filter.legacy ? (this.quadUv.map(input._frame, input.filterFrame), renderer.geometry.bind(this.quadUv), renderer.geometry.draw(constants.DRAW_MODES.TRIANGLES)) : (renderer.geometry.bind(this.quad), renderer.geometry.draw(constants.DRAW_MODES.TRIANGLE_STRIP));
    }
    calculateSpriteMatrix(outputMatrix, sprite) {
      const {sourceFrame, destinationFrame} = this.activeState, {orig} = sprite._texture;
      outputMatrix = outputMatrix.set(destinationFrame.width, 0, 0, destinationFrame.height, sourceFrame.x, sourceFrame.y);
      const worldTransform = sprite.worldTransform.copyTo(math.Matrix.TEMP_MATRIX);
      return worldTransform.invert(), outputMatrix.prepend(worldTransform), outputMatrix.scale(1 / orig.width, 1 / orig.height), outputMatrix.translate(sprite.anchor.x, sprite.anchor.y), outputMatrix;
    }
    destroy() {
      this.renderer = null;
      this.texturePool.clear(!1);
    }
    getOptimalFilterTexture(minWidth, minHeight, resolution = 1, multisample = constants.MSAA_QUALITY.NONE) {
      return this.texturePool.getOptimalTexture(minWidth, minHeight, resolution, multisample);
    }
    getFilterTexture(input, resolution, multisample) {
      if ("number" == typeof input) {
        const swap = input;
        input = resolution;
        resolution = swap;
      }
      input = input || this.activeState.renderTexture;
      resolution = this.texturePool.getOptimalTexture(input.width, input.height, resolution || input.resolution, multisample || constants.MSAA_QUALITY.NONE);
      return resolution.filterFrame = input.filterFrame, resolution;
    }
    returnFilterTexture(renderTexture) {
      this.texturePool.returnTexture(renderTexture);
    }
    emptyPool() {
      this.texturePool.clear(!0);
    }
    resize() {
      this.texturePool.setScreenSize(this.renderer.view);
    }
    transformAABB(matrix, rect) {
      var lt = tempPoints[0];
      const lb = tempPoints[1], rt = tempPoints[2], rb = tempPoints[3];
      lt.set(rect.left, rect.top);
      lb.set(rect.left, rect.bottom);
      rt.set(rect.right, rect.top);
      rb.set(rect.right, rect.bottom);
      matrix.apply(lt, lt);
      matrix.apply(lb, lb);
      matrix.apply(rt, rt);
      matrix.apply(rb, rb);
      matrix = Math.min(lt.x, lb.x, rt.x, rb.x);
      const y0 = Math.min(lt.y, lb.y, rt.y, rb.y), x1 = Math.max(lt.x, lb.x, rt.x, rb.x);
      lt = Math.max(lt.y, lb.y, rt.y, rb.y);
      rect.x = matrix;
      rect.y = y0;
      rect.width = x1 - matrix;
      rect.height = lt - y0;
    }
    roundFrame(frame, resolution, bindingSourceFrame, bindingDestinationFrame, transform) {
      if (!(0 >= frame.width || 0 >= frame.height || 0 >= bindingSourceFrame.width || 0 >= bindingSourceFrame.height)) {
        if (transform) {
          const {a, b, c, d} = transform;
          if ((1e-4 < Math.abs(b) || 1e-4 < Math.abs(c)) && (1e-4 < Math.abs(a) || 1e-4 < Math.abs(d))) {
            return;
          }
        }
        transform = transform ? tempMatrix.copyFrom(transform) : tempMatrix.identity();
        transform.translate(-bindingSourceFrame.x, -bindingSourceFrame.y).scale(bindingDestinationFrame.width / bindingSourceFrame.width, bindingDestinationFrame.height / bindingSourceFrame.height).translate(bindingDestinationFrame.x, bindingDestinationFrame.y);
        this.transformAABB(transform, frame);
        frame.ceil(resolution);
        this.transformAABB(transform.invert(), frame);
      }
    }
  }
  FilterSystem.extension = {type:global.ExtensionType.RendererSystem, name:"filter"};
  global.extensions.add(FilterSystem);
  exports.FilterSystem = FilterSystem;
};

//# sourceMappingURL=module$node_modules$$pixi$core$lib$filters$FilterSystem.js.map
