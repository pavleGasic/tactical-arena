shadow$provide.module$node_modules$pixi_DOT_js$lib$events$FederatedEventTarget = function(global, require, module, exports) {
  var EventSystem = require("module$node_modules$pixi_DOT_js$lib$events$EventSystem"), FederatedEvent = require("module$node_modules$pixi_DOT_js$lib$events$FederatedEvent");
  "use strict";
  exports.FederatedContainer = {onclick:null, onmousedown:null, onmouseenter:null, onmouseleave:null, onmousemove:null, onglobalmousemove:null, onmouseout:null, onmouseover:null, onmouseup:null, onmouseupoutside:null, onpointercancel:null, onpointerdown:null, onpointerenter:null, onpointerleave:null, onpointermove:null, onglobalpointermove:null, onpointerout:null, onpointerover:null, onpointertap:null, onpointerup:null, onpointerupoutside:null, onrightclick:null, onrightdown:null, onrightup:null, 
  onrightupoutside:null, ontap:null, ontouchcancel:null, ontouchend:null, ontouchendoutside:null, ontouchmove:null, onglobaltouchmove:null, ontouchstart:null, onwheel:null, get interactive() {
    return "dynamic" === this.eventMode || "static" === this.eventMode;
  }, set interactive(value) {
    this.eventMode = value ? "static" : "passive";
  }, _internalEventMode:void 0, get eventMode() {
    return this._internalEventMode ?? EventSystem.EventSystem.defaultEventMode;
  }, set eventMode(value) {
    this._internalEventMode = value;
  }, isInteractive() {
    return "static" === this.eventMode || "dynamic" === this.eventMode;
  }, interactiveChildren:!0, hitArea:null, addEventListener(type, listener, options) {
    const signal = "object" === typeof options ? options.signal : void 0, once = "object" === typeof options ? !0 === options.once : !1, context = "function" === typeof listener ? void 0 : listener;
    type = "boolean" === typeof options && options || "object" === typeof options && options.capture ? `${type}capture` : type;
    const listenerFn = "function" === typeof listener ? listener : listener.handleEvent, emitter = this;
    signal && signal.addEventListener("abort", () => {
      emitter.off(type, listenerFn, context);
    });
    if (once) {
      emitter.once(type, listenerFn, context);
    } else {
      emitter.on(type, listenerFn, context);
    }
  }, removeEventListener(type, listener, options) {
    const context = "function" === typeof listener ? void 0 : listener;
    type = "boolean" === typeof options && options || "object" === typeof options && options.capture ? `${type}capture` : type;
    listener = "function" === typeof listener ? listener : listener.handleEvent;
    this.off(type, listener, context);
  }, dispatchEvent(e) {
    if (!(e instanceof FederatedEvent.FederatedEvent)) {
      throw Error("Container cannot propagate events outside of the Federated Events API");
    }
    e.defaultPrevented = !1;
    e.path = null;
    e.target = this;
    e.manager.dispatchEvent(e);
    return !e.defaultPrevented;
  }};
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$events$FederatedEventTarget.js.map
