shadow$provide.module$node_modules$$pixi$sprite_animated$lib$AnimatedSprite = function(global, require, module, exports) {
  var core = require("module$node_modules$$pixi$core$lib$index");
  global = require("module$node_modules$$pixi$sprite$lib$index");
  class AnimatedSprite extends global.Sprite {
    constructor(textures, autoUpdate = !0) {
      super(textures[0] instanceof core.Texture ? textures[0] : textures[0].texture);
      this._durations = this._textures = null;
      this._autoUpdate = autoUpdate;
      this._isConnectedToTicker = !1;
      this.animationSpeed = 1;
      this.loop = !0;
      this.updateAnchor = !1;
      this.onLoop = this.onFrameChange = this.onComplete = null;
      this._currentTime = 0;
      this._playing = !1;
      this._previousFrame = null;
      this.textures = textures;
    }
    stop() {
      this._playing && (this._playing = !1, this._autoUpdate && this._isConnectedToTicker && (core.Ticker.shared.remove(this.update, this), this._isConnectedToTicker = !1));
    }
    play() {
      this._playing || (this._playing = !0, this._autoUpdate && !this._isConnectedToTicker && (core.Ticker.shared.add(this.update, this, core.UPDATE_PRIORITY.HIGH), this._isConnectedToTicker = !0));
    }
    gotoAndStop(frameNumber) {
      this.stop();
      this.currentFrame = frameNumber;
    }
    gotoAndPlay(frameNumber) {
      this.currentFrame = frameNumber;
      this.play();
    }
    update(deltaTime) {
      if (this._playing) {
        var elapsed = this.animationSpeed * deltaTime, previousFrame = this.currentFrame;
        if (null !== this._durations) {
          let lag = this._currentTime % 1 * this._durations[this.currentFrame];
          for (lag += elapsed / 60 * 1e3; 0 > lag;) {
            this._currentTime--, lag += this._durations[this.currentFrame];
          }
          deltaTime = Math.sign(this.animationSpeed * deltaTime);
          for (this._currentTime = Math.floor(this._currentTime); lag >= this._durations[this.currentFrame];) {
            lag -= this._durations[this.currentFrame] * deltaTime, this._currentTime += deltaTime;
          }
          this._currentTime += lag / this._durations[this.currentFrame];
        } else {
          this._currentTime += elapsed;
        }
        0 > this._currentTime && !this.loop ? (this.gotoAndStop(0), this.onComplete && this.onComplete()) : this._currentTime >= this._textures.length && !this.loop ? (this.gotoAndStop(this._textures.length - 1), this.onComplete && this.onComplete()) : previousFrame !== this.currentFrame && (this.loop && this.onLoop && (0 < this.animationSpeed && this.currentFrame < previousFrame || 0 > this.animationSpeed && this.currentFrame > previousFrame) && this.onLoop(), this.updateTexture());
      }
    }
    updateTexture() {
      const currentFrame = this.currentFrame;
      this._previousFrame !== currentFrame && (this._previousFrame = currentFrame, this._texture = this._textures[currentFrame], this._textureID = -1, this._textureTrimmedID = -1, this._cachedTint = 16777215, this.uvs = this._texture._uvs.uvsFloat32, this.updateAnchor && this._anchor.copyFrom(this._texture.defaultAnchor), this.onFrameChange && this.onFrameChange(this.currentFrame));
    }
    destroy(options) {
      this.stop();
      super.destroy(options);
      this.onLoop = this.onFrameChange = this.onComplete = null;
    }
    static fromFrames(frames) {
      const textures = [];
      for (let i = 0; i < frames.length; ++i) {
        textures.push(core.Texture.from(frames[i]));
      }
      return new AnimatedSprite(textures);
    }
    static fromImages(images) {
      const textures = [];
      for (let i = 0; i < images.length; ++i) {
        textures.push(core.Texture.from(images[i]));
      }
      return new AnimatedSprite(textures);
    }
    get totalFrames() {
      return this._textures.length;
    }
    get textures() {
      return this._textures;
    }
    set textures(value) {
      if (value[0] instanceof core.Texture) {
        this._textures = value, this._durations = null;
      } else {
        this._textures = [];
        this._durations = [];
        for (let i = 0; i < value.length; i++) {
          this._textures.push(value[i].texture), this._durations.push(value[i].time);
        }
      }
      this._previousFrame = null;
      this.gotoAndStop(0);
      this.updateTexture();
    }
    get currentFrame() {
      let currentFrame = Math.floor(this._currentTime) % this._textures.length;
      return 0 > currentFrame && (currentFrame += this._textures.length), currentFrame;
    }
    set currentFrame(value) {
      if (0 > value || value > this.totalFrames - 1) {
        throw Error(`[AnimatedSprite]: Invalid frame index value ${value}, expected to be between 0 and totalFrames ${this.totalFrames}.`);
      }
      const previousFrame = this.currentFrame;
      this._currentTime = value;
      previousFrame !== this.currentFrame && this.updateTexture();
    }
    get playing() {
      return this._playing;
    }
    get autoUpdate() {
      return this._autoUpdate;
    }
    set autoUpdate(value) {
      value !== this._autoUpdate && (this._autoUpdate = value, !this._autoUpdate && this._isConnectedToTicker ? (core.Ticker.shared.remove(this.update, this), this._isConnectedToTicker = !1) : this._autoUpdate && !this._isConnectedToTicker && this._playing && (core.Ticker.shared.add(this.update, this), this._isConnectedToTicker = !0));
    }
  }
  exports.AnimatedSprite = AnimatedSprite;
};

//# sourceMappingURL=module$node_modules$$pixi$sprite_animated$lib$AnimatedSprite.js.map
