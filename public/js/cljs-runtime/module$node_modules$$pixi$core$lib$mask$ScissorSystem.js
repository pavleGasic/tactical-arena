shadow$provide.module$node_modules$$pixi$core$lib$mask$ScissorSystem = function(global, require, module, exports) {
  global = require("module$node_modules$$pixi$extensions$lib$index");
  var math = require("module$node_modules$$pixi$math$lib$index"), settings = require("module$node_modules$$pixi$settings$lib$index"), AbstractMaskSystem = require("module$node_modules$$pixi$core$lib$mask$AbstractMaskSystem");
  const tempMatrix = new math.Matrix(), rectPool = [];
  require = (() => {
    const node_modules$$pixi$core$lib$mask$ScissorSystem$classdecl$var5 = class extends AbstractMaskSystem.AbstractMaskSystem {
      constructor(renderer) {
        super(renderer);
        this.glConst = settings.settings.ADAPTER.getWebGLRenderingContext().SCISSOR_TEST;
      }
      getStackLength() {
        const maskData = this.maskStack[this.maskStack.length - 1];
        return maskData ? maskData._scissorCounter : 0;
      }
      calcScissorRect(maskData) {
        if (!maskData._scissorRectLocal) {
          var prevData = maskData._scissorRect, {maskObject} = maskData, {renderer} = this, renderTextureSystem = renderer.renderTexture;
          maskObject = maskObject.getBounds(!0, rectPool.pop() ?? new math.Rectangle());
          this.roundFrameToPixels(maskObject, renderTextureSystem.current ? renderTextureSystem.current.resolution : renderer.resolution, renderTextureSystem.sourceFrame, renderTextureSystem.destinationFrame, renderer.projection.transform);
          prevData && maskObject.fit(prevData);
          maskData._scissorRectLocal = maskObject;
        }
      }
      static isMatrixRotated(matrix) {
        if (!matrix) {
          return !1;
        }
        const {a, b, c, d} = matrix;
        return (1e-4 < Math.abs(b) || 1e-4 < Math.abs(c)) && (1e-4 < Math.abs(a) || 1e-4 < Math.abs(d));
      }
      testScissor(maskData) {
        const {maskObject} = maskData;
        if (!maskObject.isFastRect || !maskObject.isFastRect() || node_modules$$pixi$core$lib$mask$ScissorSystem$classdecl$var5.isMatrixRotated(maskObject.worldTransform) || node_modules$$pixi$core$lib$mask$ScissorSystem$classdecl$var5.isMatrixRotated(this.renderer.projection.transform)) {
          return !1;
        }
        this.calcScissorRect(maskData);
        maskData = maskData._scissorRectLocal;
        return 0 < maskData.width && 0 < maskData.height;
      }
      roundFrameToPixels(frame, resolution, bindingSourceFrame, bindingDestinationFrame, transform) {
        node_modules$$pixi$core$lib$mask$ScissorSystem$classdecl$var5.isMatrixRotated(transform) || (transform = transform ? tempMatrix.copyFrom(transform) : tempMatrix.identity(), transform.translate(-bindingSourceFrame.x, -bindingSourceFrame.y).scale(bindingDestinationFrame.width / bindingSourceFrame.width, bindingDestinationFrame.height / bindingSourceFrame.height).translate(bindingDestinationFrame.x, bindingDestinationFrame.y), this.renderer.filter.transformAABB(transform, frame), frame.fit(bindingDestinationFrame), 
        frame.x = Math.round(frame.x * resolution), frame.y = Math.round(frame.y * resolution), frame.width = Math.round(frame.width * resolution), frame.height = Math.round(frame.height * resolution));
      }
      push(maskData) {
        maskData._scissorRectLocal || this.calcScissorRect(maskData);
        const {gl} = this.renderer;
        maskData._scissorRect || gl.enable(gl.SCISSOR_TEST);
        maskData._scissorCounter++;
        maskData._scissorRect = maskData._scissorRectLocal;
        this._useCurrent();
      }
      pop(maskData) {
        const {gl} = this.renderer;
        maskData && rectPool.push(maskData._scissorRectLocal);
        0 < this.getStackLength() ? this._useCurrent() : gl.disable(gl.SCISSOR_TEST);
      }
      _useCurrent() {
        const rect = this.maskStack[this.maskStack.length - 1]._scissorRect;
        let y;
        this.renderer.renderTexture.current ? y = rect.y : y = this.renderer.height - rect.height - rect.y;
        this.renderer.gl.scissor(rect.x, y, rect.width, rect.height);
      }
    };
    return node_modules$$pixi$core$lib$mask$ScissorSystem$classdecl$var5;
  })();
  require.extension = {type:global.ExtensionType.RendererSystem, name:"scissor"};
  global.extensions.add(require);
  exports.ScissorSystem = require;
};

//# sourceMappingURL=module$node_modules$$pixi$core$lib$mask$ScissorSystem.js.map
