shadow$provide.module$node_modules$$pixi$core$lib$textures$resources$ArrayResource = function(global, require, module, exports) {
  var constants = require("module$node_modules$$pixi$constants$lib$index");
  global = require("module$node_modules$$pixi$core$lib$textures$resources$AbstractMultiResource");
  class ArrayResource extends global.AbstractMultiResource {
    constructor(source, options) {
      const {width, height} = options || {};
      let urls, length;
      Array.isArray(source) ? (urls = source, length = source.length) : length = source;
      super(length, {width, height});
      urls && this.initFromArray(urls, options);
    }
    addBaseTextureAt(baseTexture, index) {
      if (baseTexture.resource) {
        this.addResourceAt(baseTexture.resource, index);
      } else {
        throw Error("ArrayResource does not support RenderTexture");
      }
      return this;
    }
    bind(baseTexture) {
      super.bind(baseTexture);
      baseTexture.target = constants.TARGETS.TEXTURE_2D_ARRAY;
    }
    upload(renderer, texture, glTexture) {
      const {length, itemDirtyIds, items} = this;
      ({gl:renderer} = renderer);
      0 > glTexture.dirtyId && renderer.texImage3D(renderer.TEXTURE_2D_ARRAY, 0, glTexture.internalFormat, this._width, this._height, length, 0, texture.format, glTexture.type, null);
      for (let i = 0; i < length; i++) {
        const item = items[i];
        itemDirtyIds[i] < item.dirtyId && (itemDirtyIds[i] = item.dirtyId, item.valid && renderer.texSubImage3D(renderer.TEXTURE_2D_ARRAY, 0, 0, 0, i, item.resource.width, item.resource.height, 1, texture.format, glTexture.type, item.resource.source));
      }
      return !0;
    }
  }
  exports.ArrayResource = ArrayResource;
};

//# sourceMappingURL=module$node_modules$$pixi$core$lib$textures$resources$ArrayResource.js.map
