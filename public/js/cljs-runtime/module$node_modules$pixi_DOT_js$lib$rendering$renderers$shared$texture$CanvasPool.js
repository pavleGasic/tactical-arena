shadow$provide.module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$texture$CanvasPool = function(global, require, module, exports) {
  var adapter = require("module$node_modules$pixi_DOT_js$lib$environment$adapter"), pow2 = require("module$node_modules$pixi_DOT_js$lib$maths$misc$pow2");
  "use strict";
  class CanvasPoolClass {
    constructor(canvasOptions) {
      this._canvasPool = Object.create(null);
      this.canvasOptions = canvasOptions || {};
      this.enableFullScreen = !1;
    }
    _createCanvasAndContext(pixelWidth, pixelHeight) {
      const canvas = adapter.DOMAdapter.get().createCanvas();
      canvas.width = pixelWidth;
      canvas.height = pixelHeight;
      pixelWidth = canvas.getContext("2d");
      return {canvas, context:pixelWidth};
    }
    getOptimalCanvasAndContext(minWidth, minHeight, resolution = 1) {
      minWidth = Math.ceil(minWidth * resolution - 1e-6);
      minHeight = Math.ceil(minHeight * resolution - 1e-6);
      minWidth = pow2.nextPow2(minWidth);
      minHeight = pow2.nextPow2(minHeight);
      resolution = (minWidth << 17) + (minHeight << 1);
      this._canvasPool[resolution] || (this._canvasPool[resolution] = []);
      (resolution = this._canvasPool[resolution].pop()) || (resolution = this._createCanvasAndContext(minWidth, minHeight));
      return resolution;
    }
    returnCanvasAndContext(canvasAndContext) {
      const {width, height} = canvasAndContext.canvas, key = (width << 17) + (height << 1);
      canvasAndContext.context.clearRect(0, 0, width, height);
      this._canvasPool[key].push(canvasAndContext);
    }
    clear() {
      this._canvasPool = {};
    }
  }
  global = new CanvasPoolClass();
  exports.CanvasPool = global;
  exports.CanvasPoolClass = CanvasPoolClass;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$texture$CanvasPool.js.map
