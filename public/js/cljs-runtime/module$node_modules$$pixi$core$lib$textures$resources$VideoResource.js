shadow$provide.module$node_modules$$pixi$core$lib$textures$resources$VideoResource = function(global, require, module, exports) {
  var ticker = require("module$node_modules$$pixi$ticker$lib$index"), BaseImageResource = require("module$node_modules$$pixi$core$lib$textures$resources$BaseImageResource");
  const node_modules$$pixi$core$lib$textures$resources$VideoResource$classdecl$var12 = class extends BaseImageResource.BaseImageResource {
    constructor(source, options) {
      if (options = options || {}, !(source instanceof HTMLVideoElement)) {
        const videoElement = document.createElement("video");
        !1 !== options.autoLoad && videoElement.setAttribute("preload", "auto");
        !1 !== options.playsinline && (videoElement.setAttribute("webkit-playsinline", ""), videoElement.setAttribute("playsinline", ""));
        !0 === options.muted && (videoElement.setAttribute("muted", ""), videoElement.muted = !0);
        !0 === options.loop && videoElement.setAttribute("loop", "");
        !1 !== options.autoPlay && videoElement.setAttribute("autoplay", "");
        "string" == typeof source && (source = [source]);
        BaseImageResource.BaseImageResource.crossOrigin(videoElement, source[0].src || source[0], options.crossorigin);
        for (let i = 0; i < source.length; ++i) {
          const sourceElement = document.createElement("source");
          let {src, mime} = source[i];
          if (src = src || source[i], src.startsWith("data:")) {
            mime = src.slice(5, src.indexOf(";"));
          } else if (!src.startsWith("blob:")) {
            var baseSrc = src.split("?").shift().toLowerCase();
            baseSrc = baseSrc.slice(baseSrc.lastIndexOf(".") + 1);
            mime = mime || node_modules$$pixi$core$lib$textures$resources$VideoResource$classdecl$var12.MIME_TYPES[baseSrc] || `video/${baseSrc}`;
          }
          sourceElement.src = src;
          mime && (sourceElement.type = mime);
          videoElement.appendChild(sourceElement);
        }
        source = videoElement;
      }
      super(source);
      this._autoUpdate = this.noSubImage = !0;
      this._isConnectedToTicker = !1;
      this._updateFPS = options.updateFPS || 0;
      this._msToNextUpdate = 0;
      this.autoPlay = !1 !== options.autoPlay;
      this._videoFrameRequestCallback = this._videoFrameRequestCallback.bind(this);
      this._reject = this._resolve = this._load = this._videoFrameRequestCallbackHandle = null;
      this._onCanPlay = this._onCanPlay.bind(this);
      this._onError = this._onError.bind(this);
      this._onPlayStart = this._onPlayStart.bind(this);
      this._onPlayStop = this._onPlayStop.bind(this);
      this._onSeeked = this._onSeeked.bind(this);
      !1 !== options.autoLoad && this.load();
    }
    update(_deltaTime) {
      this.destroyed || (this._updateFPS && (this._msToNextUpdate = Math.floor(this._msToNextUpdate - ticker.Ticker.shared.elapsedMS * this.source.playbackRate)), (!this._updateFPS || 0 >= this._msToNextUpdate) && (super.update(), this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0));
    }
    _videoFrameRequestCallback() {
      this.update();
      this.destroyed ? this._videoFrameRequestCallbackHandle = null : this._videoFrameRequestCallbackHandle = this.source.requestVideoFrameCallback(this._videoFrameRequestCallback);
    }
    load() {
      if (this._load) {
        return this._load;
      }
      const source = this.source;
      return (source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA) && source.width && source.height && (source.complete = !0), source.addEventListener("play", this._onPlayStart), source.addEventListener("pause", this._onPlayStop), source.addEventListener("seeked", this._onSeeked), this._isSourceReady() ? this._onCanPlay() : (source.addEventListener("canplay", this._onCanPlay), source.addEventListener("canplaythrough", this._onCanPlay), source.addEventListener("error", 
      this._onError, !0)), this._load = new Promise((resolve, reject) => {
        this.valid ? resolve(this) : (this._resolve = resolve, this._reject = reject, source.load());
      }), this._load;
    }
    _onError(event) {
      this.source.removeEventListener("error", this._onError, !0);
      this.onError.emit(event);
      this._reject && (this._reject(event), this._reject = null, this._resolve = null);
    }
    _isSourcePlaying() {
      const source = this.source;
      return !source.paused && !source.ended;
    }
    _isSourceReady() {
      return 2 < this.source.readyState;
    }
    _onPlayStart() {
      this.valid || this._onCanPlay();
      this._configureAutoUpdate();
    }
    _onPlayStop() {
      this._configureAutoUpdate();
    }
    _onSeeked() {
      this._autoUpdate && !this._isSourcePlaying() && (this._msToNextUpdate = 0, this.update(), this._msToNextUpdate = 0);
    }
    _onCanPlay() {
      const source = this.source;
      source.removeEventListener("canplay", this._onCanPlay);
      source.removeEventListener("canplaythrough", this._onCanPlay);
      const valid = this.valid;
      this._msToNextUpdate = 0;
      this.update();
      this._msToNextUpdate = 0;
      !valid && this._resolve && (this._resolve(this), this._resolve = null, this._reject = null);
      this._isSourcePlaying() ? this._onPlayStart() : this.autoPlay && source.play();
    }
    dispose() {
      this._configureAutoUpdate();
      const source = this.source;
      source && (source.removeEventListener("play", this._onPlayStart), source.removeEventListener("pause", this._onPlayStop), source.removeEventListener("seeked", this._onSeeked), source.removeEventListener("canplay", this._onCanPlay), source.removeEventListener("canplaythrough", this._onCanPlay), source.removeEventListener("error", this._onError, !0), source.pause(), source.src = "", source.load());
      super.dispose();
    }
    get autoUpdate() {
      return this._autoUpdate;
    }
    set autoUpdate(value) {
      value !== this._autoUpdate && (this._autoUpdate = value, this._configureAutoUpdate());
    }
    get updateFPS() {
      return this._updateFPS;
    }
    set updateFPS(value) {
      value !== this._updateFPS && (this._updateFPS = value, this._configureAutoUpdate());
    }
    _configureAutoUpdate() {
      this._autoUpdate && this._isSourcePlaying() ? !this._updateFPS && this.source.requestVideoFrameCallback ? (this._isConnectedToTicker && (ticker.Ticker.shared.remove(this.update, this), this._isConnectedToTicker = !1, this._msToNextUpdate = 0), null === this._videoFrameRequestCallbackHandle && (this._videoFrameRequestCallbackHandle = this.source.requestVideoFrameCallback(this._videoFrameRequestCallback))) : (null !== this._videoFrameRequestCallbackHandle && (this.source.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle), 
      this._videoFrameRequestCallbackHandle = null), this._isConnectedToTicker || (ticker.Ticker.shared.add(this.update, this), this._isConnectedToTicker = !0, this._msToNextUpdate = 0)) : (null !== this._videoFrameRequestCallbackHandle && (this.source.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle), this._videoFrameRequestCallbackHandle = null), this._isConnectedToTicker && (ticker.Ticker.shared.remove(this.update, this), this._isConnectedToTicker = !1, this._msToNextUpdate = 0));
    }
    static test(source, extension) {
      return globalThis.HTMLVideoElement && source instanceof HTMLVideoElement || node_modules$$pixi$core$lib$textures$resources$VideoResource$classdecl$var12.TYPES.includes(extension);
    }
  };
  global = node_modules$$pixi$core$lib$textures$resources$VideoResource$classdecl$var12;
  global.TYPES = "mp4 m4v webm ogg ogv h264 avi mov".split(" ");
  global.MIME_TYPES = {ogv:"video/ogg", mov:"video/quicktime", m4v:"video/mp4"};
  exports.VideoResource = global;
};

//# sourceMappingURL=module$node_modules$$pixi$core$lib$textures$resources$VideoResource.js.map
