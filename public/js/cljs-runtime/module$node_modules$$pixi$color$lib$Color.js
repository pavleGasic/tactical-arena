shadow$provide.module$node_modules$$pixi$color$lib$Color = function(global, require, module, exports) {
  var colord = require("module$node_modules$$pixi$colord$index");
  global = require("module$node_modules$$pixi$colord$plugins$names");
  colord.extend([global]);
  const node_modules$$pixi$color$lib$Color$classdecl$var0 = class {
    constructor(value = 16777215) {
      this._value = null;
      this._components = new Float32Array(4);
      this._components.fill(1);
      this._int = 16777215;
      this.value = value;
    }
    get red() {
      return this._components[0];
    }
    get green() {
      return this._components[1];
    }
    get blue() {
      return this._components[2];
    }
    get alpha() {
      return this._components[3];
    }
    setValue(value) {
      return this.value = value, this;
    }
    set value(value) {
      if (value instanceof node_modules$$pixi$color$lib$Color$classdecl$var0) {
        this._value = this.cloneSource(value._value), this._int = value._int, this._components.set(value._components);
      } else {
        if (null === value) {
          throw Error("Cannot set PIXI.Color#value to null");
        }
        (null === this._value || !this.isSourceEqual(this._value, value)) && (this.normalize(value), this._value = this.cloneSource(value));
      }
    }
    get value() {
      return this._value;
    }
    cloneSource(value) {
      return "string" == typeof value || "number" == typeof value || value instanceof Number || null === value ? value : Array.isArray(value) || ArrayBuffer.isView(value) ? value.slice(0) : "object" == typeof value && null !== value ? {...value} : value;
    }
    isSourceEqual(value1, value2) {
      var type1 = typeof value1;
      if (type1 !== typeof value2) {
        return !1;
      }
      if ("number" === type1 || "string" === type1 || value1 instanceof Number) {
        return value1 === value2;
      }
      if (Array.isArray(value1) && Array.isArray(value2) || ArrayBuffer.isView(value1) && ArrayBuffer.isView(value2)) {
        return value1.length !== value2.length ? !1 : value1.every((v, i) => v === value2[i]);
      }
      if (null !== value1 && null !== value2) {
        type1 = Object.keys(value1);
        const keys2 = Object.keys(value2);
        return type1.length !== keys2.length ? !1 : type1.every(key => value1[key] === value2[key]);
      }
      return value1 === value2;
    }
    toRgba() {
      const [r, g, b, a] = this._components;
      return {r, g, b, a};
    }
    toRgb() {
      const [r, g, b] = this._components;
      return {r, g, b};
    }
    toRgbaString() {
      const [r, g, b] = this.toUint8RgbArray();
      return `rgba(${r},${g},${b},${this.alpha})`;
    }
    toUint8RgbArray(out) {
      const [r, g, b] = this._components;
      return out = out ?? [], out[0] = Math.round(255 * r), out[1] = Math.round(255 * g), out[2] = Math.round(255 * b), out;
    }
    toRgbArray(out) {
      out = out ?? [];
      const [r, g, b] = this._components;
      return out[0] = r, out[1] = g, out[2] = b, out;
    }
    toNumber() {
      return this._int;
    }
    toLittleEndianNumber() {
      const value = this._int;
      return (value >> 16) + (value & 65280) + ((value & 255) << 16);
    }
    multiply(value) {
      const [r, g, b, a] = node_modules$$pixi$color$lib$Color$classdecl$var0.temp.setValue(value)._components;
      return this._components[0] *= r, this._components[1] *= g, this._components[2] *= b, this._components[3] *= a, this.refreshInt(), this._value = null, this;
    }
    premultiply(alpha, applyToRGB = !0) {
      return applyToRGB && (this._components[0] *= alpha, this._components[1] *= alpha, this._components[2] *= alpha), this._components[3] = alpha, this.refreshInt(), this._value = null, this;
    }
    toPremultiplied(alpha, applyToRGB = !0) {
      if (1 === alpha) {
        return -16777216 + this._int;
      }
      if (0 === alpha) {
        return applyToRGB ? 0 : this._int;
      }
      let r = this._int >> 16 & 255, g = this._int >> 8 & 255, b = this._int & 255;
      return applyToRGB && (r = r * alpha + 0.5 | 0, g = g * alpha + 0.5 | 0, b = b * alpha + 0.5 | 0), (255 * alpha << 24) + (r << 16) + (g << 8) + b;
    }
    toHex() {
      const hexString = this._int.toString(16);
      return `#${"000000".substring(0, 6 - hexString.length) + hexString}`;
    }
    toHexa() {
      const alphaString = Math.round(255 * this._components[3]).toString(16);
      return this.toHex() + "00".substring(0, 2 - alphaString.length) + alphaString;
    }
    setAlpha(alpha) {
      return this._components[3] = this._clamp(alpha), this;
    }
    round(steps) {
      const [r, g, b] = this._components;
      return this._components[0] = Math.round(r * steps) / steps, this._components[1] = Math.round(g * steps) / steps, this._components[2] = Math.round(b * steps) / steps, this.refreshInt(), this._value = null, this;
    }
    toArray(out) {
      out = out ?? [];
      const [r, g, b, a] = this._components;
      return out[0] = r, out[1] = g, out[2] = b, out[3] = a, out;
    }
    normalize(value) {
      let r, g;
      let a;
      if (("number" == typeof value || value instanceof Number) && 0 <= value && 16777215 >= value) {
        var b = value;
        r = (b >> 16 & 255) / 255;
        g = (b >> 8 & 255) / 255;
        b = (b & 255) / 255;
        a = 1;
      } else if ((Array.isArray(value) || value instanceof Float32Array) && 3 <= value.length && 4 >= value.length) {
        value = this._clamp(value), [r, g, b, a = 1] = value;
      } else if ((value instanceof Uint8Array || value instanceof Uint8ClampedArray) && 3 <= value.length && 4 >= value.length) {
        value = this._clamp(value, 0, 255), [r, g, b, a = 255] = value, r /= 255, g /= 255, b /= 255, a /= 255;
      } else if ("string" == typeof value || "object" == typeof value) {
        if ("string" == typeof value) {
          var match = node_modules$$pixi$color$lib$Color$classdecl$var0.HEX_PATTERN.exec(value);
          match && (value = `#${match[2]}`);
        }
        match = colord.colord(value);
        match.isValid() && ({r, g, b, a} = match.rgba, r /= 255, g /= 255, b /= 255);
      }
      if (void 0 !== r) {
        this._components[0] = r, this._components[1] = g, this._components[2] = b, this._components[3] = a, this.refreshInt();
      } else {
        throw Error(`Unable to convert color ${value}`);
      }
    }
    refreshInt() {
      this._clamp(this._components);
      const [r, g, b] = this._components;
      this._int = (255 * r << 16) + (255 * g << 8) + (255 * b | 0);
    }
    _clamp(value, min = 0, max = 1) {
      return "number" == typeof value ? Math.min(Math.max(value, min), max) : (value.forEach((v, i) => {
        value[i] = Math.min(Math.max(v, min), max);
      }), value);
    }
  };
  global = node_modules$$pixi$color$lib$Color$classdecl$var0;
  global.shared = new global();
  global.temp = new global();
  global.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;
  exports.Color = global;
};

//# sourceMappingURL=module$node_modules$$pixi$color$lib$Color.js.map
