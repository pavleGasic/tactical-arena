shadow$provide.module$node_modules$pixi_DOT_js$lib$scene$text$sdfShader$shader_bits$mSDFBit = function(global, require, module, exports) {
  exports.mSDFBit = {name:"msdf-bit", fragment:{header:"\n            fn calculateMSDFAlpha(msdfColor:vec4\x3cf32\x3e, shapeColor:vec4\x3cf32\x3e, distance:f32) -\x3e f32 {\n                \n                // MSDF\n                var median \x3d msdfColor.r + msdfColor.g + msdfColor.b -\n                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n            \n                // SDF\n                median \x3d min(median, msdfColor.a);\n\n                var screenPxDistance \x3d distance * (median - 0.5);\n                var alpha \x3d clamp(screenPxDistance + 0.5, 0.0, 1.0);\n                if (median \x3c 0.01) {\n                    alpha \x3d 0.0;\n                } else if (median \x3e 0.99) {\n                    alpha \x3d 1.0;\n                }\n\n                // Gamma correction for coverage-like alpha\n                var luma: f32 \x3d dot(shapeColor.rgb, vec3\x3cf32\x3e(0.299, 0.587, 0.114));\n                var gamma: f32 \x3d mix(1.0, 1.0 / 2.2, luma);\n                var coverage: f32 \x3d pow(shapeColor.a * alpha, gamma);\n\n                return coverage;\n             \n            }\n        "}};
  exports.mSDFBitGl = {name:"msdf-bit", fragment:{header:"\n            float calculateMSDFAlpha(vec4 msdfColor, vec4 shapeColor, float distance) {\n                \n                // MSDF\n                float median \x3d msdfColor.r + msdfColor.g + msdfColor.b -\n                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n               \n                // SDF\n                median \x3d min(median, msdfColor.a);\n            \n                float screenPxDistance \x3d distance * (median - 0.5);\n                float alpha \x3d clamp(screenPxDistance + 0.5, 0.0, 1.0);\n           \n                if (median \x3c 0.01) {\n                    alpha \x3d 0.0;\n                } else if (median \x3e 0.99) {\n                    alpha \x3d 1.0;\n                }\n\n                // Gamma correction for coverage-like alpha\n                float luma \x3d dot(shapeColor.rgb, vec3(0.299, 0.587, 0.114));\n                float gamma \x3d mix(1.0, 1.0 / 2.2, luma);\n                float coverage \x3d pow(shapeColor.a * alpha, gamma);  \n              \n                return coverage;\n            }\n        "}};
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$scene$text$sdfShader$shader_bits$mSDFBit.js.map
