{
"version":3,
"file":"module$node_modules$pixi_DOT_js$lib$rendering$high_shader$compiler$utils$compileOutputs.js",
"lineCount":34,
"mappings":"AAAAA,cAAA,CAAA,uFAAA,GAA4G,QAAQ,CAACC,MAAD,EAAQC,OAAR,EAAgBC,MAAhB,EAAuBC,OAAvB,CAAgC;AAIpJC,UAASA,eAAc,CAACC,cAAD,EAAiBC,GAAjB,CAAsB;AAC3C,QAAIC,KAAJ;AACA,UAAMC,QAAQ,kBAAd;AACA,SAAA,EAAgD,IAAhD,MAAQD,KAAR,GAAgBC,KAAMC,CAAAA,IAAN,CAAWJ,cAAX,CAAhB,EAAA;AACEC,SAAII,CAAAA,IAAJ,CAASH,KAAA,CAAM,CAAN,CAAT,CAAA;AADF;AAH2C;AA+C7CJ,SAAQQ,CAAAA,cAAR,GA/BAA,QAAuB,CAACC,SAAD,EAAYC,QAAZ,CAAsB;AAC3C,UAAMC,UAAU,EAAhB;AACAV,kBAAA,CAAeS,QAAf,EAAyBC,OAAzB,CAAA;AACAF,aAAUG,CAAAA,OAAV,CAAmBC,QAAD,IAAc;AAC1BA,cAASC,CAAAA,MAAb,IACEb,cAAA,CAAeY,QAASC,CAAAA,MAAxB,EAAgCH,OAAhC,CADF;AAD8B,KAAhC,CAAA;AAKA,QAAII,QAAQ,CAAZ;AACMC,aAAAA,GAAaL,OAAQM,CAAAA,IAAR,EAAeC,CAAAA,GAAf,CAAoBC,OAAD,IACH,CAAC,CAAlC,GAAIA,OAAQC,CAAAA,OAAR,CAAgB,SAAhB,CAAJ,GACSD,OADT,GAGQ,aAAYJ,KAAA,EAAZ,KAAwBI,OAAxB,EAJS,CAKhBE,CAAAA,IALgB,CAKX,KALW,CAAbL;AAMN,UAAMM,YAAYX,OAAQM,CAAAA,IAAR,EAAeC,CAAAA,GAAf,CAAoBC,OAAD,IAAc,cAA2BA,OAjBjEI,CAAAA,OAAN,CADOlB,UACP,EAAqB,EAArB,CAiB4C,GAAjC,CAAyEgB,CAAAA,IAAzE,CAA8E,IAA9E,CAAlB,EACMG,UAAW;cACLb,OAAQM,CAAAA,IAAR,EAAeC,CAAAA,GAAf,CAAoBC,OAAD,IAAc;AAxBvCf,aAAAA,GADQC,cACMC,CAAAA,IAAN,CAwBsDa,OAxBtD,CAARf;AAwBuC,aAAA,IAvBtCA,OAAA,GAAQA,OAAA,CAAM,CAAN,CAAR,GAAmB,EAuBmB,EAAA;AAAA,KAAjC,CAAoEiB,CAAAA,IAApE,CAAyE,KAAzE,CADK,IADjB;AAGII,YAAAA,GAAef,QAASa,CAAAA,OAAT,CAAiB,mBAAjB,EAAsC,EAAtC,CAAfE;AACJA,YAAA,GAAeA,QAAaF,CAAAA,OAAb,CAAqB,YAArB,EAAoC;EACnDP,SADmD;CAApC,CAAf;AAGAS,YAAA,GAAeA,QAAaF,CAAAA,OAAb,CAAqB,WAArB,EAAmC;EAClDD,SADkD;CAAnC,CAAf;AAMA,WAHAG,QAGA,GAHeA,QAAaF,CAAAA,OAAb,CAAqB,YAArB,EAAoC;EACnDC,OADmD;CAApC,CAGf;AA5B2C,GA+B7C;AAnDoJ,CAApJ;;",
"sources":["node_modules/pixi_DOT_js/lib/rendering/high-shader/compiler/utils/compileOutputs.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$pixi_DOT_js$lib$rendering$high_shader$compiler$utils$compileOutputs\"] = function(global,require,module,exports) {\n'use strict';\n\n\"use strict\";\nfunction extractOutputs(fragmentSource, out) {\n  let match;\n  const regex = /@out\\s+([^;]+);/g;\n  while ((match = regex.exec(fragmentSource)) !== null) {\n    out.push(match[1]);\n  }\n}\nfunction extractVariableName(value) {\n  const regex = /\\b(\\w+)\\s*:/g;\n  const match = regex.exec(value);\n  return match ? match[1] : \"\";\n}\nfunction stripVariable(value) {\n  const regex = /@.*?\\s+/g;\n  return value.replace(regex, \"\");\n}\nfunction compileOutputs(fragments, template) {\n  const results = [];\n  extractOutputs(template, results);\n  fragments.forEach((fragment) => {\n    if (fragment.header) {\n      extractOutputs(fragment.header, results);\n    }\n  });\n  let index = 0;\n  const mainStruct = results.sort().map((inValue) => {\n    if (inValue.indexOf(\"builtin\") > -1) {\n      return inValue;\n    }\n    return `@location(${index++}) ${inValue}`;\n  }).join(\",\\n\");\n  const mainStart = results.sort().map((inValue) => `       var ${stripVariable(inValue)};`).join(\"\\n\");\n  const mainEnd = `return VSOutput(\n            ${results.sort().map((inValue) => ` ${extractVariableName(inValue)}`).join(\",\\n\")});`;\n  let compiledCode = template.replace(/@out\\s+[^;]+;\\s*/g, \"\");\n  compiledCode = compiledCode.replace(\"{{struct}}\", `\n${mainStruct}\n`);\n  compiledCode = compiledCode.replace(\"{{start}}\", `\n${mainStart}\n`);\n  compiledCode = compiledCode.replace(\"{{return}}\", `\n${mainEnd}\n`);\n  return compiledCode;\n}\n\nexports.compileOutputs = compileOutputs;\n//# sourceMappingURL=compileOutputs.js.map\n\n};"],
"names":["shadow$provide","global","require","module","exports","extractOutputs","fragmentSource","out","match","regex","exec","push","compileOutputs","fragments","template","results","forEach","fragment","header","index","mainStruct","sort","map","inValue","indexOf","join","mainStart","replace","mainEnd","compiledCode"]
}
