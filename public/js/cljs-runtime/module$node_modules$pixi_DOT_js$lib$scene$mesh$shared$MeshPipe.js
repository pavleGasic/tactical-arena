shadow$provide.module$node_modules$pixi_DOT_js$lib$scene$mesh$shared$MeshPipe = function(global, require, module, exports) {
  global = require("module$node_modules$pixi_DOT_js$lib$extensions$Extensions");
  var Matrix = require("module$node_modules$pixi_DOT_js$lib$maths$matrix$Matrix"), BindGroup = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$gpu$shader$BindGroup"), UniformGroup = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$shader$UniformGroup"), getAdjustedBlendModeBlend = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$state$getAdjustedBlendModeBlend"), PoolGroup = require("module$node_modules$pixi_DOT_js$lib$utils$pool$PoolGroup"), 
  colorToUniform = require("module$node_modules$pixi_DOT_js$lib$scene$graphics$gpu$colorToUniform"), BatchableMesh = require("module$node_modules$pixi_DOT_js$lib$scene$mesh$shared$BatchableMesh");
  "use strict";
  class MeshPipe {
    constructor(renderer, adaptor) {
      this.localUniforms = new UniformGroup.UniformGroup({uTransformMatrix:{value:new Matrix.Matrix(), type:"mat3x3\x3cf32\x3e"}, uColor:{value:new Float32Array([1, 1, 1, 1]), type:"vec4\x3cf32\x3e"}, uRound:{value:0, type:"f32"}});
      this.localUniformsBindGroup = new BindGroup.BindGroup({0:this.localUniforms});
      this._meshDataHash = Object.create(null);
      this._gpuBatchableMeshHash = Object.create(null);
      this._destroyRenderableBound = this.destroyRenderable.bind(this);
      this.renderer = renderer;
      this._adaptor = adaptor;
      this._adaptor.init();
      renderer.renderableGC.addManagedHash(this, "_gpuBatchableMeshHash");
      renderer.renderableGC.addManagedHash(this, "_meshDataHash");
    }
    validateRenderable(mesh) {
      var meshData = this._getMeshData(mesh), wasBatched = meshData.batched;
      const isBatched = mesh.batched;
      meshData.batched = isBatched;
      if (wasBatched !== isBatched) {
        return !0;
      }
      if (isBatched) {
        wasBatched = mesh._geometry;
        if (wasBatched.indices.length !== meshData.indexSize || wasBatched.positions.length !== meshData.vertexSize) {
          return meshData.indexSize = wasBatched.indices.length, meshData.vertexSize = wasBatched.positions.length, !0;
        }
        meshData = this._getBatchableMesh(mesh);
        meshData.texture.uid !== mesh._texture.uid && (meshData._textureMatrixUpdateId = -1);
        return !meshData._batcher.checkAndUpdateTexture(meshData, mesh._texture);
      }
      return !1;
    }
    addRenderable(mesh, instructionSet) {
      const batcher = this.renderer.renderPipes.batch;
      var {batched} = this._getMeshData(mesh);
      batched ? (batched = this._getBatchableMesh(mesh), batched.setTexture(mesh._texture), batched.geometry = mesh._geometry, batcher.addToBatch(batched, instructionSet)) : (batcher.break(instructionSet), instructionSet.add(mesh));
    }
    updateRenderable(mesh) {
      if (mesh.batched) {
        const gpuBatchableMesh = this._gpuBatchableMeshHash[mesh.uid];
        gpuBatchableMesh.setTexture(mesh._texture);
        gpuBatchableMesh.geometry = mesh._geometry;
        gpuBatchableMesh._batcher.updateElement(gpuBatchableMesh);
      }
    }
    destroyRenderable(mesh) {
      this._meshDataHash[mesh.uid] = null;
      const gpuMesh = this._gpuBatchableMeshHash[mesh.uid];
      gpuMesh && (PoolGroup.BigPool.return(gpuMesh), this._gpuBatchableMeshHash[mesh.uid] = null);
      mesh.off("destroyed", this._destroyRenderableBound);
    }
    execute(mesh) {
      if (mesh.isRenderable) {
        mesh.state.blendMode = getAdjustedBlendModeBlend.getAdjustedBlendModeBlend(mesh.groupBlendMode, mesh.texture._source);
        var localUniforms = this.localUniforms;
        localUniforms.uniforms.uTransformMatrix = mesh.groupTransform;
        localUniforms.uniforms.uRound = this.renderer._roundPixels | mesh._roundPixels;
        localUniforms.update();
        colorToUniform.color32BitToUniform(mesh.groupColorAlpha, localUniforms.uniforms.uColor, 0);
        this._adaptor.execute(this, mesh);
      }
    }
    _getMeshData(mesh) {
      return this._meshDataHash[mesh.uid] || this._initMeshData(mesh);
    }
    _initMeshData(mesh) {
      this._meshDataHash[mesh.uid] = {batched:mesh.batched, indexSize:mesh._geometry.indices?.length, vertexSize:mesh._geometry.positions?.length};
      mesh.on("destroyed", this._destroyRenderableBound);
      return this._meshDataHash[mesh.uid];
    }
    _getBatchableMesh(mesh) {
      return this._gpuBatchableMeshHash[mesh.uid] || this._initBatchableMesh(mesh);
    }
    _initBatchableMesh(mesh) {
      const gpuMesh = PoolGroup.BigPool.get(BatchableMesh.BatchableMesh);
      gpuMesh.renderable = mesh;
      gpuMesh.setTexture(mesh._texture);
      gpuMesh.transform = mesh.groupTransform;
      gpuMesh.roundPixels = this.renderer._roundPixels | mesh._roundPixels;
      return this._gpuBatchableMeshHash[mesh.uid] = gpuMesh;
    }
    destroy() {
      for (const i in this._gpuBatchableMeshHash) {
        this._gpuBatchableMeshHash[i] && PoolGroup.BigPool.return(this._gpuBatchableMeshHash[i]);
      }
      this.localUniformsBindGroup = this.localUniforms = this._meshDataHash = this._gpuBatchableMeshHash = null;
      this._adaptor.destroy();
      this.renderer = this._adaptor = null;
    }
  }
  MeshPipe.extension = {type:[global.ExtensionType.WebGLPipes, global.ExtensionType.WebGPUPipes, global.ExtensionType.CanvasPipes], name:"mesh"};
  exports.MeshPipe = MeshPipe;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$scene$mesh$shared$MeshPipe.js.map
