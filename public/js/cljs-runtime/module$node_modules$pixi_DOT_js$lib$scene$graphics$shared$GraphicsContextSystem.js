shadow$provide.module$node_modules$pixi_DOT_js$lib$scene$graphics$shared$GraphicsContextSystem = function(global, require, module, exports) {
  global = require("module$node_modules$pixi_DOT_js$lib$extensions$Extensions");
  var getTextureBatchBindGroup = require("module$node_modules$pixi_DOT_js$lib$rendering$batcher$gpu$getTextureBatchBindGroup"), DefaultBatcher = require("module$node_modules$pixi_DOT_js$lib$rendering$batcher$shared$DefaultBatcher"), InstructionSet = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$instructions$InstructionSet"), deprecation = require("module$node_modules$pixi_DOT_js$lib$utils$logging$deprecation"), PoolGroup = require("module$node_modules$pixi_DOT_js$lib$utils$pool$PoolGroup"), 
  buildContextBatches = require("module$node_modules$pixi_DOT_js$lib$scene$graphics$shared$utils$buildContextBatches");
  "use strict";
  class GpuGraphicsContext {
    constructor() {
      this.batches = [];
      this.geometryData = {vertices:[], uvs:[], indices:[]};
    }
  }
  class GraphicsContextRenderData {
    constructor() {
      this.batcher = new DefaultBatcher.DefaultBatcher();
      this.instructions = new InstructionSet.InstructionSet();
    }
    init() {
      this.instructions.reset();
    }
    get geometry() {
      deprecation.deprecation(deprecation.v8_3_4, "GraphicsContextRenderData#geometry is deprecated, please use batcher.geometry instead.");
      return this.batcher.geometry;
    }
  }
  const node_modules$pixi_DOT_js$lib$scene$graphics$shared$GraphicsContextSystem$classdecl$var13 = class {
    constructor(renderer) {
      this._gpuContextHash = {};
      this._graphicsDataContextHash = Object.create(null);
      renderer.renderableGC.addManagedHash(this, "_gpuContextHash");
      renderer.renderableGC.addManagedHash(this, "_graphicsDataContextHash");
    }
    init(options) {
      node_modules$pixi_DOT_js$lib$scene$graphics$shared$GraphicsContextSystem$classdecl$var13.defaultOptions.bezierSmoothness = options?.bezierSmoothness ?? node_modules$pixi_DOT_js$lib$scene$graphics$shared$GraphicsContextSystem$classdecl$var13.defaultOptions.bezierSmoothness;
    }
    getContextRenderData(context) {
      return this._graphicsDataContextHash[context.uid] || this._initContextRenderData(context);
    }
    updateGpuContext(context) {
      let gpuContext = this._gpuContextHash[context.uid] || this._initContext(context);
      if (context.dirty) {
        gpuContext ? this._cleanGraphicsContextData(context) : gpuContext = this._initContext(context);
        buildContextBatches.buildContextBatches(context, gpuContext);
        const batchMode = context.batchMode;
        context.customShader || "no-batch" === batchMode ? gpuContext.isBatchable = !1 : "auto" === batchMode && (gpuContext.isBatchable = 400 > gpuContext.geometryData.vertices.length);
        context.dirty = !1;
      }
      return gpuContext;
    }
    getGpuContext(context) {
      return this._gpuContextHash[context.uid] || this._initContext(context);
    }
    _initContextRenderData(context) {
      const graphicsData = PoolGroup.BigPool.get(GraphicsContextRenderData), {batches, geometryData} = this._gpuContextHash[context.uid];
      var vertexSize = geometryData.vertices.length, indexSize = geometryData.indices.length;
      for (var i = 0; i < batches.length; i++) {
        batches[i].applyTransform = !1;
      }
      i = graphicsData.batcher;
      i.ensureAttributeBuffer(vertexSize);
      i.ensureIndexBuffer(indexSize);
      i.begin();
      for (vertexSize = 0; vertexSize < batches.length; vertexSize++) {
        i.add(batches[vertexSize]);
      }
      i.finish(graphicsData.instructions);
      vertexSize = i.geometry;
      vertexSize.indexBuffer.setDataWithSize(i.indexBuffer, i.indexSize, !0);
      vertexSize.buffers[0].setDataWithSize(i.attributeBuffer.float32View, i.attributeSize, !0);
      i = i.batches;
      for (vertexSize = 0; vertexSize < i.length; vertexSize++) {
        indexSize = i[vertexSize], indexSize.bindGroup = getTextureBatchBindGroup.getTextureBatchBindGroup(indexSize.textures.textures, indexSize.textures.count);
      }
      return this._graphicsDataContextHash[context.uid] = graphicsData;
    }
    _initContext(context) {
      const gpuContext = new GpuGraphicsContext();
      gpuContext.context = context;
      this._gpuContextHash[context.uid] = gpuContext;
      context.on("destroy", this.onGraphicsContextDestroy, this);
      return this._gpuContextHash[context.uid];
    }
    onGraphicsContextDestroy(context) {
      this._cleanGraphicsContextData(context);
      context.off("destroy", this.onGraphicsContextDestroy, this);
      this._gpuContextHash[context.uid] = null;
    }
    _cleanGraphicsContextData(context) {
      const gpuContext = this._gpuContextHash[context.uid];
      !gpuContext.isBatchable && this._graphicsDataContextHash[context.uid] && (PoolGroup.BigPool.return(this.getContextRenderData(context)), this._graphicsDataContextHash[context.uid] = null);
      gpuContext.batches && gpuContext.batches.forEach(batch => {
        PoolGroup.BigPool.return(batch);
      });
    }
    destroy() {
      for (const i in this._gpuContextHash) {
        if (this._gpuContextHash[i]) {
          this.onGraphicsContextDestroy(this._gpuContextHash[i].context);
        }
      }
    }
  };
  require = node_modules$pixi_DOT_js$lib$scene$graphics$shared$GraphicsContextSystem$classdecl$var13;
  require.extension = {type:[global.ExtensionType.WebGLSystem, global.ExtensionType.WebGPUSystem, global.ExtensionType.CanvasSystem], name:"graphicsContext"};
  require.defaultOptions = {bezierSmoothness:0.5};
  exports.GpuGraphicsContext = GpuGraphicsContext;
  exports.GraphicsContextRenderData = GraphicsContextRenderData;
  exports.GraphicsContextSystem = require;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$scene$graphics$shared$GraphicsContextSystem.js.map
