shadow$provide.module$node_modules$pixi_DOT_js$lib$filters$defaults$blur$BlurFilterPass = function(global, require, module, exports) {
  var TexturePool = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$texture$TexturePool"), types = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$types");
  global = require("module$node_modules$pixi_DOT_js$lib$filters$Filter");
  var generateBlurGlProgram = require("module$node_modules$pixi_DOT_js$lib$filters$defaults$blur$gl$generateBlurGlProgram"), generateBlurProgram = require("module$node_modules$pixi_DOT_js$lib$filters$defaults$blur$gpu$generateBlurProgram");
  "use strict";
  const node_modules$pixi_DOT_js$lib$filters$defaults$blur$BlurFilterPass$classdecl$var37 = class extends global.Filter {
    constructor(options) {
      options = {...node_modules$pixi_DOT_js$lib$filters$defaults$blur$BlurFilterPass$classdecl$var37.defaultOptions, ...options};
      const glProgram = generateBlurGlProgram.generateBlurGlProgram(options.horizontal, options.kernelSize), gpuProgram = generateBlurProgram.generateBlurProgram(options.horizontal, options.kernelSize);
      super({glProgram, gpuProgram, resources:{blurUniforms:{uStrength:{value:0, type:"f32"}}}, ...options});
      this.horizontal = options.horizontal;
      this._quality = 0;
      this.quality = options.quality;
      this.blur = options.strength;
      this._uniforms = this.resources.blurUniforms.uniforms;
    }
    apply(filterManager, input, output, clearMode) {
      this._uniforms.uStrength = this.strength / this.passes;
      if (1 === this.passes) {
        filterManager.applyFilter(this, input, output, clearMode);
      } else {
        const tempTexture = TexturePool.TexturePool.getSameSizeTexture(input);
        let flop = tempTexture;
        this._state.blend = !1;
        const shouldClear = filterManager.renderer.type === types.RendererType.WEBGPU;
        for (let i = 0; i < this.passes - 1; i++) {
          filterManager.applyFilter(this, input, flop, 0 === i ? !0 : shouldClear);
          const temp = flop;
          flop = input;
          input = temp;
        }
        this._state.blend = !0;
        filterManager.applyFilter(this, input, output, clearMode);
        TexturePool.TexturePool.returnTexture(tempTexture);
      }
    }
    get blur() {
      return this.strength;
    }
    set blur(value) {
      this.padding = 1 + 2 * Math.abs(value);
      this.strength = value;
    }
    get quality() {
      return this._quality;
    }
    set quality(value) {
      this.passes = this._quality = value;
    }
  };
  require = node_modules$pixi_DOT_js$lib$filters$defaults$blur$BlurFilterPass$classdecl$var37;
  require.defaultOptions = {strength:8, quality:4, kernelSize:5};
  exports.BlurFilterPass = require;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$filters$defaults$blur$BlurFilterPass.js.map
