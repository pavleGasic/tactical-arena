shadow$provide.module$node_modules$$pixi$assets$lib$Assets = function(global, require, module, exports) {
  var core = require("module$node_modules$$pixi$core$lib$index"), BackgroundLoader = require("module$node_modules$$pixi$assets$lib$BackgroundLoader"), Cache = require("module$node_modules$$pixi$assets$lib$cache$Cache"), Loader = require("module$node_modules$$pixi$assets$lib$loader$Loader");
  require("module$node_modules$$pixi$assets$lib$loader$parsers$index");
  var Resolver = require("module$node_modules$$pixi$assets$lib$resolver$Resolver"), convertToList = require("module$node_modules$$pixi$assets$lib$utils$convertToList"), isSingleItem = require("module$node_modules$$pixi$assets$lib$utils$isSingleItem"), loadTextures = require("module$node_modules$$pixi$assets$lib$loader$parsers$textures$loadTextures");
  class AssetsClass {
    constructor() {
      this._detections = [];
      this._initialized = !1;
      this.resolver = new Resolver.Resolver();
      this.loader = new Loader.Loader();
      this.cache = Cache.Cache;
      this._backgroundLoader = new BackgroundLoader.BackgroundLoader(this.loader);
      this._backgroundLoader.active = !0;
      this.reset();
    }
    async init(options = {}) {
      if (this._initialized) {
        console.warn("[Assets]AssetManager already initialized, did you load before calling this Assets.init()?");
      } else {
        if (this._initialized = !0, options.defaultSearchParams && this.resolver.setDefaultSearchParams(options.defaultSearchParams), options.basePath && (this.resolver.basePath = options.basePath), options.bundleIdentifier && this.resolver.setBundleIdentifier(options.bundleIdentifier), options.manifest) {
          var manifest = options.manifest;
          "string" == typeof manifest && (manifest = await this.load(manifest));
          this.resolver.addManifest(manifest);
        }
        manifest = options.texturePreference?.resolution ?? 1;
        manifest = "number" == typeof manifest ? [manifest] : manifest;
        var formats = await this._detectFormats({preferredFormats:options.texturePreference?.format, skipDetections:options.skipDetections, detections:this._detections});
        this.resolver.prefer({params:{format:formats, resolution:manifest}});
        options.preferences && this.setPreferences(options.preferences);
      }
    }
    add(aliases, srcs, data, format, loadParser) {
      this.resolver.add(aliases, srcs, data, format, loadParser);
    }
    async load(urls, onProgress) {
      this._initialized || await this.init();
      const singleAsset = isSingleItem.isSingleItem(urls);
      urls = convertToList.convertToList(urls).map(url => {
        if ("string" != typeof url) {
          const aliases = this.resolver.getAlias(url);
          return aliases.some(alias => !this.resolver.hasKey(alias)) && this.add(url), Array.isArray(aliases) ? aliases[0] : aliases;
        }
        return this.resolver.hasKey(url) || this.add({alias:url, src:url}), url;
      });
      const resolveResults = this.resolver.resolve(urls);
      onProgress = await this._mapLoadToResolve(resolveResults, onProgress);
      return singleAsset ? onProgress[urls[0]] : onProgress;
    }
    addBundle(bundleId, assets) {
      this.resolver.addBundle(bundleId, assets);
    }
    async loadBundle(bundleIds, onProgress) {
      this._initialized || await this.init();
      let singleAsset = !1;
      "string" == typeof bundleIds && (singleAsset = !0, bundleIds = [bundleIds]);
      const resolveResults = this.resolver.resolveBundle(bundleIds), out = {};
      let count = 0, total = 0;
      const _onProgress = () => {
        onProgress?.(++count / total);
      }, promises = Object.keys(resolveResults).map(bundleId => {
        const resolveResult = resolveResults[bundleId];
        return total += Object.keys(resolveResult).length, this._mapLoadToResolve(resolveResult, _onProgress).then(resolveResult2 => {
          out[bundleId] = resolveResult2;
        });
      });
      return await Promise.all(promises), singleAsset ? out[bundleIds[0]] : out;
    }
    async backgroundLoad(urls) {
      this._initialized || await this.init();
      "string" == typeof urls && (urls = [urls]);
      urls = this.resolver.resolve(urls);
      this._backgroundLoader.add(Object.values(urls));
    }
    async backgroundLoadBundle(bundleIds) {
      this._initialized || await this.init();
      "string" == typeof bundleIds && (bundleIds = [bundleIds]);
      bundleIds = this.resolver.resolveBundle(bundleIds);
      Object.values(bundleIds).forEach(resolveResult => {
        this._backgroundLoader.add(Object.values(resolveResult));
      });
    }
    reset() {
      this.resolver.reset();
      this.loader.reset();
      this.cache.reset();
      this._initialized = !1;
    }
    get(keys) {
      if ("string" == typeof keys) {
        return Cache.Cache.get(keys);
      }
      const assets = {};
      for (let i = 0; i < keys.length; i++) {
        assets[i] = Cache.Cache.get(keys[i]);
      }
      return assets;
    }
    async _mapLoadToResolve(resolveResults, onProgress) {
      const resolveArray = Object.values(resolveResults), resolveKeys = Object.keys(resolveResults);
      this._backgroundLoader.active = !1;
      const loadedAssets = await this.loader.load(resolveArray, onProgress);
      this._backgroundLoader.active = !0;
      const out = {};
      return resolveArray.forEach((resolveResult, i) => {
        const asset = loadedAssets[resolveResult.src], keys = [resolveResult.src];
        resolveResult.alias && keys.push(...resolveResult.alias);
        out[resolveKeys[i]] = asset;
        Cache.Cache.set(keys, asset);
      }), out;
    }
    async unload(urls) {
      this._initialized || await this.init();
      urls = convertToList.convertToList(urls).map(url => "string" != typeof url ? url.src : url);
      urls = this.resolver.resolve(urls);
      await this._unloadFromResolved(urls);
    }
    async unloadBundle(bundleIds) {
      this._initialized || await this.init();
      bundleIds = convertToList.convertToList(bundleIds);
      const resolveResults = this.resolver.resolveBundle(bundleIds);
      bundleIds = Object.keys(resolveResults).map(bundleId => this._unloadFromResolved(resolveResults[bundleId]));
      await Promise.all(bundleIds);
    }
    async _unloadFromResolved(resolveResult) {
      resolveResult = Object.values(resolveResult);
      resolveResult.forEach(resolveResult2 => {
        Cache.Cache.remove(resolveResult2.src);
      });
      await this.loader.unload(resolveResult);
    }
    async _detectFormats(options) {
      let formats = [];
      options.preferredFormats && (formats = Array.isArray(options.preferredFormats) ? options.preferredFormats : [options.preferredFormats]);
      for (const detection of options.detections) {
        options.skipDetections || await detection.test() ? formats = await detection.add(formats) : options.skipDetections || (formats = await detection.remove(formats));
      }
      return formats = formats.filter((format, index) => formats.indexOf(format) === index), formats;
    }
    get detections() {
      return this._detections;
    }
    get preferWorkers() {
      return loadTextures.loadTextures.config.preferWorkers;
    }
    set preferWorkers(value) {
      core.utils.deprecation("7.2.0", "Assets.prefersWorkers is deprecated, use Assets.setPreferences({ preferWorkers: true }) instead.");
      this.setPreferences({preferWorkers:value});
    }
    setPreferences(preferences) {
      this.loader.parsers.forEach(parser => {
        parser.config && Object.keys(parser.config).filter(key => key in preferences).forEach(key => {
          parser.config[key] = preferences[key];
        });
      });
    }
  }
  global = new AssetsClass();
  core.extensions.handleByList(core.ExtensionType.LoadParser, global.loader.parsers).handleByList(core.ExtensionType.ResolveParser, global.resolver.parsers).handleByList(core.ExtensionType.CacheParser, global.cache.parsers).handleByList(core.ExtensionType.DetectionParser, global.detections);
  exports.Assets = global;
  exports.AssetsClass = AssetsClass;
};

//# sourceMappingURL=module$node_modules$$pixi$assets$lib$Assets.js.map
