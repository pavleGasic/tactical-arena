shadow$provide.module$node_modules$$pixi$display$lib$DisplayObject = function(global, require, module, exports) {
  var core = require("module$node_modules$$pixi$core$lib$index"), Bounds = require("module$node_modules$$pixi$display$lib$Bounds");
  class DisplayObject extends core.utils.EventEmitter {
    constructor() {
      super();
      this.tempDisplayObjectParent = null;
      this.transform = new core.Transform();
      this.alpha = 1;
      this.renderable = this.visible = !0;
      this.cullable = !1;
      this.parent = this.cullArea = null;
      this.worldAlpha = 1;
      this._zIndex = this._lastSortedIndex = 0;
      this._enabledFilters = this.filters = this.filterArea = null;
      this._bounds = new Bounds.Bounds();
      this._localBounds = null;
      this._boundsID = 0;
      this._mask = this._localBoundsRect = this._boundsRect = null;
      this._maskRefCount = 0;
      this.isMask = this.isSprite = this._destroyed = !1;
    }
    static mixin(source) {
      const keys = Object.keys(source);
      for (let i = 0; i < keys.length; ++i) {
        const propertyName = keys[i];
        Object.defineProperty(DisplayObject.prototype, propertyName, Object.getOwnPropertyDescriptor(source, propertyName));
      }
    }
    get destroyed() {
      return this._destroyed;
    }
    _recursivePostUpdateTransform() {
      this.parent ? (this.parent._recursivePostUpdateTransform(), this.transform.updateTransform(this.parent.transform)) : this.transform.updateTransform(this._tempDisplayObjectParent.transform);
    }
    updateTransform() {
      this._boundsID++;
      this.transform.updateTransform(this.parent.transform);
      this.worldAlpha = this.alpha * this.parent.worldAlpha;
    }
    getBounds(skipUpdate, rect) {
      return skipUpdate || (this.parent ? (this._recursivePostUpdateTransform(), this.updateTransform()) : (this.parent = this._tempDisplayObjectParent, this.updateTransform(), this.parent = null)), this._bounds.updateID !== this._boundsID && (this.calculateBounds(), this._bounds.updateID = this._boundsID), rect || (this._boundsRect || (this._boundsRect = new core.Rectangle()), rect = this._boundsRect), this._bounds.getRectangle(rect);
    }
    getLocalBounds(rect) {
      rect || (this._localBoundsRect || (this._localBoundsRect = new core.Rectangle()), rect = this._localBoundsRect);
      this._localBounds || (this._localBounds = new Bounds.Bounds());
      const transformRef = this.transform, parentRef = this.parent;
      this.parent = null;
      this._tempDisplayObjectParent.worldAlpha = parentRef?.worldAlpha ?? 1;
      this.transform = this._tempDisplayObjectParent.transform;
      const worldBounds = this._bounds, worldBoundsID = this._boundsID;
      this._bounds = this._localBounds;
      rect = this.getBounds(!1, rect);
      return this.parent = parentRef, this.transform = transformRef, this._bounds = worldBounds, this._bounds.updateID += this._boundsID - worldBoundsID, rect;
    }
    toGlobal(position, point, skipUpdate = !1) {
      return skipUpdate || (this._recursivePostUpdateTransform(), this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent, this.displayObjectUpdateTransform(), this.parent = null)), this.worldTransform.apply(position, point);
    }
    toLocal(position, from, point, skipUpdate) {
      return from && (position = from.toGlobal(position, point, skipUpdate)), skipUpdate || (this._recursivePostUpdateTransform(), this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent, this.displayObjectUpdateTransform(), this.parent = null)), this.worldTransform.applyInverse(position, point);
    }
    setParent(container) {
      if (!container || !container.addChild) {
        throw Error("setParent: Argument must be a Container");
      }
      return container.addChild(this), container;
    }
    removeFromParent() {
      this.parent?.removeChild(this);
    }
    setTransform(x = 0, y = 0, scaleX = 1, scaleY = 1, rotation = 0, skewX = 0, skewY = 0, pivotX = 0, pivotY = 0) {
      return this.position.x = x, this.position.y = y, this.scale.x = scaleX || 1, this.scale.y = scaleY || 1, this.rotation = rotation, this.skew.x = skewX, this.skew.y = skewY, this.pivot.x = pivotX, this.pivot.y = pivotY, this;
    }
    destroy(_options) {
      this.removeFromParent();
      this._destroyed = !0;
      this.hitArea = this.filterArea = this.filters = this.cullArea = this.mask = this._bounds = this.parent = this.transform = null;
      this.eventMode = "auto";
      this.interactiveChildren = !1;
      this.emit("destroyed");
      this.removeAllListeners();
    }
    get _tempDisplayObjectParent() {
      return null === this.tempDisplayObjectParent && (this.tempDisplayObjectParent = new TemporaryDisplayObject()), this.tempDisplayObjectParent;
    }
    enableTempParent() {
      const myParent = this.parent;
      return this.parent = this._tempDisplayObjectParent, myParent;
    }
    disableTempParent(cacheParent) {
      this.parent = cacheParent;
    }
    get x() {
      return this.position.x;
    }
    set x(value) {
      this.transform.position.x = value;
    }
    get y() {
      return this.position.y;
    }
    set y(value) {
      this.transform.position.y = value;
    }
    get worldTransform() {
      return this.transform.worldTransform;
    }
    get localTransform() {
      return this.transform.localTransform;
    }
    get position() {
      return this.transform.position;
    }
    set position(value) {
      this.transform.position.copyFrom(value);
    }
    get scale() {
      return this.transform.scale;
    }
    set scale(value) {
      this.transform.scale.copyFrom(value);
    }
    get pivot() {
      return this.transform.pivot;
    }
    set pivot(value) {
      this.transform.pivot.copyFrom(value);
    }
    get skew() {
      return this.transform.skew;
    }
    set skew(value) {
      this.transform.skew.copyFrom(value);
    }
    get rotation() {
      return this.transform.rotation;
    }
    set rotation(value) {
      this.transform.rotation = value;
    }
    get angle() {
      return this.transform.rotation * core.RAD_TO_DEG;
    }
    set angle(value) {
      this.transform.rotation = value * core.DEG_TO_RAD;
    }
    get zIndex() {
      return this._zIndex;
    }
    set zIndex(value) {
      this._zIndex !== value && (this._zIndex = value, this.parent && (this.parent.sortDirty = !0));
    }
    get worldVisible() {
      let item = this;
      do {
        if (!item.visible) {
          return !1;
        }
        item = item.parent;
      } while (item);
      return !0;
    }
    get mask() {
      return this._mask;
    }
    set mask(value) {
      if (this._mask !== value) {
        if (this._mask) {
          const maskObject = this._mask.isMaskData ? this._mask.maskObject : this._mask;
          maskObject && (maskObject._maskRefCount--, 0 === maskObject._maskRefCount && (maskObject.renderable = !0, maskObject.isMask = !1));
        }
        (this._mask = value, this._mask) && (value = this._mask.isMaskData ? this._mask.maskObject : this._mask) && (0 === value._maskRefCount && (value.renderable = !1, value.isMask = !0), value._maskRefCount++);
      }
    }
  }
  class TemporaryDisplayObject extends DisplayObject {
    constructor() {
      super(...arguments);
      this.sortDirty = null;
    }
  }
  DisplayObject.prototype.displayObjectUpdateTransform = DisplayObject.prototype.updateTransform;
  exports.DisplayObject = DisplayObject;
  exports.TemporaryDisplayObject = TemporaryDisplayObject;
};

//# sourceMappingURL=module$node_modules$$pixi$display$lib$DisplayObject.js.map
