shadow$provide.module$node_modules$pixi_DOT_js$lib$maths$matrix$Matrix = function(global, require, module, exports) {
  var _const = require("module$node_modules$pixi_DOT_js$lib$maths$misc$const"), Point = require("module$node_modules$pixi_DOT_js$lib$maths$point$Point");
  "use strict";
  class Matrix {
    constructor(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0) {
      this.array = null;
      this.a = a;
      this.b = b;
      this.c = c;
      this.d = d;
      this.tx = tx;
      this.ty = ty;
    }
    fromArray(array) {
      this.a = array[0];
      this.b = array[1];
      this.c = array[3];
      this.d = array[4];
      this.tx = array[2];
      this.ty = array[5];
    }
    set(a, b, c, d, tx, ty) {
      this.a = a;
      this.b = b;
      this.c = c;
      this.d = d;
      this.tx = tx;
      this.ty = ty;
      return this;
    }
    toArray(transpose, out) {
      this.array || (this.array = new Float32Array(9));
      out = out || this.array;
      transpose ? (out[0] = this.a, out[1] = this.b, out[2] = 0, out[3] = this.c, out[4] = this.d, out[5] = 0, out[6] = this.tx, out[7] = this.ty) : (out[0] = this.a, out[1] = this.c, out[2] = this.tx, out[3] = this.b, out[4] = this.d, out[5] = this.ty, out[6] = 0, out[7] = 0);
      out[8] = 1;
      return out;
    }
    apply(pos, newPos) {
      newPos = newPos || new Point.Point();
      const x = pos.x;
      pos = pos.y;
      newPos.x = this.a * x + this.c * pos + this.tx;
      newPos.y = this.b * x + this.d * pos + this.ty;
      return newPos;
    }
    applyInverse(pos, newPos) {
      newPos = newPos || new Point.Point();
      const a = this.a, b = this.b, c = this.c, d = this.d, tx = this.tx, ty = this.ty, id = 1 / (a * d + c * -b), x = pos.x;
      pos = pos.y;
      newPos.x = d * id * x + -c * id * pos + (ty * c - tx * d) * id;
      newPos.y = a * id * pos + -b * id * x + (-ty * a + tx * b) * id;
      return newPos;
    }
    translate(x, y) {
      this.tx += x;
      this.ty += y;
      return this;
    }
    scale(x, y) {
      this.a *= x;
      this.d *= y;
      this.c *= x;
      this.b *= y;
      this.tx *= x;
      this.ty *= y;
      return this;
    }
    rotate(angle) {
      const cos = Math.cos(angle);
      angle = Math.sin(angle);
      const a1 = this.a, c1 = this.c, tx1 = this.tx;
      this.a = a1 * cos - this.b * angle;
      this.b = a1 * angle + this.b * cos;
      this.c = c1 * cos - this.d * angle;
      this.d = c1 * angle + this.d * cos;
      this.tx = tx1 * cos - this.ty * angle;
      this.ty = tx1 * angle + this.ty * cos;
      return this;
    }
    append(matrix) {
      const a1 = this.a, b1 = this.b, c1 = this.c, d1 = this.d;
      this.a = matrix.a * a1 + matrix.b * c1;
      this.b = matrix.a * b1 + matrix.b * d1;
      this.c = matrix.c * a1 + matrix.d * c1;
      this.d = matrix.c * b1 + matrix.d * d1;
      this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx;
      this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty;
      return this;
    }
    appendFrom(a, b) {
      const a1 = a.a, b1 = a.b, c1 = a.c, d1 = a.d, tx = a.tx;
      a = a.ty;
      const a2 = b.a, b2 = b.b, c2 = b.c, d2 = b.d;
      this.a = a1 * a2 + b1 * c2;
      this.b = a1 * b2 + b1 * d2;
      this.c = c1 * a2 + d1 * c2;
      this.d = c1 * b2 + d1 * d2;
      this.tx = tx * a2 + a * c2 + b.tx;
      this.ty = tx * b2 + a * d2 + b.ty;
      return this;
    }
    setTransform(x, y, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY) {
      this.a = Math.cos(rotation + skewY) * scaleX;
      this.b = Math.sin(rotation + skewY) * scaleX;
      this.c = -Math.sin(rotation - skewX) * scaleY;
      this.d = Math.cos(rotation - skewX) * scaleY;
      this.tx = x - (pivotX * this.a + pivotY * this.c);
      this.ty = y - (pivotX * this.b + pivotY * this.d);
      return this;
    }
    prepend(matrix) {
      const tx1 = this.tx;
      if (1 !== matrix.a || 0 !== matrix.b || 0 !== matrix.c || 1 !== matrix.d) {
        const a1 = this.a, c1 = this.c;
        this.a = a1 * matrix.a + this.b * matrix.c;
        this.b = a1 * matrix.b + this.b * matrix.d;
        this.c = c1 * matrix.a + this.d * matrix.c;
        this.d = c1 * matrix.b + this.d * matrix.d;
      }
      this.tx = tx1 * matrix.a + this.ty * matrix.c + matrix.tx;
      this.ty = tx1 * matrix.b + this.ty * matrix.d + matrix.ty;
      return this;
    }
    decompose(transform) {
      const a = this.a, b = this.b, c = this.c, d = this.d, pivot = transform.pivot, skewX = -Math.atan2(-c, d), skewY = Math.atan2(b, a), delta = Math.abs(skewX + skewY);
      1e-5 > delta || 1e-5 > Math.abs(_const.PI_2 - delta) ? (transform.rotation = skewY, transform.skew.x = transform.skew.y = 0) : (transform.rotation = 0, transform.skew.x = skewX, transform.skew.y = skewY);
      transform.scale.x = Math.sqrt(a * a + b * b);
      transform.scale.y = Math.sqrt(c * c + d * d);
      transform.position.x = this.tx + (pivot.x * a + pivot.y * c);
      transform.position.y = this.ty + (pivot.x * b + pivot.y * d);
      return transform;
    }
    invert() {
      const a1 = this.a, b1 = this.b, c1 = this.c, d1 = this.d, tx1 = this.tx, n = a1 * d1 - b1 * c1;
      this.a = d1 / n;
      this.b = -b1 / n;
      this.c = -c1 / n;
      this.d = a1 / n;
      this.tx = (c1 * this.ty - d1 * tx1) / n;
      this.ty = -(a1 * this.ty - b1 * tx1) / n;
      return this;
    }
    isIdentity() {
      return 1 === this.a && 0 === this.b && 0 === this.c && 1 === this.d && 0 === this.tx && 0 === this.ty;
    }
    identity() {
      this.a = 1;
      this.c = this.b = 0;
      this.d = 1;
      this.ty = this.tx = 0;
      return this;
    }
    clone() {
      const matrix = new Matrix();
      matrix.a = this.a;
      matrix.b = this.b;
      matrix.c = this.c;
      matrix.d = this.d;
      matrix.tx = this.tx;
      matrix.ty = this.ty;
      return matrix;
    }
    copyTo(matrix) {
      matrix.a = this.a;
      matrix.b = this.b;
      matrix.c = this.c;
      matrix.d = this.d;
      matrix.tx = this.tx;
      matrix.ty = this.ty;
      return matrix;
    }
    copyFrom(matrix) {
      this.a = matrix.a;
      this.b = matrix.b;
      this.c = matrix.c;
      this.d = matrix.d;
      this.tx = matrix.tx;
      this.ty = matrix.ty;
      return this;
    }
    equals(matrix) {
      return matrix.a === this.a && matrix.b === this.b && matrix.c === this.c && matrix.d === this.d && matrix.tx === this.tx && matrix.ty === this.ty;
    }
    toString() {
      return `[pixi.js:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;
    }
    static get IDENTITY() {
      return identityMatrix.identity();
    }
    static get shared() {
      return tempMatrix.identity();
    }
  }
  const tempMatrix = new Matrix(), identityMatrix = new Matrix();
  exports.Matrix = Matrix;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$maths$matrix$Matrix.js.map
