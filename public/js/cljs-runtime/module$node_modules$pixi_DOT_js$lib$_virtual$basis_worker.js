shadow$provide.module$node_modules$pixi_DOT_js$lib$_virtual$basis_worker = function(global, require, module, exports) {
  Object.defineProperty(exports, "__esModule", {value:!0});
  let WORKER_URL = null;
  class WorkerInstance {
    constructor() {
      WORKER_URL || (WORKER_URL = URL.createObjectURL(new Blob(['(function () {\n    \'use strict\';\n\n    function createLevelBuffers(basisTexture, basisTranscoderFormat) {\n      const images \x3d basisTexture.getNumImages();\n      const levels \x3d basisTexture.getNumLevels(0);\n      const success \x3d basisTexture.startTranscoding();\n      if (!success) {\n        throw new Error("startTranscoding failed");\n      }\n      const levelBuffers \x3d [];\n      for (let levelIndex \x3d 0; levelIndex \x3c levels; ++levelIndex) {\n        for (let sliceIndex \x3d 0; sliceIndex \x3c images; ++sliceIndex) {\n          const transcodeSize \x3d basisTexture.getImageTranscodedSizeInBytes(sliceIndex, levelIndex, basisTranscoderFormat);\n          const levelBuffer \x3d new Uint8Array(transcodeSize);\n          const success2 \x3d basisTexture.transcodeImage(levelBuffer, sliceIndex, levelIndex, basisTranscoderFormat, 1, 0);\n          if (!success2) {\n            throw new Error("transcodeImage failed");\n          }\n          levelBuffers.push(levelBuffer);\n        }\n      }\n      return levelBuffers;\n    }\n\n    const gpuFormatToBasisTranscoderFormatMap \x3d {\n      "bc3-rgba-unorm": 3,\n      // cTFBC3_RGBA\n      "bc7-rgba-unorm": 6,\n      // cTFBC7_RGBA,\n      "etc2-rgba8unorm": 1,\n      // cTFETC2_RGBA,\n      "astc-4x4-unorm": 10,\n      // cTFASTC_4x4_RGBA,\n      // Uncompressed\n      rgba8unorm: 13,\n      // cTFRGBA32,\n      rgba4unorm: 16\n      // cTFRGBA4444,\n    };\n    function gpuFormatToBasisTranscoderFormat(transcoderFormat) {\n      const format \x3d gpuFormatToBasisTranscoderFormatMap[transcoderFormat];\n      if (format) {\n        return format;\n      }\n      throw new Error(`Unsupported transcoderFormat: ${transcoderFormat}`);\n    }\n\n    const settings \x3d {\n      jsUrl: "basis/basis_transcoder.js",\n      wasmUrl: "basis/basis_transcoder.wasm"\n    };\n    let basisTranscoderFormat;\n    let basisTranscodedTextureFormat;\n    let basisPromise;\n    async function getBasis() {\n      if (!basisPromise) {\n        const absoluteJsUrl \x3d new URL(settings.jsUrl, location.origin).href;\n        const absoluteWasmUrl \x3d new URL(settings.wasmUrl, location.origin).href;\n        importScripts(absoluteJsUrl);\n        basisPromise \x3d new Promise((resolve) \x3d\x3e {\n          BASIS({\n            locateFile: (_file) \x3d\x3e absoluteWasmUrl\n          }).then((module) \x3d\x3e {\n            module.initializeBasis();\n            resolve(module.BasisFile);\n          });\n        });\n      }\n      return basisPromise;\n    }\n    async function fetchBasisTexture(url, BasisTexture) {\n      const basisResponse \x3d await fetch(url);\n      if (basisResponse.ok) {\n        const basisArrayBuffer \x3d await basisResponse.arrayBuffer();\n        return new BasisTexture(new Uint8Array(basisArrayBuffer));\n      }\n      throw new Error(`Failed to load Basis texture: ${url}`);\n    }\n    const preferredTranscodedFormat \x3d [\n      "bc7-rgba-unorm",\n      "astc-4x4-unorm",\n      "etc2-rgba8unorm",\n      "bc3-rgba-unorm",\n      "rgba8unorm"\n    ];\n    async function load(url) {\n      const BasisTexture \x3d await getBasis();\n      const basisTexture \x3d await fetchBasisTexture(url, BasisTexture);\n      const levelBuffers \x3d createLevelBuffers(basisTexture, basisTranscoderFormat);\n      return {\n        width: basisTexture.getImageWidth(0, 0),\n        height: basisTexture.getImageHeight(0, 0),\n        format: basisTranscodedTextureFormat,\n        resource: levelBuffers,\n        alphaMode: "no-premultiply-alpha"\n      };\n    }\n    async function init(jsUrl, wasmUrl, supportedTextures) {\n      if (jsUrl)\n        settings.jsUrl \x3d jsUrl;\n      if (wasmUrl)\n        settings.wasmUrl \x3d wasmUrl;\n      basisTranscodedTextureFormat \x3d preferredTranscodedFormat.filter((format) \x3d\x3e supportedTextures.includes(format))[0];\n      basisTranscoderFormat \x3d gpuFormatToBasisTranscoderFormat(basisTranscodedTextureFormat);\n      await getBasis();\n    }\n    const messageHandlers \x3d {\n      init: async (data) \x3d\x3e {\n        const { jsUrl, wasmUrl, supportedTextures } \x3d data;\n        await init(jsUrl, wasmUrl, supportedTextures);\n      },\n      load: async (data) \x3d\x3e {\n        try {\n          const textureOptions \x3d await load(data.url);\n          return {\n            type: "load",\n            url: data.url,\n            success: true,\n            textureOptions,\n            transferables: textureOptions.resource?.map((arr) \x3d\x3e arr.buffer)\n          };\n        } catch (e) {\n          throw e;\n        }\n      }\n    };\n    self.onmessage \x3d async (messageEvent) \x3d\x3e {\n      const message \x3d messageEvent.data;\n      const response \x3d await messageHandlers[message.type](message);\n      if (response) {\n        self.postMessage(response, response.transferables);\n      }\n    };\n\n})();\n'], 
      {type:"application/javascript"})));
      this.worker = new Worker(WORKER_URL);
    }
  }
  WorkerInstance.revokeObjectURL = function() {
    WORKER_URL && (URL.revokeObjectURL(WORKER_URL), WORKER_URL = null);
  };
  exports.default = WorkerInstance;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$_virtual$basis_worker.js.map
