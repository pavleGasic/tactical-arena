shadow$provide.module$node_modules$pixi_DOT_js$lib$assets$loader$Loader = function(global, require, module, exports) {
  var warn = require("module$node_modules$pixi_DOT_js$lib$utils$logging$warn"), path = require("module$node_modules$pixi_DOT_js$lib$utils$path"), convertToList = require("module$node_modules$pixi_DOT_js$lib$assets$utils$convertToList"), isSingleItem = require("module$node_modules$pixi_DOT_js$lib$assets$utils$isSingleItem");
  "use strict";
  class Loader {
    constructor() {
      this._parsers = [];
      this._parsersValidated = !1;
      this.parsers = new Proxy(this._parsers, {set:(target, key, value) => {
        this._parsersValidated = !1;
        target[key] = value;
        return !0;
      }});
      this.promiseCache = {};
    }
    reset() {
      this._parsersValidated = !1;
      this.promiseCache = {};
    }
    _getLoadPromiseAndParser(url, data) {
      const result = {promise:null, parser:null};
      result.promise = (async() => {
        var asset, parser = null;
        data.loadParser && ((parser = this._parserHash[data.loadParser]) || warn.warn(`[Assets] specified load parser "${data.loadParser}" not found while loading ${url}`));
        if (!parser) {
          for (asset = 0; asset < this.parsers.length; asset++) {
            var parserX = this.parsers[asset];
            if (parserX.load && parserX.test?.(url, data, this)) {
              parser = parserX;
              break;
            }
          }
          if (!parser) {
            return warn.warn(`[Assets] ${url} could not be loaded as we don't know how to parse it, ensure the correct parser has been added`), null;
          }
        }
        asset = await parser.load(url, data, this);
        result.parser = parser;
        for (parser = 0; parser < this.parsers.length; parser++) {
          parserX = this.parsers[parser], parserX.parse && parserX.parse && await parserX.testParse?.(asset, data, this) && (asset = await parserX.parse(asset, data, this) || asset, result.parser = parserX);
        }
        return asset;
      })();
      return result;
    }
    async load(assetsToLoadIn, onProgress) {
      this._parsersValidated || this._validateParsers();
      let count = 0;
      const assets = {}, singleAsset = isSingleItem.isSingleItem(assetsToLoadIn);
      assetsToLoadIn = convertToList.convertToList(assetsToLoadIn, item => ({alias:[item], src:item, data:{}}));
      const total = assetsToLoadIn.length, promises = assetsToLoadIn.map(async asset => {
        const url = path.path.toAbsolute(asset.src);
        if (!assets[asset.src]) {
          try {
            this.promiseCache[url] || (this.promiseCache[url] = this._getLoadPromiseAndParser(url, asset)), assets[asset.src] = await this.promiseCache[url].promise, onProgress && onProgress(++count / total);
          } catch (e) {
            throw delete this.promiseCache[url], delete assets[asset.src], Error(`[Loader.load] Failed to load ${url}.
${e}`);
          }
        }
      });
      await Promise.all(promises);
      return singleAsset ? assets[assetsToLoadIn[0].src] : assets;
    }
    async unload(assetsToUnloadIn) {
      assetsToUnloadIn = convertToList.convertToList(assetsToUnloadIn, item => ({alias:[item], src:item})).map(async asset => {
        const url = path.path.toAbsolute(asset.src), loadPromise = this.promiseCache[url];
        if (loadPromise) {
          const loadedAsset = await loadPromise.promise;
          delete this.promiseCache[url];
          await loadPromise.parser?.unload?.(loadedAsset, asset, this);
        }
      });
      await Promise.all(assetsToUnloadIn);
    }
    _validateParsers() {
      this._parsersValidated = !0;
      this._parserHash = this._parsers.filter(parser => parser.name).reduce((hash, parser) => {
        parser.name ? hash[parser.name] && warn.warn(`[Assets] loadParser name conflict "${parser.name}"`) : warn.warn("[Assets] loadParser should have a name");
        return {...hash, [parser.name]:parser};
      }, {});
    }
  }
  exports.Loader = Loader;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$assets$loader$Loader.js.map
