shadow$provide.module$node_modules$pixi_DOT_js$lib$assets$resolver$Resolver = function(global, require, module, exports) {
  function getUrlExtension(url) {
    return url.split(".").pop().split("?").shift().split("#").shift();
  }
  var warn = require("module$node_modules$pixi_DOT_js$lib$utils$logging$warn"), path = require("module$node_modules$pixi_DOT_js$lib$utils$path"), convertToList = require("module$node_modules$pixi_DOT_js$lib$assets$utils$convertToList"), createStringVariations = require("module$node_modules$pixi_DOT_js$lib$assets$utils$createStringVariations"), isSingleItem = require("module$node_modules$pixi_DOT_js$lib$assets$utils$isSingleItem");
  "use strict";
  class Resolver {
    constructor() {
      this._defaultBundleIdentifierOptions = {connector:"-", createBundleAssetId:(bundleId, assetId) => `${bundleId}${this._bundleIdConnector}${assetId}`, extractAssetIdFromBundle:(bundleId, assetBundleId) => assetBundleId.replace(`${bundleId}${this._bundleIdConnector}`, "")};
      this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector;
      this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId;
      this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle;
      this._assetMap = {};
      this._preferredOrder = [];
      this._parsers = [];
      this._resolverHash = {};
      this._bundles = {};
    }
    setBundleIdentifier(bundleIdentifier) {
      this._bundleIdConnector = bundleIdentifier.connector ?? this._bundleIdConnector;
      this._createBundleAssetId = bundleIdentifier.createBundleAssetId ?? this._createBundleAssetId;
      this._extractAssetIdFromBundle = bundleIdentifier.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle;
      if ("bar" !== this._extractAssetIdFromBundle("foo", this._createBundleAssetId("foo", "bar"))) {
        throw Error("[Resolver] GenerateBundleAssetId are not working correctly");
      }
    }
    prefer(...preferOrders) {
      preferOrders.forEach(prefer => {
        this._preferredOrder.push(prefer);
        prefer.priority || (prefer.priority = Object.keys(prefer.params));
      });
      this._resolverHash = {};
    }
    set basePath(basePath) {
      this._basePath = basePath;
    }
    get basePath() {
      return this._basePath;
    }
    set rootPath(rootPath) {
      this._rootPath = rootPath;
    }
    get rootPath() {
      return this._rootPath;
    }
    get parsers() {
      return this._parsers;
    }
    reset() {
      this.setBundleIdentifier(this._defaultBundleIdentifierOptions);
      this._assetMap = {};
      this._preferredOrder = [];
      this._resolverHash = {};
      this._manifest = this._basePath = this._rootPath = null;
      this._bundles = {};
      this._defaultSearchParams = null;
    }
    setDefaultSearchParams(searchParams) {
      this._defaultSearchParams = "string" === typeof searchParams ? searchParams : Object.keys(searchParams).map(key => `${encodeURIComponent(key)}=${encodeURIComponent(searchParams[key])}`).join("\x26");
    }
    getAlias(asset) {
      const {alias, src} = asset;
      return convertToList.convertToList(alias || src, value => "string" === typeof value ? value : Array.isArray(value) ? value.map(v => v?.src ?? v) : value?.src ? value.src : value, !0);
    }
    addManifest(manifest) {
      this._manifest && warn.warn("[Resolver] Manifest already exists, this will be overwritten");
      this._manifest = manifest;
      manifest.bundles.forEach(bundle => {
        this.addBundle(bundle.name, bundle.assets);
      });
    }
    addBundle(bundleId, assets) {
      const assetNames = [];
      let convertedAssets = assets;
      Array.isArray(assets) || (convertedAssets = Object.entries(assets).map(([alias, src]) => "string" === typeof src || Array.isArray(src) ? {alias, src} : {alias, ...src}));
      convertedAssets.forEach(asset => {
        const srcs = asset.src;
        var aliases = asset.alias;
        if ("string" === typeof aliases) {
          var bundleAssetId = this._createBundleAssetId(bundleId, aliases);
          assetNames.push(bundleAssetId);
          aliases = [aliases, bundleAssetId];
        } else {
          bundleAssetId = aliases.map(name => this._createBundleAssetId(bundleId, name)), assetNames.push(...bundleAssetId), aliases = [...aliases, ...bundleAssetId];
        }
        this.add({...asset, alias:aliases, src:srcs});
      });
      this._bundles[bundleId] = assetNames;
    }
    add(aliases) {
      const assets = [];
      Array.isArray(aliases) ? assets.push(...aliases) : assets.push(aliases);
      let keyCheck;
      keyCheck = key => {
        this.hasKey(key) && warn.warn(`[Resolver] already has key: ${key} overwriting`);
      };
      convertToList.convertToList(assets).forEach(asset => {
        var {src} = asset;
        let {data, format, loadParser} = asset;
        src = convertToList.convertToList(src).map(src2 => "string" === typeof src2 ? createStringVariations.createStringVariations(src2) : Array.isArray(src2) ? src2 : [src2]);
        const aliasesToUse = this.getAlias(asset);
        Array.isArray(aliasesToUse) ? aliasesToUse.forEach(keyCheck) : keyCheck(aliasesToUse);
        const resolvedAssets = [];
        src.forEach(srcs => {
          srcs.forEach(src2 => {
            let formattedAsset = {};
            if ("object" !== typeof src2) {
              formattedAsset.src = src2;
              for (let i = 0; i < this._parsers.length; i++) {
                const parser = this._parsers[i];
                if (parser.test(src2)) {
                  formattedAsset = parser.parse(src2);
                  break;
                }
              }
            } else {
              data = src2.data ?? data, format = src2.format ?? format, loadParser = src2.loadParser ?? loadParser, formattedAsset = {...formattedAsset, ...src2};
            }
            if (!aliasesToUse) {
              throw Error(`[Resolver] alias is undefined for this asset: ${formattedAsset.src}`);
            }
            formattedAsset = this._buildResolvedAsset(formattedAsset, {aliases:aliasesToUse, data, format, loadParser});
            resolvedAssets.push(formattedAsset);
          });
        });
        aliasesToUse.forEach(alias => {
          this._assetMap[alias] = resolvedAssets;
        });
      });
    }
    resolveBundle(bundleIds) {
      const singleAsset = isSingleItem.isSingleItem(bundleIds);
      bundleIds = convertToList.convertToList(bundleIds);
      const out = {};
      bundleIds.forEach(bundleId => {
        var assetNames = this._bundles[bundleId];
        if (assetNames) {
          assetNames = this.resolve(assetNames);
          const assets = {};
          for (const key in assetNames) {
            const asset = assetNames[key];
            assets[this._extractAssetIdFromBundle(bundleId, key)] = asset;
          }
          out[bundleId] = assets;
        }
      });
      return singleAsset ? out[bundleIds[0]] : out;
    }
    resolveUrl(key) {
      const result = this.resolve(key);
      if ("string" !== typeof key) {
        key = {};
        for (const i in result) {
          key[i] = result[i].src;
        }
        return key;
      }
      return result.src;
    }
    resolve(keys) {
      const singleAsset = isSingleItem.isSingleItem(keys);
      keys = convertToList.convertToList(keys);
      const result = {};
      keys.forEach(key => {
        if (!this._resolverHash[key]) {
          if (this._assetMap[key]) {
            let assets = this._assetMap[key];
            const preferredOrder = this._getPreferredOrder(assets);
            preferredOrder?.priority.forEach(priorityKey => {
              preferredOrder.params[priorityKey].forEach(value => {
                const filteredAssets = assets.filter(asset => asset[priorityKey] ? asset[priorityKey] === value : !1);
                filteredAssets.length && (assets = filteredAssets);
              });
            });
            this._resolverHash[key] = assets[0];
          } else {
            this._resolverHash[key] = this._buildResolvedAsset({alias:[key], src:key}, {});
          }
        }
        result[key] = this._resolverHash[key];
      });
      return singleAsset ? result[keys[0]] : result;
    }
    hasKey(key) {
      return !!this._assetMap[key];
    }
    hasBundle(key) {
      return !!this._bundles[key];
    }
    _getPreferredOrder(assets) {
      for (let i = 0; i < assets.length; i++) {
        const asset = assets[i], preferred = this._preferredOrder.find(preference => preference.params.format.includes(asset.format));
        if (preferred) {
          return preferred;
        }
      }
      return this._preferredOrder[0];
    }
    _appendDefaultSearchParams(url) {
      if (!this._defaultSearchParams) {
        return url;
      }
      const paramConnector = /\?/.test(url) ? "\x26" : "?";
      return `${url}${paramConnector}${this._defaultSearchParams}`;
    }
    _buildResolvedAsset(formattedAsset, data) {
      const {aliases, data:assetData, loadParser, format} = data;
      if (this._basePath || this._rootPath) {
        formattedAsset.src = path.path.toAbsolute(formattedAsset.src, this._basePath, this._rootPath);
      }
      formattedAsset.alias = aliases ?? formattedAsset.alias ?? [formattedAsset.src];
      formattedAsset.src = this._appendDefaultSearchParams(formattedAsset.src);
      formattedAsset.data = {...(assetData || {}), ...formattedAsset.data};
      formattedAsset.loadParser = loadParser ?? formattedAsset.loadParser;
      formattedAsset.format = format ?? formattedAsset.format ?? getUrlExtension(formattedAsset.src);
      return formattedAsset;
    }
  }
  Resolver.RETINA_PREFIX = /@([0-9\.]+)x/;
  exports.Resolver = Resolver;
  exports.getUrlExtension = getUrlExtension;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$assets$resolver$Resolver.js.map
