shadow$provide.module$node_modules$pixi_DOT_js$lib$scene$sprite_tiling$TilingSpritePipe = function(global, require, module, exports) {
  global = require("module$node_modules$pixi_DOT_js$lib$extensions$Extensions");
  var getAdjustedBlendModeBlend = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$state$getAdjustedBlendModeBlend"), State = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$state$State"), types = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$types"), colorToUniform = require("module$node_modules$pixi_DOT_js$lib$scene$graphics$gpu$colorToUniform"), BatchableMesh = require("module$node_modules$pixi_DOT_js$lib$scene$mesh$shared$BatchableMesh"), 
  MeshGeometry = require("module$node_modules$pixi_DOT_js$lib$scene$mesh$shared$MeshGeometry"), TilingSpriteShader = require("module$node_modules$pixi_DOT_js$lib$scene$sprite_tiling$shader$TilingSpriteShader");
  module = require("module$node_modules$pixi_DOT_js$lib$scene$sprite_tiling$utils$QuadGeometry");
  var setPositions = require("module$node_modules$pixi_DOT_js$lib$scene$sprite_tiling$utils$setPositions"), setUvs = require("module$node_modules$pixi_DOT_js$lib$scene$sprite_tiling$utils$setUvs");
  "use strict";
  const sharedQuad = new module.QuadGeometry();
  class TilingSpritePipe {
    constructor(renderer) {
      this._state = State.State.default2d;
      this._tilingSpriteDataHash = Object.create(null);
      this._destroyRenderableBound = this.destroyRenderable.bind(this);
      this._renderer = renderer;
      this._renderer.renderableGC.addManagedHash(this, "_tilingSpriteDataHash");
    }
    validateRenderable(renderable) {
      var tilingSpriteData = this._getTilingSpriteData(renderable);
      const couldBatch = tilingSpriteData.canBatch;
      this._updateCanBatch(renderable);
      const canBatch = tilingSpriteData.canBatch;
      return canBatch && canBatch === couldBatch ? ({batchableMesh:tilingSpriteData} = tilingSpriteData, !tilingSpriteData._batcher.checkAndUpdateTexture(tilingSpriteData, renderable.texture)) : couldBatch !== canBatch;
    }
    addRenderable(tilingSprite, instructionSet) {
      const batcher = this._renderer.renderPipes.batch;
      this._updateCanBatch(tilingSprite);
      var tilingSpriteData = this._getTilingSpriteData(tilingSprite);
      const {geometry, canBatch} = tilingSpriteData;
      canBatch ? (tilingSpriteData.batchableMesh || (tilingSpriteData.batchableMesh = new BatchableMesh.BatchableMesh()), tilingSpriteData = tilingSpriteData.batchableMesh, tilingSprite.didViewUpdate && (this._updateBatchableMesh(tilingSprite), tilingSpriteData.geometry = geometry, tilingSpriteData.renderable = tilingSprite, tilingSpriteData.transform = tilingSprite.groupTransform, tilingSpriteData.setTexture(tilingSprite._texture)), tilingSpriteData.roundPixels = this._renderer._roundPixels | tilingSprite._roundPixels, 
      batcher.addToBatch(tilingSpriteData, instructionSet)) : (batcher.break(instructionSet), tilingSpriteData.shader || (tilingSpriteData.shader = new TilingSpriteShader.TilingSpriteShader()), this.updateRenderable(tilingSprite), instructionSet.add(tilingSprite));
    }
    execute(tilingSprite) {
      const {shader} = this._tilingSpriteDataHash[tilingSprite.uid];
      shader.groups[0] = this._renderer.globalUniforms.bindGroup;
      const localUniforms = shader.resources.localUniforms.uniforms;
      localUniforms.uTransformMatrix = tilingSprite.groupTransform;
      localUniforms.uRound = this._renderer._roundPixels | tilingSprite._roundPixels;
      colorToUniform.color32BitToUniform(tilingSprite.groupColorAlpha, localUniforms.uColor, 0);
      this._state.blendMode = getAdjustedBlendModeBlend.getAdjustedBlendModeBlend(tilingSprite.groupBlendMode, tilingSprite.texture._source);
      this._renderer.encoder.draw({geometry:sharedQuad, shader, state:this._state});
    }
    updateRenderable(tilingSprite) {
      var tilingSpriteData = this._getTilingSpriteData(tilingSprite);
      const {canBatch} = tilingSpriteData;
      canBatch ? ({batchableMesh:tilingSpriteData} = tilingSpriteData, tilingSprite.didViewUpdate && this._updateBatchableMesh(tilingSprite), tilingSpriteData._batcher.updateElement(tilingSpriteData)) : tilingSprite.didViewUpdate && ({shader:tilingSpriteData} = tilingSpriteData, tilingSpriteData.updateUniforms(tilingSprite.width, tilingSprite.height, tilingSprite._tileTransform.matrix, tilingSprite.anchor.x, tilingSprite.anchor.y, tilingSprite.texture));
    }
    destroyRenderable(tilingSprite) {
      const tilingSpriteData = this._getTilingSpriteData(tilingSprite);
      tilingSpriteData.batchableMesh = null;
      tilingSpriteData.shader?.destroy();
      this._tilingSpriteDataHash[tilingSprite.uid] = null;
      tilingSprite.off("destroyed", this._destroyRenderableBound);
    }
    _getTilingSpriteData(renderable) {
      return this._tilingSpriteDataHash[renderable.uid] || this._initTilingSpriteData(renderable);
    }
    _initTilingSpriteData(tilingSprite) {
      const geometry = new MeshGeometry.MeshGeometry({indices:sharedQuad.indices, positions:sharedQuad.positions.slice(), uvs:sharedQuad.uvs.slice()});
      this._tilingSpriteDataHash[tilingSprite.uid] = {canBatch:!0, renderable:tilingSprite, geometry};
      tilingSprite.on("destroyed", this._destroyRenderableBound);
      return this._tilingSpriteDataHash[tilingSprite.uid];
    }
    _updateBatchableMesh(tilingSprite) {
      var renderableData = this._getTilingSpriteData(tilingSprite);
      ({geometry:renderableData} = renderableData);
      const style = tilingSprite.texture.source.style;
      "repeat" !== style.addressMode && (style.addressMode = "repeat", style.update());
      setUvs.setUvs(tilingSprite, renderableData.uvs);
      setPositions.setPositions(tilingSprite, renderableData.positions);
    }
    destroy() {
      for (const i in this._tilingSpriteDataHash) {
        this.destroyRenderable(this._tilingSpriteDataHash[i].renderable);
      }
      this._renderer = this._tilingSpriteDataHash = null;
    }
    _updateCanBatch(tilingSprite) {
      const renderableData = this._getTilingSpriteData(tilingSprite);
      tilingSprite = tilingSprite.texture;
      let _nonPowOf2wrapping = !0;
      this._renderer.type === types.RendererType.WEBGL && (_nonPowOf2wrapping = this._renderer.context.supports.nonPowOf2wrapping);
      renderableData.canBatch = tilingSprite.textureMatrix.isSimple && (_nonPowOf2wrapping || tilingSprite.source.isPowerOfTwo);
      return renderableData.canBatch;
    }
  }
  TilingSpritePipe.extension = {type:[global.ExtensionType.WebGLPipes, global.ExtensionType.WebGPUPipes, global.ExtensionType.CanvasPipes], name:"tilingSprite"};
  exports.TilingSpritePipe = TilingSpritePipe;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$scene$sprite_tiling$TilingSpritePipe.js.map
