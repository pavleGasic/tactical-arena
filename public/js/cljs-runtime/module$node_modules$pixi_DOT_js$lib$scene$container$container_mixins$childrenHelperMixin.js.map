{
"version":3,
"file":"module$node_modules$pixi_DOT_js$lib$scene$container$container_mixins$childrenHelperMixin.js",
"lineCount":98,
"mappings":"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",
"sources":["node_modules/pixi_DOT_js/lib/scene/container/container-mixins/childrenHelperMixin.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$pixi_DOT_js$lib$scene$container$container_mixins$childrenHelperMixin\"] = function(global,require,module,exports) {\n'use strict';\n\nvar removeItems = require('../../../utils/data/removeItems.js');\nvar deprecation = require('../../../utils/logging/deprecation.js');\n\n\"use strict\";\nconst childrenHelperMixin = {\n  allowChildren: true,\n  /**\n   * Removes all children from this container that are within the begin and end indexes.\n   * @param beginIndex - The beginning position.\n   * @param endIndex - The ending position. Default value is size of the container.\n   * @returns - List of removed children\n   * @memberof scene.Container#\n   */\n  removeChildren(beginIndex = 0, endIndex) {\n    const end = endIndex ?? this.children.length;\n    const range = end - beginIndex;\n    const removed = [];\n    if (range > 0 && range <= end) {\n      for (let i = end - 1; i >= beginIndex; i--) {\n        const child = this.children[i];\n        if (!child)\n          continue;\n        removed.push(child);\n        child.parent = null;\n      }\n      removeItems.removeItems(this.children, beginIndex, end);\n      const renderGroup = this.renderGroup || this.parentRenderGroup;\n      if (renderGroup) {\n        renderGroup.removeChildren(removed);\n      }\n      for (let i = 0; i < removed.length; ++i) {\n        const child = removed[i];\n        child.parentRenderLayer?.detach(child);\n        this.emit(\"childRemoved\", child, this, i);\n        removed[i].emit(\"removed\", this);\n      }\n      if (removed.length > 0) {\n        this._didViewChangeTick++;\n      }\n      return removed;\n    } else if (range === 0 && this.children.length === 0) {\n      return removed;\n    }\n    throw new RangeError(\"removeChildren: numeric values are outside the acceptable range.\");\n  },\n  /**\n   * Removes a child from the specified index position.\n   * @param index - The index to get the child from\n   * @returns The child that was removed.\n   * @memberof scene.Container#\n   */\n  removeChildAt(index) {\n    const child = this.getChildAt(index);\n    return this.removeChild(child);\n  },\n  /**\n   * Returns the child at the specified index\n   * @param index - The index to get the child at\n   * @returns - The child at the given index, if any.\n   * @memberof scene.Container#\n   */\n  getChildAt(index) {\n    if (index < 0 || index >= this.children.length) {\n      throw new Error(`getChildAt: Index (${index}) does not exist.`);\n    }\n    return this.children[index];\n  },\n  /**\n   * Changes the position of an existing child in the container\n   * @param child - The child Container instance for which you want to change the index number\n   * @param index - The resulting index number for the child container\n   * @memberof scene.Container#\n   */\n  setChildIndex(child, index) {\n    if (index < 0 || index >= this.children.length) {\n      throw new Error(`The index ${index} supplied is out of bounds ${this.children.length}`);\n    }\n    this.getChildIndex(child);\n    this.addChildAt(child, index);\n  },\n  /**\n   * Returns the index position of a child Container instance\n   * @param child - The Container instance to identify\n   * @returns - The index position of the child container to identify\n   * @memberof scene.Container#\n   */\n  getChildIndex(child) {\n    const index = this.children.indexOf(child);\n    if (index === -1) {\n      throw new Error(\"The supplied Container must be a child of the caller\");\n    }\n    return index;\n  },\n  /**\n   * Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown.\n   * If the child is already in this container, it will be moved to the specified index.\n   * @param {Container} child - The child to add.\n   * @param {number} index - The absolute index where the child will be positioned at the end of the operation.\n   * @returns {Container} The child that was added.\n   * @memberof scene.Container#\n   */\n  addChildAt(child, index) {\n    if (!this.allowChildren) {\n      deprecation.deprecation(deprecation.v8_0_0, \"addChildAt: Only Containers will be allowed to add children in v8.0.0\");\n    }\n    const { children } = this;\n    if (index < 0 || index > children.length) {\n      throw new Error(`${child}addChildAt: The index ${index} supplied is out of bounds ${children.length}`);\n    }\n    if (child.parent) {\n      const currentIndex = child.parent.children.indexOf(child);\n      if (child.parent === this && currentIndex === index) {\n        return child;\n      }\n      if (currentIndex !== -1) {\n        child.parent.children.splice(currentIndex, 1);\n      }\n    }\n    if (index === children.length) {\n      children.push(child);\n    } else {\n      children.splice(index, 0, child);\n    }\n    child.parent = this;\n    child.didChange = true;\n    child._updateFlags = 15;\n    const renderGroup = this.renderGroup || this.parentRenderGroup;\n    if (renderGroup) {\n      renderGroup.addChild(child);\n    }\n    if (this.sortableChildren)\n      this.sortDirty = true;\n    this.emit(\"childAdded\", child, this, index);\n    child.emit(\"added\", this);\n    return child;\n  },\n  /**\n   * Swaps the position of 2 Containers within this container.\n   * @param child - First container to swap\n   * @param child2 - Second container to swap\n   * @memberof scene.Container#\n   */\n  swapChildren(child, child2) {\n    if (child === child2) {\n      return;\n    }\n    const index1 = this.getChildIndex(child);\n    const index2 = this.getChildIndex(child2);\n    this.children[index1] = child2;\n    this.children[index2] = child;\n    const renderGroup = this.renderGroup || this.parentRenderGroup;\n    if (renderGroup) {\n      renderGroup.structureDidChange = true;\n    }\n    this._didContainerChangeTick++;\n  },\n  /**\n   * Remove the Container from its parent Container. If the Container has no parent, do nothing.\n   * @memberof scene.Container#\n   */\n  removeFromParent() {\n    this.parent?.removeChild(this);\n  },\n  /**\n   * Reparent the child to this container, keeping the same worldTransform.\n   * @param child - The child to reparent\n   * @returns The first child that was reparented.\n   * @memberof scene.Container#\n   */\n  reparentChild(...child) {\n    if (child.length === 1) {\n      return this.reparentChildAt(child[0], this.children.length);\n    }\n    child.forEach((c) => this.reparentChildAt(c, this.children.length));\n    return child[0];\n  },\n  /**\n   * Reparent the child to this container at the specified index, keeping the same worldTransform.\n   * @param child - The child to reparent\n   * @param index - The index to reparent the child to\n   * @memberof scene.Container#\n   */\n  reparentChildAt(child, index) {\n    if (child.parent === this) {\n      this.setChildIndex(child, index);\n      return child;\n    }\n    const childMat = child.worldTransform.clone();\n    child.removeFromParent();\n    this.addChildAt(child, index);\n    const newMatrix = this.worldTransform.clone();\n    newMatrix.invert();\n    childMat.prepend(newMatrix);\n    child.setFromMatrix(childMat);\n    return child;\n  }\n};\n\nexports.childrenHelperMixin = childrenHelperMixin;\n//# sourceMappingURL=childrenHelperMixin.js.map\n\n};"],
"names":["shadow$provide","global","require","module","exports","removeItems","deprecation","childrenHelperMixin","allowChildren","removeChildren","beginIndex","endIndex","end","children","length","range","removed","i","child","push","parent","renderGroup","parentRenderGroup","parentRenderLayer","detach","emit","_didViewChangeTick","RangeError","removeChildAt","index","getChildAt","removeChild","Error","setChildIndex","getChildIndex","addChildAt","indexOf","v8_0_0","currentIndex","splice","didChange","_updateFlags","addChild","sortableChildren","sortDirty","swapChildren","child2","index1","index2","structureDidChange","_didContainerChangeTick","removeFromParent","reparentChild","reparentChildAt","forEach","c","childMat","worldTransform","clone","newMatrix","invert","prepend","setFromMatrix"]
}
