shadow$provide.module$node_modules$$pixi$mesh_extras$lib$geometry$RopeGeometry = function(global, require, module, exports) {
  global = require("module$node_modules$$pixi$mesh$lib$index");
  class RopeGeometry extends global.MeshGeometry {
    constructor(width = 200, points, textureScale = 0) {
      super(new Float32Array(4 * points.length), new Float32Array(4 * points.length), new Uint16Array(6 * (points.length - 1)));
      this.points = points;
      this._width = width;
      this.textureScale = textureScale;
      this.build();
    }
    get width() {
      return this._width;
    }
    build() {
      var points = this.points;
      if (points) {
        var vertexBuffer = this.getBuffer("aVertexPosition"), uvBuffer = this.getBuffer("aTextureCoord"), indexBuffer = this.getIndex();
        if (!(1 > points.length)) {
          vertexBuffer.data.length / 4 !== points.length && (vertexBuffer.data = new Float32Array(4 * points.length), uvBuffer.data = new Float32Array(4 * points.length), indexBuffer.data = new Uint16Array(6 * (points.length - 1)));
          var uvs = uvBuffer.data;
          vertexBuffer = indexBuffer.data;
          uvs[0] = 0;
          uvs[1] = 0;
          uvs[2] = 0;
          uvs[3] = 1;
          var amount = 0, prev = points[0], textureWidth = this._width * this.textureScale, total = points.length;
          for (let i = 0; i < total; i++) {
            const index = 4 * i;
            if (0 < this.textureScale) {
              var dx = prev.x - points[i].x;
              prev = prev.y - points[i].y;
              dx = Math.sqrt(dx * dx + prev * prev);
              prev = points[i];
              amount += dx / textureWidth;
            } else {
              amount = i / (total - 1);
            }
            uvs[index] = amount;
            uvs[index + 1] = 0;
            uvs[index + 2] = amount;
            uvs[index + 3] = 1;
          }
          points = 0;
          for (uvs = 0; uvs < total - 1; uvs++) {
            amount = 2 * uvs, vertexBuffer[points++] = amount, vertexBuffer[points++] = amount + 1, vertexBuffer[points++] = amount + 2, vertexBuffer[points++] = amount + 2, vertexBuffer[points++] = amount + 1, vertexBuffer[points++] = amount + 3;
          }
          uvBuffer.update();
          indexBuffer.update();
          this.updateVertices();
        }
      }
    }
    updateVertices() {
      const points = this.points;
      if (!(1 > points.length)) {
        var lastPoint = points[0], nextPoint, vertices = this.buffers[0].data, total = points.length, halfWidth = 0 < this.textureScale ? this.textureScale * this._width / 2 : this._width / 2;
        for (let i = 0; i < total; i++) {
          const point = points[i], index = 4 * i;
          i < points.length - 1 ? nextPoint = points[i + 1] : nextPoint = point;
          var perpY = -(nextPoint.x - lastPoint.x);
          lastPoint = nextPoint.y - lastPoint.y;
          const perpLength = Math.sqrt(lastPoint * lastPoint + perpY * perpY);
          1e-6 > perpLength ? (lastPoint = 0, perpY = 0) : (lastPoint /= perpLength, perpY /= perpLength, lastPoint *= halfWidth, perpY *= halfWidth);
          vertices[index] = point.x + lastPoint;
          vertices[index + 1] = point.y + perpY;
          vertices[index + 2] = point.x - lastPoint;
          vertices[index + 3] = point.y - perpY;
          lastPoint = point;
        }
        this.buffers[0].update();
      }
    }
    update() {
      0 < this.textureScale ? this.build() : this.updateVertices();
    }
  }
  exports.RopeGeometry = RopeGeometry;
};

//# sourceMappingURL=module$node_modules$$pixi$mesh_extras$lib$geometry$RopeGeometry.js.map
