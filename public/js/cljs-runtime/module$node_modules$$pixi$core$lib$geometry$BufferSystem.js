shadow$provide.module$node_modules$$pixi$core$lib$geometry$BufferSystem = function(global, require, module, exports) {
  global = require("module$node_modules$$pixi$extensions$lib$index");
  var GLBuffer = require("module$node_modules$$pixi$core$lib$geometry$GLBuffer");
  class BufferSystem {
    constructor(renderer) {
      this.renderer = renderer;
      this.managedBuffers = {};
      this.boundBufferBases = {};
    }
    destroy() {
      this.renderer = null;
    }
    contextChange() {
      this.disposeAll(!0);
      this.gl = this.renderer.gl;
      this.CONTEXT_UID = this.renderer.CONTEXT_UID;
    }
    bind(buffer) {
      const {gl, CONTEXT_UID} = this, glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);
      gl.bindBuffer(buffer.type, glBuffer.buffer);
    }
    unbind(type) {
      const {gl} = this;
      gl.bindBuffer(type, null);
    }
    bindBufferBase(buffer, index) {
      const {gl, CONTEXT_UID} = this;
      if (this.boundBufferBases[index] !== buffer) {
        const glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);
        this.boundBufferBases[index] = buffer;
        gl.bindBufferBase(gl.UNIFORM_BUFFER, index, glBuffer.buffer);
      }
    }
    bindBufferRange(buffer, index, offset) {
      const {gl, CONTEXT_UID} = this;
      offset = offset || 0;
      buffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);
      gl.bindBufferRange(gl.UNIFORM_BUFFER, index || 0, buffer.buffer, 256 * offset, 256);
    }
    update(buffer) {
      const {gl, CONTEXT_UID} = this, glBuffer = buffer._glBuffers[CONTEXT_UID] || this.createGLBuffer(buffer);
      if (buffer._updateID !== glBuffer.updateID) {
        if (glBuffer.updateID = buffer._updateID, gl.bindBuffer(buffer.type, glBuffer.buffer), glBuffer.byteLength >= buffer.data.byteLength) {
          gl.bufferSubData(buffer.type, 0, buffer.data);
        } else {
          const drawType = buffer.static ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW;
          glBuffer.byteLength = buffer.data.byteLength;
          gl.bufferData(buffer.type, buffer.data, drawType);
        }
      }
    }
    dispose(buffer, contextLost) {
      if (this.managedBuffers[buffer.id]) {
        delete this.managedBuffers[buffer.id];
        var glBuffer = buffer._glBuffers[this.CONTEXT_UID], gl = this.gl;
        buffer.disposeRunner.remove(this);
        glBuffer && (contextLost || gl.deleteBuffer(glBuffer.buffer), delete buffer._glBuffers[this.CONTEXT_UID]);
      }
    }
    disposeAll(contextLost) {
      const all = Object.keys(this.managedBuffers);
      for (let i = 0; i < all.length; i++) {
        this.dispose(this.managedBuffers[all[i]], contextLost);
      }
    }
    createGLBuffer(buffer) {
      const {CONTEXT_UID, gl} = this;
      return buffer._glBuffers[CONTEXT_UID] = new GLBuffer.GLBuffer(gl.createBuffer()), this.managedBuffers[buffer.id] = buffer, buffer.disposeRunner.add(this), buffer._glBuffers[CONTEXT_UID];
    }
  }
  BufferSystem.extension = {type:global.ExtensionType.RendererSystem, name:"buffer"};
  global.extensions.add(BufferSystem);
  exports.BufferSystem = BufferSystem;
};

//# sourceMappingURL=module$node_modules$$pixi$core$lib$geometry$BufferSystem.js.map
