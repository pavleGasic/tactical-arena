shadow$provide.module$node_modules$$pixi$core$lib$textures$resources$AbstractMultiResource = function(global, require, module, exports) {
  var BaseTexture = require("module$node_modules$$pixi$core$lib$textures$BaseTexture"), autoDetectResource = require("module$node_modules$$pixi$core$lib$textures$resources$autoDetectResource"), Resource = require("module$node_modules$$pixi$core$lib$textures$resources$Resource");
  class AbstractMultiResource extends Resource.Resource {
    constructor(length, options) {
      const {width, height} = options || {};
      super(width, height);
      this.items = [];
      this.itemDirtyIds = [];
      for (options = 0; options < length; options++) {
        const partTexture = new BaseTexture.BaseTexture();
        this.items.push(partTexture);
        this.itemDirtyIds.push(-2);
      }
      this.length = length;
      this.baseTexture = this._load = null;
    }
    initFromArray(resources, options) {
      for (let i = 0; i < this.length; i++) {
        resources[i] && (resources[i].castToBaseTexture ? this.addBaseTextureAt(resources[i].castToBaseTexture(), i) : resources[i] instanceof Resource.Resource ? this.addResourceAt(resources[i], i) : this.addResourceAt(autoDetectResource.autoDetectResource(resources[i], options), i));
      }
    }
    dispose() {
      for (let i = 0, len = this.length; i < len; i++) {
        this.items[i].destroy();
      }
      this._load = this.itemDirtyIds = this.items = null;
    }
    addResourceAt(resource, index) {
      if (!this.items[index]) {
        throw Error(`Index ${index} is out of bounds`);
      }
      return resource.valid && !this.valid && this.resize(resource.width, resource.height), this.items[index].setResource(resource), this;
    }
    bind(baseTexture) {
      if (null !== this.baseTexture) {
        throw Error("Only one base texture per TextureArray is allowed");
      }
      super.bind(baseTexture);
      for (let i = 0; i < this.length; i++) {
        this.items[i].parentTextureArray = baseTexture, this.items[i].on("update", baseTexture.update, baseTexture);
      }
    }
    unbind(baseTexture) {
      super.unbind(baseTexture);
      for (let i = 0; i < this.length; i++) {
        this.items[i].parentTextureArray = null, this.items[i].off("update", baseTexture.update, baseTexture);
      }
    }
    load() {
      if (this._load) {
        return this._load;
      }
      const promises = this.items.map(item => item.resource).filter(item => item).map(item => item.load());
      return this._load = Promise.all(promises).then(() => {
        const {realWidth, realHeight} = this.items[0];
        return this.resize(realWidth, realHeight), this.update(), Promise.resolve(this);
      }), this._load;
    }
  }
  exports.AbstractMultiResource = AbstractMultiResource;
};

//# sourceMappingURL=module$node_modules$$pixi$core$lib$textures$resources$AbstractMultiResource.js.map
