shadow$provide.module$node_modules$pixi_DOT_js$lib$rendering$renderers$gpu$texture$GpuTextureSystem = function(global, require, module, exports) {
  var adapter = require("module$node_modules$pixi_DOT_js$lib$environment$adapter");
  global = require("module$node_modules$pixi_DOT_js$lib$extensions$Extensions");
  var UniformGroup = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$shader$UniformGroup"), CanvasPool = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$texture$CanvasPool"), BindGroup = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$gpu$shader$BindGroup"), gpuUploadBufferImageResource = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$gpu$texture$uploaders$gpuUploadBufferImageResource"), gpuUploadCompressedTextureResource = 
  require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$gpu$texture$uploaders$gpuUploadCompressedTextureResource"), gpuUploadImageSource = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$gpu$texture$uploaders$gpuUploadImageSource"), gpuUploadVideoSource = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$gpu$texture$uploaders$gpuUploadVideoSource"), GpuMipmapGenerator = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$gpu$texture$utils$GpuMipmapGenerator");
  "use strict";
  class GpuTextureSystem {
    constructor(renderer) {
      this.managedTextures = [];
      this._gpuSources = Object.create(null);
      this._gpuSamplers = Object.create(null);
      this._bindGroupHash = Object.create(null);
      this._textureViewHash = Object.create(null);
      this._uploads = {image:gpuUploadImageSource.gpuUploadImageResource, buffer:gpuUploadBufferImageResource.gpuUploadBufferImageResource, video:gpuUploadVideoSource.gpuUploadVideoResource, compressed:gpuUploadCompressedTextureResource.gpuUploadCompressedTextureResource};
      this._renderer = renderer;
      renderer.renderableGC.addManagedHash(this, "_gpuSources");
      renderer.renderableGC.addManagedHash(this, "_gpuSamplers");
      renderer.renderableGC.addManagedHash(this, "_bindGroupHash");
      renderer.renderableGC.addManagedHash(this, "_textureViewHash");
    }
    contextChange(gpu) {
      this._gpu = gpu;
    }
    initSource(source) {
      source.autoGenerateMipmaps && (source.mipLevelCount = Math.floor(Math.log2(Math.max(source.pixelWidth, source.pixelHeight))) + 1);
      var usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST;
      "compressed" !== source.uploadMethodId && (usage |= GPUTextureUsage.RENDER_ATTACHMENT, usage |= GPUTextureUsage.COPY_SRC);
      const blockData = gpuUploadCompressedTextureResource.blockDataMap[source.format] || {blockBytes:4, blockWidth:1, blockHeight:1};
      usage = this._gpu.device.createTexture({label:source.label, size:{width:Math.ceil(source.pixelWidth / blockData.blockWidth) * blockData.blockWidth, height:Math.ceil(source.pixelHeight / blockData.blockHeight) * blockData.blockHeight}, format:source.format, sampleCount:source.sampleCount, mipLevelCount:source.mipLevelCount, dimension:source.dimension, usage});
      this._gpuSources[source.uid] = usage;
      this.managedTextures.includes(source) || (source.on("update", this.onSourceUpdate, this), source.on("resize", this.onSourceResize, this), source.on("destroy", this.onSourceDestroy, this), source.on("unload", this.onSourceUnload, this), source.on("updateMipmaps", this.onUpdateMipmaps, this), this.managedTextures.push(source));
      this.onSourceUpdate(source);
      return usage;
    }
    onSourceUpdate(source) {
      const gpuTexture = this.getGpuSource(source);
      if (gpuTexture && (this._uploads[source.uploadMethodId] && this._uploads[source.uploadMethodId].upload(source, gpuTexture, this._gpu), source.autoGenerateMipmaps && 1 < source.mipLevelCount)) {
        this.onUpdateMipmaps(source);
      }
    }
    onSourceUnload(source) {
      const gpuTexture = this._gpuSources[source.uid];
      gpuTexture && (this._gpuSources[source.uid] = null, gpuTexture.destroy());
    }
    onUpdateMipmaps(source) {
      this._mipmapGenerator || (this._mipmapGenerator = new GpuMipmapGenerator.GpuMipmapGenerator(this._gpu.device));
      source = this.getGpuSource(source);
      this._mipmapGenerator.generateMipmap(source);
    }
    onSourceDestroy(source) {
      source.off("update", this.onSourceUpdate, this);
      source.off("unload", this.onSourceUnload, this);
      source.off("destroy", this.onSourceDestroy, this);
      source.off("resize", this.onSourceResize, this);
      source.off("updateMipmaps", this.onUpdateMipmaps, this);
      this.managedTextures.splice(this.managedTextures.indexOf(source), 1);
      this.onSourceUnload(source);
    }
    onSourceResize(source) {
      const gpuTexture = this._gpuSources[source.uid];
      if (!gpuTexture) {
        this.initSource(source);
      } else if (gpuTexture.width !== source.pixelWidth || gpuTexture.height !== source.pixelHeight) {
        this._textureViewHash[source.uid] = null, this._bindGroupHash[source.uid] = null, this.onSourceUnload(source), this.initSource(source);
      }
    }
    _initSampler(sampler) {
      this._gpuSamplers[sampler._resourceId] = this._gpu.device.createSampler(sampler);
      return this._gpuSamplers[sampler._resourceId];
    }
    getGpuSampler(sampler) {
      return this._gpuSamplers[sampler._resourceId] || this._initSampler(sampler);
    }
    getGpuSource(source) {
      return this._gpuSources[source.uid] || this.initSource(source);
    }
    getTextureBindGroup(texture) {
      return this._bindGroupHash[texture.uid] ?? this._createTextureBindGroup(texture);
    }
    _createTextureBindGroup(texture) {
      const source = texture.source;
      this._bindGroupHash[texture.uid] = new BindGroup.BindGroup({0:source, 1:source.style, 2:new UniformGroup.UniformGroup({uTextureMatrix:{type:"mat3x3\x3cf32\x3e", value:texture.textureMatrix.mapCoord}})});
      return this._bindGroupHash[texture.uid];
    }
    getTextureView(texture) {
      texture = texture.source;
      return this._textureViewHash[texture.uid] ?? this._createTextureView(texture);
    }
    _createTextureView(texture) {
      this._textureViewHash[texture.uid] = this.getGpuSource(texture).createView();
      return this._textureViewHash[texture.uid];
    }
    generateCanvas(texture) {
      const renderer = this._renderer, commandEncoder = renderer.gpu.device.createCommandEncoder(), canvas = adapter.DOMAdapter.get().createCanvas();
      canvas.width = texture.source.pixelWidth;
      canvas.height = texture.source.pixelHeight;
      const context = canvas.getContext("webgpu");
      context.configure({device:renderer.gpu.device, usage:GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC, format:adapter.DOMAdapter.get().getNavigator().gpu.getPreferredCanvasFormat(), alphaMode:"premultiplied"});
      commandEncoder.copyTextureToTexture({texture:renderer.texture.getGpuSource(texture.source), origin:{x:0, y:0}}, {texture:context.getCurrentTexture()}, {width:canvas.width, height:canvas.height});
      renderer.gpu.device.queue.submit([commandEncoder.finish()]);
      return canvas;
    }
    getPixels(texture) {
      var webGPUCanvas = this.generateCanvas(texture);
      texture = CanvasPool.CanvasPool.getOptimalCanvasAndContext(webGPUCanvas.width, webGPUCanvas.height);
      const context = texture.context;
      context.drawImage(webGPUCanvas, 0, 0);
      const {width, height} = webGPUCanvas;
      webGPUCanvas = context.getImageData(0, 0, width, height);
      webGPUCanvas = new Uint8ClampedArray(webGPUCanvas.data.buffer);
      CanvasPool.CanvasPool.returnCanvasAndContext(texture);
      return {pixels:webGPUCanvas, width, height};
    }
    destroy() {
      this.managedTextures.slice().forEach(source => this.onSourceDestroy(source));
      this.managedTextures = null;
      for (const k of Object.keys(this._bindGroupHash)) {
        const key = Number(k);
        this._bindGroupHash[key]?.destroy();
        this._bindGroupHash[key] = null;
      }
      this._gpuSamplers = this._textureViewHash = this._bindGroupHash = this._gpuSources = this._mipmapGenerator = this._gpu = null;
    }
  }
  GpuTextureSystem.extension = {type:[global.ExtensionType.WebGPUSystem], name:"texture"};
  exports.GpuTextureSystem = GpuTextureSystem;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$rendering$renderers$gpu$texture$GpuTextureSystem.js.map
