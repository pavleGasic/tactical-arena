shadow$provide.module$node_modules$pixi_DOT_js$lib$scene$graphics$shared$utils$generateTextureFillMatrix = function(global, require, module, exports) {
  global = require("module$node_modules$pixi_DOT_js$lib$maths$matrix$Matrix");
  module = require("module$node_modules$pixi_DOT_js$lib$maths$shapes$Rectangle");
  var FillGradient = require("module$node_modules$pixi_DOT_js$lib$scene$graphics$shared$fill$FillGradient");
  "use strict";
  const tempTextureMatrix = new global.Matrix(), tempRect = new module.Rectangle();
  exports.generateTextureMatrix = function(out, style, shape, matrix) {
    out = style.matrix ? out.copyFrom(style.matrix).invert() : out.identity();
    if ("local" === style.textureSpace) {
      var bounds = shape.getBounds(tempRect);
      style.width && bounds.pad(style.width);
      const {x:tx, y:ty} = bounds;
      shape = 1 / bounds.width;
      bounds = 1 / bounds.height;
      const mTx = -tx * shape, mTy = -ty * bounds, a1 = out.a, b1 = out.b, c1 = out.c, d1 = out.d;
      out.a *= shape;
      out.b *= shape;
      out.c *= bounds;
      out.d *= bounds;
      out.tx = mTx * a1 + mTy * c1 + out.tx;
      out.ty = mTx * b1 + mTy * d1 + out.ty;
    } else {
      out.translate(style.texture.frame.x, style.texture.frame.y), out.scale(1 / style.texture.source.width, 1 / style.texture.source.height);
    }
    shape = style.texture.source.style;
    style.fill instanceof FillGradient.FillGradient || "clamp-to-edge" !== shape.addressMode || (shape.addressMode = "repeat", shape.update());
    matrix && out.append(tempTextureMatrix.copyFrom(matrix).invert());
    return out;
  };
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$scene$graphics$shared$utils$generateTextureFillMatrix.js.map
