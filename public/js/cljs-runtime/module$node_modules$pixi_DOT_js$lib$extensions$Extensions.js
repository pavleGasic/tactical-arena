shadow$provide.module$node_modules$pixi_DOT_js$lib$extensions$Extensions = function(global, require, module, exports) {
  var ExtensionType = (ExtensionType2 => {
    ExtensionType2.Application = "application";
    ExtensionType2.WebGLPipes = "webgl-pipes";
    ExtensionType2.WebGLPipesAdaptor = "webgl-pipes-adaptor";
    ExtensionType2.WebGLSystem = "webgl-system";
    ExtensionType2.WebGPUPipes = "webgpu-pipes";
    ExtensionType2.WebGPUPipesAdaptor = "webgpu-pipes-adaptor";
    ExtensionType2.WebGPUSystem = "webgpu-system";
    ExtensionType2.CanvasSystem = "canvas-system";
    ExtensionType2.CanvasPipesAdaptor = "canvas-pipes-adaptor";
    ExtensionType2.CanvasPipes = "canvas-pipes";
    ExtensionType2.Asset = "asset";
    ExtensionType2.LoadParser = "load-parser";
    ExtensionType2.ResolveParser = "resolve-parser";
    ExtensionType2.CacheParser = "cache-parser";
    ExtensionType2.DetectionParser = "detection-parser";
    ExtensionType2.MaskEffect = "mask-effect";
    ExtensionType2.BlendMode = "blend-mode";
    ExtensionType2.TextureSource = "texture-source";
    ExtensionType2.Environment = "environment";
    ExtensionType2.ShapeBuilder = "shape-builder";
    ExtensionType2.Batcher = "batcher";
    return ExtensionType2;
  })(ExtensionType || {});
  const normalizeExtension = ext => {
    if ("function" === typeof ext || "object" === typeof ext && ext.extension) {
      if (!ext.extension) {
        throw Error("Extension class must have an extension object");
      }
      ext = {...("object" !== typeof ext.extension ? {type:ext.extension} : ext.extension), ref:ext};
    }
    if ("object" === typeof ext) {
      ext = {...ext};
    } else {
      throw Error("Invalid extension type");
    }
    "string" === typeof ext.type && (ext.type = [ext.type]);
    return ext;
  }, normalizeExtensionPriority = (ext, defaultPriority) => normalizeExtension(ext).priority ?? defaultPriority;
  exports.ExtensionType = ExtensionType;
  exports.extensions = {_addHandlers:{}, _removeHandlers:{}, _queue:{}, remove(...extensions2) {
    extensions2.map(normalizeExtension).forEach(ext => {
      ext.type.forEach(type => this._removeHandlers[type]?.(ext));
    });
    return this;
  }, add(...extensions2) {
    extensions2.map(normalizeExtension).forEach(ext => {
      ext.type.forEach(type => {
        const handlers = this._addHandlers, queue = this._queue;
        if (handlers[type]) {
          handlers[type]?.(ext);
        } else {
          queue[type] = queue[type] || [], queue[type]?.push(ext);
        }
      });
    });
    return this;
  }, handle(type, onAdd, onRemove) {
    const addHandlers = this._addHandlers, removeHandlers = this._removeHandlers;
    if (addHandlers[type] || removeHandlers[type]) {
      throw Error(`Extension type ${type} already has a handler`);
    }
    addHandlers[type] = onAdd;
    removeHandlers[type] = onRemove;
    onRemove = this._queue;
    onRemove[type] && (onRemove[type]?.forEach(ext => onAdd(ext)), delete onRemove[type]);
    return this;
  }, handleByMap(type, map) {
    return this.handle(type, extension => {
      extension.name && (map[extension.name] = extension.ref);
    }, extension => {
      extension.name && delete map[extension.name];
    });
  }, handleByNamedList(type, map, defaultPriority = -1) {
    return this.handle(type, extension => {
      0 <= map.findIndex(item => item.name === extension.name) || (map.push({name:extension.name, value:extension.ref}), map.sort((a, b) => normalizeExtensionPriority(b.value, defaultPriority) - normalizeExtensionPriority(a.value, defaultPriority)));
    }, extension => {
      const index = map.findIndex(item => item.name === extension.name);
      -1 !== index && map.splice(index, 1);
    });
  }, handleByList(type, list, defaultPriority = -1) {
    return this.handle(type, extension => {
      list.includes(extension.ref) || (list.push(extension.ref), list.sort((a, b) => normalizeExtensionPriority(b, defaultPriority) - normalizeExtensionPriority(a, defaultPriority)));
    }, extension => {
      extension = list.indexOf(extension.ref);
      -1 !== extension && list.splice(extension, 1);
    });
  }, mixin(Target, ...sources) {
    for (const source of sources) {
      Object.defineProperties(Target.prototype, Object.getOwnPropertyDescriptors(source));
    }
  }};
  exports.normalizeExtensionPriority = normalizeExtensionPriority;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$extensions$Extensions.js.map
