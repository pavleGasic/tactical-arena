shadow$provide.module$node_modules$pixi_DOT_js$lib$scene$graphics$shared$path$roundShape = function(global, require, module, exports) {
  exports.roundedShapeArc = function(g, points, radius) {
    const vecFrom = (p, pp) => {
      const x = pp.x - p.x;
      p = pp.y - p.y;
      pp = Math.sqrt(x * x + p * p);
      return {len:pp, nx:x / pp, ny:p / pp};
    };
    var p1 = points[points.length - 1];
    for (let i = 0; i < points.length; i++) {
      const p2 = points[i % points.length];
      var pRadius = p2.radius ?? radius;
      if (0 >= pRadius) {
        0 === i ? g.moveTo(p2.x, p2.y) : g.lineTo(p2.x, p2.y);
        p1 = p2;
        continue;
      }
      var p3 = points[(i + 1) % points.length];
      p1 = vecFrom(p2, p1);
      var v2 = vecFrom(p2, p3);
      if (1e-4 > p1.len || 1e-4 > v2.len) {
        0 === i ? g.moveTo(p2.x, p2.y) : g.lineTo(p2.x, p2.y);
        p1 = p2;
        continue;
      }
      var angle = Math.asin(p1.nx * v2.ny - p1.ny * v2.nx);
      let radDirection = 1;
      p3 = !1;
      0 > p1.nx * v2.nx - p1.ny * -v2.ny ? 0 > angle ? angle = Math.PI + angle : (angle = Math.PI - angle, radDirection = -1, p3 = !0) : 0 < angle && (radDirection = -1, p3 = !0);
      angle /= 2;
      var lenOut = Math.abs(Math.cos(angle) * pRadius / Math.sin(angle));
      lenOut > Math.min(p1.len / 2, v2.len / 2) && (lenOut = Math.min(p1.len / 2, v2.len / 2), pRadius = Math.abs(lenOut * Math.sin(angle) / Math.cos(angle)));
      angle = p2.x + v2.nx * lenOut + -v2.ny * pRadius * radDirection;
      lenOut = p2.y + v2.ny * lenOut + v2.nx * pRadius * radDirection;
      p1 = Math.atan2(p1.ny, p1.nx) + Math.PI / 2 * radDirection;
      v2 = Math.atan2(v2.ny, v2.nx) - Math.PI / 2 * radDirection;
      0 === i && g.moveTo(angle + Math.cos(p1) * pRadius, lenOut + Math.sin(p1) * pRadius);
      g.arc(angle, lenOut, pRadius, p1, v2, p3);
      p1 = p2;
    }
  };
  exports.roundedShapeQuadraticCurve = function(g, points, radius, smoothness) {
    const pointLerp = (p1, p2, t) => ({x:p1.x + (p2.x - p1.x) * t, y:p1.y + (p2.y - p1.y) * t}), numPoints = points.length;
    for (let i = 0; i < numPoints; i++) {
      const thisPoint = points[(i + 1) % numPoints];
      var pRadius = thisPoint.radius ?? radius;
      if (0 >= pRadius) {
        0 === i ? g.moveTo(thisPoint.x, thisPoint.y) : g.lineTo(thisPoint.x, thisPoint.y);
        continue;
      }
      var lastPoint = points[i];
      const nextPoint = points[(i + 2) % numPoints];
      var lastEdgeLength = Math.sqrt((lastPoint.x - thisPoint.x) ** 2 + (lastPoint.y - thisPoint.y) ** 2);
      lastPoint = 1e-4 > lastEdgeLength ? thisPoint : pointLerp(thisPoint, lastPoint, Math.min(lastEdgeLength / 2, pRadius) / lastEdgeLength);
      lastEdgeLength = Math.sqrt((nextPoint.x - thisPoint.x) ** 2 + (nextPoint.y - thisPoint.y) ** 2);
      pRadius = 1e-4 > lastEdgeLength ? thisPoint : pointLerp(thisPoint, nextPoint, Math.min(lastEdgeLength / 2, pRadius) / lastEdgeLength);
      0 === i ? g.moveTo(lastPoint.x, lastPoint.y) : g.lineTo(lastPoint.x, lastPoint.y);
      g.quadraticCurveTo(thisPoint.x, thisPoint.y, pRadius.x, pRadius.y, smoothness);
    }
  };
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$scene$graphics$shared$path$roundShape.js.map
