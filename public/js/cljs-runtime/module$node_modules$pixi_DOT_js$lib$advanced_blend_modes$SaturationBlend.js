shadow$provide.module$node_modules$pixi_DOT_js$lib$advanced_blend_modes$SaturationBlend = function(global, require, module, exports) {
  global = require("module$node_modules$pixi_DOT_js$lib$extensions$Extensions");
  module = require("module$node_modules$pixi_DOT_js$lib$filters$blend_modes$BlendModeFilter");
  var GLhls = require("module$node_modules$pixi_DOT_js$lib$filters$blend_modes$hls$GLhls"), GPUhls = require("module$node_modules$pixi_DOT_js$lib$filters$blend_modes$hls$GPUhls");
  "use strict";
  class SaturationBlend extends module.BlendModeFilter {
    constructor() {
      super({gl:{functions:`
                ${GLhls.hslgl}

                vec3 blendSaturation(vec3 base, vec3 blend,  float opacity)
                {
                    vec3 blendSaturation = setLuminosity(setSaturation(base, getSaturation(blend)), getLuminosity(base));
                    return (blendSaturation * opacity + base * (1.0 - opacity));
                }
            `, main:"\n                finalColor \x3d vec4(blendSaturation(back.rgb, front.rgb, front.a), blendedAlpha) * uBlend;\n            "}, gpu:{functions:`
                ${GPUhls.hslgpu}

                fn blendSaturation(base:vec3<f32>,  blend:vec3<f32>,  opacity:f32) -> vec3<f32>
                {
                    let blendSaturation = setLuminosity(setSaturation(base, getSaturation(blend)), getLuminosity(base));
                    return (blendSaturation * opacity + base * (1.0 - opacity));
                }
            `, main:"\n                out \x3d vec4\x3cf32\x3e(blendSaturation(back.rgb, front.rgb, front.a), blendedAlpha) * blendUniforms.uBlend;\n            "}});
    }
  }
  SaturationBlend.extension = {name:"saturation", type:global.ExtensionType.BlendMode};
  exports.SaturationBlend = SaturationBlend;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$advanced_blend_modes$SaturationBlend.js.map
