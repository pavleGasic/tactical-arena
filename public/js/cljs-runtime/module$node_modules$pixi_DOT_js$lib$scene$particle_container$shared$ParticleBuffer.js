shadow$provide.module$node_modules$pixi_DOT_js$lib$scene$particle_container$shared$ParticleBuffer = function(global, require, module, exports) {
  var Buffer = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$buffer$Buffer"), _const = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$buffer$const"), Geometry = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$geometry$Geometry"), getAttributeInfoFromFormat = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$geometry$utils$getAttributeInfoFromFormat"), ViewableBuffer = require("module$node_modules$pixi_DOT_js$lib$utils$data$ViewableBuffer"), 
  createIndicesForQuads = require("module$node_modules$pixi_DOT_js$lib$scene$particle_container$shared$utils$createIndicesForQuads"), generateParticleUpdateFunction = require("module$node_modules$pixi_DOT_js$lib$scene$particle_container$shared$utils$generateParticleUpdateFunction");
  "use strict";
  class ParticleBuffer {
    constructor(options) {
      this._size = 0;
      this._generateParticleUpdateCache = {};
      var size = this._size = options.size ?? 1e3;
      options = options.properties;
      var staticVertexSize = 0, dynamicVertexSize = 0;
      for (var i in options) {
        var property = options[i];
        const attributeInfo = getAttributeInfoFromFormat.getAttributeInfoFromFormat(property.format);
        property.dynamic ? dynamicVertexSize += attributeInfo.stride : staticVertexSize += attributeInfo.stride;
      }
      this._dynamicStride = dynamicVertexSize / 4;
      this._staticStride = staticVertexSize / 4;
      this.staticAttributeBuffer = new ViewableBuffer.ViewableBuffer(4 * size * staticVertexSize);
      this.dynamicAttributeBuffer = new ViewableBuffer.ViewableBuffer(4 * size * dynamicVertexSize);
      this.indexBuffer = createIndicesForQuads.createIndicesForQuads(size);
      size = new Geometry.Geometry();
      staticVertexSize = i = 0;
      this._staticBuffer = new Buffer.Buffer({data:new Float32Array(1), label:"static-particle-buffer", shrinkToFit:!1, usage:_const.BufferUsage.VERTEX | _const.BufferUsage.COPY_DST});
      this._dynamicBuffer = new Buffer.Buffer({data:new Float32Array(1), label:"dynamic-particle-buffer", shrinkToFit:!1, usage:_const.BufferUsage.VERTEX | _const.BufferUsage.COPY_DST});
      for (var i$jscomp$0 in options) {
        dynamicVertexSize = options[i$jscomp$0], property = getAttributeInfoFromFormat.getAttributeInfoFromFormat(dynamicVertexSize.format), dynamicVertexSize.dynamic ? (size.addAttribute(dynamicVertexSize.attributeName, {buffer:this._dynamicBuffer, stride:4 * this._dynamicStride, offset:4 * i, format:dynamicVertexSize.format}), i += property.size) : (size.addAttribute(dynamicVertexSize.attributeName, {buffer:this._staticBuffer, stride:4 * this._staticStride, offset:4 * staticVertexSize, format:dynamicVertexSize.format}), 
        staticVertexSize += property.size);
      }
      size.addIndex(this.indexBuffer);
      i$jscomp$0 = this.getParticleUpdate(options);
      this._dynamicUpload = i$jscomp$0.dynamicUpdate;
      this._staticUpload = i$jscomp$0.staticUpdate;
      this.geometry = size;
    }
    getParticleUpdate(properties) {
      var JSCompiler_inline_result = [];
      for (const key in properties) {
        const property = properties[key];
        JSCompiler_inline_result.push(key, property.code, property.dynamic ? "d" : "s");
      }
      JSCompiler_inline_result = JSCompiler_inline_result.join("_");
      if (this._generateParticleUpdateCache[JSCompiler_inline_result]) {
        return this._generateParticleUpdateCache[JSCompiler_inline_result];
      }
      this._generateParticleUpdateCache[JSCompiler_inline_result] = this.generateParticleUpdate(properties);
      return this._generateParticleUpdateCache[JSCompiler_inline_result];
    }
    generateParticleUpdate(properties) {
      return generateParticleUpdateFunction.generateParticleUpdateFunction(properties);
    }
    update(particles, uploadStatic) {
      particles.length > this._size && (uploadStatic = !0, this._size = Math.max(particles.length, 1.5 * this._size | 0), this.staticAttributeBuffer = new ViewableBuffer.ViewableBuffer(this._size * this._staticStride * 16), this.dynamicAttributeBuffer = new ViewableBuffer.ViewableBuffer(this._size * this._dynamicStride * 16), this.indexBuffer = createIndicesForQuads.createIndicesForQuads(this._size), this.geometry.indexBuffer.setDataWithSize(this.indexBuffer, this.indexBuffer.byteLength, !0));
      const dynamicAttributeBuffer = this.dynamicAttributeBuffer;
      this._dynamicUpload(particles, dynamicAttributeBuffer.float32View, dynamicAttributeBuffer.uint32View);
      this._dynamicBuffer.setDataWithSize(this.dynamicAttributeBuffer.float32View, particles.length * this._dynamicStride * 4, !0);
      uploadStatic && (uploadStatic = this.staticAttributeBuffer, this._staticUpload(particles, uploadStatic.float32View, uploadStatic.uint32View), this._staticBuffer.setDataWithSize(uploadStatic.float32View, particles.length * this._staticStride * 4, !0));
    }
    destroy() {
      this._staticBuffer.destroy();
      this._dynamicBuffer.destroy();
      this.geometry.destroy();
    }
  }
  exports.ParticleBuffer = ParticleBuffer;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$scene$particle_container$shared$ParticleBuffer.js.map
