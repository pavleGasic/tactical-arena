{
"version":3,
"file":"module$node_modules$$pixi$core$lib$shader$utils$uniformParsers.js",
"lineCount":124,
"mappings":"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",
"sources":["node_modules/@pixi/core/lib/shader/utils/uniformParsers.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$$pixi$core$lib$shader$utils$uniformParsers\"] = function(global,require,module,exports) {\n\"use strict\";\nconst uniformParsers = [\n  // a float cache layer\n  {\n    test: (data) => data.type === \"float\" && data.size === 1 && !data.isArray,\n    code: (name) => `\n            if(uv[\"${name}\"] !== ud[\"${name}\"].value)\n            {\n                ud[\"${name}\"].value = uv[\"${name}\"]\n                gl.uniform1f(ud[\"${name}\"].location, uv[\"${name}\"])\n            }\n            `\n  },\n  // handling samplers\n  {\n    test: (data, uniform) => (\n      // eslint-disable-next-line max-len,no-eq-null,eqeqeq\n      (data.type === \"sampler2D\" || data.type === \"samplerCube\" || data.type === \"sampler2DArray\") && data.size === 1 && !data.isArray && (uniform == null || uniform.castToBaseTexture !== void 0)\n    ),\n    code: (name) => `t = syncData.textureCount++;\n\n            renderer.texture.bind(uv[\"${name}\"], t);\n\n            if(ud[\"${name}\"].value !== t)\n            {\n                ud[\"${name}\"].value = t;\n                gl.uniform1i(ud[\"${name}\"].location, t);\n; // eslint-disable-line max-len\n            }`\n  },\n  // uploading pixi matrix object to mat3\n  {\n    test: (data, uniform) => data.type === \"mat3\" && data.size === 1 && !data.isArray && uniform.a !== void 0,\n    code: (name) => (\n      // TODO and some smart caching dirty ids here!\n      `\n            gl.uniformMatrix3fv(ud[\"${name}\"].location, false, uv[\"${name}\"].toArray(true));\n            `\n    ),\n    codeUbo: (name) => `\n                var ${name}_matrix = uv.${name}.toArray(true);\n\n                data[offset] = ${name}_matrix[0];\n                data[offset+1] = ${name}_matrix[1];\n                data[offset+2] = ${name}_matrix[2];\n        \n                data[offset + 4] = ${name}_matrix[3];\n                data[offset + 5] = ${name}_matrix[4];\n                data[offset + 6] = ${name}_matrix[5];\n        \n                data[offset + 8] = ${name}_matrix[6];\n                data[offset + 9] = ${name}_matrix[7];\n                data[offset + 10] = ${name}_matrix[8];\n            `\n  },\n  // uploading a pixi point as a vec2 with caching layer\n  {\n    test: (data, uniform) => data.type === \"vec2\" && data.size === 1 && !data.isArray && uniform.x !== void 0,\n    code: (name) => `\n                cv = ud[\"${name}\"].value;\n                v = uv[\"${name}\"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    gl.uniform2f(ud[\"${name}\"].location, v.x, v.y);\n                }`,\n    codeUbo: (name) => `\n                v = uv.${name};\n\n                data[offset] = v.x;\n                data[offset+1] = v.y;\n            `\n  },\n  // caching layer for a vec2\n  {\n    test: (data) => data.type === \"vec2\" && data.size === 1 && !data.isArray,\n    code: (name) => `\n                cv = ud[\"${name}\"].value;\n                v = uv[\"${name}\"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    gl.uniform2f(ud[\"${name}\"].location, v[0], v[1]);\n                }\n            `\n  },\n  // upload a pixi rectangle as a vec4 with caching layer\n  {\n    test: (data, uniform) => data.type === \"vec4\" && data.size === 1 && !data.isArray && uniform.width !== void 0,\n    code: (name) => `\n                cv = ud[\"${name}\"].value;\n                v = uv[\"${name}\"];\n\n                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    cv[2] = v.width;\n                    cv[3] = v.height;\n                    gl.uniform4f(ud[\"${name}\"].location, v.x, v.y, v.width, v.height)\n                }`,\n    codeUbo: (name) => `\n                    v = uv.${name};\n\n                    data[offset] = v.x;\n                    data[offset+1] = v.y;\n                    data[offset+2] = v.width;\n                    data[offset+3] = v.height;\n                `\n  },\n  // upload a pixi color as vec4 with caching layer\n  {\n    test: (data, uniform) => data.type === \"vec4\" && data.size === 1 && !data.isArray && uniform.red !== void 0,\n    code: (name) => `\n                cv = ud[\"${name}\"].value;\n                v = uv[\"${name}\"];\n\n                if(cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha)\n                {\n                    cv[0] = v.red;\n                    cv[1] = v.green;\n                    cv[2] = v.blue;\n                    cv[3] = v.alpha;\n                    gl.uniform4f(ud[\"${name}\"].location, v.red, v.green, v.blue, v.alpha)\n                }`,\n    codeUbo: (name) => `\n                    v = uv.${name};\n\n                    data[offset] = v.red;\n                    data[offset+1] = v.green;\n                    data[offset+2] = v.blue;\n                    data[offset+3] = v.alpha;\n                `\n  },\n  // upload a pixi color as a vec3 with caching layer\n  {\n    test: (data, uniform) => data.type === \"vec3\" && data.size === 1 && !data.isArray && uniform.red !== void 0,\n    code: (name) => `\n                cv = ud[\"${name}\"].value;\n                v = uv[\"${name}\"];\n\n                if(cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.a)\n                {\n                    cv[0] = v.red;\n                    cv[1] = v.green;\n                    cv[2] = v.blue;\n    \n                    gl.uniform3f(ud[\"${name}\"].location, v.red, v.green, v.blue)\n                }`,\n    codeUbo: (name) => `\n                    v = uv.${name};\n\n                    data[offset] = v.red;\n                    data[offset+1] = v.green;\n                    data[offset+2] = v.blue;\n                `\n  },\n  // a caching layer for vec4 uploading\n  {\n    test: (data) => data.type === \"vec4\" && data.size === 1 && !data.isArray,\n    code: (name) => `\n                cv = ud[\"${name}\"].value;\n                v = uv[\"${name}\"];\n\n                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    cv[2] = v[2];\n                    cv[3] = v[3];\n\n                    gl.uniform4f(ud[\"${name}\"].location, v[0], v[1], v[2], v[3])\n                }`\n  }\n];\nexports.uniformParsers = uniformParsers;\n//# sourceMappingURL=uniformParsers.js.map\n\n};"],
"names":["shadow$provide","global","require","module","exports","uniformParsers","test","data","type","size","isArray","code","name","uniform","castToBaseTexture","a","codeUbo","x","width","red"]
}
