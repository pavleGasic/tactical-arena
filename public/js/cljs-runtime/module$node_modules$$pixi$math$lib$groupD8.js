shadow$provide.module$node_modules$$pixi$math$lib$groupD8 = function(global, require, module, exports) {
  var Matrix = require("module$node_modules$$pixi$math$lib$Matrix");
  const ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1], uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1], vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1], vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1], rotationCayley = [], rotationMatrices = [], signum = Math.sign;
  (function() {
    for (var i = 0; 16 > i; i++) {
      var row = [];
      rotationCayley.push(row);
      for (let j = 0; 16 > j; j++) {
        const _ux = signum(ux[i] * ux[j] + vx[i] * uy[j]), _uy = signum(uy[i] * ux[j] + vy[i] * uy[j]), _vx = signum(ux[i] * vx[j] + vx[i] * vy[j]), _vy = signum(uy[i] * vx[j] + vy[i] * vy[j]);
        for (let k = 0; 16 > k; k++) {
          if (ux[k] === _ux && uy[k] === _uy && vx[k] === _vx && vy[k] === _vy) {
            row.push(k);
            break;
          }
        }
      }
    }
    for (i = 0; 16 > i; i++) {
      row = new Matrix.Matrix(), row.set(ux[i], uy[i], vx[i], vy[i], 0, 0), rotationMatrices.push(row);
    }
  })();
  const groupD8 = {E:0, SE:1, S:2, SW:3, W:4, NW:5, N:6, NE:7, MIRROR_VERTICAL:8, MAIN_DIAGONAL:10, MIRROR_HORIZONTAL:12, REVERSE_DIAGONAL:14, uX:ind => ux[ind], uY:ind => uy[ind], vX:ind => vx[ind], vY:ind => vy[ind], inv:rotation => rotation & 8 ? rotation & 15 : -rotation & 7, add:(rotationSecond, rotationFirst) => rotationCayley[rotationSecond][rotationFirst], sub:(rotationSecond, rotationFirst) => rotationCayley[rotationSecond][groupD8.inv(rotationFirst)], rotate180:rotation => rotation ^ 4, 
  isVertical:rotation => 2 === (rotation & 3), byDirection:(dx, dy) => 2 * Math.abs(dx) <= Math.abs(dy) ? 0 <= dy ? groupD8.S : groupD8.N : 2 * Math.abs(dy) <= Math.abs(dx) ? 0 < dx ? groupD8.E : groupD8.W : 0 < dy ? 0 < dx ? groupD8.SE : groupD8.SW : 0 < dx ? groupD8.NE : groupD8.NW, matrixAppendRotationInv:(matrix, rotation, tx = 0, ty = 0) => {
    rotation = rotationMatrices[groupD8.inv(rotation)];
    rotation.tx = tx;
    rotation.ty = ty;
    matrix.append(rotation);
  }};
  exports.groupD8 = groupD8;
};

//# sourceMappingURL=module$node_modules$$pixi$math$lib$groupD8.js.map
