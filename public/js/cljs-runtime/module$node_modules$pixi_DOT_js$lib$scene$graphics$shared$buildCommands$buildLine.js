shadow$provide.module$node_modules$pixi_DOT_js$lib$scene$graphics$shared$buildCommands$buildLine = function(global, require, module, exports) {
  function square(x, y, nx, ny, innerWeight, outerWeight, clockwise, verts) {
    let eyy;
    clockwise ? (clockwise = ny, eyy = -nx) : (clockwise = -ny, eyy = nx);
    const eox = x + nx * outerWeight + clockwise;
    outerWeight = y + ny * outerWeight + eyy;
    verts.push(x - nx * innerWeight + clockwise, y - ny * innerWeight + eyy);
    verts.push(eox, outerWeight);
    return 2;
  }
  function round(cx, cy, sx, sy, ex, ey, verts, clockwise) {
    var cx2p0x = sx - cx, cy2p0y = sy - cy, angle0 = Math.atan2(cx2p0x, cy2p0y), angle1 = Math.atan2(ex - cx, ey - cy);
    clockwise && angle0 < angle1 ? angle0 += 2 * Math.PI : !clockwise && angle0 > angle1 && (angle1 += 2 * Math.PI);
    angle1 -= angle0;
    cx2p0x = Math.sqrt(cx2p0x * cx2p0x + cy2p0y * cy2p0y);
    cy2p0y = (15 * Math.abs(angle1) * Math.sqrt(cx2p0x) / Math.PI >> 0) + 1;
    angle1 /= cy2p0y;
    angle0 += angle1;
    if (clockwise) {
      verts.push(cx, cy);
      verts.push(sx, sy);
      for (let i = 1, angle = angle0; i < cy2p0y; i++, angle += angle1) {
        verts.push(cx, cy), verts.push(cx + Math.sin(angle) * cx2p0x, cy + Math.cos(angle) * cx2p0x);
      }
      verts.push(cx, cy);
      verts.push(ex, ey);
    } else {
      verts.push(sx, sy);
      verts.push(cx, cy);
      for (let i = 1, angle = angle0; i < cy2p0y; i++, angle += angle1) {
        verts.push(cx + Math.sin(angle) * cx2p0x, cy + Math.cos(angle) * cx2p0x), verts.push(cx, cy);
      }
      verts.push(ex, ey);
      verts.push(cx, cy);
    }
    return 2 * cy2p0y;
  }
  var Point = require("module$node_modules$pixi_DOT_js$lib$maths$point$Point"), _const = require("module$node_modules$pixi_DOT_js$lib$scene$graphics$shared$const"), getOrientationOfPoints = require("module$node_modules$pixi_DOT_js$lib$scene$graphics$shared$utils$getOrientationOfPoints");
  "use strict";
  exports.buildLine = function(points, lineStyle, flipAlignment, closed, vertices, indices) {
    var eps = _const.closePointEps;
    if (0 !== points.length) {
      var alignment = lineStyle.alignment;
      if (0.5 !== lineStyle.alignment) {
        var orientation = getOrientationOfPoints.getOrientationOfPoints(points);
        flipAlignment && (orientation *= -1);
        alignment = (alignment - 0.5) * orientation + 0.5;
      }
      flipAlignment = new Point.Point(points[0], points[1]);
      orientation = new Point.Point(points[points.length - 2], points[points.length - 1]);
      eps = Math.abs(flipAlignment.x - orientation.x) < eps && Math.abs(flipAlignment.y - orientation.y) < eps;
      closed && (points = points.slice(), eps && (points.pop(), points.pop(), orientation.set(points[points.length - 2], points[points.length - 1])), eps = 0.5 * (flipAlignment.x + orientation.x), flipAlignment = 0.5 * (orientation.y + flipAlignment.y), points.unshift(eps, flipAlignment), points.push(eps, flipAlignment));
      var length = points.length / 2;
      eps = points.length;
      flipAlignment = vertices.length / 2;
      var width = lineStyle.width / 2, widthSquared = width * width, miterLimitSquared = lineStyle.miterLimit * lineStyle.miterLimit, x0 = points[0], y0 = points[1];
      orientation = points[2];
      var y1 = points[3], perpX = -(y0 - y1), perpY = x0 - orientation, dist = Math.sqrt(perpX * perpX + perpY * perpY);
      perpX = perpX / dist * width;
      perpY = perpY / dist * width;
      orientation = alignment;
      alignment = 2 * (1 - orientation);
      var outerWeight = 2 * orientation;
      closed || ("round" === lineStyle.cap ? eps += round(x0 - perpX * (alignment - outerWeight) * 0.5, y0 - perpY * (alignment - outerWeight) * 0.5, x0 - perpX * alignment, y0 - perpY * alignment, x0 + perpX * outerWeight, y0 + perpY * outerWeight, vertices, !0) + 2 : "square" === lineStyle.cap && (eps += square(x0, y0, perpX, perpY, alignment, outerWeight, !0, vertices)));
      vertices.push(x0 - perpX * alignment, y0 - perpY * alignment);
      vertices.push(x0 + perpX * outerWeight, y0 + perpY * outerWeight);
      for (let i = 1; i < length - 1; ++i) {
        x0 = points[2 * (i - 1)];
        y0 = points[2 * (i - 1) + 1];
        orientation = points[2 * i];
        y1 = points[2 * i + 1];
        var x2 = points[2 * (i + 1)];
        var y2 = points[2 * (i + 1) + 1];
        perpX = -(y0 - y1);
        perpY = x0 - orientation;
        dist = Math.sqrt(perpX * perpX + perpY * perpY);
        perpX /= dist;
        perpY /= dist;
        perpX *= width;
        perpY *= width;
        var perp1x = -(y1 - y2);
        var perp1y = orientation - x2;
        dist = Math.sqrt(perp1x * perp1x + perp1y * perp1y);
        perp1x /= dist;
        perp1y /= dist;
        perp1x *= width;
        perp1y *= width;
        dist = orientation - x0;
        const dy0 = y0 - y1, dx1 = orientation - x2, dy1 = y2 - y1;
        var dot = dist * dx1 + dy0 * dy1, cross = dy0 * dx1 - dy1 * dist;
        const clockwise = 0 > cross;
        Math.abs(cross) < 1e-3 * Math.abs(dot) ? (vertices.push(orientation - perpX * alignment, y1 - perpY * alignment), vertices.push(orientation + perpX * outerWeight, y1 + perpY * outerWeight), 0 <= dot && (eps = "round" === lineStyle.join ? eps + (round(orientation, y1, orientation - perpX * alignment, y1 - perpY * alignment, orientation - perp1x * alignment, y1 - perp1y * alignment, vertices, !1) + 4) : eps + 2, vertices.push(orientation - perp1x * outerWeight, y1 - perp1y * outerWeight), vertices.push(orientation + 
        perp1x * alignment, y1 + perp1y * alignment))) : (y0 = (-perpX + x0) * (-perpY + y1) - (-perpX + orientation) * (-perpY + y0), x2 = (-perp1x + x2) * (-perp1y + y1) - (-perp1x + orientation) * (-perp1y + y2), x0 = (dist * x2 - dx1 * y0) / cross, cross = (dy1 * y0 - dy0 * x2) / cross, y0 = (x0 - orientation) * (x0 - orientation) + (cross - y1) * (cross - y1), x2 = orientation + (x0 - orientation) * alignment, y2 = y1 + (cross - y1) * alignment, x0 = orientation - (x0 - orientation) * outerWeight, 
        cross = y1 - (cross - y1) * outerWeight, dot = clockwise ? alignment : outerWeight, y0 <= Math.min(dist * dist + dy0 * dy0, dx1 * dx1 + dy1 * dy1) + dot * dot * widthSquared ? "bevel" === lineStyle.join || y0 / widthSquared > miterLimitSquared ? (clockwise ? (vertices.push(x2, y2), vertices.push(orientation + perpX * outerWeight, y1 + perpY * outerWeight), vertices.push(x2, y2), vertices.push(orientation + perp1x * outerWeight, y1 + perp1y * outerWeight)) : (vertices.push(orientation - perpX * 
        alignment, y1 - perpY * alignment), vertices.push(x0, cross), vertices.push(orientation - perp1x * alignment, y1 - perp1y * alignment), vertices.push(x0, cross)), eps += 2) : "round" === lineStyle.join ? clockwise ? (vertices.push(x2, y2), vertices.push(orientation + perpX * outerWeight, y1 + perpY * outerWeight), eps += round(orientation, y1, orientation + perpX * outerWeight, y1 + perpY * outerWeight, orientation + perp1x * outerWeight, y1 + perp1y * outerWeight, vertices, !0) + 4, vertices.push(x2, 
        y2), vertices.push(orientation + perp1x * outerWeight, y1 + perp1y * outerWeight)) : (vertices.push(orientation - perpX * alignment, y1 - perpY * alignment), vertices.push(x0, cross), eps += round(orientation, y1, orientation - perpX * alignment, y1 - perpY * alignment, orientation - perp1x * alignment, y1 - perp1y * alignment, vertices, !1) + 4, vertices.push(orientation - perp1x * alignment, y1 - perp1y * alignment), vertices.push(x0, cross)) : (vertices.push(x2, y2), vertices.push(x0, 
        cross)) : (vertices.push(orientation - perpX * alignment, y1 - perpY * alignment), vertices.push(orientation + perpX * outerWeight, y1 + perpY * outerWeight), "round" === lineStyle.join ? eps = clockwise ? eps + (round(orientation, y1, orientation + perpX * outerWeight, y1 + perpY * outerWeight, orientation + perp1x * outerWeight, y1 + perp1y * outerWeight, vertices, !0) + 2) : eps + (round(orientation, y1, orientation - perpX * alignment, y1 - perpY * alignment, orientation - perp1x * alignment, 
        y1 - perp1y * alignment, vertices, !1) + 2) : "miter" === lineStyle.join && y0 / widthSquared <= miterLimitSquared && (clockwise ? (vertices.push(x0, cross), vertices.push(x0, cross)) : (vertices.push(x2, y2), vertices.push(x2, y2)), eps += 2), vertices.push(orientation - perp1x * alignment, y1 - perp1y * alignment), vertices.push(orientation + perp1x * outerWeight, y1 + perp1y * outerWeight), eps += 2));
      }
      x0 = points[2 * (length - 2)];
      y0 = points[2 * (length - 2) + 1];
      orientation = points[2 * (length - 1)];
      y1 = points[2 * (length - 1) + 1];
      perpX = -(y0 - y1);
      perpY = x0 - orientation;
      dist = Math.sqrt(perpX * perpX + perpY * perpY);
      perpX = perpX / dist * width;
      perpY = perpY / dist * width;
      vertices.push(orientation - perpX * alignment, y1 - perpY * alignment);
      vertices.push(orientation + perpX * outerWeight, y1 + perpY * outerWeight);
      closed || ("round" === lineStyle.cap ? eps += round(orientation - perpX * (alignment - outerWeight) * 0.5, y1 - perpY * (alignment - outerWeight) * 0.5, orientation - perpX * alignment, y1 - perpY * alignment, orientation + perpX * outerWeight, y1 + perpY * outerWeight, vertices, !1) + 2 : "square" === lineStyle.cap && (eps += square(orientation, y1, perpX, perpY, alignment, outerWeight, !1, vertices)));
      points = _const.curveEps * _const.curveEps;
      for (lineStyle = flipAlignment; lineStyle < eps + flipAlignment - 2; ++lineStyle) {
        x0 = vertices[2 * lineStyle], y0 = vertices[2 * lineStyle + 1], orientation = vertices[2 * (lineStyle + 1)], y1 = vertices[2 * (lineStyle + 1) + 1], x2 = vertices[2 * (lineStyle + 2)], y2 = vertices[2 * (lineStyle + 2) + 1], Math.abs(x0 * (y1 - y2) + orientation * (y2 - y0) + x2 * (y0 - y1)) < points || indices.push(lineStyle, lineStyle + 1, lineStyle + 2);
      }
    }
  };
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$scene$graphics$shared$buildCommands$buildLine.js.map
