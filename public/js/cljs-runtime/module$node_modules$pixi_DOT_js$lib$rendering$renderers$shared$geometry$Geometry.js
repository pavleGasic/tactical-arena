shadow$provide.module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$geometry$Geometry = function(global, require, module, exports) {
  global = require("module$node_modules$eventemitter3$index");
  var Bounds = require("module$node_modules$pixi_DOT_js$lib$scene$container$bounds$Bounds"), uid = require("module$node_modules$pixi_DOT_js$lib$utils$data$uid"), Buffer = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$buffer$Buffer"), ensureIsBuffer = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$geometry$utils$ensureIsBuffer"), getGeometryBounds = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$geometry$utils$getGeometryBounds");
  "use strict";
  class Geometry extends global {
    constructor(options = {}) {
      super();
      this.uid = uid.uid("geometry");
      this._layoutKey = 0;
      this.instanceCount = 1;
      this._bounds = new Bounds.Bounds();
      this._boundsDirty = !0;
      const {attributes, indexBuffer, topology} = options;
      this.buffers = [];
      this.attributes = {};
      if (attributes) {
        for (const i in attributes) {
          this.addAttribute(i, attributes[i]);
        }
      }
      this.instanceCount = options.instanceCount ?? 1;
      indexBuffer && this.addIndex(indexBuffer);
      this.topology = topology || "triangle-list";
    }
    onBufferUpdate() {
      this._boundsDirty = !0;
      this.emit("update", this);
    }
    getAttribute(id) {
      return this.attributes[id];
    }
    getIndex() {
      return this.indexBuffer;
    }
    getBuffer(id) {
      return this.getAttribute(id).buffer;
    }
    getSize() {
      for (var i in this.attributes) {
        return i = this.attributes[i], i.buffer.data.length / (i.stride / 4 || i.size);
      }
      return 0;
    }
    addAttribute(name, attributeOption) {
      if (attributeOption instanceof Buffer.Buffer || Array.isArray(attributeOption) || attributeOption.BYTES_PER_ELEMENT) {
        attributeOption = {buffer:attributeOption};
      }
      attributeOption.buffer = ensureIsBuffer.ensureIsBuffer(attributeOption.buffer, !1);
      -1 === this.buffers.indexOf(attributeOption.buffer) && (this.buffers.push(attributeOption.buffer), attributeOption.buffer.on("update", this.onBufferUpdate, this), attributeOption.buffer.on("change", this.onBufferUpdate, this));
      this.attributes[name] = attributeOption;
    }
    addIndex(indexBuffer) {
      this.indexBuffer = ensureIsBuffer.ensureIsBuffer(indexBuffer, !0);
      this.buffers.push(this.indexBuffer);
    }
    get bounds() {
      if (!this._boundsDirty) {
        return this._bounds;
      }
      this._boundsDirty = !1;
      return getGeometryBounds.getGeometryBounds(this, "aPosition", this._bounds);
    }
    destroy(destroyBuffers = !1) {
      this.emit("destroy", this);
      this.removeAllListeners();
      destroyBuffers && this.buffers.forEach(buffer => buffer.destroy());
      this._bounds = this.indexBuffer = this.buffers = this.attributes = null;
    }
  }
  exports.Geometry = Geometry;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$geometry$Geometry.js.map
