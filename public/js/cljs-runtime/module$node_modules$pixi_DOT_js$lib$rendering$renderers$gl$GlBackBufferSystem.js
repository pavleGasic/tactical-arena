shadow$provide.module$node_modules$pixi_DOT_js$lib$rendering$renderers$gl$GlBackBufferSystem = function(global, require, module, exports) {
  global = require("module$node_modules$pixi_DOT_js$lib$extensions$Extensions");
  var warn = require("module$node_modules$pixi_DOT_js$lib$utils$logging$warn");
  module = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$geometry$Geometry");
  var Shader = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$shader$Shader"), State = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$state$State"), TextureSource = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$texture$sources$TextureSource"), Texture = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$texture$Texture"), GlProgram = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$gl$shader$GlProgram");
  "use strict";
  const bigTriangleGeometry = new module.Geometry({attributes:{aPosition:[-1, -1, 3, -1, -1, 3]}}), node_modules$pixi_DOT_js$lib$rendering$renderers$gl$GlBackBufferSystem$classdecl$var32 = class {
    constructor(renderer) {
      this._useBackBufferThisRender = this.useBackBuffer = !1;
      this._renderer = renderer;
    }
    init(options = {}) {
      const {useBackBuffer, antialias} = {...node_modules$pixi_DOT_js$lib$rendering$renderers$gl$GlBackBufferSystem$classdecl$var32.defaultOptions, ...options};
      this.useBackBuffer = useBackBuffer;
      this._antialias = antialias;
      this._renderer.context.supports.msaa || (warn.warn("antialiasing, is not supported on when using the back buffer"), this._antialias = !1);
      this._state = State.State.for2d();
      options = new GlProgram.GlProgram({vertex:"\n                attribute vec2 aPosition;\n                out vec2 vUv;\n\n                void main() {\n                    gl_Position \x3d vec4(aPosition, 0.0, 1.0);\n\n                    vUv \x3d (aPosition + 1.0) / 2.0;\n\n                    // flip dem UVs\n                    vUv.y \x3d 1.0 - vUv.y;\n                }", fragment:"\n                in vec2 vUv;\n                out vec4 finalColor;\n\n                uniform sampler2D uTexture;\n\n                void main() {\n                    finalColor \x3d texture(uTexture, vUv);\n                }", 
      name:"big-triangle"});
      this._bigTriangleShader = new Shader.Shader({glProgram:options, resources:{uTexture:Texture.Texture.WHITE.source}});
    }
    renderStart(options) {
      var renderTarget = this._renderer.renderTarget.getRenderTarget(options.target);
      if (this._useBackBufferThisRender = this.useBackBuffer && !!renderTarget.isRoot) {
        renderTarget = this._renderer.renderTarget.getRenderTarget(options.target), this._targetTexture = renderTarget.colorTexture, options.target = this._getBackBufferTexture(renderTarget.colorTexture);
      }
    }
    renderEnd() {
      this._presentBackBuffer();
    }
    _presentBackBuffer() {
      const renderer = this._renderer;
      renderer.renderTarget.finishRenderPass();
      this._useBackBufferThisRender && (renderer.renderTarget.bind(this._targetTexture, !1), this._bigTriangleShader.resources.uTexture = this._backBufferTexture.source, renderer.encoder.draw({geometry:bigTriangleGeometry, shader:this._bigTriangleShader, state:this._state}));
    }
    _getBackBufferTexture(targetSourceTexture) {
      this._backBufferTexture = this._backBufferTexture || new Texture.Texture({source:new TextureSource.TextureSource({width:targetSourceTexture.width, height:targetSourceTexture.height, resolution:targetSourceTexture._resolution, antialias:this._antialias})});
      this._backBufferTexture.source.resize(targetSourceTexture.width, targetSourceTexture.height, targetSourceTexture._resolution);
      return this._backBufferTexture;
    }
    destroy() {
      this._backBufferTexture && (this._backBufferTexture.destroy(), this._backBufferTexture = null);
    }
  };
  require = node_modules$pixi_DOT_js$lib$rendering$renderers$gl$GlBackBufferSystem$classdecl$var32;
  require.extension = {type:[global.ExtensionType.WebGLSystem], name:"backBuffer", priority:1};
  require.defaultOptions = {useBackBuffer:!1};
  exports.GlBackBufferSystem = require;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$rendering$renderers$gl$GlBackBufferSystem.js.map
