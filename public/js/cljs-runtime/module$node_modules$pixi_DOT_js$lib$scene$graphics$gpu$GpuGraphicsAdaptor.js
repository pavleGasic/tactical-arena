shadow$provide.module$node_modules$pixi_DOT_js$lib$scene$graphics$gpu$GpuGraphicsAdaptor = function(global, require, module, exports) {
  global = require("module$node_modules$pixi_DOT_js$lib$extensions$Extensions");
  var Matrix = require("module$node_modules$pixi_DOT_js$lib$maths$matrix$Matrix"), maxRecommendedTextures = require("module$node_modules$pixi_DOT_js$lib$rendering$batcher$gl$utils$maxRecommendedTextures"), getTextureBatchBindGroup = require("module$node_modules$pixi_DOT_js$lib$rendering$batcher$gpu$getTextureBatchBindGroup"), compileHighShaderToProgram = require("module$node_modules$pixi_DOT_js$lib$rendering$high_shader$compileHighShaderToProgram"), colorBit = require("module$node_modules$pixi_DOT_js$lib$rendering$high_shader$shader_bits$colorBit"), 
  generateTextureBatchBit = require("module$node_modules$pixi_DOT_js$lib$rendering$high_shader$shader_bits$generateTextureBatchBit"), localUniformBit = require("module$node_modules$pixi_DOT_js$lib$rendering$high_shader$shader_bits$localUniformBit"), roundPixelsBit = require("module$node_modules$pixi_DOT_js$lib$rendering$high_shader$shader_bits$roundPixelsBit"), Shader = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$shader$Shader"), UniformGroup = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$shader$UniformGroup");
  "use strict";
  class GpuGraphicsAdaptor {
    init() {
      const localUniforms = new UniformGroup.UniformGroup({uTransformMatrix:{value:new Matrix.Matrix(), type:"mat3x3\x3cf32\x3e"}, uColor:{value:new Float32Array([1, 1, 1, 1]), type:"vec4\x3cf32\x3e"}, uRound:{value:0, type:"f32"}}), gpuProgram = compileHighShaderToProgram.compileHighShaderGpuProgram({name:"graphics", bits:[colorBit.colorBit, generateTextureBatchBit.generateTextureBatchBit(maxRecommendedTextures.getMaxTexturesPerBatch()), localUniformBit.localUniformBitGroup2, roundPixelsBit.roundPixelsBit]});
      this.shader = new Shader.Shader({gpuProgram, resources:{localUniforms}});
    }
    execute(graphicsPipe, renderable) {
      var context = renderable.context;
      renderable = context.customShader || this.shader;
      const renderer = graphicsPipe.renderer, {batcher, instructions} = renderer.graphicsContext.getContextRenderData(context);
      context = renderer.encoder;
      context.setGeometry(batcher.geometry, renderable.gpuProgram);
      context.setBindGroup(0, renderer.globalUniforms.bindGroup, renderable.gpuProgram);
      var localBindGroup = renderer.renderPipes.uniformBatch.getUniformBindGroup(renderable.resources.localUniforms, !0);
      context.setBindGroup(2, localBindGroup, renderable.gpuProgram);
      localBindGroup = instructions.instructions;
      let topology = null;
      for (let i = 0; i < instructions.instructionSize; i++) {
        const batch = localBindGroup[i];
        batch.topology !== topology && (topology = batch.topology, context.setPipelineFromGeometryProgramAndState(batcher.geometry, renderable.gpuProgram, graphicsPipe.state, batch.topology));
        renderable.groups[1] = batch.bindGroup;
        if (!batch.gpuBindGroup) {
          const textureBatch = batch.textures;
          batch.bindGroup = getTextureBatchBindGroup.getTextureBatchBindGroup(textureBatch.textures, textureBatch.count);
          batch.gpuBindGroup = renderer.bindGroup.getBindGroup(batch.bindGroup, renderable.gpuProgram, 1);
        }
        context.setBindGroup(1, batch.bindGroup, renderable.gpuProgram);
        context.renderPassEncoder.drawIndexed(batch.size, 1, batch.start);
      }
    }
    destroy() {
      this.shader.destroy(!0);
      this.shader = null;
    }
  }
  GpuGraphicsAdaptor.extension = {type:[global.ExtensionType.WebGPUPipesAdaptor], name:"graphics"};
  exports.GpuGraphicsAdaptor = GpuGraphicsAdaptor;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$scene$graphics$gpu$GpuGraphicsAdaptor.js.map
