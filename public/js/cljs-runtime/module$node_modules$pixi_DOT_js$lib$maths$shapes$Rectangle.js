shadow$provide.module$node_modules$pixi_DOT_js$lib$maths$shapes$Rectangle = function(global, require, module, exports) {
  global = require("module$node_modules$pixi_DOT_js$lib$maths$point$Point");
  "use strict";
  const tempPoints = [new global.Point(), new global.Point(), new global.Point(), new global.Point()];
  class Rectangle {
    constructor(x = 0, y = 0, width = 0, height = 0) {
      this.type = "rectangle";
      this.x = Number(x);
      this.y = Number(y);
      this.width = Number(width);
      this.height = Number(height);
    }
    get left() {
      return this.x;
    }
    get right() {
      return this.x + this.width;
    }
    get top() {
      return this.y;
    }
    get bottom() {
      return this.y + this.height;
    }
    isEmpty() {
      return this.left === this.right || this.top === this.bottom;
    }
    static get EMPTY() {
      return new Rectangle(0, 0, 0, 0);
    }
    clone() {
      return new Rectangle(this.x, this.y, this.width, this.height);
    }
    copyFromBounds(bounds) {
      this.x = bounds.minX;
      this.y = bounds.minY;
      this.width = bounds.maxX - bounds.minX;
      this.height = bounds.maxY - bounds.minY;
      return this;
    }
    copyFrom(rectangle) {
      this.x = rectangle.x;
      this.y = rectangle.y;
      this.width = rectangle.width;
      this.height = rectangle.height;
      return this;
    }
    copyTo(rectangle) {
      rectangle.copyFrom(this);
      return rectangle;
    }
    contains(x, y) {
      return 0 >= this.width || 0 >= this.height ? !1 : x >= this.x && x < this.x + this.width && y >= this.y && y < this.y + this.height ? !0 : !1;
    }
    strokeContains(x, y, strokeWidth, alignment = 0.5) {
      const {width, height} = this;
      if (0 >= width || 0 >= height) {
        return !1;
      }
      const _x = this.x, _y = this.y;
      alignment = strokeWidth * (1 - alignment);
      strokeWidth -= alignment;
      return x >= _x - alignment && x <= _x + width + alignment && y >= _y - alignment && y <= _y + height + alignment && !(x > _x + strokeWidth && x < _x + width - strokeWidth && y > _y + strokeWidth && y < _y + height - strokeWidth);
    }
    intersects(other, transform) {
      if (!transform) {
        return (this.right > other.right ? other.right : this.right) <= (this.x < other.x ? other.x : this.x) ? !1 : (this.bottom > other.bottom ? other.bottom : this.bottom) > (this.y < other.y ? other.y : this.y);
      }
      var x0 = this.left, x1 = this.right, y0 = this.top;
      const y1 = this.bottom;
      if (x1 <= x0 || y1 <= y0) {
        return !1;
      }
      const lt = tempPoints[0].set(other.left, other.top);
      var lb = tempPoints[1].set(other.left, other.bottom), rt = tempPoints[2].set(other.right, other.top);
      other = tempPoints[3].set(other.right, other.bottom);
      if (rt.x <= lt.x || lb.y <= lt.y) {
        return !1;
      }
      var s = Math.sign(transform.a * transform.d - transform.b * transform.c);
      if (0 === s) {
        return !1;
      }
      transform.apply(lt, lt);
      transform.apply(lb, lb);
      transform.apply(rt, rt);
      transform.apply(other, other);
      if (Math.max(lt.x, lb.x, rt.x, other.x) <= x0 || Math.min(lt.x, lb.x, rt.x, other.x) >= x1 || Math.max(lt.y, lb.y, rt.y, other.y) <= y0 || Math.min(lt.y, lb.y, rt.y, other.y) >= y1) {
        return !1;
      }
      transform = s * (lb.y - lt.y);
      lb = s * (lt.x - lb.x);
      const n00 = transform * x0 + lb * y0, n10 = transform * x1 + lb * y0, n01 = transform * x0 + lb * y1, n11 = transform * x1 + lb * y1;
      if (Math.max(n00, n10, n01, n11) <= transform * lt.x + lb * lt.y || Math.min(n00, n10, n01, n11) >= transform * other.x + lb * other.y) {
        return !1;
      }
      transform = s * (lt.y - rt.y);
      rt = s * (rt.x - lt.x);
      s = transform * x0 + rt * y0;
      y0 = transform * x1 + rt * y0;
      x0 = transform * x0 + rt * y1;
      x1 = transform * x1 + rt * y1;
      return Math.max(s, y0, x0, x1) <= transform * lt.x + rt * lt.y || Math.min(s, y0, x0, x1) >= transform * other.x + rt * other.y ? !1 : !0;
    }
    pad(paddingX = 0, paddingY = paddingX) {
      this.x -= paddingX;
      this.y -= paddingY;
      this.width += 2 * paddingX;
      this.height += 2 * paddingY;
      return this;
    }
    fit(rectangle) {
      const x1 = Math.max(this.x, rectangle.x), x2 = Math.min(this.x + this.width, rectangle.x + rectangle.width), y1 = Math.max(this.y, rectangle.y);
      rectangle = Math.min(this.y + this.height, rectangle.y + rectangle.height);
      this.x = x1;
      this.width = Math.max(x2 - x1, 0);
      this.y = y1;
      this.height = Math.max(rectangle - y1, 0);
      return this;
    }
    ceil(resolution = 1, eps = 1e-3) {
      const x2 = Math.ceil((this.x + this.width - eps) * resolution) / resolution, y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;
      this.x = Math.floor((this.x + eps) * resolution) / resolution;
      this.y = Math.floor((this.y + eps) * resolution) / resolution;
      this.width = x2 - this.x;
      this.height = y2 - this.y;
      return this;
    }
    enlarge(rectangle) {
      const x1 = Math.min(this.x, rectangle.x), x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width), y1 = Math.min(this.y, rectangle.y);
      rectangle = Math.max(this.y + this.height, rectangle.y + rectangle.height);
      this.x = x1;
      this.width = x2 - x1;
      this.y = y1;
      this.height = rectangle - y1;
      return this;
    }
    getBounds(out) {
      out || (out = new Rectangle());
      out.copyFrom(this);
      return out;
    }
    containsRect(other) {
      if (0 >= this.width || 0 >= this.height) {
        return !1;
      }
      const x1 = other.x, y1 = other.y, x2 = other.x + other.width;
      other = other.y + other.height;
      return x1 >= this.x && x1 < this.x + this.width && y1 >= this.y && y1 < this.y + this.height && x2 >= this.x && x2 < this.x + this.width && other >= this.y && other < this.y + this.height;
    }
    toString() {
      return `[pixi.js/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;
    }
  }
  exports.Rectangle = Rectangle;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$maths$shapes$Rectangle.js.map
