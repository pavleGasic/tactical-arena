shadow$provide.module$node_modules$$pixi$core$lib$shader$utils$generateUniformsSync = function(global, require, module, exports) {
  var uniformParsers = require("module$node_modules$$pixi$core$lib$shader$utils$uniformParsers");
  const GLSL_TO_SINGLE_SETTERS_CACHED = {float:"\n    if (cv !\x3d\x3d v)\n    {\n        cu.value \x3d v;\n        gl.uniform1f(location, v);\n    }", vec2:"\n    if (cv[0] !\x3d\x3d v[0] || cv[1] !\x3d\x3d v[1])\n    {\n        cv[0] \x3d v[0];\n        cv[1] \x3d v[1];\n\n        gl.uniform2f(location, v[0], v[1])\n    }", vec3:"\n    if (cv[0] !\x3d\x3d v[0] || cv[1] !\x3d\x3d v[1] || cv[2] !\x3d\x3d v[2])\n    {\n        cv[0] \x3d v[0];\n        cv[1] \x3d v[1];\n        cv[2] \x3d v[2];\n\n        gl.uniform3f(location, v[0], v[1], v[2])\n    }", 
  vec4:"\n    if (cv[0] !\x3d\x3d v[0] || cv[1] !\x3d\x3d v[1] || cv[2] !\x3d\x3d v[2] || cv[3] !\x3d\x3d v[3])\n    {\n        cv[0] \x3d v[0];\n        cv[1] \x3d v[1];\n        cv[2] \x3d v[2];\n        cv[3] \x3d v[3];\n\n        gl.uniform4f(location, v[0], v[1], v[2], v[3]);\n    }", int:"\n    if (cv !\x3d\x3d v)\n    {\n        cu.value \x3d v;\n\n        gl.uniform1i(location, v);\n    }", ivec2:"\n    if (cv[0] !\x3d\x3d v[0] || cv[1] !\x3d\x3d v[1])\n    {\n        cv[0] \x3d v[0];\n        cv[1] \x3d v[1];\n\n        gl.uniform2i(location, v[0], v[1]);\n    }", 
  ivec3:"\n    if (cv[0] !\x3d\x3d v[0] || cv[1] !\x3d\x3d v[1] || cv[2] !\x3d\x3d v[2])\n    {\n        cv[0] \x3d v[0];\n        cv[1] \x3d v[1];\n        cv[2] \x3d v[2];\n\n        gl.uniform3i(location, v[0], v[1], v[2]);\n    }", ivec4:"\n    if (cv[0] !\x3d\x3d v[0] || cv[1] !\x3d\x3d v[1] || cv[2] !\x3d\x3d v[2] || cv[3] !\x3d\x3d v[3])\n    {\n        cv[0] \x3d v[0];\n        cv[1] \x3d v[1];\n        cv[2] \x3d v[2];\n        cv[3] \x3d v[3];\n\n        gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n    }", 
  uint:"\n    if (cv !\x3d\x3d v)\n    {\n        cu.value \x3d v;\n\n        gl.uniform1ui(location, v);\n    }", uvec2:"\n    if (cv[0] !\x3d\x3d v[0] || cv[1] !\x3d\x3d v[1])\n    {\n        cv[0] \x3d v[0];\n        cv[1] \x3d v[1];\n\n        gl.uniform2ui(location, v[0], v[1]);\n    }", uvec3:"\n    if (cv[0] !\x3d\x3d v[0] || cv[1] !\x3d\x3d v[1] || cv[2] !\x3d\x3d v[2])\n    {\n        cv[0] \x3d v[0];\n        cv[1] \x3d v[1];\n        cv[2] \x3d v[2];\n\n        gl.uniform3ui(location, v[0], v[1], v[2]);\n    }", 
  uvec4:"\n    if (cv[0] !\x3d\x3d v[0] || cv[1] !\x3d\x3d v[1] || cv[2] !\x3d\x3d v[2] || cv[3] !\x3d\x3d v[3])\n    {\n        cv[0] \x3d v[0];\n        cv[1] \x3d v[1];\n        cv[2] \x3d v[2];\n        cv[3] \x3d v[3];\n\n        gl.uniform4ui(location, v[0], v[1], v[2], v[3]);\n    }", bool:"\n    if (cv !\x3d\x3d v)\n    {\n        cu.value \x3d v;\n        gl.uniform1i(location, v);\n    }", bvec2:"\n    if (cv[0] !\x3d v[0] || cv[1] !\x3d v[1])\n    {\n        cv[0] \x3d v[0];\n        cv[1] \x3d v[1];\n\n        gl.uniform2i(location, v[0], v[1]);\n    }", 
  bvec3:"\n    if (cv[0] !\x3d\x3d v[0] || cv[1] !\x3d\x3d v[1] || cv[2] !\x3d\x3d v[2])\n    {\n        cv[0] \x3d v[0];\n        cv[1] \x3d v[1];\n        cv[2] \x3d v[2];\n\n        gl.uniform3i(location, v[0], v[1], v[2]);\n    }", bvec4:"\n    if (cv[0] !\x3d\x3d v[0] || cv[1] !\x3d\x3d v[1] || cv[2] !\x3d\x3d v[2] || cv[3] !\x3d\x3d v[3])\n    {\n        cv[0] \x3d v[0];\n        cv[1] \x3d v[1];\n        cv[2] \x3d v[2];\n        cv[3] \x3d v[3];\n\n        gl.uniform4i(location, v[0], v[1], v[2], v[3]);\n    }", 
  mat2:"gl.uniformMatrix2fv(location, false, v)", mat3:"gl.uniformMatrix3fv(location, false, v)", mat4:"gl.uniformMatrix4fv(location, false, v)", sampler2D:"\n    if (cv !\x3d\x3d v)\n    {\n        cu.value \x3d v;\n\n        gl.uniform1i(location, v);\n    }", samplerCube:"\n    if (cv !\x3d\x3d v)\n    {\n        cu.value \x3d v;\n\n        gl.uniform1i(location, v);\n    }", sampler2DArray:"\n    if (cv !\x3d\x3d v)\n    {\n        cu.value \x3d v;\n\n        gl.uniform1i(location, v);\n    }"}, 
  GLSL_TO_ARRAY_SETTERS = {float:"gl.uniform1fv(location, v)", vec2:"gl.uniform2fv(location, v)", vec3:"gl.uniform3fv(location, v)", vec4:"gl.uniform4fv(location, v)", mat4:"gl.uniformMatrix4fv(location, false, v)", mat3:"gl.uniformMatrix3fv(location, false, v)", mat2:"gl.uniformMatrix2fv(location, false, v)", int:"gl.uniform1iv(location, v)", ivec2:"gl.uniform2iv(location, v)", ivec3:"gl.uniform3iv(location, v)", ivec4:"gl.uniform4iv(location, v)", uint:"gl.uniform1uiv(location, v)", uvec2:"gl.uniform2uiv(location, v)", 
  uvec3:"gl.uniform3uiv(location, v)", uvec4:"gl.uniform4uiv(location, v)", bool:"gl.uniform1iv(location, v)", bvec2:"gl.uniform2iv(location, v)", bvec3:"gl.uniform3iv(location, v)", bvec4:"gl.uniform4iv(location, v)", sampler2D:"gl.uniform1iv(location, v)", samplerCube:"gl.uniform1iv(location, v)", sampler2DArray:"gl.uniform1iv(location, v)"};
  exports.generateUniformsSync = function(group, uniformData) {
    const funcFragments = ["\n        var v \x3d null;\n        var cv \x3d null;\n        var cu \x3d null;\n        var t \x3d 0;\n        var gl \x3d renderer.gl;\n    "];
    for (const i in group.uniforms) {
      var data = uniformData[i];
      if (!data) {
        !0 === group.uniforms[i]?.group && (group.uniforms[i].ubo ? funcFragments.push(`
                        renderer.shader.syncUniformBufferGroup(uv.${i}, '${i}');
                    `) : funcFragments.push(`
                        renderer.shader.syncUniformGroup(uv.${i}, syncData);
                    `));
        continue;
      }
      const uniform = group.uniforms[i];
      let parsed = !1;
      for (let j = 0; j < uniformParsers.uniformParsers.length; j++) {
        if (uniformParsers.uniformParsers[j].test(data, uniform)) {
          funcFragments.push(uniformParsers.uniformParsers[j].code(i, uniform));
          parsed = !0;
          break;
        }
      }
      parsed || (data = (1 !== data.size || data.isArray ? GLSL_TO_ARRAY_SETTERS : GLSL_TO_SINGLE_SETTERS_CACHED)[data.type].replace("location", `ud["${i}"].location`), funcFragments.push(`
            cu = ud["${i}"];
            cv = cu.value;
            v = uv["${i}"];
            ${data};`));
    }
    return new Function("ud", "uv", "renderer", "syncData", funcFragments.join("\n"));
  };
};

//# sourceMappingURL=module$node_modules$$pixi$core$lib$shader$utils$generateUniformsSync.js.map
