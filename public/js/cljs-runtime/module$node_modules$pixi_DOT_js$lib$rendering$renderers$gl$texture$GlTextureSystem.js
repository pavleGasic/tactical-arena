shadow$provide.module$node_modules$pixi_DOT_js$lib$rendering$renderers$gl$texture$GlTextureSystem = function(global, require, module, exports) {
  var adapter = require("module$node_modules$pixi_DOT_js$lib$environment$adapter");
  global = require("module$node_modules$pixi_DOT_js$lib$extensions$Extensions");
  var Texture = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$texture$Texture"), GlTexture = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$gl$texture$GlTexture"), glUploadBufferImageResource = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$gl$texture$uploaders$glUploadBufferImageResource"), glUploadCompressedTextureResource = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$gl$texture$uploaders$glUploadCompressedTextureResource"), 
  glUploadImageResource = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$gl$texture$uploaders$glUploadImageResource"), glUploadVideoResource = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$gl$texture$uploaders$glUploadVideoResource"), applyStyleParams = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$gl$texture$utils$applyStyleParams"), mapFormatToGlFormat = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$gl$texture$utils$mapFormatToGlFormat"), 
  mapFormatToGlInternalFormat = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$gl$texture$utils$mapFormatToGlInternalFormat"), mapFormatToGlType = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$gl$texture$utils$mapFormatToGlType");
  require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$gl$texture$utils$unpremultiplyAlpha");
  "use strict";
  class GlTextureSystem {
    constructor(renderer) {
      this.managedTextures = [];
      this._glTextures = Object.create(null);
      this._glSamplers = Object.create(null);
      this._boundTextures = [];
      this._activeTextureLocation = -1;
      this._boundSamplers = Object.create(null);
      this._uploads = {image:glUploadImageResource.glUploadImageResource, buffer:glUploadBufferImageResource.glUploadBufferImageResource, video:glUploadVideoResource.glUploadVideoResource, compressed:glUploadCompressedTextureResource.glUploadCompressedTextureResource};
      this._useSeparateSamplers = this._premultiplyAlpha = !1;
      this._renderer = renderer;
      this._renderer.renderableGC.addManagedHash(this, "_glTextures");
      this._renderer.renderableGC.addManagedHash(this, "_glSamplers");
    }
    contextChange(gl) {
      this._gl = gl;
      this._mapFormatToInternalFormat || (this._mapFormatToInternalFormat = mapFormatToGlInternalFormat.mapFormatToGlInternalFormat(gl, this._renderer.context.extensions), this._mapFormatToType = mapFormatToGlType.mapFormatToGlType(gl), this._mapFormatToFormat = mapFormatToGlFormat.mapFormatToGlFormat(gl));
      this._glTextures = Object.create(null);
      this._glSamplers = Object.create(null);
      this._boundSamplers = Object.create(null);
      this._premultiplyAlpha = !1;
      for (gl = 0; 16 > gl; gl++) {
        this.bind(Texture.Texture.EMPTY, gl);
      }
    }
    initSource(source) {
      this.bind(source);
    }
    bind(texture, location = 0) {
      const source = texture.source;
      texture ? (this.bindSource(source, location), this._useSeparateSamplers && this._bindSampler(source.style, location)) : (this.bindSource(null, location), this._useSeparateSamplers && this._bindSampler(null, location));
    }
    bindSource(source, location = 0) {
      const gl = this._gl;
      source._touched = this._renderer.textureGC.count;
      this._boundTextures[location] !== source && (this._boundTextures[location] = source, this._activateLocation(location), source || (source = Texture.Texture.EMPTY.source), source = this.getGlSource(source), gl.bindTexture(source.target, source.texture));
    }
    _bindSampler(style, location = 0) {
      const gl = this._gl;
      style ? (style = this._getGlSampler(style), this._boundSamplers[location] !== style && (this._boundSamplers[location] = style, gl.bindSampler(location, style))) : (this._boundSamplers[location] = null, gl.bindSampler(location, null));
    }
    unbind(texture) {
      texture = texture.source;
      const boundTextures = this._boundTextures, gl = this._gl;
      for (let i = 0; i < boundTextures.length; i++) {
        if (boundTextures[i] === texture) {
          this._activateLocation(i);
          const glTexture = this.getGlSource(texture);
          gl.bindTexture(glTexture.target, null);
          boundTextures[i] = null;
        }
      }
    }
    _activateLocation(location) {
      this._activeTextureLocation !== location && (this._activeTextureLocation = location, this._gl.activeTexture(this._gl.TEXTURE0 + location));
    }
    _initSource(source) {
      const glTexture = new GlTexture.GlTexture(this._gl.createTexture());
      glTexture.type = this._mapFormatToType[source.format];
      glTexture.internalFormat = this._mapFormatToInternalFormat[source.format];
      glTexture.format = this._mapFormatToFormat[source.format];
      source.autoGenerateMipmaps && (this._renderer.context.supports.nonPowOf2mipmaps || source.isPowerOfTwo) && (source.mipLevelCount = Math.floor(Math.log2(Math.max(source.width, source.height))) + 1);
      this._glTextures[source.uid] = glTexture;
      this.managedTextures.includes(source) || (source.on("update", this.onSourceUpdate, this), source.on("resize", this.onSourceUpdate, this), source.on("styleChange", this.onStyleChange, this), source.on("destroy", this.onSourceDestroy, this), source.on("unload", this.onSourceUnload, this), source.on("updateMipmaps", this.onUpdateMipmaps, this), this.managedTextures.push(source));
      this.onSourceUpdate(source);
      this.updateStyle(source, !1);
      return glTexture;
    }
    onStyleChange(source) {
      this.updateStyle(source, !1);
    }
    updateStyle(source, firstCreation) {
      const gl = this._gl, glTexture = this.getGlSource(source);
      gl.bindTexture(gl.TEXTURE_2D, glTexture.texture);
      this._boundTextures[this._activeTextureLocation] = source;
      applyStyleParams.applyStyleParams(source.style, gl, 1 < source.mipLevelCount, this._renderer.context.extensions.anisotropicFiltering, "texParameteri", gl.TEXTURE_2D, !this._renderer.context.supports.nonPowOf2wrapping && !source.isPowerOfTwo, firstCreation);
    }
    onSourceUnload(source) {
      const glTexture = this._glTextures[source.uid];
      glTexture && (this.unbind(source), this._glTextures[source.uid] = null, this._gl.deleteTexture(glTexture.texture));
    }
    onSourceUpdate(source) {
      const gl = this._gl, glTexture = this.getGlSource(source);
      gl.bindTexture(gl.TEXTURE_2D, glTexture.texture);
      this._boundTextures[this._activeTextureLocation] = source;
      const premultipliedAlpha = "premultiply-alpha-on-upload" === source.alphaMode;
      this._premultiplyAlpha !== premultipliedAlpha && (this._premultiplyAlpha = premultipliedAlpha, gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultipliedAlpha));
      this._uploads[source.uploadMethodId] ? this._uploads[source.uploadMethodId].upload(source, glTexture, gl, this._renderer.context.webGLVersion) : gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, source.pixelWidth, source.pixelHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
      if (source.autoGenerateMipmaps && 1 < source.mipLevelCount) {
        this.onUpdateMipmaps(source, !1);
      }
    }
    onUpdateMipmaps(source, bind = !0) {
      bind && this.bindSource(source, 0);
      source = this.getGlSource(source);
      this._gl.generateMipmap(source.target);
    }
    onSourceDestroy(source) {
      source.off("destroy", this.onSourceDestroy, this);
      source.off("update", this.onSourceUpdate, this);
      source.off("resize", this.onSourceUpdate, this);
      source.off("unload", this.onSourceUnload, this);
      source.off("styleChange", this.onStyleChange, this);
      source.off("updateMipmaps", this.onUpdateMipmaps, this);
      this.managedTextures.splice(this.managedTextures.indexOf(source), 1);
      this.onSourceUnload(source);
    }
    _initSampler(style) {
      const gl = this._gl, glSampler = this._gl.createSampler();
      this._glSamplers[style._resourceId] = glSampler;
      applyStyleParams.applyStyleParams(style, gl, 1 < this._boundTextures[this._activeTextureLocation].mipLevelCount, this._renderer.context.extensions.anisotropicFiltering, "samplerParameteri", glSampler, !1, !0);
      return this._glSamplers[style._resourceId];
    }
    _getGlSampler(sampler) {
      return this._glSamplers[sampler._resourceId] || this._initSampler(sampler);
    }
    getGlSource(source) {
      return this._glTextures[source.uid] || this._initSource(source);
    }
    generateCanvas(texture) {
      const {pixels, width, height} = this.getPixels(texture);
      texture = adapter.DOMAdapter.get().createCanvas();
      texture.width = width;
      texture.height = height;
      const ctx = texture.getContext("2d");
      if (ctx) {
        const imageData = ctx.createImageData(width, height);
        imageData.data.set(pixels);
        ctx.putImageData(imageData, 0, 0);
      }
      return texture;
    }
    getPixels(texture) {
      const resolution = texture.source.resolution, frame = texture.frame, width = Math.max(Math.round(frame.width * resolution), 1), height = Math.max(Math.round(frame.height * resolution), 1), pixels = new Uint8Array(4 * width * height);
      var renderer = this._renderer;
      texture = renderer.renderTarget.getRenderTarget(texture);
      texture = renderer.renderTarget.getGpuRenderTarget(texture);
      renderer = renderer.gl;
      renderer.bindFramebuffer(renderer.FRAMEBUFFER, texture.resolveTargetFramebuffer);
      renderer.readPixels(Math.round(frame.x * resolution), Math.round(frame.y * resolution), width, height, renderer.RGBA, renderer.UNSIGNED_BYTE, pixels);
      return {pixels:new Uint8ClampedArray(pixels.buffer), width, height};
    }
    destroy() {
      this.managedTextures.slice().forEach(source => this.onSourceDestroy(source));
      this._renderer = this.managedTextures = null;
    }
    resetState() {
      this._activeTextureLocation = -1;
      this._boundTextures.fill(Texture.Texture.EMPTY.source);
      this._boundSamplers = Object.create(null);
      const gl = this._gl;
      this._premultiplyAlpha = !1;
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this._premultiplyAlpha);
    }
  }
  GlTextureSystem.extension = {type:[global.ExtensionType.WebGLSystem], name:"texture"};
  exports.GlTextureSystem = GlTextureSystem;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$rendering$renderers$gl$texture$GlTextureSystem.js.map
