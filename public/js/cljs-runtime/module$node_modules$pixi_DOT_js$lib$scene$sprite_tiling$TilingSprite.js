shadow$provide.module$node_modules$pixi_DOT_js$lib$scene$sprite_tiling$TilingSprite = function(global, require, module, exports) {
  var Cache = require("module$node_modules$pixi_DOT_js$lib$assets$cache$Cache"), ObservablePoint = require("module$node_modules$pixi_DOT_js$lib$maths$point$ObservablePoint"), Texture = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$texture$Texture"), deprecation = require("module$node_modules$pixi_DOT_js$lib$utils$logging$deprecation"), warn = require("module$node_modules$pixi_DOT_js$lib$utils$logging$warn"), Transform = require("module$node_modules$pixi_DOT_js$lib$utils$misc$Transform");
  global = require("module$node_modules$pixi_DOT_js$lib$scene$view$ViewContainer");
  "use strict";
  const node_modules$pixi_DOT_js$lib$scene$sprite_tiling$TilingSprite$classdecl$var40 = class extends global.ViewContainer {
    constructor(...args) {
      let options = args[0] || {};
      options instanceof Texture.Texture && (options = {texture:options});
      1 < args.length && (deprecation.deprecation(deprecation.v8_0_0, "use new TilingSprite({ texture, width:100, height:100 }) instead"), options.width = args[1], options.height = args[2]);
      options = {...node_modules$pixi_DOT_js$lib$scene$sprite_tiling$TilingSprite$classdecl$var40.defaultOptions, ...options};
      const {texture, anchor, tilePosition, tileScale, tileRotation, width, height, applyAnchorToTexture, roundPixels, ...rest} = options ?? {};
      super({label:"TilingSprite", ...rest});
      this.renderPipeId = "tilingSprite";
      this.batched = !0;
      this.allowChildren = !1;
      this._anchor = new ObservablePoint.ObservablePoint({_onUpdate:() => {
        this.onViewUpdate();
      }});
      this.applyAnchorToTexture = applyAnchorToTexture;
      this.texture = texture;
      this._width = width ?? texture.width;
      this._height = height ?? texture.height;
      this._tileTransform = new Transform.Transform({observer:{_onUpdate:() => this.onViewUpdate()}});
      anchor && (this.anchor = anchor);
      this.tilePosition = tilePosition;
      this.tileScale = tileScale;
      this.tileRotation = tileRotation;
      this.roundPixels = roundPixels ?? !1;
    }
    static from(source, options = {}) {
      return "string" === typeof source ? new node_modules$pixi_DOT_js$lib$scene$sprite_tiling$TilingSprite$classdecl$var40({texture:Cache.Cache.get(source), ...options}) : new node_modules$pixi_DOT_js$lib$scene$sprite_tiling$TilingSprite$classdecl$var40({texture:source, ...options});
    }
    get uvRespectAnchor() {
      warn.warn("uvRespectAnchor is deprecated, please use applyAnchorToTexture instead");
      return this.applyAnchorToTexture;
    }
    set uvRespectAnchor(value) {
      warn.warn("uvRespectAnchor is deprecated, please use applyAnchorToTexture instead");
      this.applyAnchorToTexture = value;
    }
    get clampMargin() {
      return this._texture.textureMatrix.clampMargin;
    }
    set clampMargin(value) {
      this._texture.textureMatrix.clampMargin = value;
    }
    get anchor() {
      return this._anchor;
    }
    set anchor(value) {
      "number" === typeof value ? this._anchor.set(value) : this._anchor.copyFrom(value);
    }
    get tilePosition() {
      return this._tileTransform.position;
    }
    set tilePosition(value) {
      this._tileTransform.position.copyFrom(value);
    }
    get tileScale() {
      return this._tileTransform.scale;
    }
    set tileScale(value) {
      "number" === typeof value ? this._tileTransform.scale.set(value) : this._tileTransform.scale.copyFrom(value);
    }
    set tileRotation(value) {
      this._tileTransform.rotation = value;
    }
    get tileRotation() {
      return this._tileTransform.rotation;
    }
    get tileTransform() {
      return this._tileTransform;
    }
    set texture(value) {
      value || (value = Texture.Texture.EMPTY);
      const currentTexture = this._texture;
      if (currentTexture !== value) {
        currentTexture && currentTexture.dynamic && currentTexture.off("update", this.onViewUpdate, this);
        if (value.dynamic) {
          value.on("update", this.onViewUpdate, this);
        }
        this._texture = value;
        this.onViewUpdate();
      }
    }
    get texture() {
      return this._texture;
    }
    set width(value) {
      this._width = value;
      this.onViewUpdate();
    }
    get width() {
      return this._width;
    }
    set height(value) {
      this._height = value;
      this.onViewUpdate();
    }
    get height() {
      return this._height;
    }
    setSize(value, height) {
      "object" === typeof value && (height = value.height ?? value.width, value = value.width);
      this._width = value;
      this._height = height ?? value;
      this.onViewUpdate();
    }
    getSize(out) {
      out || (out = {});
      out.width = this._width;
      out.height = this._height;
      return out;
    }
    updateBounds() {
      const bounds = this._bounds, anchor = this._anchor, width = this._width, height = this._height;
      bounds.minX = -anchor._x * width;
      bounds.maxX = bounds.minX + width;
      bounds.minY = -anchor._y * height;
      bounds.maxY = bounds.minY + height;
    }
    containsPoint(point) {
      var width = this._width;
      const height = this._height, x1 = -width * this._anchor._x;
      return point.x >= x1 && point.x <= x1 + width && (width = -height * this._anchor._y, point.y >= width && point.y <= width + height) ? !0 : !1;
    }
    destroy(options = !1) {
      super.destroy(options);
      this._bounds = this._tileTransform = this._anchor = null;
      ("boolean" === typeof options ? options : options?.texture) && this._texture.destroy("boolean" === typeof options ? options : options?.textureSource);
      this._texture = null;
    }
  };
  global = node_modules$pixi_DOT_js$lib$scene$sprite_tiling$TilingSprite$classdecl$var40;
  global.defaultOptions = {texture:Texture.Texture.EMPTY, anchor:{x:0, y:0}, tilePosition:{x:0, y:0}, tileScale:{x:1, y:1}, tileRotation:0, applyAnchorToTexture:!1};
  exports.TilingSprite = global;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$scene$sprite_tiling$TilingSprite.js.map
