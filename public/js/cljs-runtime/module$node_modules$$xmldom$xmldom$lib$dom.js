shadow$provide.module$node_modules$$xmldom$xmldom$lib$dom = function(global, require, module, exports) {
  function notEmptyString(input) {
    return "" !== input;
  }
  function orderedSetReducer(current, element) {
    current.hasOwnProperty(element) || (current[element] = !0);
    return current;
  }
  function toOrderedSet(input) {
    if (!input) {
      return [];
    }
    input = input ? input.split(/[\t\n\f\r ]+/).filter(notEmptyString) : [];
    return Object.keys(input.reduce(orderedSetReducer, {}));
  }
  function arrayIncludes(list) {
    return function(element) {
      return list && -1 !== list.indexOf(element);
    };
  }
  function copy(src, dest) {
    for (var p in src) {
      Object.prototype.hasOwnProperty.call(src, p) && (dest[p] = src[p]);
    }
  }
  function _extends(Class, Super) {
    var pt = Class.prototype;
    if (!(pt instanceof Super)) {
      function t() {
      }
      t.prototype = Super.prototype;
      t = new t();
      copy(pt, t);
      Class.prototype = pt = t;
    }
    pt.constructor != Class && ("function" != typeof Class && console.error("unknown Class:" + Class), pt.constructor = Class);
  }
  function DOMException(code, message) {
    if (message instanceof Error) {
      var error = message;
    } else {
      error = this, Error.call(this, ExceptionMessage[code]), this.message = ExceptionMessage[code], Error.captureStackTrace && Error.captureStackTrace(this, DOMException);
    }
    error.code = code;
    message && (this.message = this.message + ": " + message);
    return error;
  }
  function NodeList() {
  }
  function LiveNodeList(node, refresh) {
    this._node = node;
    this._refresh = refresh;
    _updateLiveList(this);
  }
  function _updateLiveList(list) {
    var inc = list._node._inc || list._node.ownerDocument._inc;
    if (list._inc !== inc) {
      var ls = list._refresh(list._node);
      __set__(list, "length", ls.length);
      if (!list.$$length || ls.length < list.$$length) {
        for (var i = ls.length; i in list; i++) {
          Object.prototype.hasOwnProperty.call(list, i) && delete list[i];
        }
      }
      copy(ls, list);
      list._inc = inc;
    }
  }
  function NamedNodeMap() {
  }
  function _findNodeIndex(list, node) {
    for (var i = list.length; i--;) {
      if (list[i] === node) {
        return i;
      }
    }
  }
  function _addNamedNode(el, list, newAttr, oldAttr) {
    oldAttr ? list[_findNodeIndex(list, oldAttr)] = newAttr : list[list.length++] = newAttr;
    el && (newAttr.ownerElement = el, list = el.ownerDocument) && (oldAttr && (list && list._inc++, oldAttr.namespaceURI === NAMESPACE.XMLNS && delete el._nsMap[oldAttr.prefix ? oldAttr.localName : ""]), list && list._inc++, newAttr.namespaceURI === NAMESPACE.XMLNS && (el._nsMap[newAttr.prefix ? newAttr.localName : ""] = newAttr.value));
  }
  function _removeNamedNode(el, list, attr) {
    var i = _findNodeIndex(list, attr);
    if (0 <= i) {
      for (var lastIndex = list.length - 1; i < lastIndex;) {
        list[i] = list[++i];
      }
      list.length = lastIndex;
      el && (list = el.ownerDocument) && (list && list._inc++, attr.namespaceURI === NAMESPACE.XMLNS && delete el._nsMap[attr.prefix ? attr.localName : ""], attr.ownerElement = null);
    } else {
      throw new DOMException(NOT_FOUND_ERR, Error(el.tagName + "@" + attr));
    }
  }
  function DOMImplementation() {
  }
  function Node() {
  }
  function _xmlEncoder(c) {
    return "\x3c" == c && "\x26lt;" || "\x3e" == c && "\x26gt;" || "\x26" == c && "\x26amp;" || '"' == c && "\x26quot;" || "\x26#" + c.charCodeAt() + ";";
  }
  function _visitNode(node, callback) {
    if (callback(node)) {
      return !0;
    }
    if (node = node.firstChild) {
      do {
        if (_visitNode(node, callback)) {
          return !0;
        }
      } while (node = node.nextSibling);
    }
  }
  function Document() {
    this.ownerDocument = this;
  }
  function _onUpdateChild(doc, el, newChild) {
    if (doc && doc._inc) {
      if (doc._inc++, doc = el.childNodes, newChild) {
        doc[doc.length++] = newChild;
      } else {
        el = el.firstChild;
        for (newChild = 0; el;) {
          doc[newChild++] = el, el = el.nextSibling;
        }
        doc.length = newChild;
        delete doc[doc.length];
      }
    }
  }
  function _removeChild(parentNode, child) {
    var previous = child.previousSibling, next = child.nextSibling;
    previous ? previous.nextSibling = next : parentNode.firstChild = next;
    next ? next.previousSibling = previous : parentNode.lastChild = previous;
    child.parentNode = null;
    child.previousSibling = null;
    child.nextSibling = null;
    _onUpdateChild(parentNode.ownerDocument, parentNode);
    return child;
  }
  function isDocTypeNode(node) {
    return node && node.nodeType === Node.DOCUMENT_TYPE_NODE;
  }
  function isElementNode(node) {
    return node && node.nodeType === Node.ELEMENT_NODE;
  }
  function isTextNode(node) {
    return node && node.nodeType === Node.TEXT_NODE;
  }
  function isElementInsertionPossible(doc, child) {
    doc = doc.childNodes || [];
    if (find(doc, isElementNode) || isDocTypeNode(child)) {
      return !1;
    }
    var docTypeNode = find(doc, isDocTypeNode);
    return !(child && docTypeNode && doc.indexOf(docTypeNode) > doc.indexOf(child));
  }
  function isElementReplacementPossible(doc, child) {
    doc = doc.childNodes || [];
    if (find(doc, function(node) {
      return isElementNode(node) && node !== child;
    })) {
      return !1;
    }
    var docTypeNode = find(doc, isDocTypeNode);
    return !(child && docTypeNode && doc.indexOf(docTypeNode) > doc.indexOf(child));
  }
  function assertPreInsertionValidityInDocument(parent, node, child) {
    var parentChildNodes = parent.childNodes || [], nodeChildNodes = node.childNodes || [];
    if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
      var nodeChildElements = nodeChildNodes.filter(isElementNode);
      if (1 < nodeChildElements.length || find(nodeChildNodes, isTextNode)) {
        throw new DOMException(HIERARCHY_REQUEST_ERR, "More than one element or text in fragment");
      }
      if (1 === nodeChildElements.length && !isElementInsertionPossible(parent, child)) {
        throw new DOMException(HIERARCHY_REQUEST_ERR, "Element in fragment can not be inserted before doctype");
      }
    }
    if (isElementNode(node) && !isElementInsertionPossible(parent, child)) {
      throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one element can be added and only after doctype");
    }
    if (isDocTypeNode(node)) {
      if (find(parentChildNodes, isDocTypeNode)) {
        throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one doctype is allowed");
      }
      parent = find(parentChildNodes, isElementNode);
      if (child && parentChildNodes.indexOf(parent) < parentChildNodes.indexOf(child)) {
        throw new DOMException(HIERARCHY_REQUEST_ERR, "Doctype can only be inserted before an element");
      }
      if (!child && parent) {
        throw new DOMException(HIERARCHY_REQUEST_ERR, "Doctype can not be appended since element is present");
      }
    }
  }
  function assertPreReplacementValidityInDocument(parent, node, child) {
    var parentChildNodes = parent.childNodes || [], nodeChildNodes = node.childNodes || [];
    if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
      var nodeChildElements = nodeChildNodes.filter(isElementNode);
      if (1 < nodeChildElements.length || find(nodeChildNodes, isTextNode)) {
        throw new DOMException(HIERARCHY_REQUEST_ERR, "More than one element or text in fragment");
      }
      if (1 === nodeChildElements.length && !isElementReplacementPossible(parent, child)) {
        throw new DOMException(HIERARCHY_REQUEST_ERR, "Element in fragment can not be inserted before doctype");
      }
    }
    if (isElementNode(node) && !isElementReplacementPossible(parent, child)) {
      throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one element can be added and only after doctype");
    }
    if (isDocTypeNode(node)) {
      if (find(parentChildNodes, function(node) {
        return isDocTypeNode(node) && node !== child;
      })) {
        throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one doctype is allowed");
      }
      parent = find(parentChildNodes, isElementNode);
      if (child && parentChildNodes.indexOf(parent) < parentChildNodes.indexOf(child)) {
        throw new DOMException(HIERARCHY_REQUEST_ERR, "Doctype can only be inserted before an element");
      }
    }
  }
  function _insertBefore(parent, node, child, _inDocumentAssertion) {
    if (!parent || parent.nodeType !== Node.DOCUMENT_NODE && parent.nodeType !== Node.DOCUMENT_FRAGMENT_NODE && parent.nodeType !== Node.ELEMENT_NODE) {
      throw new DOMException(HIERARCHY_REQUEST_ERR, "Unexpected parent node type " + parent.nodeType);
    }
    if (child && child.parentNode !== parent) {
      throw new DOMException(NOT_FOUND_ERR, "child not in parent");
    }
    if (!node || !(isElementNode(node) || isTextNode(node) || isDocTypeNode(node) || node.nodeType === Node.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node.COMMENT_NODE || node.nodeType === Node.PROCESSING_INSTRUCTION_NODE) || isDocTypeNode(node) && parent.nodeType !== Node.DOCUMENT_NODE) {
      throw new DOMException(HIERARCHY_REQUEST_ERR, "Unexpected node type " + node.nodeType + " for parent node type " + parent.nodeType);
    }
    parent.nodeType === Node.DOCUMENT_NODE && (_inDocumentAssertion || assertPreInsertionValidityInDocument)(parent, node, child);
    (_inDocumentAssertion = node.parentNode) && _inDocumentAssertion.removeChild(node);
    if (node.nodeType === DOCUMENT_FRAGMENT_NODE) {
      _inDocumentAssertion = node.firstChild;
      if (null == _inDocumentAssertion) {
        return node;
      }
      var newLast = node.lastChild;
    } else {
      _inDocumentAssertion = newLast = node;
    }
    var pre = child ? child.previousSibling : parent.lastChild;
    _inDocumentAssertion.previousSibling = pre;
    newLast.nextSibling = child;
    pre ? pre.nextSibling = _inDocumentAssertion : parent.firstChild = _inDocumentAssertion;
    null == child ? parent.lastChild = newLast : child.previousSibling = newLast;
    do {
      _inDocumentAssertion.parentNode = parent;
    } while (_inDocumentAssertion !== newLast && (_inDocumentAssertion = _inDocumentAssertion.nextSibling));
    _onUpdateChild(parent.ownerDocument || parent, parent);
    node.nodeType == DOCUMENT_FRAGMENT_NODE && (node.firstChild = node.lastChild = null);
    return node;
  }
  function Element() {
    this._nsMap = {};
  }
  function Attr() {
  }
  function CharacterData() {
  }
  function Text() {
  }
  function Comment() {
  }
  function CDATASection() {
  }
  function DocumentType() {
  }
  function Notation() {
  }
  function Entity() {
  }
  function EntityReference() {
  }
  function DocumentFragment() {
  }
  function ProcessingInstruction() {
  }
  function XMLSerializer() {
  }
  function nodeSerializeToString(isHtml, nodeFilter) {
    var buf = [], refNode = 9 == this.nodeType && this.documentElement || this, prefix = refNode.prefix, uri = refNode.namespaceURI;
    if (uri && null == prefix && (prefix = refNode.lookupPrefix(uri), null == prefix)) {
      var visibleNamespaces = [{namespace:uri, prefix:null}];
    }
    serializeToString(this, buf, isHtml, nodeFilter, visibleNamespaces);
    return buf.join("");
  }
  function needNamespaceDefine(node, isHTML, visibleNamespaces) {
    isHTML = node.prefix || "";
    node = node.namespaceURI;
    if (!node || "xml" === isHTML && node === NAMESPACE.XML || node === NAMESPACE.XMLNS) {
      return !1;
    }
    for (var i = visibleNamespaces.length; i--;) {
      var ns = visibleNamespaces[i];
      if (ns.prefix === isHTML) {
        return ns.namespace !== node;
      }
    }
    return !0;
  }
  function addSerializedAttribute(buf, qualifiedName, value) {
    buf.push(" ", qualifiedName, '\x3d"', value.replace(/[<>&"\t\n\r]/g, _xmlEncoder), '"');
  }
  function serializeToString(node, buf, isHTML, nodeFilter, visibleNamespaces) {
    visibleNamespaces || (visibleNamespaces = []);
    if (nodeFilter) {
      if (node = nodeFilter(node)) {
        if ("string" == typeof node) {
          buf.push(node);
          return;
        }
      } else {
        return;
      }
    }
    switch(node.nodeType) {
      case ELEMENT_NODE:
        var attrs = node.attributes, len = attrs.length, child = node.firstChild, nodeName = node.tagName;
        isHTML = NAMESPACE.isHTML(node.namespaceURI) || isHTML;
        var prefixedNodeName = nodeName;
        if (!isHTML && !node.prefix && node.namespaceURI) {
          for (var defaultNS, ai = 0; ai < attrs.length; ai++) {
            if ("xmlns" === attrs.item(ai).name) {
              defaultNS = attrs.item(ai).value;
              break;
            }
          }
          if (!defaultNS) {
            for (ai = visibleNamespaces.length - 1; 0 <= ai; ai--) {
              var namespace = visibleNamespaces[ai];
              if ("" === namespace.prefix && namespace.namespace === node.namespaceURI) {
                defaultNS = namespace.namespace;
                break;
              }
            }
          }
          if (defaultNS !== node.namespaceURI) {
            for (ai = visibleNamespaces.length - 1; 0 <= ai; ai--) {
              if (namespace = visibleNamespaces[ai], namespace.namespace === node.namespaceURI) {
                namespace.prefix && (prefixedNodeName = namespace.prefix + ":" + nodeName);
                break;
              }
            }
          }
        }
        buf.push("\x3c", prefixedNodeName);
        for (defaultNS = 0; defaultNS < len; defaultNS++) {
          ai = attrs.item(defaultNS), "xmlns" == ai.prefix ? visibleNamespaces.push({prefix:ai.localName, namespace:ai.value}) : "xmlns" == ai.nodeName && visibleNamespaces.push({prefix:"", namespace:ai.value});
        }
        for (defaultNS = 0; defaultNS < len; defaultNS++) {
          ai = attrs.item(defaultNS);
          if (needNamespaceDefine(ai, isHTML, visibleNamespaces)) {
            namespace = ai.prefix || "";
            var uri = ai.namespaceURI;
            addSerializedAttribute(buf, namespace ? "xmlns:" + namespace : "xmlns", uri);
            visibleNamespaces.push({prefix:namespace, namespace:uri});
          }
          serializeToString(ai, buf, isHTML, nodeFilter, visibleNamespaces);
        }
        nodeName === prefixedNodeName && needNamespaceDefine(node, isHTML, visibleNamespaces) && (namespace = node.prefix || "", uri = node.namespaceURI, addSerializedAttribute(buf, namespace ? "xmlns:" + namespace : "xmlns", uri), visibleNamespaces.push({prefix:namespace, namespace:uri}));
        if (child || isHTML && !/^(?:meta|link|img|br|hr|input)$/i.test(nodeName)) {
          buf.push("\x3e");
          if (isHTML && /^script$/i.test(nodeName)) {
            for (; child;) {
              child.data ? buf.push(child.data) : serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice()), child = child.nextSibling;
            }
          } else {
            for (; child;) {
              serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice()), child = child.nextSibling;
            }
          }
          buf.push("\x3c/", prefixedNodeName, "\x3e");
        } else {
          buf.push("/\x3e");
        }
        break;
      case DOCUMENT_NODE:
      case DOCUMENT_FRAGMENT_NODE:
        for (child = node.firstChild; child;) {
          serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice()), child = child.nextSibling;
        }
        break;
      case ATTRIBUTE_NODE:
        return addSerializedAttribute(buf, node.name, node.value);
      case TEXT_NODE:
        return buf.push(node.data.replace(/[<&>]/g, _xmlEncoder));
      case CDATA_SECTION_NODE:
        return buf.push("\x3c![CDATA[", node.data, "]]\x3e");
      case COMMENT_NODE:
        return buf.push("\x3c!--", node.data, "--\x3e");
      case DOCUMENT_TYPE_NODE:
        isHTML = node.publicId;
        nodeFilter = node.systemId;
        buf.push("\x3c!DOCTYPE ", node.name);
        isHTML ? (buf.push(" PUBLIC ", isHTML), nodeFilter && "." != nodeFilter && buf.push(" ", nodeFilter), buf.push("\x3e")) : nodeFilter && "." != nodeFilter ? buf.push(" SYSTEM ", nodeFilter, "\x3e") : ((node = node.internalSubset) && buf.push(" [", node, "]"), buf.push("\x3e"));
        break;
      case PROCESSING_INSTRUCTION_NODE:
        return buf.push("\x3c?", node.target, " ", node.data, "?\x3e");
      case ENTITY_REFERENCE_NODE:
        return buf.push("\x26", node.nodeName, ";");
      default:
        buf.push("??", node.nodeName);
    }
  }
  function importNode(doc, node, deep) {
    switch(node.nodeType) {
      case ELEMENT_NODE:
        var node2 = node.cloneNode(!1);
        node2.ownerDocument = doc;
      case DOCUMENT_FRAGMENT_NODE:
        break;
      case ATTRIBUTE_NODE:
        deep = !0;
    }
    node2 || (node2 = node.cloneNode(!1));
    node2.ownerDocument = doc;
    node2.parentNode = null;
    if (deep) {
      for (node = node.firstChild; node;) {
        node2.appendChild(importNode(doc, node, deep)), node = node.nextSibling;
      }
    }
    return node2;
  }
  function cloneNode(doc, node, deep) {
    var node2 = new node.constructor();
    for (n in node) {
      if (Object.prototype.hasOwnProperty.call(node, n)) {
        var v = node[n];
        "object" != typeof v && v != node2[n] && (node2[n] = v);
      }
    }
    node.childNodes && (node2.childNodes = new NodeList());
    node2.ownerDocument = doc;
    switch(node2.nodeType) {
      case ELEMENT_NODE:
        var n = node.attributes;
        var attrs2 = node2.attributes = new NamedNodeMap();
        v = n.length;
        attrs2._ownerElement = node2;
        for (attrs2 = 0; attrs2 < v; attrs2++) {
          node2.setAttributeNode(cloneNode(doc, n.item(attrs2), !0));
        }
        break;
      case ATTRIBUTE_NODE:
        deep = !0;
    }
    if (deep) {
      for (node = node.firstChild; node;) {
        node2.appendChild(cloneNode(doc, node, deep)), node = node.nextSibling;
      }
    }
    return node2;
  }
  function __set__(object, key, value) {
    object[key] = value;
  }
  global = require("module$node_modules$$xmldom$xmldom$lib$conventions");
  var find = global.find, NAMESPACE = global.NAMESPACE;
  global = {};
  var ELEMENT_NODE = global.ELEMENT_NODE = 1, ATTRIBUTE_NODE = global.ATTRIBUTE_NODE = 2, TEXT_NODE = global.TEXT_NODE = 3, CDATA_SECTION_NODE = global.CDATA_SECTION_NODE = 4, ENTITY_REFERENCE_NODE = global.ENTITY_REFERENCE_NODE = 5;
  require = global.ENTITY_NODE = 6;
  var PROCESSING_INSTRUCTION_NODE = global.PROCESSING_INSTRUCTION_NODE = 7, COMMENT_NODE = global.COMMENT_NODE = 8, DOCUMENT_NODE = global.DOCUMENT_NODE = 9, DOCUMENT_TYPE_NODE = global.DOCUMENT_TYPE_NODE = 10, DOCUMENT_FRAGMENT_NODE = global.DOCUMENT_FRAGMENT_NODE = 11;
  module = global.NOTATION_NODE = 12;
  var ExceptionCode = {}, ExceptionMessage = {};
  ExceptionCode.INDEX_SIZE_ERR = (ExceptionMessage[1] = "Index size error", 1);
  ExceptionCode.DOMSTRING_SIZE_ERR = (ExceptionMessage[2] = "DOMString size error", 2);
  var HIERARCHY_REQUEST_ERR = ExceptionCode.HIERARCHY_REQUEST_ERR = (ExceptionMessage[3] = "Hierarchy request error", 3);
  ExceptionCode.WRONG_DOCUMENT_ERR = (ExceptionMessage[4] = "Wrong document", 4);
  ExceptionCode.INVALID_CHARACTER_ERR = (ExceptionMessage[5] = "Invalid character", 5);
  ExceptionCode.NO_DATA_ALLOWED_ERR = (ExceptionMessage[6] = "No data allowed", 6);
  ExceptionCode.NO_MODIFICATION_ALLOWED_ERR = (ExceptionMessage[7] = "No modification allowed", 7);
  var NOT_FOUND_ERR = ExceptionCode.NOT_FOUND_ERR = (ExceptionMessage[8] = "Not found", 8);
  ExceptionCode.NOT_SUPPORTED_ERR = (ExceptionMessage[9] = "Not supported", 9);
  var INUSE_ATTRIBUTE_ERR = ExceptionCode.INUSE_ATTRIBUTE_ERR = (ExceptionMessage[10] = "Attribute in use", 10);
  ExceptionCode.INVALID_STATE_ERR = (ExceptionMessage[11] = "Invalid state", 11);
  ExceptionCode.SYNTAX_ERR = (ExceptionMessage[12] = "Syntax error", 12);
  ExceptionCode.INVALID_MODIFICATION_ERR = (ExceptionMessage[13] = "Invalid modification", 13);
  ExceptionCode.NAMESPACE_ERR = (ExceptionMessage[14] = "Invalid namespace", 14);
  ExceptionCode.INVALID_ACCESS_ERR = (ExceptionMessage[15] = "Invalid access", 15);
  DOMException.prototype = Error.prototype;
  copy(ExceptionCode, DOMException);
  NodeList.prototype = {length:0, item:function(index) {
    return 0 <= index && index < this.length ? this[index] : null;
  }, toString:function(isHTML, nodeFilter) {
    for (var buf = [], i = 0; i < this.length; i++) {
      serializeToString(this[i], buf, isHTML, nodeFilter);
    }
    return buf.join("");
  }, filter:function(predicate) {
    return Array.prototype.filter.call(this, predicate);
  }, indexOf:function(item) {
    return Array.prototype.indexOf.call(this, item);
  }};
  LiveNodeList.prototype.item = function(i) {
    _updateLiveList(this);
    return this[i] || null;
  };
  _extends(LiveNodeList, NodeList);
  NamedNodeMap.prototype = {length:0, item:NodeList.prototype.item, getNamedItem:function(key) {
    for (var i = this.length; i--;) {
      var attr = this[i];
      if (attr.nodeName == key) {
        return attr;
      }
    }
  }, setNamedItem:function(attr) {
    var el = attr.ownerElement;
    if (el && el != this._ownerElement) {
      throw new DOMException(INUSE_ATTRIBUTE_ERR);
    }
    el = this.getNamedItem(attr.nodeName);
    _addNamedNode(this._ownerElement, this, attr, el);
    return el;
  }, setNamedItemNS:function(attr) {
    var el = attr.ownerElement;
    if (el && el != this._ownerElement) {
      throw new DOMException(INUSE_ATTRIBUTE_ERR);
    }
    el = this.getNamedItemNS(attr.namespaceURI, attr.localName);
    _addNamedNode(this._ownerElement, this, attr, el);
    return el;
  }, removeNamedItem:function(key) {
    key = this.getNamedItem(key);
    _removeNamedNode(this._ownerElement, this, key);
    return key;
  }, removeNamedItemNS:function(namespaceURI, localName) {
    namespaceURI = this.getNamedItemNS(namespaceURI, localName);
    _removeNamedNode(this._ownerElement, this, namespaceURI);
    return namespaceURI;
  }, getNamedItemNS:function(namespaceURI, localName) {
    for (var i = this.length; i--;) {
      var node = this[i];
      if (node.localName == localName && node.namespaceURI == namespaceURI) {
        return node;
      }
    }
    return null;
  }};
  DOMImplementation.prototype = {hasFeature:function(feature, version) {
    return !0;
  }, createDocument:function(namespaceURI, qualifiedName, doctype) {
    var doc = new Document();
    doc.implementation = this;
    doc.childNodes = new NodeList();
    doc.doctype = doctype || null;
    doctype && doc.appendChild(doctype);
    qualifiedName && (namespaceURI = doc.createElementNS(namespaceURI, qualifiedName), doc.appendChild(namespaceURI));
    return doc;
  }, createDocumentType:function(qualifiedName, publicId, systemId) {
    var node = new DocumentType();
    node.name = qualifiedName;
    node.nodeName = qualifiedName;
    node.publicId = publicId || "";
    node.systemId = systemId || "";
    return node;
  }};
  Node.prototype = {firstChild:null, lastChild:null, previousSibling:null, nextSibling:null, attributes:null, parentNode:null, childNodes:null, ownerDocument:null, nodeValue:null, namespaceURI:null, prefix:null, localName:null, insertBefore:function(newChild, refChild) {
    return _insertBefore(this, newChild, refChild);
  }, replaceChild:function(newChild, oldChild) {
    _insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);
    oldChild && this.removeChild(oldChild);
  }, removeChild:function(oldChild) {
    return _removeChild(this, oldChild);
  }, appendChild:function(newChild) {
    return this.insertBefore(newChild, null);
  }, hasChildNodes:function() {
    return null != this.firstChild;
  }, cloneNode:function(deep) {
    return cloneNode(this.ownerDocument || this, this, deep);
  }, normalize:function() {
    for (var child = this.firstChild; child;) {
      var next = child.nextSibling;
      next && next.nodeType == TEXT_NODE && child.nodeType == TEXT_NODE ? (this.removeChild(next), child.appendData(next.data)) : (child.normalize(), child = next);
    }
  }, isSupported:function(feature, version) {
    return this.ownerDocument.implementation.hasFeature(feature, version);
  }, hasAttributes:function() {
    return 0 < this.attributes.length;
  }, lookupPrefix:function(namespaceURI) {
    for (var el = this; el;) {
      var map = el._nsMap;
      if (map) {
        for (var n in map) {
          if (Object.prototype.hasOwnProperty.call(map, n) && map[n] === namespaceURI) {
            return n;
          }
        }
      }
      el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;
    }
    return null;
  }, lookupNamespaceURI:function(prefix) {
    for (var el = this; el;) {
      var map = el._nsMap;
      if (map && Object.prototype.hasOwnProperty.call(map, prefix)) {
        return map[prefix];
      }
      el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;
    }
    return null;
  }, isDefaultNamespace:function(namespaceURI) {
    return null == this.lookupPrefix(namespaceURI);
  }};
  copy(global, Node);
  copy(global, Node.prototype);
  Document.prototype = {nodeName:"#document", nodeType:DOCUMENT_NODE, doctype:null, documentElement:null, _inc:1, insertBefore:function(newChild, refChild) {
    if (newChild.nodeType == DOCUMENT_FRAGMENT_NODE) {
      for (var child = newChild.firstChild; child;) {
        var next = child.nextSibling;
        this.insertBefore(child, refChild);
        child = next;
      }
      return newChild;
    }
    _insertBefore(this, newChild, refChild);
    newChild.ownerDocument = this;
    null === this.documentElement && newChild.nodeType === ELEMENT_NODE && (this.documentElement = newChild);
    return newChild;
  }, removeChild:function(oldChild) {
    this.documentElement == oldChild && (this.documentElement = null);
    return _removeChild(this, oldChild);
  }, replaceChild:function(newChild, oldChild) {
    _insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);
    newChild.ownerDocument = this;
    oldChild && this.removeChild(oldChild);
    isElementNode(newChild) && (this.documentElement = newChild);
  }, importNode:function(importedNode, deep) {
    return importNode(this, importedNode, deep);
  }, getElementById:function(id) {
    var rtv = null;
    _visitNode(this.documentElement, function(node) {
      if (node.nodeType == ELEMENT_NODE && node.getAttribute("id") == id) {
        return rtv = node, !0;
      }
    });
    return rtv;
  }, getElementsByClassName:function(classNames) {
    var classNamesSet = toOrderedSet(classNames);
    return new LiveNodeList(this, function(base) {
      var ls = [];
      0 < classNamesSet.length && _visitNode(base.documentElement, function(node) {
        if (node !== base && node.nodeType === ELEMENT_NODE) {
          var nodeClassNames = node.getAttribute("class");
          if (nodeClassNames) {
            var matches = classNames === nodeClassNames;
            matches || (nodeClassNames = toOrderedSet(nodeClassNames), matches = classNamesSet.every(arrayIncludes(nodeClassNames)));
            matches && ls.push(node);
          }
        }
      });
      return ls;
    });
  }, createElement:function(tagName) {
    var node = new Element();
    node.ownerDocument = this;
    node.nodeName = tagName;
    node.tagName = tagName;
    node.localName = tagName;
    node.childNodes = new NodeList();
    return (node.attributes = new NamedNodeMap())._ownerElement = node;
  }, createDocumentFragment:function() {
    var node = new DocumentFragment();
    node.ownerDocument = this;
    node.childNodes = new NodeList();
    return node;
  }, createTextNode:function(data) {
    var node = new Text();
    node.ownerDocument = this;
    node.appendData(data);
    return node;
  }, createComment:function(data) {
    var node = new Comment();
    node.ownerDocument = this;
    node.appendData(data);
    return node;
  }, createCDATASection:function(data) {
    var node = new CDATASection();
    node.ownerDocument = this;
    node.appendData(data);
    return node;
  }, createProcessingInstruction:function(target, data) {
    var node = new ProcessingInstruction();
    node.ownerDocument = this;
    node.tagName = node.nodeName = node.target = target;
    node.nodeValue = node.data = data;
    return node;
  }, createAttribute:function(name) {
    var node = new Attr();
    node.ownerDocument = this;
    node.name = name;
    node.nodeName = name;
    node.localName = name;
    node.specified = !0;
    return node;
  }, createEntityReference:function(name) {
    var node = new EntityReference();
    node.ownerDocument = this;
    node.nodeName = name;
    return node;
  }, createElementNS:function(namespaceURI, qualifiedName) {
    var node = new Element(), pl = qualifiedName.split(":"), attrs = node.attributes = new NamedNodeMap();
    node.childNodes = new NodeList();
    node.ownerDocument = this;
    node.nodeName = qualifiedName;
    node.tagName = qualifiedName;
    node.namespaceURI = namespaceURI;
    2 == pl.length ? (node.prefix = pl[0], node.localName = pl[1]) : node.localName = qualifiedName;
    return attrs._ownerElement = node;
  }, createAttributeNS:function(namespaceURI, qualifiedName) {
    var node = new Attr(), pl = qualifiedName.split(":");
    node.ownerDocument = this;
    node.nodeName = qualifiedName;
    node.name = qualifiedName;
    node.namespaceURI = namespaceURI;
    node.specified = !0;
    2 == pl.length ? (node.prefix = pl[0], node.localName = pl[1]) : node.localName = qualifiedName;
    return node;
  }};
  _extends(Document, Node);
  Element.prototype = {nodeType:ELEMENT_NODE, hasAttribute:function(name) {
    return null != this.getAttributeNode(name);
  }, getAttribute:function(name) {
    return (name = this.getAttributeNode(name)) && name.value || "";
  }, getAttributeNode:function(name) {
    return this.attributes.getNamedItem(name);
  }, setAttribute:function(name, value) {
    name = this.ownerDocument.createAttribute(name);
    name.value = name.nodeValue = "" + value;
    this.setAttributeNode(name);
  }, removeAttribute:function(name) {
    (name = this.getAttributeNode(name)) && this.removeAttributeNode(name);
  }, appendChild:function(newChild) {
    if (newChild.nodeType === DOCUMENT_FRAGMENT_NODE) {
      return this.insertBefore(newChild, null);
    }
    newChild.parentNode && newChild.parentNode.removeChild(newChild);
    newChild.parentNode = this;
    newChild.previousSibling = this.lastChild;
    newChild.nextSibling = null;
    newChild.previousSibling ? newChild.previousSibling.nextSibling = newChild : this.firstChild = newChild;
    this.lastChild = newChild;
    _onUpdateChild(this.ownerDocument, this, newChild);
    return newChild;
  }, setAttributeNode:function(newAttr) {
    return this.attributes.setNamedItem(newAttr);
  }, setAttributeNodeNS:function(newAttr) {
    return this.attributes.setNamedItemNS(newAttr);
  }, removeAttributeNode:function(oldAttr) {
    return this.attributes.removeNamedItem(oldAttr.nodeName);
  }, removeAttributeNS:function(namespaceURI, localName) {
    (namespaceURI = this.getAttributeNodeNS(namespaceURI, localName)) && this.removeAttributeNode(namespaceURI);
  }, hasAttributeNS:function(namespaceURI, localName) {
    return null != this.getAttributeNodeNS(namespaceURI, localName);
  }, getAttributeNS:function(namespaceURI, localName) {
    return (namespaceURI = this.getAttributeNodeNS(namespaceURI, localName)) && namespaceURI.value || "";
  }, setAttributeNS:function(namespaceURI, qualifiedName, value) {
    namespaceURI = this.ownerDocument.createAttributeNS(namespaceURI, qualifiedName);
    namespaceURI.value = namespaceURI.nodeValue = "" + value;
    this.setAttributeNode(namespaceURI);
  }, getAttributeNodeNS:function(namespaceURI, localName) {
    return this.attributes.getNamedItemNS(namespaceURI, localName);
  }, getElementsByTagName:function(tagName) {
    return new LiveNodeList(this, function(base) {
      var ls = [];
      _visitNode(base, function(node) {
        node === base || node.nodeType != ELEMENT_NODE || "*" !== tagName && node.tagName != tagName || ls.push(node);
      });
      return ls;
    });
  }, getElementsByTagNameNS:function(namespaceURI, localName) {
    return new LiveNodeList(this, function(base) {
      var ls = [];
      _visitNode(base, function(node) {
        node === base || node.nodeType !== ELEMENT_NODE || "*" !== namespaceURI && node.namespaceURI !== namespaceURI || "*" !== localName && node.localName != localName || ls.push(node);
      });
      return ls;
    });
  }};
  Document.prototype.getElementsByTagName = Element.prototype.getElementsByTagName;
  Document.prototype.getElementsByTagNameNS = Element.prototype.getElementsByTagNameNS;
  _extends(Element, Node);
  Attr.prototype.nodeType = ATTRIBUTE_NODE;
  _extends(Attr, Node);
  CharacterData.prototype = {data:"", substringData:function(offset, count) {
    return this.data.substring(offset, offset + count);
  }, appendData:function(text) {
    this.nodeValue = this.data = text = this.data + text;
    this.length = text.length;
  }, insertData:function(offset, text) {
    this.replaceData(offset, 0, text);
  }, appendChild:function(newChild) {
    throw Error(ExceptionMessage[HIERARCHY_REQUEST_ERR]);
  }, deleteData:function(offset, count) {
    this.replaceData(offset, count, "");
  }, replaceData:function(offset, count, text) {
    var start = this.data.substring(0, offset);
    offset = this.data.substring(offset + count);
    this.nodeValue = this.data = text = start + text + offset;
    this.length = text.length;
  }};
  _extends(CharacterData, Node);
  Text.prototype = {nodeName:"#text", nodeType:TEXT_NODE, splitText:function(offset) {
    var text = this.data, newText = text.substring(offset);
    this.data = this.nodeValue = text = text.substring(0, offset);
    this.length = text.length;
    offset = this.ownerDocument.createTextNode(newText);
    this.parentNode && this.parentNode.insertBefore(offset, this.nextSibling);
    return offset;
  }};
  _extends(Text, CharacterData);
  Comment.prototype = {nodeName:"#comment", nodeType:COMMENT_NODE};
  _extends(Comment, CharacterData);
  CDATASection.prototype = {nodeName:"#cdata-section", nodeType:CDATA_SECTION_NODE};
  _extends(CDATASection, CharacterData);
  DocumentType.prototype.nodeType = DOCUMENT_TYPE_NODE;
  _extends(DocumentType, Node);
  Notation.prototype.nodeType = module;
  _extends(Notation, Node);
  Entity.prototype.nodeType = require;
  _extends(Entity, Node);
  EntityReference.prototype.nodeType = ENTITY_REFERENCE_NODE;
  _extends(EntityReference, Node);
  DocumentFragment.prototype.nodeName = "#document-fragment";
  DocumentFragment.prototype.nodeType = DOCUMENT_FRAGMENT_NODE;
  _extends(DocumentFragment, Node);
  ProcessingInstruction.prototype.nodeType = PROCESSING_INSTRUCTION_NODE;
  _extends(ProcessingInstruction, Node);
  XMLSerializer.prototype.serializeToString = function(node, isHtml, nodeFilter) {
    return nodeSerializeToString.call(node, isHtml, nodeFilter);
  };
  Node.prototype.toString = nodeSerializeToString;
  try {
    if (Object.defineProperty) {
      Object.defineProperty(LiveNodeList.prototype, "length", {get:function() {
        _updateLiveList(this);
        return this.$$length;
      }});
      Object.defineProperty(Node.prototype, "textContent", {get:function() {
        return getTextContent(this);
      }, set:function(data) {
        switch(this.nodeType) {
          case ELEMENT_NODE:
          case DOCUMENT_FRAGMENT_NODE:
            for (; this.firstChild;) {
              this.removeChild(this.firstChild);
            }
            (data || String(data)) && this.appendChild(this.ownerDocument.createTextNode(data));
            break;
          default:
            this.nodeValue = this.value = this.data = data;
        }
      }});
      function getTextContent(node) {
        switch(node.nodeType) {
          case ELEMENT_NODE:
          case DOCUMENT_FRAGMENT_NODE:
            var buf = [];
            for (node = node.firstChild; node;) {
              7 !== node.nodeType && 8 !== node.nodeType && buf.push(getTextContent(node)), node = node.nextSibling;
            }
            return buf.join("");
          default:
            return node.nodeValue;
        }
      }
      __set__ = function(object, key, value) {
        object["$$" + key] = value;
      };
    }
  } catch (e) {
  }
  exports.DocumentType = DocumentType;
  exports.DOMException = DOMException;
  exports.DOMImplementation = DOMImplementation;
  exports.Element = Element;
  exports.Node = Node;
  exports.NodeList = NodeList;
  exports.XMLSerializer = XMLSerializer;
};

//# sourceMappingURL=module$node_modules$$xmldom$xmldom$lib$dom.js.map
