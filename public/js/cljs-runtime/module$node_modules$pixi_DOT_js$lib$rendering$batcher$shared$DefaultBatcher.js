shadow$provide.module$node_modules$pixi_DOT_js$lib$rendering$batcher$shared$DefaultBatcher = function(global, require, module, exports) {
  global = require("module$node_modules$pixi_DOT_js$lib$extensions$Extensions");
  module = require("module$node_modules$pixi_DOT_js$lib$rendering$batcher$shared$Batcher");
  var BatchGeometry = require("module$node_modules$pixi_DOT_js$lib$rendering$batcher$shared$BatchGeometry"), DefaultShader = require("module$node_modules$pixi_DOT_js$lib$rendering$batcher$shared$DefaultShader");
  "use strict";
  let defaultShader = null;
  const node_modules$pixi_DOT_js$lib$rendering$batcher$shared$DefaultBatcher$classdecl$var11 = class extends module.Batcher {
    constructor() {
      super(...arguments);
      this.geometry = new BatchGeometry.BatchGeometry();
      this.shader = defaultShader || (defaultShader = new DefaultShader.DefaultShader(this.maxTextures));
      this.name = node_modules$pixi_DOT_js$lib$rendering$batcher$shared$DefaultBatcher$classdecl$var11.extension.name;
      this.vertexSize = 6;
    }
    packAttributes(element, float32View, uint32View, index, textureId) {
      textureId = textureId << 16 | element.roundPixels & 65535;
      var wt = element.transform;
      const a = wt.a, b = wt.b, c = wt.c, d = wt.d, tx = wt.tx;
      wt = wt.ty;
      const {positions, uvs} = element, argb = element.color;
      var offset = element.attributeOffset;
      for (element = offset + element.attributeSize; offset < element; offset++) {
        const i2 = 2 * offset, x = positions[i2], y = positions[i2 + 1];
        float32View[index++] = a * x + c * y + tx;
        float32View[index++] = d * y + b * x + wt;
        float32View[index++] = uvs[i2];
        float32View[index++] = uvs[i2 + 1];
        uint32View[index++] = argb;
        uint32View[index++] = textureId;
      }
    }
    packQuadAttributes(element, float32View, uint32View, index, textureId) {
      var wt = element.transform;
      const a = wt.a, b = wt.b, c = wt.c, d = wt.d, tx = wt.tx;
      wt = wt.ty;
      var bounds = element.bounds;
      const w0 = bounds.maxX, w1 = bounds.minX, h0 = bounds.maxY;
      bounds = bounds.minY;
      const uvs = element.texture.uvs, argb = element.color;
      element = textureId << 16 | element.roundPixels & 65535;
      float32View[index + 0] = a * w1 + c * bounds + tx;
      float32View[index + 1] = d * bounds + b * w1 + wt;
      float32View[index + 2] = uvs.x0;
      float32View[index + 3] = uvs.y0;
      uint32View[index + 4] = argb;
      uint32View[index + 5] = element;
      float32View[index + 6] = a * w0 + c * bounds + tx;
      float32View[index + 7] = d * bounds + b * w0 + wt;
      float32View[index + 8] = uvs.x1;
      float32View[index + 9] = uvs.y1;
      uint32View[index + 10] = argb;
      uint32View[index + 11] = element;
      float32View[index + 12] = a * w0 + c * h0 + tx;
      float32View[index + 13] = d * h0 + b * w0 + wt;
      float32View[index + 14] = uvs.x2;
      float32View[index + 15] = uvs.y2;
      uint32View[index + 16] = argb;
      uint32View[index + 17] = element;
      float32View[index + 18] = a * w1 + c * h0 + tx;
      float32View[index + 19] = d * h0 + b * w1 + wt;
      float32View[index + 20] = uvs.x3;
      float32View[index + 21] = uvs.y3;
      uint32View[index + 22] = argb;
      uint32View[index + 23] = element;
    }
  };
  require = node_modules$pixi_DOT_js$lib$rendering$batcher$shared$DefaultBatcher$classdecl$var11;
  require.extension = {type:[global.ExtensionType.Batcher], name:"default"};
  exports.DefaultBatcher = require;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$rendering$batcher$shared$DefaultBatcher.js.map
