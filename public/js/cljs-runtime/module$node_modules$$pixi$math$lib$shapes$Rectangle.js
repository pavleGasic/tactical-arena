shadow$provide.module$node_modules$$pixi$math$lib$shapes$Rectangle = function(global, require, module, exports) {
  var _const = require("module$node_modules$$pixi$math$lib$const");
  global = require("module$node_modules$$pixi$math$lib$Point");
  const tempPoints = [new global.Point(), new global.Point(), new global.Point(), new global.Point()];
  class Rectangle {
    constructor(x = 0, y = 0, width = 0, height = 0) {
      this.x = Number(x);
      this.y = Number(y);
      this.width = Number(width);
      this.height = Number(height);
      this.type = _const.SHAPES.RECT;
    }
    get left() {
      return this.x;
    }
    get right() {
      return this.x + this.width;
    }
    get top() {
      return this.y;
    }
    get bottom() {
      return this.y + this.height;
    }
    static get EMPTY() {
      return new Rectangle(0, 0, 0, 0);
    }
    clone() {
      return new Rectangle(this.x, this.y, this.width, this.height);
    }
    copyFrom(rectangle) {
      return this.x = rectangle.x, this.y = rectangle.y, this.width = rectangle.width, this.height = rectangle.height, this;
    }
    copyTo(rectangle) {
      return rectangle.x = this.x, rectangle.y = this.y, rectangle.width = this.width, rectangle.height = this.height, rectangle;
    }
    contains(x, y) {
      return 0 >= this.width || 0 >= this.height ? !1 : x >= this.x && x < this.x + this.width && y >= this.y && y < this.y + this.height;
    }
    intersects(other, transform) {
      if (!transform) {
        return (this.right > other.right ? other.right : this.right) <= (this.x < other.x ? other.x : this.x) ? !1 : (this.bottom > other.bottom ? other.bottom : this.bottom) > (this.y < other.y ? other.y : this.y);
      }
      var x0 = this.left, x1 = this.right, y0 = this.top;
      const y1 = this.bottom;
      if (x1 <= x0 || y1 <= y0) {
        return !1;
      }
      const lt = tempPoints[0].set(other.left, other.top);
      var lb = tempPoints[1].set(other.left, other.bottom), rt = tempPoints[2].set(other.right, other.top);
      other = tempPoints[3].set(other.right, other.bottom);
      if (rt.x <= lt.x || lb.y <= lt.y) {
        return !1;
      }
      var s = Math.sign(transform.a * transform.d - transform.b * transform.c);
      if (0 === s || (transform.apply(lt, lt), transform.apply(lb, lb), transform.apply(rt, rt), transform.apply(other, other), Math.max(lt.x, lb.x, rt.x, other.x) <= x0 || Math.min(lt.x, lb.x, rt.x, other.x) >= x1 || Math.max(lt.y, lb.y, rt.y, other.y) <= y0 || Math.min(lt.y, lb.y, rt.y, other.y) >= y1)) {
        return !1;
      }
      transform = s * (lb.y - lt.y);
      lb = s * (lt.x - lb.x);
      const n00 = transform * x0 + lb * y0, n10 = transform * x1 + lb * y0, n01 = transform * x0 + lb * y1, n11 = transform * x1 + lb * y1;
      if (Math.max(n00, n10, n01, n11) <= transform * lt.x + lb * lt.y || Math.min(n00, n10, n01, n11) >= transform * other.x + lb * other.y) {
        return !1;
      }
      transform = s * (lt.y - rt.y);
      rt = s * (rt.x - lt.x);
      s = transform * x0 + rt * y0;
      y0 = transform * x1 + rt * y0;
      x0 = transform * x0 + rt * y1;
      x1 = transform * x1 + rt * y1;
      return !(Math.max(s, y0, x0, x1) <= transform * lt.x + rt * lt.y || Math.min(s, y0, x0, x1) >= transform * other.x + rt * other.y);
    }
    pad(paddingX = 0, paddingY = paddingX) {
      return this.x -= paddingX, this.y -= paddingY, this.width += 2 * paddingX, this.height += 2 * paddingY, this;
    }
    fit(rectangle) {
      const x1 = Math.max(this.x, rectangle.x), x2 = Math.min(this.x + this.width, rectangle.x + rectangle.width), y1 = Math.max(this.y, rectangle.y);
      rectangle = Math.min(this.y + this.height, rectangle.y + rectangle.height);
      return this.x = x1, this.width = Math.max(x2 - x1, 0), this.y = y1, this.height = Math.max(rectangle - y1, 0), this;
    }
    ceil(resolution = 1, eps = 1e-3) {
      const x2 = Math.ceil((this.x + this.width - eps) * resolution) / resolution, y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;
      return this.x = Math.floor((this.x + eps) * resolution) / resolution, this.y = Math.floor((this.y + eps) * resolution) / resolution, this.width = x2 - this.x, this.height = y2 - this.y, this;
    }
    enlarge(rectangle) {
      const x1 = Math.min(this.x, rectangle.x), x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width), y1 = Math.min(this.y, rectangle.y);
      rectangle = Math.max(this.y + this.height, rectangle.y + rectangle.height);
      return this.x = x1, this.width = x2 - x1, this.y = y1, this.height = rectangle - y1, this;
    }
  }
  Rectangle.prototype.toString = function() {
    return `[@pixi/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;
  };
  exports.Rectangle = Rectangle;
};

//# sourceMappingURL=module$node_modules$$pixi$math$lib$shapes$Rectangle.js.map
