shadow$provide.module$node_modules$pixi_DOT_js$lib$scene$text$canvas$CanvasTextPipe = function(global, require, module, exports) {
  global = require("module$node_modules$pixi_DOT_js$lib$extensions$Extensions");
  var PoolGroup = require("module$node_modules$pixi_DOT_js$lib$utils$pool$PoolGroup"), BatchableSprite = require("module$node_modules$pixi_DOT_js$lib$scene$sprite$BatchableSprite"), updateTextBounds = require("module$node_modules$pixi_DOT_js$lib$scene$text$utils$updateTextBounds");
  "use strict";
  class CanvasTextPipe {
    constructor(renderer) {
      this._gpuText = Object.create(null);
      this._destroyRenderableBound = this.destroyRenderable.bind(this);
      this._renderer = renderer;
      this._renderer.runners.resolutionChange.add(this);
      this._renderer.renderableGC.addManagedHash(this, "_gpuText");
    }
    resolutionChange() {
      for (const i in this._gpuText) {
        var gpuText = this._gpuText[i];
        gpuText && (gpuText = gpuText.batchableSprite.renderable, gpuText._autoResolution && (gpuText._resolution = this._renderer.resolution, gpuText.onViewUpdate()));
      }
    }
    validateRenderable(text) {
      const gpuText = this._getGpuText(text);
      text = text._getKey();
      return gpuText.currentKey !== text ? !0 : !1;
    }
    addRenderable(text, instructionSet) {
      const batchableSprite = this._getGpuText(text).batchableSprite;
      text._didTextUpdate && this._updateText(text);
      this._renderer.renderPipes.batch.addToBatch(batchableSprite, instructionSet);
    }
    updateRenderable(text) {
      const batchableSprite = this._getGpuText(text).batchableSprite;
      text._didTextUpdate && this._updateText(text);
      batchableSprite._batcher.updateElement(batchableSprite);
    }
    destroyRenderable(text) {
      text.off("destroyed", this._destroyRenderableBound);
      this._destroyRenderableById(text.uid);
    }
    _destroyRenderableById(textUid) {
      const gpuText = this._gpuText[textUid];
      this._renderer.canvasText.decreaseReferenceCount(gpuText.currentKey);
      PoolGroup.BigPool.return(gpuText.batchableSprite);
      this._gpuText[textUid] = null;
    }
    _updateText(text) {
      const newKey = text._getKey(), gpuText = this._getGpuText(text), batchableSprite = gpuText.batchableSprite;
      gpuText.currentKey !== newKey && this._updateGpuText(text);
      text._didTextUpdate = !1;
      updateTextBounds.updateTextBounds(batchableSprite, text);
    }
    _updateGpuText(text) {
      const gpuText = this._getGpuText(text), batchableSprite = gpuText.batchableSprite;
      gpuText.texture && this._renderer.canvasText.decreaseReferenceCount(gpuText.currentKey);
      gpuText.texture = batchableSprite.texture = this._renderer.canvasText.getManagedTexture(text);
      gpuText.currentKey = text._getKey();
      batchableSprite.texture = gpuText.texture;
    }
    _getGpuText(text) {
      return this._gpuText[text.uid] || this.initGpuText(text);
    }
    initGpuText(text) {
      const gpuTextData = {texture:null, currentKey:"--", batchableSprite:PoolGroup.BigPool.get(BatchableSprite.BatchableSprite)};
      gpuTextData.batchableSprite.renderable = text;
      gpuTextData.batchableSprite.transform = text.groupTransform;
      gpuTextData.batchableSprite.bounds = {minX:0, maxX:1, minY:0, maxY:0};
      gpuTextData.batchableSprite.roundPixels = this._renderer._roundPixels | text._roundPixels;
      this._gpuText[text.uid] = gpuTextData;
      text._resolution = text._autoResolution ? this._renderer.resolution : text.resolution;
      this._updateText(text);
      text.on("destroyed", this._destroyRenderableBound);
      return gpuTextData;
    }
    destroy() {
      for (const i in this._gpuText) {
        this._destroyRenderableById(i);
      }
      this._renderer = this._gpuText = null;
    }
  }
  CanvasTextPipe.extension = {type:[global.ExtensionType.WebGLPipes, global.ExtensionType.WebGPUPipes, global.ExtensionType.CanvasPipes], name:"text"};
  exports.CanvasTextPipe = CanvasTextPipe;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$scene$text$canvas$CanvasTextPipe.js.map
