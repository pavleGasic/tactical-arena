shadow$provide.module$node_modules$pixi_DOT_js$lib$scene$container$RenderGroup = function(global, require, module, exports) {
  var Matrix = require("module$node_modules$pixi_DOT_js$lib$maths$matrix$Matrix"), InstructionSet = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$instructions$InstructionSet"), TexturePool = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$texture$TexturePool");
  "use strict";
  class RenderGroup {
    constructor() {
      this.renderPipeId = "renderGroup";
      this.root = null;
      this.canBundle = !1;
      this.renderGroupParent = null;
      this.renderGroupChildren = [];
      this.worldTransform = new Matrix.Matrix();
      this.worldColorAlpha = 4294967295;
      this.worldColor = 16777215;
      this.worldAlpha = 1;
      this.childrenToUpdate = Object.create(null);
      this.gcTick = this.updateTick = 0;
      this.childrenRenderablesToUpdate = {list:[], index:0};
      this.structureDidChange = !0;
      this.instructionSet = new InstructionSet.InstructionSet();
      this._onRenderContainers = [];
      this.textureNeedsUpdate = !0;
      this.isCachedAsTexture = !1;
      this._matrixDirty = 7;
    }
    init(root) {
      this.root = root;
      root._onRender && this.addOnRender(root);
      root.didChange = !0;
      root = root.children;
      for (let i = 0; i < root.length; i++) {
        const child = root[i];
        child._updateFlags = 15;
        this.addChild(child);
      }
    }
    enableCacheAsTexture(options = {}) {
      this.textureOptions = options;
      this.textureNeedsUpdate = this.isCachedAsTexture = !0;
    }
    disableCacheAsTexture() {
      this.isCachedAsTexture = !1;
      this.texture && (TexturePool.TexturePool.returnTexture(this.texture), this.texture = null);
    }
    updateCacheTexture() {
      this.textureNeedsUpdate = !0;
    }
    reset() {
      this.renderGroupChildren.length = 0;
      for (const i in this.childrenToUpdate) {
        const childrenAtDepth = this.childrenToUpdate[i];
        childrenAtDepth.list.fill(null);
        childrenAtDepth.index = 0;
      }
      this.childrenRenderablesToUpdate.index = 0;
      this.childrenRenderablesToUpdate.list.fill(null);
      this.root = null;
      this.updateTick = 0;
      this.structureDidChange = !0;
      this._onRenderContainers.length = 0;
      this.renderGroupParent = null;
      this.disableCacheAsTexture();
    }
    get localTransform() {
      return this.root.localTransform;
    }
    addRenderGroupChild(renderGroupChild) {
      renderGroupChild.renderGroupParent && renderGroupChild.renderGroupParent._removeRenderGroupChild(renderGroupChild);
      renderGroupChild.renderGroupParent = this;
      this.renderGroupChildren.push(renderGroupChild);
    }
    _removeRenderGroupChild(renderGroupChild) {
      const index = this.renderGroupChildren.indexOf(renderGroupChild);
      -1 < index && this.renderGroupChildren.splice(index, 1);
      renderGroupChild.renderGroupParent = null;
    }
    addChild(child) {
      this.structureDidChange = !0;
      child.parentRenderGroup = this;
      child.updateTick = -1;
      child.relativeRenderGroupDepth = child.parent === this.root ? 1 : child.parent.relativeRenderGroupDepth + 1;
      child.didChange = !0;
      this.onChildUpdate(child);
      if (child.renderGroup) {
        this.addRenderGroupChild(child.renderGroup);
      } else {
        child._onRender && this.addOnRender(child);
        child = child.children;
        for (let i = 0; i < child.length; i++) {
          this.addChild(child[i]);
        }
      }
    }
    removeChild(child) {
      this.structureDidChange = !0;
      child._onRender && (child.renderGroup || this.removeOnRender(child));
      child.parentRenderGroup = null;
      if (child.renderGroup) {
        this._removeRenderGroupChild(child.renderGroup);
      } else {
        child = child.children;
        for (let i = 0; i < child.length; i++) {
          this.removeChild(child[i]);
        }
      }
    }
    removeChildren(children) {
      for (let i = 0; i < children.length; i++) {
        this.removeChild(children[i]);
      }
    }
    onChildUpdate(child) {
      let childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth];
      childrenToUpdate || (childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth] = {index:0, list:[]});
      childrenToUpdate.list[childrenToUpdate.index++] = child;
    }
    updateRenderable(renderable) {
      7 > renderable.globalDisplayStatus || (this.instructionSet.renderPipes[renderable.renderPipeId].updateRenderable(renderable), renderable.didViewUpdate = !1);
    }
    onChildViewUpdate(child) {
      this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++] = child;
    }
    get isRenderable() {
      return 7 === this.root.localDisplayStatus && 0 < this.worldAlpha;
    }
    addOnRender(container) {
      this._onRenderContainers.push(container);
    }
    removeOnRender(container) {
      this._onRenderContainers.splice(this._onRenderContainers.indexOf(container), 1);
    }
    runOnRender(renderer) {
      for (let i = 0; i < this._onRenderContainers.length; i++) {
        this._onRenderContainers[i]._onRender(renderer);
      }
    }
    destroy() {
      this.disableCacheAsTexture();
      this.instructionSet = this._onRenderContainers = this.renderGroupChildren = this.childrenToUpdate = this.childrenRenderablesToUpdate = this.root = this.renderGroupParent = null;
    }
    getChildren(out = []) {
      const children = this.root.children;
      for (let i = 0; i < children.length; i++) {
        this._getChildren(children[i], out);
      }
      return out;
    }
    _getChildren(container, out = []) {
      out.push(container);
      if (container.renderGroup) {
        return out;
      }
      container = container.children;
      for (let i = 0; i < container.length; i++) {
        this._getChildren(container[i], out);
      }
      return out;
    }
    invalidateMatrices() {
      this._matrixDirty = 7;
    }
    get inverseWorldTransform() {
      if (0 === (this._matrixDirty & 1)) {
        return this._inverseWorldTransform;
      }
      this._matrixDirty &= -2;
      this._inverseWorldTransform || (this._inverseWorldTransform = new Matrix.Matrix());
      return this._inverseWorldTransform.copyFrom(this.worldTransform).invert();
    }
    get textureOffsetInverseTransform() {
      if (0 === (this._matrixDirty & 2)) {
        return this._textureOffsetInverseTransform;
      }
      this._matrixDirty &= -3;
      this._textureOffsetInverseTransform || (this._textureOffsetInverseTransform = new Matrix.Matrix());
      return this._textureOffsetInverseTransform.copyFrom(this.inverseWorldTransform).translate(-this._textureBounds.x, -this._textureBounds.y);
    }
    get inverseParentTextureTransform() {
      if (0 === (this._matrixDirty & 4)) {
        return this._inverseParentTextureTransform;
      }
      this._matrixDirty &= -5;
      const parentCacheAsTexture = this._parentCacheAsTextureRenderGroup;
      return parentCacheAsTexture ? (this._inverseParentTextureTransform || (this._inverseParentTextureTransform = new Matrix.Matrix()), this._inverseParentTextureTransform.copyFrom(this.worldTransform).prepend(parentCacheAsTexture.inverseWorldTransform).translate(-parentCacheAsTexture._textureBounds.x, -parentCacheAsTexture._textureBounds.y)) : this.worldTransform;
    }
    get cacheToLocalTransform() {
      return this._parentCacheAsTextureRenderGroup ? this._parentCacheAsTextureRenderGroup.textureOffsetInverseTransform : null;
    }
  }
  exports.RenderGroup = RenderGroup;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$scene$container$RenderGroup.js.map
