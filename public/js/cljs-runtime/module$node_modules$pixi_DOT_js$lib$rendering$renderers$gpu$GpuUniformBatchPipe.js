shadow$provide.module$node_modules$pixi_DOT_js$lib$rendering$renderers$gpu$GpuUniformBatchPipe = function(global, require, module, exports) {
  global = require("module$node_modules$pixi_DOT_js$lib$extensions$Extensions");
  var Buffer = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$buffer$Buffer"), BufferResource = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$buffer$BufferResource"), _const = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$buffer$const"), UboBatch = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$gpu$buffer$UboBatch"), BindGroup = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$gpu$shader$BindGroup");
  "use strict";
  class GpuUniformBatchPipe {
    constructor(renderer) {
      this._bindGroupHash = Object.create(null);
      this._buffers = [];
      this._bindGroups = [];
      this._bufferResources = [];
      this._renderer = renderer;
      this._renderer.renderableGC.addManagedHash(this, "_bindGroupHash");
      this._batchBuffer = new UboBatch.UboBatch({minUniformOffsetAlignment:128});
      for (renderer = 0; 2 > renderer; renderer++) {
        let usage = _const.BufferUsage.UNIFORM | _const.BufferUsage.COPY_DST;
        0 === renderer && (usage |= _const.BufferUsage.COPY_SRC);
        this._buffers.push(new Buffer.Buffer({data:this._batchBuffer.data, usage}));
      }
    }
    renderEnd() {
      this._uploadBindGroups();
      this._resetBindGroups();
    }
    _resetBindGroups() {
      for (const i in this._bindGroupHash) {
        this._bindGroupHash[i] = null;
      }
      this._batchBuffer.clear();
    }
    getUniformBindGroup(group, duplicate) {
      if (!duplicate && this._bindGroupHash[group.uid]) {
        return this._bindGroupHash[group.uid];
      }
      this._renderer.ubo.ensureUniformGroup(group);
      duplicate = this._batchBuffer.addEmptyGroup(group.buffer.data.length);
      this._renderer.ubo.syncUniformGroup(group, this._batchBuffer.data, duplicate / 4);
      this._bindGroupHash[group.uid] = this._getBindGroup(duplicate / 128);
      return this._bindGroupHash[group.uid];
    }
    getUboResource(group) {
      this._renderer.ubo.updateUniformGroup(group);
      group = this._batchBuffer.addGroup(group.buffer.data);
      return this._getBufferResource(group / 128);
    }
    getArrayBindGroup(data) {
      data = this._batchBuffer.addGroup(data);
      return this._getBindGroup(data / 128);
    }
    getArrayBufferResource(data) {
      data = this._batchBuffer.addGroup(data) / 128;
      return this._getBufferResource(data);
    }
    _getBufferResource(index) {
      this._bufferResources[index] || (this._bufferResources[index] = new BufferResource.BufferResource({buffer:this._buffers[index % 2], offset:256 * (index / 2 | 0), size:128}));
      return this._bufferResources[index];
    }
    _getBindGroup(index) {
      if (!this._bindGroups[index]) {
        const bindGroup = new BindGroup.BindGroup({0:this._getBufferResource(index)});
        this._bindGroups[index] = bindGroup;
      }
      return this._bindGroups[index];
    }
    _uploadBindGroups() {
      const bufferSystem = this._renderer.buffer, firstBuffer = this._buffers[0];
      firstBuffer.update(this._batchBuffer.byteIndex);
      bufferSystem.updateBuffer(firstBuffer);
      const commandEncoder = this._renderer.gpu.device.createCommandEncoder();
      for (let i = 1; i < this._buffers.length; i++) {
        const buffer = this._buffers[i];
        commandEncoder.copyBufferToBuffer(bufferSystem.getGPUBuffer(firstBuffer), 128, bufferSystem.getGPUBuffer(buffer), 0, this._batchBuffer.byteIndex);
      }
      this._renderer.gpu.device.queue.submit([commandEncoder.finish()]);
    }
    destroy() {
      for (var i = 0; i < this._bindGroups.length; i++) {
        this._bindGroups[i].destroy();
      }
      this._bindGroupHash = this._bindGroups = null;
      for (i = 0; i < this._buffers.length; i++) {
        this._buffers[i].destroy();
      }
      this._buffers = null;
      for (i = 0; i < this._bufferResources.length; i++) {
        this._bufferResources[i].destroy();
      }
      this._bufferResources = null;
      this._batchBuffer.destroy();
      this._renderer = this._bindGroupHash = null;
    }
  }
  GpuUniformBatchPipe.extension = {type:[global.ExtensionType.WebGPUPipes], name:"uniformBatch"};
  exports.GpuUniformBatchPipe = GpuUniformBatchPipe;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$rendering$renderers$gpu$GpuUniformBatchPipe.js.map
