shadow$provide.module$node_modules$$pixi$graphics$lib$Graphics = function(global, require, module, exports) {
  var core = require("module$node_modules$$pixi$core$lib$index"), display = require("module$node_modules$$pixi$display$lib$index"), _const = require("module$node_modules$$pixi$graphics$lib$const"), GraphicsGeometry = require("module$node_modules$$pixi$graphics$lib$GraphicsGeometry"), FillStyle = require("module$node_modules$$pixi$graphics$lib$styles$FillStyle"), LineStyle = require("module$node_modules$$pixi$graphics$lib$styles$LineStyle");
  require("module$node_modules$$pixi$graphics$lib$utils$index");
  var QuadraticUtils = require("module$node_modules$$pixi$graphics$lib$utils$QuadraticUtils"), BezierUtils = require("module$node_modules$$pixi$graphics$lib$utils$BezierUtils"), ArcUtils = require("module$node_modules$$pixi$graphics$lib$utils$ArcUtils");
  const DEFAULT_SHADERS = {};
  global = (() => {
    const node_modules$$pixi$graphics$lib$Graphics$classdecl$var18 = class extends display.Container {
      constructor(geometry = null) {
        super();
        this.shader = null;
        this.pluginName = "batch";
        this.currentPath = null;
        this.batches = [];
        this.batchDirty = this.batchTint = -1;
        this.vertexData = null;
        this._fillStyle = new FillStyle.FillStyle();
        this._lineStyle = new LineStyle.LineStyle();
        this._matrix = null;
        this._holeMode = !1;
        this.state = core.State.for2d();
        this._geometry = geometry || new GraphicsGeometry.GraphicsGeometry();
        this._geometry.refCount++;
        this._transformID = -1;
        this._tintColor = new core.Color(16777215);
        this.blendMode = core.BLEND_MODES.NORMAL;
      }
      get geometry() {
        return this._geometry;
      }
      clone() {
        return this.finishPoly(), new node_modules$$pixi$graphics$lib$Graphics$classdecl$var18(this._geometry);
      }
      set blendMode(value) {
        this.state.blendMode = value;
      }
      get blendMode() {
        return this.state.blendMode;
      }
      get tint() {
        return this._tintColor.value;
      }
      set tint(value) {
        this._tintColor.setValue(value);
      }
      get fill() {
        return this._fillStyle;
      }
      get line() {
        return this._lineStyle;
      }
      lineStyle(options = null, color = 0, alpha, alignment = 0.5, native = !1) {
        return "number" == typeof options && (options = {width:options, color, alpha, alignment, native}), this.lineTextureStyle(options);
      }
      lineTextureStyle(options) {
        options = Object.assign({width:0, texture:core.Texture.WHITE, color:options?.texture ? 16777215 : 0, matrix:null, alignment:0.5, native:!1, cap:_const.LINE_CAP.BUTT, join:_const.LINE_JOIN.MITER, miterLimit:10}, options);
        this.normalizeColor(options);
        this.currentPath && this.startPoly();
        const visible = 0 < options.width && 0 < options.alpha;
        return visible ? (options.matrix && (options.matrix = options.matrix.clone(), options.matrix.invert()), Object.assign(this._lineStyle, {visible}, options)) : this._lineStyle.reset(), this;
      }
      startPoly() {
        if (this.currentPath) {
          const points = this.currentPath.points, len = this.currentPath.points.length;
          2 < len && (this.drawShape(this.currentPath), this.currentPath = new core.Polygon(), this.currentPath.closeStroke = !1, this.currentPath.points.push(points[len - 2], points[len - 1]));
        } else {
          this.currentPath = new core.Polygon(), this.currentPath.closeStroke = !1;
        }
      }
      finishPoly() {
        this.currentPath && (2 < this.currentPath.points.length ? (this.drawShape(this.currentPath), this.currentPath = null) : this.currentPath.points.length = 0);
      }
      moveTo(x, y) {
        return this.startPoly(), this.currentPath.points[0] = x, this.currentPath.points[1] = y, this;
      }
      lineTo(x, y) {
        this.currentPath || this.moveTo(0, 0);
        const points = this.currentPath.points, fromY = points[points.length - 1];
        return (points[points.length - 2] !== x || fromY !== y) && points.push(x, y), this;
      }
      _initCurve(x = 0, y = 0) {
        this.currentPath ? 0 === this.currentPath.points.length && (this.currentPath.points = [x, y]) : this.moveTo(x, y);
      }
      quadraticCurveTo(cpX, cpY, toX, toY) {
        this._initCurve();
        const points = this.currentPath.points;
        return 0 === points.length && this.moveTo(0, 0), QuadraticUtils.QuadraticUtils.curveTo(cpX, cpY, toX, toY, points), this;
      }
      bezierCurveTo(cpX, cpY, cpX2, cpY2, toX, toY) {
        return this._initCurve(), BezierUtils.BezierUtils.curveTo(cpX, cpY, cpX2, cpY2, toX, toY, this.currentPath.points), this;
      }
      arcTo(x1, y1, x2, y2, radius) {
        this._initCurve(x1, y1);
        if (x1 = ArcUtils.ArcUtils.curveTo(x1, y1, x2, y2, radius, this.currentPath.points)) {
          const {cx, cy, radius:radius2, startAngle, endAngle, anticlockwise} = x1;
          this.arc(cx, cy, radius2, startAngle, endAngle, anticlockwise);
        }
        return this;
      }
      arc(cx, cy, radius, startAngle, endAngle, anticlockwise = !1) {
        if (startAngle === endAngle || (!anticlockwise && endAngle <= startAngle ? endAngle += core.PI_2 : anticlockwise && startAngle <= endAngle && (startAngle += core.PI_2), 0 === endAngle - startAngle)) {
          return this;
        }
        const startX = cx + Math.cos(startAngle) * radius, startY = cy + Math.sin(startAngle) * radius, eps = this._geometry.closePointEps;
        let points = this.currentPath ? this.currentPath.points : null;
        if (points) {
          const yDiff = Math.abs(points[points.length - 1] - startY);
          Math.abs(points[points.length - 2] - startX) < eps && yDiff < eps || points.push(startX, startY);
        } else {
          this.moveTo(startX, startY), points = this.currentPath.points;
        }
        return ArcUtils.ArcUtils.arc(startX, startY, cx, cy, radius, startAngle, endAngle, anticlockwise, points), this;
      }
      beginFill(color = 0, alpha) {
        return this.beginTextureFill({texture:core.Texture.WHITE, color, alpha});
      }
      normalizeColor(options) {
        const temp = core.Color.shared.setValue(options.color ?? 0);
        options.color = temp.toNumber();
        options.alpha ?? (options.alpha = temp.alpha);
      }
      beginTextureFill(options) {
        options = Object.assign({texture:core.Texture.WHITE, color:16777215, matrix:null}, options);
        this.normalizeColor(options);
        this.currentPath && this.startPoly();
        const visible = 0 < options.alpha;
        return visible ? (options.matrix && (options.matrix = options.matrix.clone(), options.matrix.invert()), Object.assign(this._fillStyle, {visible}, options)) : this._fillStyle.reset(), this;
      }
      endFill() {
        return this.finishPoly(), this._fillStyle.reset(), this;
      }
      drawRect(x, y, width, height) {
        return this.drawShape(new core.Rectangle(x, y, width, height));
      }
      drawRoundedRect(x, y, width, height, radius) {
        return this.drawShape(new core.RoundedRectangle(x, y, width, height, radius));
      }
      drawCircle(x, y, radius) {
        return this.drawShape(new core.Circle(x, y, radius));
      }
      drawEllipse(x, y, width, height) {
        return this.drawShape(new core.Ellipse(x, y, width, height));
      }
      drawPolygon(...path) {
        let points, closeStroke = !0;
        const poly = path[0];
        poly.points ? (closeStroke = poly.closeStroke, points = poly.points) : Array.isArray(path[0]) ? points = path[0] : points = path;
        path = new core.Polygon(points);
        return path.closeStroke = closeStroke, this.drawShape(path), this;
      }
      drawShape(shape) {
        return this._holeMode ? this._geometry.drawHole(shape, this._matrix) : this._geometry.drawShape(shape, this._fillStyle.clone(), this._lineStyle.clone(), this._matrix), this;
      }
      clear() {
        return this._geometry.clear(), this._lineStyle.reset(), this._fillStyle.reset(), this._boundsID++, this._matrix = null, this._holeMode = !1, this.currentPath = null, this;
      }
      isFastRect() {
        const data = this._geometry.graphicsData;
        return 1 === data.length && data[0].shape.type === core.SHAPES.RECT && !data[0].matrix && !data[0].holes.length && !(data[0].lineStyle.visible && data[0].lineStyle.width);
      }
      _render(renderer) {
        this.finishPoly();
        const geometry = this._geometry;
        geometry.updateBatches();
        geometry.batchable ? (this.batchDirty !== geometry.batchDirty && this._populateBatches(), this._renderBatched(renderer)) : (renderer.batch.flush(), this._renderDirect(renderer));
      }
      _populateBatches() {
        const geometry = this._geometry, blendMode = this.blendMode, len = geometry.batches.length;
        this._transformID = this.batchTint = -1;
        this.batchDirty = geometry.batchDirty;
        this.batches.length = len;
        this.vertexData = new Float32Array(geometry.points);
        for (let i = 0; i < len; i++) {
          var gI = geometry.batches[i];
          const color = gI.style.color, vertexData = new Float32Array(this.vertexData.buffer, 8 * gI.attribStart, 2 * gI.attribSize), uvs = new Float32Array(geometry.uvsFloat32.buffer, 8 * gI.attribStart, 2 * gI.attribSize), indices = new Uint16Array(geometry.indicesUint16.buffer, 2 * gI.start, gI.size);
          gI = {vertexData, blendMode, indices, uvs, _batchRGB:core.Color.shared.setValue(color).toRgbArray(), _tintRGB:color, _texture:gI.style.texture, alpha:gI.style.alpha, worldAlpha:1};
          this.batches[i] = gI;
        }
      }
      _renderBatched(renderer) {
        if (this.batches.length) {
          renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);
          this.calculateVertices();
          this.calculateTints();
          for (let i = 0, l = this.batches.length; i < l; i++) {
            const batch = this.batches[i];
            batch.worldAlpha = this.worldAlpha * batch.alpha;
            renderer.plugins[this.pluginName].render(batch);
          }
        }
      }
      _renderDirect(renderer) {
        const shader = this._resolveDirectShader(renderer), geometry = this._geometry, worldAlpha = this.worldAlpha, uniforms = shader.uniforms, drawCalls = geometry.drawCalls;
        uniforms.translationMatrix = this.transform.worldTransform;
        core.Color.shared.setValue(this._tintColor).premultiply(worldAlpha).toArray(uniforms.tint);
        renderer.shader.bind(shader);
        renderer.geometry.bind(geometry, shader);
        renderer.state.set(this.state);
        for (let i = 0, l = drawCalls.length; i < l; i++) {
          this._renderDrawCallDirect(renderer, geometry.drawCalls[i]);
        }
      }
      _renderDrawCallDirect(renderer, drawCall) {
        const {texArray, type, size, start} = drawCall;
        drawCall = texArray.count;
        for (let j = 0; j < drawCall; j++) {
          renderer.texture.bind(texArray.elements[j], j);
        }
        renderer.geometry.draw(type, size, start);
      }
      _resolveDirectShader(renderer) {
        var shader = this.shader;
        const pluginName = this.pluginName;
        if (!shader) {
          if (!DEFAULT_SHADERS[pluginName]) {
            ({maxTextures:shader} = renderer.plugins[pluginName]);
            const sampleValues = new Int32Array(shader);
            for (let i = 0; i < shader; i++) {
              sampleValues[i] = i;
            }
            shader = {tint:new Float32Array([1, 1, 1, 1]), translationMatrix:new core.Matrix(), default:core.UniformGroup.from({uSamplers:sampleValues}, !0)};
            DEFAULT_SHADERS[pluginName] = new core.Shader(renderer.plugins[pluginName]._shader.program, shader);
          }
          shader = DEFAULT_SHADERS[pluginName];
        }
        return shader;
      }
      _calculateBounds() {
        this.finishPoly();
        const geometry = this._geometry;
        if (geometry.graphicsData.length) {
          var {minX, minY, maxX, maxY} = geometry.bounds;
          this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);
        }
      }
      containsPoint(point) {
        return this.worldTransform.applyInverse(point, node_modules$$pixi$graphics$lib$Graphics$classdecl$var18._TEMP_POINT), this._geometry.containsPoint(node_modules$$pixi$graphics$lib$Graphics$classdecl$var18._TEMP_POINT);
      }
      calculateTints() {
        if (this.batchTint !== this.tint) {
          this.batchTint = this._tintColor.toNumber();
          for (let i = 0; i < this.batches.length; i++) {
            const batch = this.batches[i];
            batch._tintRGB = core.Color.shared.setValue(this._tintColor).multiply(batch._batchRGB).toLittleEndianNumber();
          }
        }
      }
      calculateVertices() {
        var wtID = this.transform._worldID;
        if (this._transformID !== wtID) {
          this._transformID = wtID;
          var wt = this.transform.worldTransform;
          wtID = wt.a;
          var b = wt.b, c = wt.c, d = wt.d, tx = wt.tx;
          wt = wt.ty;
          var data = this._geometry.points, vertexData = this.vertexData, count = 0;
          for (let i = 0; i < data.length; i += 2) {
            const x = data[i], y = data[i + 1];
            vertexData[count++] = wtID * x + c * y + tx;
            vertexData[count++] = d * y + b * x + wt;
          }
        }
      }
      closePath() {
        const currentPath = this.currentPath;
        return currentPath && (currentPath.closeStroke = !0, this.finishPoly()), this;
      }
      setMatrix(matrix) {
        return this._matrix = matrix, this;
      }
      beginHole() {
        return this.finishPoly(), this._holeMode = !0, this;
      }
      endHole() {
        return this.finishPoly(), this._holeMode = !1, this;
      }
      destroy(options) {
        this._geometry.refCount--;
        0 === this._geometry.refCount && this._geometry.dispose();
        this.currentPath = this._matrix = null;
        this._lineStyle.destroy();
        this._lineStyle = null;
        this._fillStyle.destroy();
        this.vertexData = this.shader = this._geometry = this._fillStyle = null;
        this.batches.length = 0;
        this.batches = null;
        super.destroy(options);
      }
    };
    return node_modules$$pixi$graphics$lib$Graphics$classdecl$var18;
  })();
  global.curves = _const.curves;
  global._TEMP_POINT = new core.Point();
  exports.Graphics = global;
};

//# sourceMappingURL=module$node_modules$$pixi$graphics$lib$Graphics.js.map
