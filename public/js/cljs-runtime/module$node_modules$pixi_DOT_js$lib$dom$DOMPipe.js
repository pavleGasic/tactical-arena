shadow$provide.module$node_modules$pixi_DOT_js$lib$dom$DOMPipe = function(global, require, module, exports) {
  global = require("module$node_modules$pixi_DOT_js$lib$extensions$Extensions");
  "use strict";
  class DOMPipe {
    constructor(renderer) {
      this._destroyRenderableBound = this.destroyRenderable.bind(this);
      this._attachedDomElements = [];
      this._renderer = renderer;
      this._renderer.runners.postrender.add(this);
      this._domElement = document.createElement("div");
      this._domElement.style.position = "absolute";
      this._domElement.style.top = "0";
      this._domElement.style.left = "0";
      this._domElement.style.pointerEvents = "none";
      this._domElement.style.zIndex = "1000";
    }
    addRenderable(domContainer, _instructionSet) {
      this._attachedDomElements.includes(domContainer) || (this._attachedDomElements.push(domContainer), domContainer.on("destroyed", this._destroyRenderableBound));
    }
    updateRenderable(_domContainer) {
    }
    validateRenderable(_domContainer) {
      return !0;
    }
    destroyRenderable(domContainer) {
      const index = this._attachedDomElements.indexOf(domContainer);
      -1 !== index && this._attachedDomElements.splice(index, 1);
      domContainer.off("destroyed", this._destroyRenderableBound);
    }
    postrender() {
      const attachedDomElements = this._attachedDomElements;
      if (0 === attachedDomElements.length) {
        this._domElement.remove();
      } else {
        var canvas = this._renderer.view.canvas;
        this._domElement.parentNode !== canvas.parentNode && canvas.parentNode?.appendChild(this._domElement);
        this._domElement.style.transform = `translate(${canvas.offsetLeft}px, ${canvas.offsetTop}px)`;
        for (canvas = 0; canvas < attachedDomElements.length; canvas++) {
          const domContainer = attachedDomElements[canvas], element = domContainer.element;
          if (!domContainer.parent || 7 > domContainer.globalDisplayStatus) {
            element.remove(), attachedDomElements.splice(canvas, 1), canvas--;
          } else {
            this._domElement.contains(element) || (element.style.position = "absolute", element.style.pointerEvents = "auto", this._domElement.appendChild(element));
            const wt = domContainer.worldTransform;
            var anchor = domContainer._anchor;
            const ax = domContainer.width * anchor.x;
            anchor = domContainer.height * anchor.y;
            element.style.transformOrigin = `${ax}px ${anchor}px`;
            element.style.transform = `matrix(${wt.a}, ${wt.b}, ${wt.c}, ${wt.d}, ${wt.tx - ax}, ${wt.ty - anchor})`;
            element.style.opacity = domContainer.groupAlpha.toString();
          }
        }
      }
    }
    destroy() {
      this._renderer.runners.postrender.remove(this);
      for (let i = 0; i < this._attachedDomElements.length; i++) {
        const domContainer = this._attachedDomElements[i];
        domContainer.off("destroyed", this._destroyRenderableBound);
        domContainer.element.remove();
      }
      this._attachedDomElements.length = 0;
      this._domElement.remove();
      this._renderer = null;
    }
  }
  DOMPipe.extension = {type:[global.ExtensionType.WebGLPipes, global.ExtensionType.WebGPUPipes, global.ExtensionType.CanvasPipes], name:"dom"};
  exports.DOMPipe = DOMPipe;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$dom$DOMPipe.js.map
