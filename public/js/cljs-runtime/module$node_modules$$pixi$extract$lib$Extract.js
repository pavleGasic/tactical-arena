shadow$provide.module$node_modules$$pixi$extract$lib$Extract = function(global, require, module, exports) {
  var core = require("module$node_modules$$pixi$core$lib$index");
  const TEMP_RECT = new core.Rectangle();
  global = (() => {
    const node_modules$$pixi$extract$lib$Extract$classdecl$var16 = class {
      constructor(renderer) {
        this.renderer = renderer;
        this._rendererPremultipliedAlpha = !1;
      }
      contextChange() {
        const attributes = this.renderer?.gl.getContextAttributes();
        this._rendererPremultipliedAlpha = !!(attributes && attributes.alpha && attributes.premultipliedAlpha);
      }
      async image(target, format, quality, frame) {
        const image = new Image();
        return image.src = await this.base64(target, format, quality, frame), image;
      }
      async base64(target, format, quality, frame) {
        const canvas = this.canvas(target, frame);
        if (void 0 !== canvas.toBlob) {
          return new Promise((resolve, reject) => {
            canvas.toBlob(blob => {
              if (blob) {
                var reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(blob);
              } else {
                reject(Error("ICanvas.toBlob failed!"));
              }
            }, format, quality);
          });
        }
        if (void 0 !== canvas.toDataURL) {
          return canvas.toDataURL(format, quality);
        }
        if (void 0 !== canvas.convertToBlob) {
          const blob = await canvas.convertToBlob({type:format, quality});
          return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result);
            reader.onerror = reject;
            reader.readAsDataURL(blob);
          });
        }
        throw Error("Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented");
      }
      canvas(target, frame) {
        const {pixels, width, height, flipY, premultipliedAlpha} = this._rawPixels(target, frame);
        flipY && node_modules$$pixi$extract$lib$Extract$classdecl$var16._flipY(pixels, width, height);
        premultipliedAlpha && node_modules$$pixi$extract$lib$Extract$classdecl$var16._unpremultiplyAlpha(pixels);
        target = new core.utils.CanvasRenderTarget(width, height, 1);
        frame = new ImageData(new Uint8ClampedArray(pixels.buffer), width, height);
        return target.context.putImageData(frame, 0, 0), target.canvas;
      }
      pixels(target, frame) {
        const {pixels, width, height, flipY, premultipliedAlpha} = this._rawPixels(target, frame);
        return flipY && node_modules$$pixi$extract$lib$Extract$classdecl$var16._flipY(pixels, width, height), premultipliedAlpha && node_modules$$pixi$extract$lib$Extract$classdecl$var16._unpremultiplyAlpha(pixels), pixels;
      }
      _rawPixels(target, frame) {
        var renderer = this.renderer;
        if (!renderer) {
          throw Error("The Extract has already been destroyed");
        }
        let flipY, premultipliedAlpha, renderTexture, generated = !1;
        target && (target instanceof core.RenderTexture ? renderTexture = target : (renderTexture = renderer.generateTexture(target, {region:frame, resolution:renderer.resolution, multisample:renderer.multisample}), generated = !0, frame && (TEMP_RECT.width = frame.width, TEMP_RECT.height = frame.height, frame = TEMP_RECT)));
        const gl = renderer.gl;
        if (renderTexture) {
          if (target = renderTexture.baseTexture.resolution, frame = frame ?? renderTexture.frame, flipY = !1, premultipliedAlpha = 0 < renderTexture.baseTexture.alphaMode && renderTexture.baseTexture.format === core.FORMATS.RGBA, !generated) {
            renderer.renderTexture.bind(renderTexture);
            var fbo = renderTexture.framebuffer.glFramebuffers[renderer.CONTEXT_UID];
            fbo.blitFramebuffer && renderer.framebuffer.bind(fbo.blitFramebuffer);
          }
        } else {
          target = renderer.resolution, frame || (frame = TEMP_RECT, frame.width = renderer.width / target, frame.height = renderer.height / target), flipY = !0, premultipliedAlpha = this._rendererPremultipliedAlpha, renderer.renderTexture.bind();
        }
        renderer = Math.max(Math.round(frame.width * target), 1);
        fbo = Math.max(Math.round(frame.height * target), 1);
        const pixels = new Uint8Array(4 * renderer * fbo);
        return gl.readPixels(Math.round(frame.x * target), Math.round(frame.y * target), renderer, fbo, gl.RGBA, gl.UNSIGNED_BYTE, pixels), generated && renderTexture?.destroy(!0), {pixels, width:renderer, height:fbo, flipY, premultipliedAlpha};
      }
      destroy() {
        this.renderer = null;
      }
      static _flipY(pixels, width, height) {
        width <<= 2;
        const h = height >> 1, temp = new Uint8Array(width);
        for (let y = 0; y < h; y++) {
          const t = y * width, b = (height - y - 1) * width;
          temp.set(pixels.subarray(t, t + width));
          pixels.copyWithin(t, b, b + width);
          pixels.set(temp, b);
        }
      }
      static _unpremultiplyAlpha(pixels) {
        pixels instanceof Uint8ClampedArray && (pixels = new Uint8Array(pixels.buffer));
        const n = pixels.length;
        for (let i = 0; i < n; i += 4) {
          var alpha = pixels[i + 3];
          0 !== alpha && (alpha = 255.001 / alpha, pixels[i] = pixels[i] * alpha + 0.5, pixels[i + 1] = pixels[i + 1] * alpha + 0.5, pixels[i + 2] = pixels[i + 2] * alpha + 0.5);
        }
      }
    };
    return node_modules$$pixi$extract$lib$Extract$classdecl$var16;
  })();
  global.extension = {name:"extract", type:core.ExtensionType.RendererSystem};
  core.extensions.add(global);
  exports.Extract = global;
};

//# sourceMappingURL=module$node_modules$$pixi$extract$lib$Extract.js.map
