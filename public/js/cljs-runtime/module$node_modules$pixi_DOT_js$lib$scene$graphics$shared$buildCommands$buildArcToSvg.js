shadow$provide.module$node_modules$pixi_DOT_js$lib$scene$graphics$shared$buildCommands$buildArcToSvg = function(global, require, module, exports) {
  var buildAdaptiveBezier = require("module$node_modules$pixi_DOT_js$lib$scene$graphics$shared$buildCommands$buildAdaptiveBezier");
  "use strict";
  const TAU = 2 * Math.PI, out = {centerX:0, centerY:0, ang1:0, ang2:0}, mapToEllipse = ({x, y}, rx, ry, cosPhi, sinPhi, centerX, centerY, out2) => {
    x *= rx;
    y *= ry;
    out2.x = cosPhi * x - sinPhi * y + centerX;
    out2.y = sinPhi * x + cosPhi * y + centerY;
    return out2;
  }, vectorAngle = (ux, uy, vx, vy) => {
    let dot = ux * vx + uy * vy;
    1 < dot && (dot = 1);
    -1 > dot && (dot = -1);
    return (0 > ux * vy - uy * vx ? -1 : 1) * Math.acos(dot);
  };
  exports.buildArcToSvg = function(points, px, py, cx, cy, rx$jscomp$0, ry, xAxisRotation = 0, largeArcFlag = 0, sweepFlag = 0) {
    if (0 !== rx$jscomp$0 && 0 !== ry) {
      var sinPhi = Math.sin(xAxisRotation * TAU / 360);
      xAxisRotation = Math.cos(xAxisRotation * TAU / 360);
      var pxp = xAxisRotation * (px - cx) / 2 + sinPhi * (py - cy) / 2, pyp = -sinPhi * (px - cx) / 2 + xAxisRotation * (py - cy) / 2;
      if (0 !== pxp || 0 !== pyp) {
        rx$jscomp$0 = Math.abs(rx$jscomp$0);
        ry = Math.abs(ry);
        var lambda = Math.pow(pxp, 2) / Math.pow(rx$jscomp$0, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);
        1 < lambda && (rx$jscomp$0 *= Math.sqrt(lambda), ry *= Math.sqrt(lambda));
        var rx = rx$jscomp$0;
        lambda = ry;
        var rxSq = Math.pow(rx, 2), rySq = Math.pow(lambda, 2), pxpSq = Math.pow(pxp, 2), pypSq = Math.pow(pyp, 2), radicant = rxSq * rySq - rxSq * pypSq - rySq * pxpSq;
        0 > radicant && (radicant = 0);
        radicant = Math.sqrt(radicant / (rxSq * pypSq + rySq * pxpSq)) * (largeArcFlag === sweepFlag ? -1 : 1);
        largeArcFlag = radicant * rx / lambda * pyp;
        radicant = radicant * -lambda / rx * pxp;
        px = xAxisRotation * largeArcFlag - sinPhi * radicant + (px + cx) / 2;
        py = sinPhi * largeArcFlag + xAxisRotation * radicant + (py + cy) / 2;
        cy = (pxp - largeArcFlag) / rx;
        cx = (pyp - radicant) / lambda;
        pxp = (-pxp - largeArcFlag) / rx;
        lambda = (-pyp - radicant) / lambda;
        pyp = vectorAngle(1, 0, cy, cx);
        pxp = vectorAngle(cy, cx, pxp, lambda);
        0 === sweepFlag && 0 < pxp && (pxp -= TAU);
        1 === sweepFlag && 0 > pxp && (pxp += TAU);
        out.centerX = px;
        out.centerY = py;
        out.ang1 = pyp;
        out.ang2 = pxp;
        var {ang1, ang2} = out, {centerX, centerY} = out;
        sweepFlag = Math.abs(ang2) / (TAU / 4);
        1e-7 > Math.abs(1 - sweepFlag) && (sweepFlag = 1);
        sweepFlag = Math.max(Math.ceil(sweepFlag), 1);
        ang2 /= sweepFlag;
        pyp = points[points.length - 2];
        pxp = points[points.length - 1];
        lambda = {x:0, y:0};
        for (rx = 0; rx < sweepFlag; rx++) {
          py = -1.5707963267948966 === ang2 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);
          py = 1.5707963267948966 === ang2 ? 0.551915024494 : py;
          cy = Math.cos(ang1);
          px = Math.sin(ang1);
          cx = Math.cos(ang1 + ang2);
          largeArcFlag = Math.sin(ang1 + ang2);
          py = [{x:cy - px * py, y:px + cy * py}, {x:cx + largeArcFlag * py, y:largeArcFlag - cx * py}, {x:cx, y:largeArcFlag}];
          const {x:x1, y:y1} = mapToEllipse(py[0], rx$jscomp$0, ry, xAxisRotation, sinPhi, centerX, centerY, lambda), {x:x2, y:y2} = mapToEllipse(py[1], rx$jscomp$0, ry, xAxisRotation, sinPhi, centerX, centerY, lambda), {x, y} = mapToEllipse(py[2], rx$jscomp$0, ry, xAxisRotation, sinPhi, centerX, centerY, lambda);
          buildAdaptiveBezier.buildAdaptiveBezier(points, pyp, pxp, x1, y1, x2, y2, x, y);
          pyp = x;
          pxp = y;
          ang1 += ang2;
        }
      }
    }
  };
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$scene$graphics$shared$buildCommands$buildArcToSvg.js.map
