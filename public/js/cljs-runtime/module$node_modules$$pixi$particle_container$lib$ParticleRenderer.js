shadow$provide.module$node_modules$$pixi$particle_container$lib$ParticleRenderer = function(global, require, module, exports) {
  var core = require("module$node_modules$$pixi$core$lib$index"), ParticleBuffer = require("module$node_modules$$pixi$particle_container$lib$ParticleBuffer"), particles$1 = require("module$node_modules$$pixi$particle_container$lib$particles_frag"), particles = require("module$node_modules$$pixi$particle_container$lib$particles_vert");
  class ParticleRenderer extends core.ObjectRenderer {
    constructor(renderer) {
      super(renderer);
      this.properties = this.shader = null;
      this.tempMatrix = new core.Matrix();
      this.properties = [{attributeName:"aVertexPosition", size:2, uploadFunction:this.uploadVertices, offset:0}, {attributeName:"aPositionCoord", size:2, uploadFunction:this.uploadPosition, offset:0}, {attributeName:"aRotation", size:1, uploadFunction:this.uploadRotation, offset:0}, {attributeName:"aTextureCoord", size:2, uploadFunction:this.uploadUvs, offset:0}, {attributeName:"aColor", size:1, type:core.TYPES.UNSIGNED_BYTE, uploadFunction:this.uploadTint, offset:0}];
      this.shader = core.Shader.from(particles.default, particles$1.default, {});
      this.state = core.State.for2d();
    }
    render(container) {
      const children = container.children;
      var maxSize = container._maxSize;
      const batchSize = container._batchSize, renderer = this.renderer;
      let totalChildren = children.length;
      if (0 !== totalChildren) {
        totalChildren > maxSize && !container.autoResize && (totalChildren = maxSize);
        (maxSize = container._buffers) || (maxSize = container._buffers = this.generateBuffers(container));
        var baseTexture = children[0]._texture.baseTexture, premultiplied = 0 < baseTexture.alphaMode;
        this.state.blendMode = core.utils.correctBlendMode(container.blendMode, premultiplied);
        renderer.state.set(this.state);
        var gl = renderer.gl, m = container.worldTransform.copyTo(this.tempMatrix);
        m.prepend(renderer.globalUniforms.uniforms.projectionMatrix);
        this.shader.uniforms.translationMatrix = m.toArray(!0);
        this.shader.uniforms.uColor = core.Color.shared.setValue(container.tintRgb).premultiply(container.worldAlpha, premultiplied).toArray(this.shader.uniforms.uColor);
        this.shader.uniforms.uSampler = baseTexture;
        this.renderer.shader.bind(this.shader);
        baseTexture = !1;
        for (let i = 0, j = 0; i < totalChildren; i += batchSize, j += 1) {
          premultiplied = totalChildren - i;
          premultiplied > batchSize && (premultiplied = batchSize);
          j >= maxSize.length && maxSize.push(this._generateOneMoreBuffer(container));
          m = maxSize[j];
          m.uploadDynamic(children, i, premultiplied);
          const bid = container._bufferUpdateIDs[j] || 0;
          (baseTexture = baseTexture || m._updateID < bid) && (m._updateID = container._updateID, m.uploadStatic(children, i, premultiplied));
          renderer.geometry.bind(m.geometry);
          gl.drawElements(gl.TRIANGLES, 6 * premultiplied, gl.UNSIGNED_SHORT, 0);
        }
      }
    }
    generateBuffers(container) {
      const buffers = [], size = container._maxSize, batchSize = container._batchSize;
      container = container._properties;
      for (let i = 0; i < size; i += batchSize) {
        buffers.push(new ParticleBuffer.ParticleBuffer(this.properties, container, batchSize));
      }
      return buffers;
    }
    _generateOneMoreBuffer(container) {
      return new ParticleBuffer.ParticleBuffer(this.properties, container._properties, container._batchSize);
    }
    uploadVertices(children, startIndex, amount, array, stride, offset) {
      let w0 = 0, w1 = 0, h0 = 0, h1 = 0;
      for (let i = 0; i < amount; ++i) {
        const sprite = children[startIndex + i];
        var texture = sprite._texture;
        const sx = sprite.scale.x, sy = sprite.scale.y, trim = texture.trim;
        texture = texture.orig;
        trim ? (w1 = trim.x - sprite.anchor.x * texture.width, w0 = w1 + trim.width, h1 = trim.y - sprite.anchor.y * texture.height, h0 = h1 + trim.height) : (w0 = texture.width * (1 - sprite.anchor.x), w1 = texture.width * -sprite.anchor.x, h0 = texture.height * (1 - sprite.anchor.y), h1 = texture.height * -sprite.anchor.y);
        array[offset] = w1 * sx;
        array[offset + 1] = h1 * sy;
        array[offset + stride] = w0 * sx;
        array[offset + stride + 1] = h1 * sy;
        array[offset + 2 * stride] = w0 * sx;
        array[offset + 2 * stride + 1] = h0 * sy;
        array[offset + 3 * stride] = w1 * sx;
        array[offset + 3 * stride + 1] = h0 * sy;
        offset += 4 * stride;
      }
    }
    uploadPosition(children, startIndex, amount, array, stride, offset) {
      for (let i = 0; i < amount; i++) {
        const spritePosition = children[startIndex + i].position;
        array[offset] = spritePosition.x;
        array[offset + 1] = spritePosition.y;
        array[offset + stride] = spritePosition.x;
        array[offset + stride + 1] = spritePosition.y;
        array[offset + 2 * stride] = spritePosition.x;
        array[offset + 2 * stride + 1] = spritePosition.y;
        array[offset + 3 * stride] = spritePosition.x;
        array[offset + 3 * stride + 1] = spritePosition.y;
        offset += 4 * stride;
      }
    }
    uploadRotation(children, startIndex, amount, array, stride, offset) {
      for (let i = 0; i < amount; i++) {
        const spriteRotation = children[startIndex + i].rotation;
        array[offset] = spriteRotation;
        array[offset + stride] = spriteRotation;
        array[offset + 2 * stride] = spriteRotation;
        array[offset + 3 * stride] = spriteRotation;
        offset += 4 * stride;
      }
    }
    uploadUvs(children, startIndex, amount, array, stride, offset) {
      for (let i = 0; i < amount; ++i) {
        const textureUvs = children[startIndex + i]._texture._uvs;
        textureUvs ? (array[offset] = textureUvs.x0, array[offset + 1] = textureUvs.y0, array[offset + stride] = textureUvs.x1, array[offset + stride + 1] = textureUvs.y1, array[offset + 2 * stride] = textureUvs.x2, array[offset + 2 * stride + 1] = textureUvs.y2, array[offset + 3 * stride] = textureUvs.x3, array[offset + 3 * stride + 1] = textureUvs.y3, offset += 4 * stride) : (array[offset] = 0, array[offset + 1] = 0, array[offset + stride] = 0, array[offset + stride + 1] = 0, array[offset + 2 * 
        stride] = 0, array[offset + 2 * stride + 1] = 0, array[offset + 3 * stride] = 0, array[offset + 3 * stride + 1] = 0, offset += 4 * stride);
      }
    }
    uploadTint(children, startIndex, amount, array, stride, offset) {
      for (let i = 0; i < amount; ++i) {
        var sprite = children[startIndex + i];
        sprite = core.Color.shared.setValue(sprite._tintRGB).toPremultiplied(sprite.alpha, 0 < sprite.texture.baseTexture.alphaMode);
        array[offset] = sprite;
        array[offset + stride] = sprite;
        array[offset + 2 * stride] = sprite;
        array[offset + 3 * stride] = sprite;
        offset += 4 * stride;
      }
    }
    destroy() {
      super.destroy();
      this.shader && (this.shader.destroy(), this.shader = null);
      this.tempMatrix = null;
    }
  }
  ParticleRenderer.extension = {name:"particle", type:core.ExtensionType.RendererPlugin};
  core.extensions.add(ParticleRenderer);
  exports.ParticleRenderer = ParticleRenderer;
};

//# sourceMappingURL=module$node_modules$$pixi$particle_container$lib$ParticleRenderer.js.map
