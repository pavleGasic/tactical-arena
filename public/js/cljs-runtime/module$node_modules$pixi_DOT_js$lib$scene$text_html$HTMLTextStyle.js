shadow$provide.module$node_modules$pixi_DOT_js$lib$scene$text_html$HTMLTextStyle = function(global, require, module, exports) {
  var warn = require("module$node_modules$pixi_DOT_js$lib$utils$logging$warn");
  global = require("module$node_modules$pixi_DOT_js$lib$scene$text$TextStyle");
  var generateTextStyleKey = require("module$node_modules$pixi_DOT_js$lib$scene$text$utils$generateTextStyleKey"), textStyleToCSS = require("module$node_modules$pixi_DOT_js$lib$scene$text_html$utils$textStyleToCSS");
  "use strict";
  class HTMLTextStyle extends global.TextStyle {
    constructor(options = {}) {
      super(options);
      this._cssOverrides = [];
      this.cssOverrides ?? (this.cssOverrides = options.cssOverrides);
      this.tagStyles = options.tagStyles ?? {};
    }
    set cssOverrides(value) {
      this._cssOverrides = value instanceof Array ? value : [value];
      this.update();
    }
    get cssOverrides() {
      return this._cssOverrides;
    }
    _generateKey() {
      return this._styleKey = generateTextStyleKey.generateTextStyleKey(this) + this._cssOverrides.join("-");
    }
    update() {
      this._cssStyle = null;
      super.update();
    }
    clone() {
      return new HTMLTextStyle({align:this.align, breakWords:this.breakWords, dropShadow:this.dropShadow ? {...this.dropShadow} : null, fill:this._fill, fontFamily:this.fontFamily, fontSize:this.fontSize, fontStyle:this.fontStyle, fontVariant:this.fontVariant, fontWeight:this.fontWeight, letterSpacing:this.letterSpacing, lineHeight:this.lineHeight, padding:this.padding, stroke:this._stroke, whiteSpace:this.whiteSpace, wordWrap:this.wordWrap, wordWrapWidth:this.wordWrapWidth, cssOverrides:this.cssOverrides});
    }
    get cssStyle() {
      this._cssStyle || (this._cssStyle = textStyleToCSS.textStyleToCSS(this));
      return this._cssStyle;
    }
    addOverride(...value) {
      value = value.filter(v => !this.cssOverrides.includes(v));
      0 < value.length && (this.cssOverrides.push(...value), this.update());
    }
    removeOverride(...value) {
      const toRemove = value.filter(v => this.cssOverrides.includes(v));
      0 < toRemove.length && (this.cssOverrides = this.cssOverrides.filter(v => !toRemove.includes(v)), this.update());
    }
    set fill(value) {
      "string" !== typeof value && "number" !== typeof value && warn.warn("[HTMLTextStyle] only color fill is not supported by HTMLText");
      super.fill = value;
    }
    set stroke(value) {
      value && "string" !== typeof value && "number" !== typeof value && warn.warn("[HTMLTextStyle] only color stroke is not supported by HTMLText");
      super.stroke = value;
    }
  }
  exports.HTMLTextStyle = HTMLTextStyle;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$scene$text_html$HTMLTextStyle.js.map
