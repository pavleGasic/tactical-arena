shadow$provide.module$node_modules$$pixi$display$lib$Bounds = function(global, require, module, exports) {
  var core = require("module$node_modules$$pixi$core$lib$index");
  class Bounds {
    constructor() {
      this.minX = 1 / 0;
      this.minY = 1 / 0;
      this.maxX = -1 / 0;
      this.maxY = -1 / 0;
      this.rect = null;
      this.updateID = -1;
    }
    isEmpty() {
      return this.minX > this.maxX || this.minY > this.maxY;
    }
    clear() {
      this.minX = 1 / 0;
      this.minY = 1 / 0;
      this.maxX = -1 / 0;
      this.maxY = -1 / 0;
    }
    getRectangle(rect) {
      return this.minX > this.maxX || this.minY > this.maxY ? core.Rectangle.EMPTY : (rect = rect || new core.Rectangle(0, 0, 1, 1), rect.x = this.minX, rect.y = this.minY, rect.width = this.maxX - this.minX, rect.height = this.maxY - this.minY, rect);
    }
    addPoint(point) {
      this.minX = Math.min(this.minX, point.x);
      this.maxX = Math.max(this.maxX, point.x);
      this.minY = Math.min(this.minY, point.y);
      this.maxY = Math.max(this.maxY, point.y);
    }
    addPointMatrix(matrix, point) {
      const {a, b, c, d, tx, ty} = matrix;
      matrix = a * point.x + c * point.y + tx;
      point = b * point.x + d * point.y + ty;
      this.minX = Math.min(this.minX, matrix);
      this.maxX = Math.max(this.maxX, matrix);
      this.minY = Math.min(this.minY, point);
      this.maxY = Math.max(this.maxY, point);
    }
    addQuad(vertices) {
      let minX = this.minX, minY = this.minY, maxX = this.maxX, maxY = this.maxY, x = vertices[0], y = vertices[1];
      minX = x < minX ? x : minX;
      minY = y < minY ? y : minY;
      maxX = x > maxX ? x : maxX;
      maxY = y > maxY ? y : maxY;
      x = vertices[2];
      y = vertices[3];
      minX = x < minX ? x : minX;
      minY = y < minY ? y : minY;
      maxX = x > maxX ? x : maxX;
      maxY = y > maxY ? y : maxY;
      x = vertices[4];
      y = vertices[5];
      minX = x < minX ? x : minX;
      minY = y < minY ? y : minY;
      maxX = x > maxX ? x : maxX;
      maxY = y > maxY ? y : maxY;
      x = vertices[6];
      y = vertices[7];
      this.minX = x < minX ? x : minX;
      this.minY = y < minY ? y : minY;
      this.maxX = x > maxX ? x : maxX;
      this.maxY = y > maxY ? y : maxY;
    }
    addFrame(transform, x0, y0, x1, y1) {
      this.addFrameMatrix(transform.worldTransform, x0, y0, x1, y1);
    }
    addFrameMatrix(matrix, x0, y0, x1, y1) {
      const a = matrix.a, b = matrix.b, c = matrix.c, d = matrix.d, tx = matrix.tx;
      matrix = matrix.ty;
      let minX = this.minX, minY = this.minY, maxX = this.maxX, maxY = this.maxY, x = a * x0 + c * y0 + tx, y = b * x0 + d * y0 + matrix;
      minX = x < minX ? x : minX;
      minY = y < minY ? y : minY;
      maxX = x > maxX ? x : maxX;
      maxY = y > maxY ? y : maxY;
      x = a * x1 + c * y0 + tx;
      y = b * x1 + d * y0 + matrix;
      minX = x < minX ? x : minX;
      minY = y < minY ? y : minY;
      maxX = x > maxX ? x : maxX;
      maxY = y > maxY ? y : maxY;
      x = a * x0 + c * y1 + tx;
      y = b * x0 + d * y1 + matrix;
      minX = x < minX ? x : minX;
      minY = y < minY ? y : minY;
      maxX = x > maxX ? x : maxX;
      maxY = y > maxY ? y : maxY;
      x = a * x1 + c * y1 + tx;
      y = b * x1 + d * y1 + matrix;
      this.minX = x < minX ? x : minX;
      this.minY = y < minY ? y : minY;
      this.maxX = x > maxX ? x : maxX;
      this.maxY = y > maxY ? y : maxY;
    }
    addVertexData(vertexData, beginOffset, endOffset) {
      let minX = this.minX, minY = this.minY, maxX = this.maxX, maxY = this.maxY;
      for (; beginOffset < endOffset; beginOffset += 2) {
        const x = vertexData[beginOffset], y = vertexData[beginOffset + 1];
        minX = x < minX ? x : minX;
        minY = y < minY ? y : minY;
        maxX = x > maxX ? x : maxX;
        maxY = y > maxY ? y : maxY;
      }
      this.minX = minX;
      this.minY = minY;
      this.maxX = maxX;
      this.maxY = maxY;
    }
    addVertices(transform, vertices, beginOffset, endOffset) {
      this.addVerticesMatrix(transform.worldTransform, vertices, beginOffset, endOffset);
    }
    addVerticesMatrix(matrix, vertices, beginOffset, endOffset, padX = 0, padY = padX) {
      const a = matrix.a, b = matrix.b, c = matrix.c, d = matrix.d, tx = matrix.tx;
      matrix = matrix.ty;
      let minX = this.minX, minY = this.minY, maxX = this.maxX, maxY = this.maxY;
      for (; beginOffset < endOffset; beginOffset += 2) {
        var rawX = vertices[beginOffset];
        const rawY = vertices[beginOffset + 1], x = a * rawX + c * rawY + tx;
        rawX = d * rawY + b * rawX + matrix;
        minX = Math.min(minX, x - padX);
        maxX = Math.max(maxX, x + padX);
        minY = Math.min(minY, rawX - padY);
        maxY = Math.max(maxY, rawX + padY);
      }
      this.minX = minX;
      this.minY = minY;
      this.maxX = maxX;
      this.maxY = maxY;
    }
    addBounds(bounds) {
      const minX = this.minX, minY = this.minY, maxX = this.maxX, maxY = this.maxY;
      this.minX = bounds.minX < minX ? bounds.minX : minX;
      this.minY = bounds.minY < minY ? bounds.minY : minY;
      this.maxX = bounds.maxX > maxX ? bounds.maxX : maxX;
      this.maxY = bounds.maxY > maxY ? bounds.maxY : maxY;
    }
    addBoundsMask(bounds, mask) {
      const _minX = bounds.minX > mask.minX ? bounds.minX : mask.minX, _minY = bounds.minY > mask.minY ? bounds.minY : mask.minY, _maxX = bounds.maxX < mask.maxX ? bounds.maxX : mask.maxX;
      bounds = bounds.maxY < mask.maxY ? bounds.maxY : mask.maxY;
      if (_minX <= _maxX && _minY <= bounds) {
        mask = this.minX;
        const minY = this.minY, maxX = this.maxX, maxY = this.maxY;
        this.minX = _minX < mask ? _minX : mask;
        this.minY = _minY < minY ? _minY : minY;
        this.maxX = _maxX > maxX ? _maxX : maxX;
        this.maxY = bounds > maxY ? bounds : maxY;
      }
    }
    addBoundsMatrix(bounds, matrix) {
      this.addFrameMatrix(matrix, bounds.minX, bounds.minY, bounds.maxX, bounds.maxY);
    }
    addBoundsArea(bounds, area) {
      const _minX = bounds.minX > area.x ? bounds.minX : area.x, _minY = bounds.minY > area.y ? bounds.minY : area.y, _maxX = bounds.maxX < area.x + area.width ? bounds.maxX : area.x + area.width;
      bounds = bounds.maxY < area.y + area.height ? bounds.maxY : area.y + area.height;
      if (_minX <= _maxX && _minY <= bounds) {
        area = this.minX;
        const minY = this.minY, maxX = this.maxX, maxY = this.maxY;
        this.minX = _minX < area ? _minX : area;
        this.minY = _minY < minY ? _minY : minY;
        this.maxX = _maxX > maxX ? _maxX : maxX;
        this.maxY = bounds > maxY ? bounds : maxY;
      }
    }
    pad(paddingX = 0, paddingY = paddingX) {
      this.isEmpty() || (this.minX -= paddingX, this.maxX += paddingX, this.minY -= paddingY, this.maxY += paddingY);
    }
    addFramePad(x0, y0, x1, y1, padX, padY) {
      x0 -= padX;
      y0 -= padY;
      x1 += padX;
      y1 += padY;
      this.minX = this.minX < x0 ? this.minX : x0;
      this.maxX = this.maxX > x1 ? this.maxX : x1;
      this.minY = this.minY < y0 ? this.minY : y0;
      this.maxY = this.maxY > y1 ? this.maxY : y1;
    }
  }
  exports.Bounds = Bounds;
};

//# sourceMappingURL=module$node_modules$$pixi$display$lib$Bounds.js.map
