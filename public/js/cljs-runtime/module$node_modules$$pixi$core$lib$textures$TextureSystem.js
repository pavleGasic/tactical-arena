shadow$provide.module$node_modules$$pixi$core$lib$textures$TextureSystem = function(global, require, module, exports) {
  var constants = require("module$node_modules$$pixi$constants$lib$index");
  global = require("module$node_modules$$pixi$extensions$lib$index");
  var utils = require("module$node_modules$$pixi$utils$lib$index"), BaseTexture = require("module$node_modules$$pixi$core$lib$textures$BaseTexture"), GLTexture = require("module$node_modules$$pixi$core$lib$textures$GLTexture"), mapInternalFormatToSamplerType = require("module$node_modules$$pixi$core$lib$textures$utils$mapInternalFormatToSamplerType"), mapTypeAndFormatToInternalFormat = require("module$node_modules$$pixi$core$lib$textures$utils$mapTypeAndFormatToInternalFormat");
  class TextureSystem {
    constructor(renderer) {
      this.renderer = renderer;
      this.boundTextures = [];
      this.currentLocation = -1;
      this.managedTextures = [];
      this._unknownBoundTextures = !1;
      this.unknownTexture = new BaseTexture.BaseTexture();
      this.hasIntegerTextures = !1;
    }
    contextChange() {
      var gl = this.gl = this.renderer.gl;
      this.CONTEXT_UID = this.renderer.CONTEXT_UID;
      this.webGLVersion = this.renderer.context.webGLVersion;
      this.internalFormats = mapTypeAndFormatToInternalFormat.mapTypeAndFormatToInternalFormat(gl);
      this.samplerTypes = mapInternalFormatToSamplerType.mapInternalFormatToSamplerType(gl);
      var maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
      this.boundTextures.length = maxTextures;
      for (let i = 0; i < maxTextures; i++) {
        this.boundTextures[i] = null;
      }
      this.emptyTextures = {};
      maxTextures = new GLTexture.GLTexture(gl.createTexture());
      gl.bindTexture(gl.TEXTURE_2D, maxTextures.texture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(4));
      this.emptyTextures[gl.TEXTURE_2D] = maxTextures;
      this.emptyTextures[gl.TEXTURE_CUBE_MAP] = new GLTexture.GLTexture(gl.createTexture());
      gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.emptyTextures[gl.TEXTURE_CUBE_MAP].texture);
      for (maxTextures = 0; 6 > maxTextures; maxTextures++) {
        gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + maxTextures, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
      }
      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      for (gl = 0; gl < this.boundTextures.length; gl++) {
        this.bind(null, gl);
      }
    }
    bind(texture, location = 0) {
      const {gl} = this;
      if (texture = texture?.castToBaseTexture(), texture?.valid && !texture.parentTextureArray) {
        texture.touched = this.renderer.textureGC.count;
        const glTexture = texture._glTextures[this.CONTEXT_UID] || this.initTexture(texture);
        this.boundTextures[location] !== texture && (this.currentLocation !== location && (this.currentLocation = location, gl.activeTexture(gl.TEXTURE0 + location)), gl.bindTexture(texture.target, glTexture.texture));
        glTexture.dirtyId !== texture.dirtyId ? (this.currentLocation !== location && (this.currentLocation = location, gl.activeTexture(gl.TEXTURE0 + location)), this.updateTexture(texture)) : glTexture.dirtyStyleId !== texture.dirtyStyleId && this.updateTextureStyle(texture);
        this.boundTextures[location] = texture;
      } else {
        this.currentLocation !== location && (this.currentLocation = location, gl.activeTexture(gl.TEXTURE0 + location)), gl.bindTexture(gl.TEXTURE_2D, this.emptyTextures[gl.TEXTURE_2D].texture), this.boundTextures[location] = null;
      }
    }
    reset() {
      this._unknownBoundTextures = !0;
      this.hasIntegerTextures = !1;
      this.currentLocation = -1;
      for (let i = 0; i < this.boundTextures.length; i++) {
        this.boundTextures[i] = this.unknownTexture;
      }
    }
    unbind(texture) {
      const {gl, boundTextures} = this;
      if (this._unknownBoundTextures) {
        this._unknownBoundTextures = !1;
        for (var i = 0; i < boundTextures.length; i++) {
          boundTextures[i] === this.unknownTexture && this.bind(null, i);
        }
      }
      for (i = 0; i < boundTextures.length; i++) {
        boundTextures[i] === texture && (this.currentLocation !== i && (gl.activeTexture(gl.TEXTURE0 + i), this.currentLocation = i), gl.bindTexture(texture.target, this.emptyTextures[texture.target].texture), boundTextures[i] = null);
      }
    }
    ensureSamplerType(maxTextures) {
      const {boundTextures, hasIntegerTextures, CONTEXT_UID} = this;
      if (hasIntegerTextures) {
        for (--maxTextures; 0 <= maxTextures; --maxTextures) {
          const tex = boundTextures[maxTextures];
          tex && tex._glTextures[CONTEXT_UID].samplerType !== constants.SAMPLER_TYPES.FLOAT && this.renderer.texture.unbind(tex);
        }
      }
    }
    initTexture(texture) {
      const glTexture = new GLTexture.GLTexture(this.gl.createTexture());
      return glTexture.dirtyId = -1, texture._glTextures[this.CONTEXT_UID] = glTexture, this.managedTextures.push(texture), texture.on("dispose", this.destroyTexture, this), glTexture;
    }
    initTextureType(texture, glTexture) {
      glTexture.internalFormat = this.internalFormats[texture.type]?.[texture.format] ?? texture.format;
      glTexture.samplerType = this.samplerTypes[glTexture.internalFormat] ?? constants.SAMPLER_TYPES.FLOAT;
      2 === this.webGLVersion && texture.type === constants.TYPES.HALF_FLOAT ? glTexture.type = this.gl.HALF_FLOAT : glTexture.type = texture.type;
    }
    updateTexture(texture) {
      const glTexture = texture._glTextures[this.CONTEXT_UID];
      if (glTexture) {
        var renderer = this.renderer;
        if (this.initTextureType(texture, glTexture), texture.resource?.upload(renderer, texture, glTexture)) {
          glTexture.samplerType !== constants.SAMPLER_TYPES.FLOAT && (this.hasIntegerTextures = !0);
        } else {
          const width = texture.realWidth, height = texture.realHeight;
          renderer = renderer.gl;
          (glTexture.width !== width || glTexture.height !== height || 0 > glTexture.dirtyId) && (glTexture.width = width, glTexture.height = height, renderer.texImage2D(texture.target, 0, glTexture.internalFormat, width, height, 0, texture.format, glTexture.type, null));
        }
        texture.dirtyStyleId !== glTexture.dirtyStyleId && this.updateTextureStyle(texture);
        glTexture.dirtyId = texture.dirtyId;
      }
    }
    destroyTexture(texture, skipRemove) {
      const {gl} = this;
      if (texture = texture.castToBaseTexture(), texture._glTextures[this.CONTEXT_UID] && (this.unbind(texture), gl.deleteTexture(texture._glTextures[this.CONTEXT_UID].texture), texture.off("dispose", this.destroyTexture, this), delete texture._glTextures[this.CONTEXT_UID], !skipRemove)) {
        texture = this.managedTextures.indexOf(texture), -1 !== texture && utils.removeItems(this.managedTextures, texture, 1);
      }
    }
    updateTextureStyle(texture) {
      const glTexture = texture._glTextures[this.CONTEXT_UID];
      glTexture && (texture.mipmap !== constants.MIPMAP_MODES.POW2 && 2 === this.webGLVersion || texture.isPowerOfTwo ? glTexture.mipmap = 1 <= texture.mipmap : glTexture.mipmap = !1, 2 === this.webGLVersion || texture.isPowerOfTwo ? glTexture.wrapMode = texture.wrapMode : glTexture.wrapMode = constants.WRAP_MODES.CLAMP, texture.resource?.style(this.renderer, texture, glTexture) || this.setStyle(texture, glTexture), glTexture.dirtyStyleId = texture.dirtyStyleId);
    }
    setStyle(texture, glTexture) {
      const gl = this.gl;
      if (glTexture.mipmap && texture.mipmap !== constants.MIPMAP_MODES.ON_MANUAL && gl.generateMipmap(texture.target), gl.texParameteri(texture.target, gl.TEXTURE_WRAP_S, glTexture.wrapMode), gl.texParameteri(texture.target, gl.TEXTURE_WRAP_T, glTexture.wrapMode), glTexture.mipmap) {
        if (gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode === constants.SCALE_MODES.LINEAR ? gl.LINEAR_MIPMAP_LINEAR : gl.NEAREST_MIPMAP_NEAREST), (glTexture = this.renderer.context.extensions.anisotropicFiltering) && 0 < texture.anisotropicLevel && texture.scaleMode === constants.SCALE_MODES.LINEAR) {
          const level = Math.min(texture.anisotropicLevel, gl.getParameter(glTexture.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
          gl.texParameterf(texture.target, glTexture.TEXTURE_MAX_ANISOTROPY_EXT, level);
        }
      } else {
        gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode === constants.SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);
      }
      gl.texParameteri(texture.target, gl.TEXTURE_MAG_FILTER, texture.scaleMode === constants.SCALE_MODES.LINEAR ? gl.LINEAR : gl.NEAREST);
    }
    destroy() {
      this.renderer = null;
    }
  }
  TextureSystem.extension = {type:global.ExtensionType.RendererSystem, name:"texture"};
  global.extensions.add(TextureSystem);
  exports.TextureSystem = TextureSystem;
};

//# sourceMappingURL=module$node_modules$$pixi$core$lib$textures$TextureSystem.js.map
