shadow$provide.module$node_modules$pixi_DOT_js$lib$scene$mesh$gpu$GpuMeshAdapter = function(global, require, module, exports) {
  global = require("module$node_modules$pixi_DOT_js$lib$extensions$Extensions");
  var Matrix = require("module$node_modules$pixi_DOT_js$lib$maths$matrix$Matrix"), compileHighShaderToProgram = require("module$node_modules$pixi_DOT_js$lib$rendering$high_shader$compileHighShaderToProgram"), localUniformBit = require("module$node_modules$pixi_DOT_js$lib$rendering$high_shader$shader_bits$localUniformBit"), roundPixelsBit = require("module$node_modules$pixi_DOT_js$lib$rendering$high_shader$shader_bits$roundPixelsBit"), textureBit = require("module$node_modules$pixi_DOT_js$lib$rendering$high_shader$shader_bits$textureBit"), 
  Shader = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$shader$Shader"), Texture = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$texture$Texture"), warn = require("module$node_modules$pixi_DOT_js$lib$utils$logging$warn");
  "use strict";
  class GpuMeshAdapter {
    init() {
      const gpuProgram = compileHighShaderToProgram.compileHighShaderGpuProgram({name:"mesh", bits:[localUniformBit.localUniformBit, textureBit.textureBit, roundPixelsBit.roundPixelsBit]});
      this._shader = new Shader.Shader({gpuProgram, resources:{uTexture:Texture.Texture.EMPTY._source, uSampler:Texture.Texture.EMPTY._source.style, textureUniforms:{uTextureMatrix:{type:"mat3x3\x3cf32\x3e", value:new Matrix.Matrix()}}}});
    }
    execute(meshPipe, mesh) {
      const renderer = meshPipe.renderer;
      let shader = mesh._shader;
      if (!shader) {
        shader = this._shader, shader.groups[2] = renderer.texture.getTextureBindGroup(mesh.texture);
      } else if (!shader.gpuProgram) {
        warn.warn("Mesh shader has no gpuProgram", mesh.shader);
        return;
      }
      const gpuProgram = shader.gpuProgram;
      gpuProgram.autoAssignGlobalUniforms && (shader.groups[0] = renderer.globalUniforms.bindGroup);
      gpuProgram.autoAssignLocalUniforms && (shader.groups[1] = renderer.renderPipes.uniformBatch.getUniformBindGroup(meshPipe.localUniforms, !0));
      renderer.encoder.draw({geometry:mesh._geometry, shader, state:mesh.state});
    }
    destroy() {
      this._shader.destroy(!0);
      this._shader = null;
    }
  }
  GpuMeshAdapter.extension = {type:[global.ExtensionType.WebGPUPipesAdaptor], name:"mesh"};
  exports.GpuMeshAdapter = GpuMeshAdapter;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$scene$mesh$gpu$GpuMeshAdapter.js.map
