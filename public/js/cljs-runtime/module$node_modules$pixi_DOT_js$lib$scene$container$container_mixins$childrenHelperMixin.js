shadow$provide.module$node_modules$pixi_DOT_js$lib$scene$container$container_mixins$childrenHelperMixin = function(global, require, module, exports) {
  var removeItems = require("module$node_modules$pixi_DOT_js$lib$utils$data$removeItems"), deprecation = require("module$node_modules$pixi_DOT_js$lib$utils$logging$deprecation");
  "use strict";
  exports.childrenHelperMixin = {allowChildren:!0, removeChildren(beginIndex = 0, endIndex) {
    var end = endIndex ?? this.children.length, range = end - beginIndex;
    endIndex = [];
    if (0 < range && range <= end) {
      for (range = end - 1; range >= beginIndex; range--) {
        const child = this.children[range];
        child && (endIndex.push(child), child.parent = null);
      }
      removeItems.removeItems(this.children, beginIndex, end);
      (beginIndex = this.renderGroup || this.parentRenderGroup) && beginIndex.removeChildren(endIndex);
      for (beginIndex = 0; beginIndex < endIndex.length; ++beginIndex) {
        end = endIndex[beginIndex], end.parentRenderLayer?.detach(end), this.emit("childRemoved", end, this, beginIndex), endIndex[beginIndex].emit("removed", this);
      }
      0 < endIndex.length && this._didViewChangeTick++;
      return endIndex;
    }
    if (0 === range && 0 === this.children.length) {
      return endIndex;
    }
    throw new RangeError("removeChildren: numeric values are outside the acceptable range.");
  }, removeChildAt(index) {
    index = this.getChildAt(index);
    return this.removeChild(index);
  }, getChildAt(index) {
    if (0 > index || index >= this.children.length) {
      throw Error(`getChildAt: Index (${index}) does not exist.`);
    }
    return this.children[index];
  }, setChildIndex(child, index) {
    if (0 > index || index >= this.children.length) {
      throw Error(`The index ${index} supplied is out of bounds ${this.children.length}`);
    }
    this.getChildIndex(child);
    this.addChildAt(child, index);
  }, getChildIndex(child) {
    child = this.children.indexOf(child);
    if (-1 === child) {
      throw Error("The supplied Container must be a child of the caller");
    }
    return child;
  }, addChildAt(child, index) {
    this.allowChildren || deprecation.deprecation(deprecation.v8_0_0, "addChildAt: Only Containers will be allowed to add children in v8.0.0");
    var {children} = this;
    if (0 > index || index > children.length) {
      throw Error(`${child}addChildAt: The index ${index} supplied is out of bounds ${children.length}`);
    }
    if (child.parent) {
      const currentIndex = child.parent.children.indexOf(child);
      if (child.parent === this && currentIndex === index) {
        return child;
      }
      -1 !== currentIndex && child.parent.children.splice(currentIndex, 1);
    }
    index === children.length ? children.push(child) : children.splice(index, 0, child);
    child.parent = this;
    child.didChange = !0;
    child._updateFlags = 15;
    (children = this.renderGroup || this.parentRenderGroup) && children.addChild(child);
    this.sortableChildren && (this.sortDirty = !0);
    this.emit("childAdded", child, this, index);
    child.emit("added", this);
    return child;
  }, swapChildren(child, child2) {
    if (child !== child2) {
      var index1 = this.getChildIndex(child), index2 = this.getChildIndex(child2);
      this.children[index1] = child2;
      this.children[index2] = child;
      if (child = this.renderGroup || this.parentRenderGroup) {
        child.structureDidChange = !0;
      }
      this._didContainerChangeTick++;
    }
  }, removeFromParent() {
    this.parent?.removeChild(this);
  }, reparentChild(...child) {
    if (1 === child.length) {
      return this.reparentChildAt(child[0], this.children.length);
    }
    child.forEach(c => this.reparentChildAt(c, this.children.length));
    return child[0];
  }, reparentChildAt(child, index) {
    if (child.parent === this) {
      return this.setChildIndex(child, index), child;
    }
    const childMat = child.worldTransform.clone();
    child.removeFromParent();
    this.addChildAt(child, index);
    index = this.worldTransform.clone();
    index.invert();
    childMat.prepend(index);
    child.setFromMatrix(childMat);
    return child;
  }};
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$scene$container$container_mixins$childrenHelperMixin.js.map
