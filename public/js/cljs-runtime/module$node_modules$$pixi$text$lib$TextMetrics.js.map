{
"version":3,
"file":"module$node_modules$$pixi$text$lib$TextMetrics.js",
"lineCount":255,
"mappings":"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",
"sources":["node_modules/@pixi/text/lib/TextMetrics.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$$pixi$text$lib$TextMetrics\"] = function(global,require,module,exports) {\n\"use strict\";\nvar core = require(\"@pixi/core\");\nconst contextSettings = {\n  // TextMetrics requires getImageData readback for measuring fonts.\n  willReadFrequently: !0\n}, _TextMetrics = class _TextMetrics2 {\n  /**\n   * Checking that we can use modern canvas 2D API.\n   *\n   * Note: This is an unstable API, Chrome < 94 use `textLetterSpacing`, later versions use `letterSpacing`.\n   * @see PIXI.TextMetrics.experimentalLetterSpacing\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/letterSpacing\n   * @see https://developer.chrome.com/origintrials/#/view_trial/3585991203293757441\n   */\n  static get experimentalLetterSpacingSupported() {\n    let result = _TextMetrics2._experimentalLetterSpacingSupported;\n    if (result !== void 0) {\n      const proto = core.settings.ADAPTER.getCanvasRenderingContext2D().prototype;\n      result = _TextMetrics2._experimentalLetterSpacingSupported = \"letterSpacing\" in proto || \"textLetterSpacing\" in proto;\n    }\n    return result;\n  }\n  /**\n   * @param text - the text that was measured\n   * @param style - the style that was measured\n   * @param width - the measured width of the text\n   * @param height - the measured height of the text\n   * @param lines - an array of the lines of text broken by new lines and wrapping if specified in style\n   * @param lineWidths - an array of the line widths for each line matched to `lines`\n   * @param lineHeight - the measured line height for this style\n   * @param maxLineWidth - the maximum line width for all measured lines\n   * @param {PIXI.IFontMetrics} fontProperties - the font properties object from TextMetrics.measureFont\n   */\n  constructor(text, style, width, height, lines, lineWidths, lineHeight, maxLineWidth, fontProperties) {\n    this.text = text, this.style = style, this.width = width, this.height = height, this.lines = lines, this.lineWidths = lineWidths, this.lineHeight = lineHeight, this.maxLineWidth = maxLineWidth, this.fontProperties = fontProperties;\n  }\n  /**\n   * Measures the supplied string of text and returns a Rectangle.\n   * @param text - The text to measure.\n   * @param style - The text style to use for measuring\n   * @param wordWrap - Override for if word-wrap should be applied to the text.\n   * @param canvas - optional specification of the canvas to use for measuring.\n   * @returns Measured width and height of the text.\n   */\n  static measureText(text, style, wordWrap, canvas = _TextMetrics2._canvas) {\n    wordWrap = wordWrap ?? style.wordWrap;\n    const font = style.toFontString(), fontProperties = _TextMetrics2.measureFont(font);\n    fontProperties.fontSize === 0 && (fontProperties.fontSize = style.fontSize, fontProperties.ascent = style.fontSize);\n    const context = canvas.getContext(\"2d\", contextSettings);\n    context.font = font;\n    const lines = (wordWrap ? _TextMetrics2.wordWrap(text, style, canvas) : text).split(/(?:\\r\\n|\\r|\\n)/), lineWidths = new Array(lines.length);\n    let maxLineWidth = 0;\n    for (let i = 0; i < lines.length; i++) {\n      const lineWidth = _TextMetrics2._measureText(lines[i], style.letterSpacing, context);\n      lineWidths[i] = lineWidth, maxLineWidth = Math.max(maxLineWidth, lineWidth);\n    }\n    let width = maxLineWidth + style.strokeThickness;\n    style.dropShadow && (width += style.dropShadowDistance);\n    const lineHeight = style.lineHeight || fontProperties.fontSize + style.strokeThickness;\n    let height = Math.max(lineHeight, fontProperties.fontSize + style.strokeThickness * 2) + style.leading + (lines.length - 1) * (lineHeight + style.leading);\n    return style.dropShadow && (height += style.dropShadowDistance), new _TextMetrics2(\n      text,\n      style,\n      width,\n      height,\n      lines,\n      lineWidths,\n      lineHeight + style.leading,\n      maxLineWidth,\n      fontProperties\n    );\n  }\n  static _measureText(text, letterSpacing, context) {\n    let useExperimentalLetterSpacing = !1;\n    _TextMetrics2.experimentalLetterSpacingSupported && (_TextMetrics2.experimentalLetterSpacing ? (context.letterSpacing = `${letterSpacing}px`, context.textLetterSpacing = `${letterSpacing}px`, useExperimentalLetterSpacing = !0) : (context.letterSpacing = \"0px\", context.textLetterSpacing = \"0px\"));\n    let width = context.measureText(text).width;\n    return width > 0 && (useExperimentalLetterSpacing ? width -= letterSpacing : width += (_TextMetrics2.graphemeSegmenter(text).length - 1) * letterSpacing), width;\n  }\n  /**\n   * Applies newlines to a string to have it optimally fit into the horizontal\n   * bounds set by the Text object's wordWrapWidth property.\n   * @param text - String to apply word wrapping to\n   * @param style - the style to use when wrapping\n   * @param canvas - optional specification of the canvas to use for measuring.\n   * @returns New string with new lines applied where required\n   */\n  static wordWrap(text, style, canvas = _TextMetrics2._canvas) {\n    const context = canvas.getContext(\"2d\", contextSettings);\n    let width = 0, line = \"\", lines = \"\";\n    const cache = /* @__PURE__ */ Object.create(null), { letterSpacing, whiteSpace } = style, collapseSpaces = _TextMetrics2.collapseSpaces(whiteSpace), collapseNewlines = _TextMetrics2.collapseNewlines(whiteSpace);\n    let canPrependSpaces = !collapseSpaces;\n    const wordWrapWidth = style.wordWrapWidth + letterSpacing, tokens = _TextMetrics2.tokenize(text);\n    for (let i = 0; i < tokens.length; i++) {\n      let token = tokens[i];\n      if (_TextMetrics2.isNewline(token)) {\n        if (!collapseNewlines) {\n          lines += _TextMetrics2.addLine(line), canPrependSpaces = !collapseSpaces, line = \"\", width = 0;\n          continue;\n        }\n        token = \" \";\n      }\n      if (collapseSpaces) {\n        const currIsBreakingSpace = _TextMetrics2.isBreakingSpace(token), lastIsBreakingSpace = _TextMetrics2.isBreakingSpace(line[line.length - 1]);\n        if (currIsBreakingSpace && lastIsBreakingSpace)\n          continue;\n      }\n      const tokenWidth = _TextMetrics2.getFromCache(token, letterSpacing, cache, context);\n      if (tokenWidth > wordWrapWidth)\n        if (line !== \"\" && (lines += _TextMetrics2.addLine(line), line = \"\", width = 0), _TextMetrics2.canBreakWords(token, style.breakWords)) {\n          const characters = _TextMetrics2.wordWrapSplit(token);\n          for (let j = 0; j < characters.length; j++) {\n            let char = characters[j], lastChar = char, k = 1;\n            for (; characters[j + k]; ) {\n              const nextChar = characters[j + k];\n              if (!_TextMetrics2.canBreakChars(lastChar, nextChar, token, j, style.breakWords))\n                char += nextChar;\n              else\n                break;\n              lastChar = nextChar, k++;\n            }\n            j += k - 1;\n            const characterWidth = _TextMetrics2.getFromCache(char, letterSpacing, cache, context);\n            characterWidth + width > wordWrapWidth && (lines += _TextMetrics2.addLine(line), canPrependSpaces = !1, line = \"\", width = 0), line += char, width += characterWidth;\n          }\n        } else {\n          line.length > 0 && (lines += _TextMetrics2.addLine(line), line = \"\", width = 0);\n          const isLastToken = i === tokens.length - 1;\n          lines += _TextMetrics2.addLine(token, !isLastToken), canPrependSpaces = !1, line = \"\", width = 0;\n        }\n      else\n        tokenWidth + width > wordWrapWidth && (canPrependSpaces = !1, lines += _TextMetrics2.addLine(line), line = \"\", width = 0), (line.length > 0 || !_TextMetrics2.isBreakingSpace(token) || canPrependSpaces) && (line += token, width += tokenWidth);\n    }\n    return lines += _TextMetrics2.addLine(line, !1), lines;\n  }\n  /**\n   * Convienience function for logging each line added during the wordWrap method.\n   * @param line    - The line of text to add\n   * @param newLine - Add new line character to end\n   * @returns A formatted line\n   */\n  static addLine(line, newLine = !0) {\n    return line = _TextMetrics2.trimRight(line), line = newLine ? `${line}\n` : line, line;\n  }\n  /**\n   * Gets & sets the widths of calculated characters in a cache object\n   * @param key            - The key\n   * @param letterSpacing  - The letter spacing\n   * @param cache          - The cache\n   * @param context        - The canvas context\n   * @returns The from cache.\n   */\n  static getFromCache(key, letterSpacing, cache, context) {\n    let width = cache[key];\n    return typeof width != \"number\" && (width = _TextMetrics2._measureText(key, letterSpacing, context) + letterSpacing, cache[key] = width), width;\n  }\n  /**\n   * Determines whether we should collapse breaking spaces.\n   * @param whiteSpace - The TextStyle property whiteSpace\n   * @returns Should collapse\n   */\n  static collapseSpaces(whiteSpace) {\n    return whiteSpace === \"normal\" || whiteSpace === \"pre-line\";\n  }\n  /**\n   * Determines whether we should collapse newLine chars.\n   * @param whiteSpace - The white space\n   * @returns should collapse\n   */\n  static collapseNewlines(whiteSpace) {\n    return whiteSpace === \"normal\";\n  }\n  /**\n   * Trims breaking whitespaces from string.\n   * @param text - The text\n   * @returns Trimmed string\n   */\n  static trimRight(text) {\n    if (typeof text != \"string\")\n      return \"\";\n    for (let i = text.length - 1; i >= 0; i--) {\n      const char = text[i];\n      if (!_TextMetrics2.isBreakingSpace(char))\n        break;\n      text = text.slice(0, -1);\n    }\n    return text;\n  }\n  /**\n   * Determines if char is a newline.\n   * @param char - The character\n   * @returns True if newline, False otherwise.\n   */\n  static isNewline(char) {\n    return typeof char != \"string\" ? !1 : _TextMetrics2._newlines.includes(char.charCodeAt(0));\n  }\n  /**\n   * Determines if char is a breaking whitespace.\n   *\n   * It allows one to determine whether char should be a breaking whitespace\n   * For example certain characters in CJK langs or numbers.\n   * It must return a boolean.\n   * @param char - The character\n   * @param [_nextChar] - The next character\n   * @returns True if whitespace, False otherwise.\n   */\n  static isBreakingSpace(char, _nextChar) {\n    return typeof char != \"string\" ? !1 : _TextMetrics2._breakingSpaces.includes(char.charCodeAt(0));\n  }\n  /**\n   * Splits a string into words, breaking-spaces and newLine characters\n   * @param text - The text\n   * @returns A tokenized array\n   */\n  static tokenize(text) {\n    const tokens = [];\n    let token = \"\";\n    if (typeof text != \"string\")\n      return tokens;\n    for (let i = 0; i < text.length; i++) {\n      const char = text[i], nextChar = text[i + 1];\n      if (_TextMetrics2.isBreakingSpace(char, nextChar) || _TextMetrics2.isNewline(char)) {\n        token !== \"\" && (tokens.push(token), token = \"\"), tokens.push(char);\n        continue;\n      }\n      token += char;\n    }\n    return token !== \"\" && tokens.push(token), tokens;\n  }\n  /**\n   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n   *\n   * It allows one to customise which words should break\n   * Examples are if the token is CJK or numbers.\n   * It must return a boolean.\n   * @param _token - The token\n   * @param breakWords - The style attr break words\n   * @returns Whether to break word or not\n   */\n  static canBreakWords(_token, breakWords) {\n    return breakWords;\n  }\n  /**\n   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n   *\n   * It allows one to determine whether a pair of characters\n   * should be broken by newlines\n   * For example certain characters in CJK langs or numbers.\n   * It must return a boolean.\n   * @param _char - The character\n   * @param _nextChar - The next character\n   * @param _token - The token/word the characters are from\n   * @param _index - The index in the token of the char\n   * @param _breakWords - The style attr break words\n   * @returns whether to break word or not\n   */\n  static canBreakChars(_char, _nextChar, _token, _index, _breakWords) {\n    return !0;\n  }\n  /**\n   * Overridable helper method used internally by TextMetrics, exposed to allow customizing the class's behavior.\n   *\n   * It is called when a token (usually a word) has to be split into separate pieces\n   * in order to determine the point to break a word.\n   * It must return an array of characters.\n   * @param token - The token to split\n   * @returns The characters of the token\n   * @see TextMetrics.graphemeSegmenter\n   */\n  static wordWrapSplit(token) {\n    return _TextMetrics2.graphemeSegmenter(token);\n  }\n  /**\n   * Calculates the ascent, descent and fontSize of a given font-style\n   * @param font - String representing the style of the font\n   * @returns Font properties object\n   */\n  static measureFont(font) {\n    if (_TextMetrics2._fonts[font])\n      return _TextMetrics2._fonts[font];\n    const properties = {\n      ascent: 0,\n      descent: 0,\n      fontSize: 0\n    }, canvas = _TextMetrics2._canvas, context = _TextMetrics2._context;\n    context.font = font;\n    const metricsString = _TextMetrics2.METRICS_STRING + _TextMetrics2.BASELINE_SYMBOL, width = Math.ceil(context.measureText(metricsString).width);\n    let baseline = Math.ceil(context.measureText(_TextMetrics2.BASELINE_SYMBOL).width);\n    const height = Math.ceil(_TextMetrics2.HEIGHT_MULTIPLIER * baseline);\n    if (baseline = baseline * _TextMetrics2.BASELINE_MULTIPLIER | 0, width === 0 || height === 0)\n      return _TextMetrics2._fonts[font] = properties, properties;\n    canvas.width = width, canvas.height = height, context.fillStyle = \"#f00\", context.fillRect(0, 0, width, height), context.font = font, context.textBaseline = \"alphabetic\", context.fillStyle = \"#000\", context.fillText(metricsString, 0, baseline);\n    const imagedata = context.getImageData(0, 0, width, height).data, pixels = imagedata.length, line = width * 4;\n    let i = 0, idx = 0, stop = !1;\n    for (i = 0; i < baseline; ++i) {\n      for (let j = 0; j < line; j += 4)\n        if (imagedata[idx + j] !== 255) {\n          stop = !0;\n          break;\n        }\n      if (!stop)\n        idx += line;\n      else\n        break;\n    }\n    for (properties.ascent = baseline - i, idx = pixels - line, stop = !1, i = height; i > baseline; --i) {\n      for (let j = 0; j < line; j += 4)\n        if (imagedata[idx + j] !== 255) {\n          stop = !0;\n          break;\n        }\n      if (!stop)\n        idx -= line;\n      else\n        break;\n    }\n    return properties.descent = i - baseline, properties.fontSize = properties.ascent + properties.descent, _TextMetrics2._fonts[font] = properties, properties;\n  }\n  /**\n   * Clear font metrics in metrics cache.\n   * @param {string} [font] - font name. If font name not set then clear cache for all fonts.\n   */\n  static clearMetrics(font = \"\") {\n    font ? delete _TextMetrics2._fonts[font] : _TextMetrics2._fonts = {};\n  }\n  /**\n   * Cached canvas element for measuring text\n   * TODO: this should be private, but isn't because of backward compat, will fix later.\n   * @ignore\n   */\n  static get _canvas() {\n    if (!_TextMetrics2.__canvas) {\n      let canvas;\n      try {\n        const c = new OffscreenCanvas(0, 0);\n        if (c.getContext(\"2d\", contextSettings)?.measureText)\n          return _TextMetrics2.__canvas = c, c;\n        canvas = core.settings.ADAPTER.createCanvas();\n      } catch {\n        canvas = core.settings.ADAPTER.createCanvas();\n      }\n      canvas.width = canvas.height = 10, _TextMetrics2.__canvas = canvas;\n    }\n    return _TextMetrics2.__canvas;\n  }\n  /**\n   * TODO: this should be private, but isn't because of backward compat, will fix later.\n   * @ignore\n   */\n  static get _context() {\n    return _TextMetrics2.__context || (_TextMetrics2.__context = _TextMetrics2._canvas.getContext(\"2d\", contextSettings)), _TextMetrics2.__context;\n  }\n};\n_TextMetrics.METRICS_STRING = \"|\\xC9q\\xC5\", /** Baseline symbol for calculate font metrics. */\n_TextMetrics.BASELINE_SYMBOL = \"M\", /** Baseline multiplier for calculate font metrics. */\n_TextMetrics.BASELINE_MULTIPLIER = 1.4, /** Height multiplier for setting height of canvas to calculate font metrics. */\n_TextMetrics.HEIGHT_MULTIPLIER = 2, /**\n* A Unicode \"character\", or \"grapheme cluster\", can be composed of multiple Unicode code points,\n* such as letters with diacritical marks (e.g. `'\\u0065\\u0301'`, letter e with acute)\n* or emojis with modifiers (e.g. `'\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB'`, technologist).\n* The new `Intl.Segmenter` API in ES2022 can split the string into grapheme clusters correctly. If it is not available,\n* PixiJS will fallback to use the iterator of String, which can only spilt the string into code points.\n* If you want to get full functionality in environments that don't support `Intl.Segmenter` (such as Firefox),\n* you can use other libraries such as [grapheme-splitter]{@link https://www.npmjs.com/package/grapheme-splitter}\n* or [graphemer]{@link https://www.npmjs.com/package/graphemer} to create a polyfill. Since these libraries can be\n* relatively large in size to handle various Unicode grapheme clusters properly, PixiJS won't use them directly.\n*/\n_TextMetrics.graphemeSegmenter = (() => {\n  if (typeof Intl?.Segmenter == \"function\") {\n    const segmenter = new Intl.Segmenter();\n    return (s) => [...segmenter.segment(s)].map((x) => x.segment);\n  }\n  return (s) => [...s];\n})(), /**\n* New rendering behavior for letter-spacing which uses Chrome's new native API. This will\n* lead to more accurate letter-spacing results because it does not try to manually draw\n* each character. However, this Chrome API is experimental and may not serve all cases yet.\n* @see PIXI.TextMetrics.experimentalLetterSpacingSupported\n*/\n_TextMetrics.experimentalLetterSpacing = !1, /** Cache of {@see PIXI.TextMetrics.FontMetrics} objects. */\n_TextMetrics._fonts = {}, /** Cache of new line chars. */\n_TextMetrics._newlines = [\n  10,\n  // line feed\n  13\n  // carriage return\n], /** Cache of breaking spaces. */\n_TextMetrics._breakingSpaces = [\n  9,\n  // character tabulation\n  32,\n  // space\n  8192,\n  // en quad\n  8193,\n  // em quad\n  8194,\n  // en space\n  8195,\n  // em space\n  8196,\n  // three-per-em space\n  8197,\n  // four-per-em space\n  8198,\n  // six-per-em space\n  8200,\n  // punctuation space\n  8201,\n  // thin space\n  8202,\n  // hair space\n  8287,\n  // medium mathematical space\n  12288\n  // ideographic space\n];\nlet TextMetrics = _TextMetrics;\nexports.TextMetrics = TextMetrics;\n//# sourceMappingURL=TextMetrics.js.map\n\n};"],
"names":["shadow$provide","global","require","module","exports","core","contextSettings","willReadFrequently","_TextMetrics","result","_TextMetrics2","_experimentalLetterSpacingSupported","proto","settings","ADAPTER","getCanvasRenderingContext2D","prototype","constructor","text","style","width","height","lines","lineWidths","lineHeight","maxLineWidth","fontProperties","measureText","wordWrap","canvas","_canvas","font","toFontString","measureFont","fontSize","ascent","context","getContext","split","Array","length","i","lineWidth","_measureText","letterSpacing","Math","max","strokeThickness","dropShadow","dropShadowDistance","leading","useExperimentalLetterSpacing","experimentalLetterSpacingSupported","experimentalLetterSpacing","textLetterSpacing","graphemeSegmenter","line","cache","Object","create","whiteSpace","collapseSpaces","collapseNewlines","canPrependSpaces","wordWrapWidth","tokens","tokenize","token","isNewline","addLine","currIsBreakingSpace","isBreakingSpace","lastIsBreakingSpace","tokenWidth","getFromCache","canBreakWords","breakWords","characters","j","wordWrapSplit","char","lastChar","k","nextChar","canBreakChars","characterWidth","newLine","trimRight","key","slice","_newlines","includes","charCodeAt","_nextChar","_breakingSpaces","push","_token","_char","_index","_breakWords","_fonts","properties","descent","_context","metricsString","METRICS_STRING","BASELINE_SYMBOL","ceil","baseline","HEIGHT_MULTIPLIER","BASELINE_MULTIPLIER","fillStyle","fillRect","textBaseline","fillText","imagedata","getImageData","data","pixels","idx","stop","clearMetrics","__canvas","c","OffscreenCanvas","createCanvas","__context","Intl","Segmenter","segmenter","s","segment","map","x","TextMetrics"]
}
