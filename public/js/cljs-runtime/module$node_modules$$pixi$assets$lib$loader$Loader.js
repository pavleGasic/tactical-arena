shadow$provide.module$node_modules$$pixi$assets$lib$loader$Loader = function(global, require, module, exports) {
  var core = require("module$node_modules$$pixi$core$lib$index");
  require("module$node_modules$$pixi$assets$lib$utils$index");
  var isSingleItem = require("module$node_modules$$pixi$assets$lib$utils$isSingleItem"), convertToList = require("module$node_modules$$pixi$assets$lib$utils$convertToList");
  class Loader {
    constructor() {
      this._parsers = [];
      this._parsersValidated = !1;
      this.parsers = new Proxy(this._parsers, {set:(target, key, value) => (this._parsersValidated = !1, target[key] = value, !0)});
      this.promiseCache = {};
    }
    reset() {
      this._parsersValidated = !1;
      this.promiseCache = {};
    }
    _getLoadPromiseAndParser(url, data) {
      const result = {promise:null, parser:null};
      return result.promise = (async() => {
        var asset, parser = null;
        if (data.loadParser && (parser = this._parserHash[data.loadParser], parser || console.warn(`[Assets] specified load parser "${data.loadParser}" not found while loading ${url}`)), !parser) {
          for (asset = 0; asset < this.parsers.length; asset++) {
            var parserX = this.parsers[asset];
            if (parserX.load && parserX.test?.(url, data, this)) {
              parser = parserX;
              break;
            }
          }
          if (!parser) {
            return console.warn(`[Assets] ${url} could not be loaded as we don't know how to parse it, ensure the correct parser has been added`), null;
          }
        }
        asset = await parser.load(url, data, this);
        result.parser = parser;
        for (parser = 0; parser < this.parsers.length; parser++) {
          parserX = this.parsers[parser], parserX.parse && parserX.parse && await parserX.testParse?.(asset, data, this) && (asset = await parserX.parse(asset, data, this) || asset, result.parser = parserX);
        }
        return asset;
      })(), result;
    }
    async load(assetsToLoadIn, onProgress) {
      this._parsersValidated || this._validateParsers();
      let count = 0;
      const assets = {}, singleAsset = isSingleItem.isSingleItem(assetsToLoadIn);
      assetsToLoadIn = convertToList.convertToList(assetsToLoadIn, item => ({alias:[item], src:item}));
      const total = assetsToLoadIn.length, promises = assetsToLoadIn.map(async asset => {
        const url = core.utils.path.toAbsolute(asset.src);
        if (!assets[asset.src]) {
          try {
            this.promiseCache[url] || (this.promiseCache[url] = this._getLoadPromiseAndParser(url, asset)), assets[asset.src] = await this.promiseCache[url].promise, onProgress && onProgress(++count / total);
          } catch (e) {
            throw delete this.promiseCache[url], delete assets[asset.src], Error(`[Loader.load] Failed to load ${url}.
${e}`);
          }
        }
      });
      return await Promise.all(promises), singleAsset ? assets[assetsToLoadIn[0].src] : assets;
    }
    async unload(assetsToUnloadIn) {
      assetsToUnloadIn = convertToList.convertToList(assetsToUnloadIn, item => ({alias:[item], src:item})).map(async asset => {
        const url = core.utils.path.toAbsolute(asset.src), loadPromise = this.promiseCache[url];
        if (loadPromise) {
          const loadedAsset = await loadPromise.promise;
          delete this.promiseCache[url];
          loadPromise.parser?.unload?.(loadedAsset, asset, this);
        }
      });
      await Promise.all(assetsToUnloadIn);
    }
    _validateParsers() {
      this._parsersValidated = !0;
      this._parserHash = this._parsers.filter(parser => parser.name).reduce((hash, parser) => (hash[parser.name] && console.warn(`[Assets] loadParser name conflict "${parser.name}"`), {...hash, [parser.name]:parser}), {});
    }
  }
  exports.Loader = Loader;
};

//# sourceMappingURL=module$node_modules$$pixi$assets$lib$loader$Loader.js.map
