{
"version":3,
"file":"module$node_modules$pixi_DOT_js$lib$assets$Assets.js",
"lineCount":181,
"mappings":"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",
"sources":["node_modules/pixi_DOT_js/lib/assets/Assets.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$pixi_DOT_js$lib$assets$Assets\"] = function(global,require,module,exports) {\n'use strict';\n\nvar Extensions = require('../extensions/Extensions.js');\nvar loadBitmapFont = require('../scene/text-bitmap/asset/loadBitmapFont.js');\nvar warn = require('../utils/logging/warn.js');\nvar BackgroundLoader = require('./BackgroundLoader.js');\nvar Cache = require('./cache/Cache.js');\nvar cacheTextureArray = require('./cache/parsers/cacheTextureArray.js');\nvar detectAvif = require('./detections/parsers/detectAvif.js');\nvar detectDefaults = require('./detections/parsers/detectDefaults.js');\nvar detectMp4 = require('./detections/parsers/detectMp4.js');\nvar detectOgv = require('./detections/parsers/detectOgv.js');\nvar detectWebm = require('./detections/parsers/detectWebm.js');\nvar detectWebp = require('./detections/parsers/detectWebp.js');\nvar Loader = require('./loader/Loader.js');\nvar loadJson = require('./loader/parsers/loadJson.js');\nvar loadTxt = require('./loader/parsers/loadTxt.js');\nvar loadWebFont = require('./loader/parsers/loadWebFont.js');\nvar loadSVG = require('./loader/parsers/textures/loadSVG.js');\nvar loadTextures = require('./loader/parsers/textures/loadTextures.js');\nvar loadVideoTextures = require('./loader/parsers/textures/loadVideoTextures.js');\nvar resolveJsonUrl = require('./resolver/parsers/resolveJsonUrl.js');\nvar resolveTextureUrl = require('./resolver/parsers/resolveTextureUrl.js');\nvar Resolver = require('./resolver/Resolver.js');\nvar convertToList = require('./utils/convertToList.js');\nvar isSingleItem = require('./utils/isSingleItem.js');\n\n\"use strict\";\nclass AssetsClass {\n  constructor() {\n    this._detections = [];\n    this._initialized = false;\n    this.resolver = new Resolver.Resolver();\n    this.loader = new Loader.Loader();\n    this.cache = Cache.Cache;\n    this._backgroundLoader = new BackgroundLoader.BackgroundLoader(this.loader);\n    this._backgroundLoader.active = true;\n    this.reset();\n  }\n  /**\n   * Best practice is to call this function before any loading commences\n   * Initiating is the best time to add any customization to the way things are loaded.\n   *\n   * you do not need to call this for the Assets class to work, only if you want to set any initial properties\n   * @param options - options to initialize the Assets manager with\n   */\n  async init(options = {}) {\n    if (this._initialized) {\n      warn.warn(\"[Assets]AssetManager already initialized, did you load before calling this Assets.init()?\");\n      return;\n    }\n    this._initialized = true;\n    if (options.defaultSearchParams) {\n      this.resolver.setDefaultSearchParams(options.defaultSearchParams);\n    }\n    if (options.basePath) {\n      this.resolver.basePath = options.basePath;\n    }\n    if (options.bundleIdentifier) {\n      this.resolver.setBundleIdentifier(options.bundleIdentifier);\n    }\n    if (options.manifest) {\n      let manifest = options.manifest;\n      if (typeof manifest === \"string\") {\n        manifest = await this.load(manifest);\n      }\n      this.resolver.addManifest(manifest);\n    }\n    const resolutionPref = options.texturePreference?.resolution ?? 1;\n    const resolution = typeof resolutionPref === \"number\" ? [resolutionPref] : resolutionPref;\n    const formats = await this._detectFormats({\n      preferredFormats: options.texturePreference?.format,\n      skipDetections: options.skipDetections,\n      detections: this._detections\n    });\n    this.resolver.prefer({\n      params: {\n        format: formats,\n        resolution\n      }\n    });\n    if (options.preferences) {\n      this.setPreferences(options.preferences);\n    }\n  }\n  /**\n   * Allows you to specify how to resolve any assets load requests.\n   * There are a few ways to add things here as shown below:\n   * @example\n   * import { Assets } from 'pixi.js';\n   *\n   * // Simple\n   * Assets.add({alias: 'bunnyBooBoo', src: 'bunny.png'});\n   * const bunny = await Assets.load('bunnyBooBoo');\n   *\n   * // Multiple keys:\n   * Assets.add({alias: ['burger', 'chicken'], src: 'bunny.png'});\n   *\n   * const bunny = await Assets.load('burger');\n   * const bunny2 = await Assets.load('chicken');\n   *\n   * // passing options to to the object\n   * Assets.add({\n   *     alias: 'bunnyBooBooSmooth',\n   *     src: 'bunny.{png,webp}',\n   *     data: { scaleMode: SCALE_MODES.NEAREST }, // Base texture options\n   * });\n   *\n   * // Multiple assets\n   *\n   * // The following all do the same thing:\n   *\n   * Assets.add({alias: 'bunnyBooBoo', src: 'bunny.{png,webp}'});\n   *\n   * Assets.add({\n   *     alias: 'bunnyBooBoo',\n   *     src: [\n   *         'bunny.png',\n   *         'bunny.webp',\n   *    ],\n   * });\n   *\n   * const bunny = await Assets.load('bunnyBooBoo'); // Will try to load WebP if available\n   * @param assets - the unresolved assets to add to the resolver\n   */\n  add(assets) {\n    this.resolver.add(assets);\n  }\n  async load(urls, onProgress) {\n    if (!this._initialized) {\n      await this.init();\n    }\n    const singleAsset = isSingleItem.isSingleItem(urls);\n    const urlArray = convertToList.convertToList(urls).map((url) => {\n      if (typeof url !== \"string\") {\n        const aliases = this.resolver.getAlias(url);\n        if (aliases.some((alias) => !this.resolver.hasKey(alias))) {\n          this.add(url);\n        }\n        return Array.isArray(aliases) ? aliases[0] : aliases;\n      }\n      if (!this.resolver.hasKey(url))\n        this.add({ alias: url, src: url });\n      return url;\n    });\n    const resolveResults = this.resolver.resolve(urlArray);\n    const out = await this._mapLoadToResolve(resolveResults, onProgress);\n    return singleAsset ? out[urlArray[0]] : out;\n  }\n  /**\n   * This adds a bundle of assets in one go so that you can load them as a group.\n   * For example you could add a bundle for each screen in you pixi app\n   * @example\n   * import { Assets } from 'pixi.js';\n   *\n   * Assets.addBundle('animals', [\n   *  { alias: 'bunny', src: 'bunny.png' },\n   *  { alias: 'chicken', src: 'chicken.png' },\n   *  { alias: 'thumper', src: 'thumper.png' },\n   * ]);\n   * // or\n   * Assets.addBundle('animals', {\n   *     bunny: 'bunny.png',\n   *     chicken: 'chicken.png',\n   *     thumper: 'thumper.png',\n   * });\n   *\n   * const assets = await Assets.loadBundle('animals');\n   * @param bundleId - the id of the bundle to add\n   * @param assets - a record of the asset or assets that will be chosen from when loading via the specified key\n   */\n  addBundle(bundleId, assets) {\n    this.resolver.addBundle(bundleId, assets);\n  }\n  /**\n   * Bundles are a way to load multiple assets at once.\n   * If a manifest has been provided to the init function then you can load a bundle, or bundles.\n   * you can also add bundles via `addBundle`\n   * @example\n   * import { Assets } from 'pixi.js';\n   *\n   * // Manifest Example\n   * const manifest = {\n   *     bundles: [\n   *         {\n   *             name: 'load-screen',\n   *             assets: [\n   *                 {\n   *                     alias: 'background',\n   *                     src: 'sunset.png',\n   *                 },\n   *                 {\n   *                     alias: 'bar',\n   *                     src: 'load-bar.{png,webp}',\n   *                 },\n   *             ],\n   *         },\n   *         {\n   *             name: 'game-screen',\n   *             assets: [\n   *                 {\n   *                     alias: 'character',\n   *                     src: 'robot.png',\n   *                 },\n   *                 {\n   *                     alias: 'enemy',\n   *                     src: 'bad-guy.png',\n   *                 },\n   *             ],\n   *         },\n   *     ]\n   * };\n   *\n   * await Assets.init({ manifest });\n   *\n   * // Load a bundle...\n   * loadScreenAssets = await Assets.loadBundle('load-screen');\n   * // Load another bundle...\n   * gameScreenAssets = await Assets.loadBundle('game-screen');\n   * @param bundleIds - the bundle id or ids to load\n   * @param onProgress - Optional function that is called when progress on asset loading is made.\n   * The function is passed a single parameter, `progress`, which represents the percentage (0.0 - 1.0)\n   * of the assets loaded. Do not use this function to detect when assets are complete and available,\n   * instead use the Promise returned by this function.\n   * @returns all the bundles assets or a hash of assets for each bundle specified\n   */\n  async loadBundle(bundleIds, onProgress) {\n    if (!this._initialized) {\n      await this.init();\n    }\n    let singleAsset = false;\n    if (typeof bundleIds === \"string\") {\n      singleAsset = true;\n      bundleIds = [bundleIds];\n    }\n    const resolveResults = this.resolver.resolveBundle(bundleIds);\n    const out = {};\n    const keys = Object.keys(resolveResults);\n    let count = 0;\n    let total = 0;\n    const _onProgress = () => {\n      onProgress?.(++count / total);\n    };\n    const promises = keys.map((bundleId) => {\n      const resolveResult = resolveResults[bundleId];\n      total += Object.keys(resolveResult).length;\n      return this._mapLoadToResolve(resolveResult, _onProgress).then((resolveResult2) => {\n        out[bundleId] = resolveResult2;\n      });\n    });\n    await Promise.all(promises);\n    return singleAsset ? out[bundleIds[0]] : out;\n  }\n  /**\n   * Initiate a background load of some assets. It will passively begin to load these assets in the background.\n   * So when you actually come to loading them you will get a promise that resolves to the loaded assets immediately\n   *\n   * An example of this might be that you would background load game assets after your initial load.\n   * then when you got to actually load your game screen assets when a player goes to the game - the loading\n   * would already have stared or may even be complete, saving you having to show an interim load bar.\n   * @example\n   * import { Assets } from 'pixi.js';\n   *\n   * Assets.backgroundLoad('bunny.png');\n   *\n   * // later on in your app...\n   * await Assets.loadBundle('bunny.png'); // Will resolve quicker as loading may have completed!\n   * @param urls - the url / urls you want to background load\n   */\n  async backgroundLoad(urls) {\n    if (!this._initialized) {\n      await this.init();\n    }\n    if (typeof urls === \"string\") {\n      urls = [urls];\n    }\n    const resolveResults = this.resolver.resolve(urls);\n    this._backgroundLoader.add(Object.values(resolveResults));\n  }\n  /**\n   * Initiate a background of a bundle, works exactly like backgroundLoad but for bundles.\n   * this can only be used if the loader has been initiated with a manifest\n   * @example\n   * import { Assets } from 'pixi.js';\n   *\n   * await Assets.init({\n   *     manifest: {\n   *         bundles: [\n   *             {\n   *                 name: 'load-screen',\n   *                 assets: [...],\n   *             },\n   *             ...\n   *         ],\n   *     },\n   * });\n   *\n   * Assets.backgroundLoadBundle('load-screen');\n   *\n   * // Later on in your app...\n   * await Assets.loadBundle('load-screen'); // Will resolve quicker as loading may have completed!\n   * @param bundleIds - the bundleId / bundleIds you want to background load\n   */\n  async backgroundLoadBundle(bundleIds) {\n    if (!this._initialized) {\n      await this.init();\n    }\n    if (typeof bundleIds === \"string\") {\n      bundleIds = [bundleIds];\n    }\n    const resolveResults = this.resolver.resolveBundle(bundleIds);\n    Object.values(resolveResults).forEach((resolveResult) => {\n      this._backgroundLoader.add(Object.values(resolveResult));\n    });\n  }\n  /**\n   * Only intended for development purposes.\n   * This will wipe the resolver and caches.\n   * You will need to reinitialize the Asset\n   */\n  reset() {\n    this.resolver.reset();\n    this.loader.reset();\n    this.cache.reset();\n    this._initialized = false;\n  }\n  get(keys) {\n    if (typeof keys === \"string\") {\n      return Cache.Cache.get(keys);\n    }\n    const assets = {};\n    for (let i = 0; i < keys.length; i++) {\n      assets[i] = Cache.Cache.get(keys[i]);\n    }\n    return assets;\n  }\n  /**\n   * helper function to map resolved assets back to loaded assets\n   * @param resolveResults - the resolve results from the resolver\n   * @param onProgress - the progress callback\n   */\n  async _mapLoadToResolve(resolveResults, onProgress) {\n    const resolveArray = [...new Set(Object.values(resolveResults))];\n    this._backgroundLoader.active = false;\n    const loadedAssets = await this.loader.load(resolveArray, onProgress);\n    this._backgroundLoader.active = true;\n    const out = {};\n    resolveArray.forEach((resolveResult) => {\n      const asset = loadedAssets[resolveResult.src];\n      const keys = [resolveResult.src];\n      if (resolveResult.alias) {\n        keys.push(...resolveResult.alias);\n      }\n      keys.forEach((key) => {\n        out[key] = asset;\n      });\n      Cache.Cache.set(keys, asset);\n    });\n    return out;\n  }\n  /**\n   * Unload an asset or assets. As the Assets class is responsible for creating the assets via the `load` function\n   * this will make sure to destroy any assets and release them from memory.\n   * Once unloaded, you will need to load the asset again.\n   *\n   * Use this to help manage assets if you find that you have a large app and you want to free up memory.\n   *\n   * - it's up to you as the developer to make sure that textures are not actively being used when you unload them,\n   * Pixi won't break but you will end up with missing assets. Not a good look for the user!\n   * @example\n   * import { Assets } from 'pixi.js';\n   *\n   * // Load a URL:\n   * const myImageTexture = await Assets.load('http://some.url.com/image.png'); // => returns a texture\n   *\n   * await Assets.unload('http://some.url.com/image.png')\n   *\n   * // myImageTexture will be destroyed now.\n   *\n   * // Unload multiple assets:\n   * const textures = await Assets.unload(['thumper', 'chicko']);\n   * @param urls - the urls to unload\n   */\n  async unload(urls) {\n    if (!this._initialized) {\n      await this.init();\n    }\n    const urlArray = convertToList.convertToList(urls).map((url) => typeof url !== \"string\" ? url.src : url);\n    const resolveResults = this.resolver.resolve(urlArray);\n    await this._unloadFromResolved(resolveResults);\n  }\n  /**\n   * Bundles are a way to manage multiple assets at once.\n   * this will unload all files in a bundle.\n   *\n   * once a bundle has been unloaded, you need to load it again to have access to the assets.\n   * @example\n   * import { Assets } from 'pixi.js';\n   *\n   * Assets.addBundle({\n   *     'thumper': 'http://some.url.com/thumper.png',\n   * })\n   *\n   * const assets = await Assets.loadBundle('thumper');\n   *\n   * // Now to unload...\n   *\n   * await Assets.unloadBundle('thumper');\n   *\n   * // All assets in the assets object will now have been destroyed and purged from the cache\n   * @param bundleIds - the bundle id or ids to unload\n   */\n  async unloadBundle(bundleIds) {\n    if (!this._initialized) {\n      await this.init();\n    }\n    bundleIds = convertToList.convertToList(bundleIds);\n    const resolveResults = this.resolver.resolveBundle(bundleIds);\n    const promises = Object.keys(resolveResults).map((bundleId) => this._unloadFromResolved(resolveResults[bundleId]));\n    await Promise.all(promises);\n  }\n  async _unloadFromResolved(resolveResult) {\n    const resolveArray = Object.values(resolveResult);\n    resolveArray.forEach((resolveResult2) => {\n      Cache.Cache.remove(resolveResult2.src);\n    });\n    await this.loader.unload(resolveArray);\n  }\n  /**\n   * Detects the supported formats for the browser, and returns an array of supported formats, respecting\n   * the users preferred formats order.\n   * @param options - the options to use when detecting formats\n   * @param options.preferredFormats - the preferred formats to use\n   * @param options.skipDetections - if we should skip the detections altogether\n   * @param options.detections - the detections to use\n   * @returns - the detected formats\n   */\n  async _detectFormats(options) {\n    let formats = [];\n    if (options.preferredFormats) {\n      formats = Array.isArray(options.preferredFormats) ? options.preferredFormats : [options.preferredFormats];\n    }\n    for (const detection of options.detections) {\n      if (options.skipDetections || await detection.test()) {\n        formats = await detection.add(formats);\n      } else if (!options.skipDetections) {\n        formats = await detection.remove(formats);\n      }\n    }\n    formats = formats.filter((format, index) => formats.indexOf(format) === index);\n    return formats;\n  }\n  /** All the detection parsers currently added to the Assets class. */\n  get detections() {\n    return this._detections;\n  }\n  /**\n   * General setter for preferences. This is a helper function to set preferences on all parsers.\n   * @param preferences - the preferences to set\n   */\n  setPreferences(preferences) {\n    this.loader.parsers.forEach((parser) => {\n      if (!parser.config)\n        return;\n      Object.keys(parser.config).filter((key) => key in preferences).forEach((key) => {\n        parser.config[key] = preferences[key];\n      });\n    });\n  }\n}\nconst Assets = new AssetsClass();\nExtensions.extensions.handleByList(Extensions.ExtensionType.LoadParser, Assets.loader.parsers).handleByList(Extensions.ExtensionType.ResolveParser, Assets.resolver.parsers).handleByList(Extensions.ExtensionType.CacheParser, Assets.cache.parsers).handleByList(Extensions.ExtensionType.DetectionParser, Assets.detections);\nExtensions.extensions.add(\n  cacheTextureArray.cacheTextureArray,\n  detectDefaults.detectDefaults,\n  detectAvif.detectAvif,\n  detectWebp.detectWebp,\n  detectMp4.detectMp4,\n  detectOgv.detectOgv,\n  detectWebm.detectWebm,\n  loadJson.loadJson,\n  loadTxt.loadTxt,\n  loadWebFont.loadWebFont,\n  loadSVG.loadSvg,\n  loadTextures.loadTextures,\n  loadVideoTextures.loadVideoTextures,\n  loadBitmapFont.loadBitmapFont,\n  loadBitmapFont.bitmapFontCachePlugin,\n  resolveTextureUrl.resolveTextureUrl,\n  resolveJsonUrl.resolveJsonUrl\n);\nconst assetKeyMap = {\n  loader: Extensions.ExtensionType.LoadParser,\n  resolver: Extensions.ExtensionType.ResolveParser,\n  cache: Extensions.ExtensionType.CacheParser,\n  detection: Extensions.ExtensionType.DetectionParser\n};\nExtensions.extensions.handle(Extensions.ExtensionType.Asset, (extension) => {\n  const ref = extension.ref;\n  Object.entries(assetKeyMap).filter(([key]) => !!ref[key]).forEach(([key, type]) => Extensions.extensions.add(Object.assign(\n    ref[key],\n    // Allow the function to optionally define it's own\n    // ExtensionMetadata, the use cases here is priority for LoaderParsers\n    { extension: ref[key].extension ?? type }\n  )));\n}, (extension) => {\n  const ref = extension.ref;\n  Object.keys(assetKeyMap).filter((key) => !!ref[key]).forEach((key) => Extensions.extensions.remove(ref[key]));\n});\n\nexports.Assets = Assets;\nexports.AssetsClass = AssetsClass;\n//# sourceMappingURL=Assets.js.map\n\n};"],
"names":["shadow$provide","global","require","module","exports","Extensions","loadBitmapFont","warn","BackgroundLoader","Cache","cacheTextureArray","detectAvif","detectDefaults","detectMp4","detectOgv","detectWebm","detectWebp","Loader","loadJson","loadTxt","loadWebFont","loadSVG","loadTextures","loadVideoTextures","resolveJsonUrl","resolveTextureUrl","Resolver","convertToList","isSingleItem","AssetsClass","constructor","_detections","_initialized","resolver","loader","cache","_backgroundLoader","active","reset","init","options","defaultSearchParams","setDefaultSearchParams","basePath","bundleIdentifier","setBundleIdentifier","manifest","load","addManifest","resolutionPref","texturePreference","resolution","formats","_detectFormats","preferredFormats","format","skipDetections","detections","prefer","params","preferences","setPreferences","add","assets","urls","onProgress","singleAsset","urlArray","map","url","aliases","getAlias","some","alias","hasKey","Array","isArray","src","resolveResults","resolve","out","_mapLoadToResolve","addBundle","bundleId","loadBundle","bundleIds","resolveBundle","count","total","_onProgress","promises","Object","keys","resolveResult","length","then","resolveResult2","Promise","all","backgroundLoad","values","backgroundLoadBundle","forEach","get","i","resolveArray","Set","loadedAssets","asset","push","key","set","unload","_unloadFromResolved","unloadBundle","remove","detection","test","filter","index","indexOf","parsers","parser","config","Assets","extensions","handleByList","ExtensionType","LoadParser","ResolveParser","CacheParser","DetectionParser","loadSvg","bitmapFontCachePlugin","assetKeyMap","handle","Asset","extension","ref","entries","type","assign"]
}
