shadow$provide.module$node_modules$$pixi$core$lib$renderTexture$RenderTexturePool = function(global, require, module, exports) {
  var constants = require("module$node_modules$$pixi$constants$lib$index"), utils = require("module$node_modules$$pixi$utils$lib$index"), BaseRenderTexture = require("module$node_modules$$pixi$core$lib$renderTexture$BaseRenderTexture"), RenderTexture = require("module$node_modules$$pixi$core$lib$renderTexture$RenderTexture");
  class RenderTexturePool {
    constructor(textureOptions) {
      this.texturePool = {};
      this.textureOptions = textureOptions || {};
      this.enableFullScreen = !1;
      this._pixelsHeight = this._pixelsWidth = 0;
    }
    createTexture(realWidth, realHeight, multisample = constants.MSAA_QUALITY.NONE) {
      realWidth = new BaseRenderTexture.BaseRenderTexture(Object.assign({width:realWidth, height:realHeight, resolution:1, multisample}, this.textureOptions));
      return new RenderTexture.RenderTexture(realWidth);
    }
    getOptimalTexture(minWidth, minHeight, resolution = 1, multisample = constants.MSAA_QUALITY.NONE) {
      let key;
      minWidth = Math.max(Math.ceil(minWidth * resolution - 1e-6), 1);
      minHeight = Math.max(Math.ceil(minHeight * resolution - 1e-6), 1);
      this.enableFullScreen && minWidth === this._pixelsWidth && minHeight === this._pixelsHeight ? key = 1 < multisample ? -multisample : -1 : (minWidth = utils.nextPow2(minWidth), minHeight = utils.nextPow2(minHeight), key = ((minWidth & 65535) << 16 | minHeight & 65535) >>> 0, 1 < multisample && (key += 4294967296 * multisample));
      this.texturePool[key] || (this.texturePool[key] = []);
      let renderTexture = this.texturePool[key].pop();
      return renderTexture || (renderTexture = this.createTexture(minWidth, minHeight, multisample)), renderTexture.filterPoolKey = key, renderTexture.setResolution(resolution), renderTexture;
    }
    getFilterTexture(input, resolution, multisample) {
      resolution = this.getOptimalTexture(input.width, input.height, resolution || input.resolution, multisample || constants.MSAA_QUALITY.NONE);
      return resolution.filterFrame = input.filterFrame, resolution;
    }
    returnTexture(renderTexture) {
      const key = renderTexture.filterPoolKey;
      renderTexture.filterFrame = null;
      this.texturePool[key].push(renderTexture);
    }
    returnFilterTexture(renderTexture) {
      this.returnTexture(renderTexture);
    }
    clear(destroyTextures) {
      if (destroyTextures = !1 !== destroyTextures, destroyTextures) {
        for (const i in this.texturePool) {
          if (destroyTextures = this.texturePool[i]) {
            for (let j = 0; j < destroyTextures.length; j++) {
              destroyTextures[j].destroy(!0);
            }
          }
        }
      }
      this.texturePool = {};
    }
    setScreenSize(size) {
      if (size.width !== this._pixelsWidth || size.height !== this._pixelsHeight) {
        this.enableFullScreen = 0 < size.width && 0 < size.height;
        for (const i in this.texturePool) {
          if (!(0 > Number(i))) {
            continue;
          }
          const textures = this.texturePool[i];
          if (textures) {
            for (let j = 0; j < textures.length; j++) {
              textures[j].destroy(!0);
            }
          }
          this.texturePool[i] = [];
        }
        this._pixelsWidth = size.width;
        this._pixelsHeight = size.height;
      }
    }
  }
  RenderTexturePool.SCREEN_KEY = -1;
  exports.RenderTexturePool = RenderTexturePool;
};

//# sourceMappingURL=module$node_modules$$pixi$core$lib$renderTexture$RenderTexturePool.js.map
