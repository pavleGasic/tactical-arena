shadow$provide.module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$shader$Shader = function(global, require, module, exports) {
  global = require("module$node_modules$eventemitter3$index");
  var uid = require("module$node_modules$pixi_DOT_js$lib$utils$data$uid"), GlProgram = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$gl$shader$GlProgram"), BindGroup = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$gpu$shader$BindGroup"), GpuProgram = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$gpu$shader$GpuProgram"), types = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$types"), UniformGroup = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$shader$UniformGroup");
  "use strict";
  class Shader extends global {
    constructor(options) {
      super();
      this.uid = uid.uid("shader");
      this._uniformBindMap = Object.create(null);
      this._ownedBindGroups = [];
      let {gpuProgram, glProgram, groups, resources, compatibleRenderers, groupMap} = options;
      this.gpuProgram = gpuProgram;
      this.glProgram = glProgram;
      void 0 === compatibleRenderers && (compatibleRenderers = 0, gpuProgram && (compatibleRenderers |= types.RendererType.WEBGPU), glProgram && (compatibleRenderers |= types.RendererType.WEBGL));
      this.compatibleRenderers = compatibleRenderers;
      const nameHash = {};
      resources || groups || (resources = {});
      if (resources && groups) {
        throw Error("[Shader] Cannot have both resources and groups");
      }
      if (!gpuProgram && groups && !groupMap) {
        throw Error("[Shader] No group map or WebGPU shader provided - consider using resources instead.");
      }
      if (!gpuProgram && groups && groupMap) {
        for (var i$jscomp$0 in groupMap) {
          for (var j in groupMap[i$jscomp$0]) {
            var uniformName = groupMap[i$jscomp$0][j];
            nameHash[uniformName] = {group:i$jscomp$0, binding:j, name:uniformName};
          }
        }
      } else if (gpuProgram && groups && !groupMap) {
        uniformName = gpuProgram.structsAndGroups.groups, groupMap = {}, uniformName.forEach(data => {
          groupMap[data.group] = groupMap[data.group] || {};
          groupMap[data.group][data.binding] = data.name;
          nameHash[data.name] = data;
        });
      } else if (resources) {
        groups = {};
        groupMap = {};
        gpuProgram && gpuProgram.structsAndGroups.groups.forEach(data => {
          groupMap[data.group] = groupMap[data.group] || {};
          groupMap[data.group][data.binding] = data.name;
          nameHash[data.name] = data;
        });
        i$jscomp$0 = 0;
        for (const i in resources) {
          nameHash[i] || (groups[99] || (groups[99] = new BindGroup.BindGroup(), this._ownedBindGroups.push(groups[99])), nameHash[i] = {group:99, binding:i$jscomp$0, name:i}, groupMap[99] = groupMap[99] || {}, groupMap[99][i$jscomp$0] = i, i$jscomp$0++);
        }
        for (uniformName in resources) {
          if (j = uniformName, i$jscomp$0 = resources[uniformName], i$jscomp$0.source || i$jscomp$0._resourceType || (i$jscomp$0 = new UniformGroup.UniformGroup(i$jscomp$0)), j = nameHash[j]) {
            groups[j.group] || (groups[j.group] = new BindGroup.BindGroup(), this._ownedBindGroups.push(groups[j.group])), groups[j.group].setResource(i$jscomp$0, j.binding);
          }
        }
      }
      this.groups = groups;
      this._uniformBindMap = groupMap;
      this.resources = this._buildResourceAccessor(groups, nameHash);
    }
    addResource(name, groupIndex, bindIndex) {
      var _a, _b;
      (_a = this._uniformBindMap)[groupIndex] || (_a[groupIndex] = {});
      (_b = this._uniformBindMap[groupIndex])[bindIndex] || (_b[bindIndex] = name);
      this.groups[groupIndex] || (this.groups[groupIndex] = new BindGroup.BindGroup(), this._ownedBindGroups.push(this.groups[groupIndex]));
    }
    _buildResourceAccessor(groups, nameHash) {
      const uniformsOut = {};
      for (const i in nameHash) {
        const data = nameHash[i];
        Object.defineProperty(uniformsOut, data.name, {get() {
          return groups[data.group].getResource(data.binding);
        }, set(value) {
          groups[data.group].setResource(value, data.binding);
        }});
      }
      return uniformsOut;
    }
    destroy(destroyPrograms = !1) {
      this.emit("destroy", this);
      destroyPrograms && (this.gpuProgram?.destroy(), this.glProgram?.destroy());
      this.glProgram = this.gpuProgram = null;
      this.removeAllListeners();
      this._uniformBindMap = null;
      this._ownedBindGroups.forEach(bindGroup => {
        bindGroup.destroy();
      });
      this.groups = this.resources = this._ownedBindGroups = null;
    }
    static from(options) {
      const {gpu, gl, ...rest} = options;
      let gpuProgram, glProgram;
      gpu && (gpuProgram = GpuProgram.GpuProgram.from(gpu));
      gl && (glProgram = GlProgram.GlProgram.from(gl));
      return new Shader({gpuProgram, glProgram, ...rest});
    }
  }
  exports.Shader = Shader;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$shader$Shader.js.map
