shadow$provide.module$node_modules$pixi_DOT_js$lib$rendering$batcher$shared$BatcherPipe = function(global, require, module, exports) {
  global = require("module$node_modules$pixi_DOT_js$lib$extensions$Extensions");
  var State = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$state$State"), DefaultBatcher = require("module$node_modules$pixi_DOT_js$lib$rendering$batcher$shared$DefaultBatcher");
  "use strict";
  const node_modules$pixi_DOT_js$lib$rendering$batcher$shared$BatcherPipe$classdecl$var24 = class {
    constructor(renderer, adaptor) {
      this.state = State.State.for2d();
      this._batchersByInstructionSet = Object.create(null);
      this._activeBatches = Object.create(null);
      this.renderer = renderer;
      this._adaptor = adaptor;
      this._adaptor.init?.(this);
    }
    static getBatcher(name) {
      return new this._availableBatchers[name]();
    }
    buildStart(instructionSet) {
      let batchers = this._batchersByInstructionSet[instructionSet.uid];
      batchers || (batchers = this._batchersByInstructionSet[instructionSet.uid] = Object.create(null), batchers.default || (batchers.default = new DefaultBatcher.DefaultBatcher()));
      this._activeBatches = batchers;
      this._activeBatch = this._activeBatches.default;
      for (const i in this._activeBatches) {
        this._activeBatches[i].begin();
      }
    }
    addToBatch(batchableObject, instructionSet) {
      this._activeBatch.name !== batchableObject.batcherName && (this._activeBatch.break(instructionSet), instructionSet = this._activeBatches[batchableObject.batcherName], instructionSet || (instructionSet = this._activeBatches[batchableObject.batcherName] = node_modules$pixi_DOT_js$lib$rendering$batcher$shared$BatcherPipe$classdecl$var24.getBatcher(batchableObject.batcherName), instructionSet.begin()), this._activeBatch = instructionSet);
      this._activeBatch.add(batchableObject);
    }
    break(instructionSet) {
      this._activeBatch.break(instructionSet);
    }
    buildEnd(instructionSet) {
      this._activeBatch.break(instructionSet);
      instructionSet = this._activeBatches;
      for (const i in instructionSet) {
        const batch = instructionSet[i], geometry = batch.geometry;
        geometry.indexBuffer.setDataWithSize(batch.indexBuffer, batch.indexSize, !0);
        geometry.buffers[0].setDataWithSize(batch.attributeBuffer.float32View, batch.attributeSize, !1);
      }
    }
    upload(instructionSet) {
      instructionSet = this._batchersByInstructionSet[instructionSet.uid];
      for (const i in instructionSet) {
        const batcher = instructionSet[i], geometry = batcher.geometry;
        batcher.dirty && (batcher.dirty = !1, geometry.buffers[0].update(4 * batcher.attributeSize));
      }
    }
    execute(batch) {
      if ("startBatch" === batch.action) {
        const batcher = batch.batcher;
        this._adaptor.start(this, batcher.geometry, batcher.shader);
      }
      this._adaptor.execute(this, batch);
    }
    destroy() {
      this._adaptor = this.renderer = this.state = null;
      for (const i in this._activeBatches) {
        this._activeBatches[i].destroy();
      }
      this._activeBatches = null;
    }
  };
  require = node_modules$pixi_DOT_js$lib$rendering$batcher$shared$BatcherPipe$classdecl$var24;
  require.extension = {type:[global.ExtensionType.WebGLPipes, global.ExtensionType.WebGPUPipes, global.ExtensionType.CanvasPipes], name:"batch"};
  require._availableBatchers = Object.create(null);
  global.extensions.handleByMap(global.ExtensionType.Batcher, require._availableBatchers);
  global.extensions.add(DefaultBatcher.DefaultBatcher);
  exports.BatcherPipe = require;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$rendering$batcher$shared$BatcherPipe.js.map
