{
"version":3,
"file":"module$node_modules$pixi_DOT_js$lib$ticker$Ticker.js",
"lineCount":152,
"mappings":"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",
"sources":["node_modules/pixi_DOT_js/lib/ticker/Ticker.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$pixi_DOT_js$lib$ticker$Ticker\"] = function(global,require,module,exports) {\n'use strict';\n\nvar _const = require('./const.js');\nvar TickerListener = require('./TickerListener.js');\n\n\"use strict\";\nconst _Ticker = class _Ticker {\n  constructor() {\n    /**\n     * Whether or not this ticker should invoke the method\n     * {@link ticker.Ticker#start|start} automatically when a listener is added.\n     */\n    this.autoStart = false;\n    /**\n     * Scalar time value from last frame to this frame.\n     * This value is capped by setting {@link ticker.Ticker#minFPS|minFPS}\n     * and is scaled with {@link ticker.Ticker#speed|speed}.\n     * **Note:** The cap may be exceeded by scaling.\n     */\n    this.deltaTime = 1;\n    /**\n     * The last time {@link ticker.Ticker#update|update} was invoked.\n     * This value is also reset internally outside of invoking\n     * update, but only when a new animation frame is requested.\n     * If the platform supports DOMHighResTimeStamp,\n     * this value will have a precision of 1 \u00b5s.\n     */\n    this.lastTime = -1;\n    /**\n     * Factor of current {@link ticker.Ticker#deltaTime|deltaTime}.\n     * @example\n     * // Scales ticker.deltaTime to what would be\n     * // the equivalent of approximately 120 FPS\n     * ticker.speed = 2;\n     */\n    this.speed = 1;\n    /**\n     * Whether or not this ticker has been started.\n     * `true` if {@link ticker.Ticker#start|start} has been called.\n     * `false` if {@link ticker.Ticker#stop|Stop} has been called.\n     * While `false`, this value may change to `true` in the\n     * event of {@link ticker.Ticker#autoStart|autoStart} being `true`\n     * and a listener is added.\n     */\n    this.started = false;\n    /** Internal current frame request ID */\n    this._requestId = null;\n    /**\n     * Internal value managed by minFPS property setter and getter.\n     * This is the maximum allowed milliseconds between updates.\n     */\n    this._maxElapsedMS = 100;\n    /**\n     * Internal value managed by minFPS property setter and getter.\n     * This is the minimum allowed milliseconds between updates.\n     */\n    this._minElapsedMS = 0;\n    /** If enabled, deleting is disabled.*/\n    this._protected = false;\n    /** The last time keyframe was executed. Maintains a relatively fixed interval with the previous value. */\n    this._lastFrame = -1;\n    this._head = new TickerListener.TickerListener(null, null, Infinity);\n    this.deltaMS = 1 / _Ticker.targetFPMS;\n    this.elapsedMS = 1 / _Ticker.targetFPMS;\n    this._tick = (time) => {\n      this._requestId = null;\n      if (this.started) {\n        this.update(time);\n        if (this.started && this._requestId === null && this._head.next) {\n          this._requestId = requestAnimationFrame(this._tick);\n        }\n      }\n    };\n  }\n  /**\n   * Conditionally requests a new animation frame.\n   * If a frame has not already been requested, and if the internal\n   * emitter has listeners, a new frame is requested.\n   * @private\n   */\n  _requestIfNeeded() {\n    if (this._requestId === null && this._head.next) {\n      this.lastTime = performance.now();\n      this._lastFrame = this.lastTime;\n      this._requestId = requestAnimationFrame(this._tick);\n    }\n  }\n  /**\n   * Conditionally cancels a pending animation frame.\n   * @private\n   */\n  _cancelIfNeeded() {\n    if (this._requestId !== null) {\n      cancelAnimationFrame(this._requestId);\n      this._requestId = null;\n    }\n  }\n  /**\n   * Conditionally requests a new animation frame.\n   * If the ticker has been started it checks if a frame has not already\n   * been requested, and if the internal emitter has listeners. If these\n   * conditions are met, a new frame is requested. If the ticker has not\n   * been started, but autoStart is `true`, then the ticker starts now,\n   * and continues with the previous conditions to request a new frame.\n   * @private\n   */\n  _startIfPossible() {\n    if (this.started) {\n      this._requestIfNeeded();\n    } else if (this.autoStart) {\n      this.start();\n    }\n  }\n  /**\n   * Register a handler for tick events. Calls continuously unless\n   * it is removed or the ticker is stopped.\n   * @param fn - The listener function to be added for updates\n   * @param context - The listener context\n   * @param {number} [priority=UPDATE_PRIORITY.NORMAL] - The priority for emitting\n   * @returns This instance of a ticker\n   */\n  add(fn, context, priority = _const.UPDATE_PRIORITY.NORMAL) {\n    return this._addListener(new TickerListener.TickerListener(fn, context, priority));\n  }\n  /**\n   * Add a handler for the tick event which is only execute once.\n   * @param fn - The listener function to be added for one update\n   * @param context - The listener context\n   * @param {number} [priority=UPDATE_PRIORITY.NORMAL] - The priority for emitting\n   * @returns This instance of a ticker\n   */\n  addOnce(fn, context, priority = _const.UPDATE_PRIORITY.NORMAL) {\n    return this._addListener(new TickerListener.TickerListener(fn, context, priority, true));\n  }\n  /**\n   * Internally adds the event handler so that it can be sorted by priority.\n   * Priority allows certain handler (user, AnimatedSprite, Interaction) to be run\n   * before the rendering.\n   * @private\n   * @param listener - Current listener being added.\n   * @returns This instance of a ticker\n   */\n  _addListener(listener) {\n    let current = this._head.next;\n    let previous = this._head;\n    if (!current) {\n      listener.connect(previous);\n    } else {\n      while (current) {\n        if (listener.priority > current.priority) {\n          listener.connect(previous);\n          break;\n        }\n        previous = current;\n        current = current.next;\n      }\n      if (!listener.previous) {\n        listener.connect(previous);\n      }\n    }\n    this._startIfPossible();\n    return this;\n  }\n  /**\n   * Removes any handlers matching the function and context parameters.\n   * If no handlers are left after removing, then it cancels the animation frame.\n   * @param fn - The listener function to be removed\n   * @param context - The listener context to be removed\n   * @returns This instance of a ticker\n   */\n  remove(fn, context) {\n    let listener = this._head.next;\n    while (listener) {\n      if (listener.match(fn, context)) {\n        listener = listener.destroy();\n      } else {\n        listener = listener.next;\n      }\n    }\n    if (!this._head.next) {\n      this._cancelIfNeeded();\n    }\n    return this;\n  }\n  /**\n   * The number of listeners on this ticker, calculated by walking through linked list\n   * @readonly\n   * @member {number}\n   */\n  get count() {\n    if (!this._head) {\n      return 0;\n    }\n    let count = 0;\n    let current = this._head;\n    while (current = current.next) {\n      count++;\n    }\n    return count;\n  }\n  /** Starts the ticker. If the ticker has listeners a new animation frame is requested at this point. */\n  start() {\n    if (!this.started) {\n      this.started = true;\n      this._requestIfNeeded();\n    }\n  }\n  /** Stops the ticker. If the ticker has requested an animation frame it is canceled at this point. */\n  stop() {\n    if (this.started) {\n      this.started = false;\n      this._cancelIfNeeded();\n    }\n  }\n  /** Destroy the ticker and don't use after this. Calling this method removes all references to internal events. */\n  destroy() {\n    if (!this._protected) {\n      this.stop();\n      let listener = this._head.next;\n      while (listener) {\n        listener = listener.destroy(true);\n      }\n      this._head.destroy();\n      this._head = null;\n    }\n  }\n  /**\n   * Triggers an update. An update entails setting the\n   * current {@link ticker.Ticker#elapsedMS|elapsedMS},\n   * the current {@link ticker.Ticker#deltaTime|deltaTime},\n   * invoking all listeners with current deltaTime,\n   * and then finally setting {@link ticker.Ticker#lastTime|lastTime}\n   * with the value of currentTime that was provided.\n   * This method will be called automatically by animation\n   * frame callbacks if the ticker instance has been started\n   * and listeners are added.\n   * @param {number} [currentTime=performance.now()] - the current time of execution\n   */\n  update(currentTime = performance.now()) {\n    let elapsedMS;\n    if (currentTime > this.lastTime) {\n      elapsedMS = this.elapsedMS = currentTime - this.lastTime;\n      if (elapsedMS > this._maxElapsedMS) {\n        elapsedMS = this._maxElapsedMS;\n      }\n      elapsedMS *= this.speed;\n      if (this._minElapsedMS) {\n        const delta = currentTime - this._lastFrame | 0;\n        if (delta < this._minElapsedMS) {\n          return;\n        }\n        this._lastFrame = currentTime - delta % this._minElapsedMS;\n      }\n      this.deltaMS = elapsedMS;\n      this.deltaTime = this.deltaMS * _Ticker.targetFPMS;\n      const head = this._head;\n      let listener = head.next;\n      while (listener) {\n        listener = listener.emit(this);\n      }\n      if (!head.next) {\n        this._cancelIfNeeded();\n      }\n    } else {\n      this.deltaTime = this.deltaMS = this.elapsedMS = 0;\n    }\n    this.lastTime = currentTime;\n  }\n  /**\n   * The frames per second at which this ticker is running.\n   * The default is approximately 60 in most modern browsers.\n   * **Note:** This does not factor in the value of\n   * {@link ticker.Ticker#speed|speed}, which is specific\n   * to scaling {@link ticker.Ticker#deltaTime|deltaTime}.\n   * @member {number}\n   * @readonly\n   */\n  get FPS() {\n    return 1e3 / this.elapsedMS;\n  }\n  /**\n   * Manages the maximum amount of milliseconds allowed to\n   * elapse between invoking {@link ticker.Ticker#update|update}.\n   * This value is used to cap {@link ticker.Ticker#deltaTime|deltaTime},\n   * but does not effect the measured value of {@link ticker.Ticker#FPS|FPS}.\n   * When setting this property it is clamped to a value between\n   * `0` and `Ticker.targetFPMS * 1000`.\n   * @member {number}\n   * @default 10\n   */\n  get minFPS() {\n    return 1e3 / this._maxElapsedMS;\n  }\n  set minFPS(fps) {\n    const minFPS = Math.min(this.maxFPS, fps);\n    const minFPMS = Math.min(Math.max(0, minFPS) / 1e3, _Ticker.targetFPMS);\n    this._maxElapsedMS = 1 / minFPMS;\n  }\n  /**\n   * Manages the minimum amount of milliseconds required to\n   * elapse between invoking {@link ticker.Ticker#update|update}.\n   * This will effect the measured value of {@link ticker.Ticker#FPS|FPS}.\n   * If it is set to `0`, then there is no limit; PixiJS will render as many frames as it can.\n   * Otherwise it will be at least `minFPS`\n   * @member {number}\n   * @default 0\n   */\n  get maxFPS() {\n    if (this._minElapsedMS) {\n      return Math.round(1e3 / this._minElapsedMS);\n    }\n    return 0;\n  }\n  set maxFPS(fps) {\n    if (fps === 0) {\n      this._minElapsedMS = 0;\n    } else {\n      const maxFPS = Math.max(this.minFPS, fps);\n      this._minElapsedMS = 1 / (maxFPS / 1e3);\n    }\n  }\n  /**\n   * The shared ticker instance used by {@link AnimatedSprite} and by\n   * {@link VideoResource} to update animation frames / video textures.\n   *\n   * It may also be used by {@link Application} if created with the `sharedTicker` option property set to true.\n   *\n   * The property {@link ticker.Ticker#autoStart|autoStart} is set to `true` for this instance.\n   * Please follow the examples for usage, including how to opt-out of auto-starting the shared ticker.\n   * @example\n   * import { Ticker } from 'pixi.js';\n   *\n   * const ticker = Ticker.shared;\n   * // Set this to prevent starting this ticker when listeners are added.\n   * // By default this is true only for the Ticker.shared instance.\n   * ticker.autoStart = false;\n   *\n   * // FYI, call this to ensure the ticker is stopped. It should be stopped\n   * // if you have not attempted to render anything yet.\n   * ticker.stop();\n   *\n   * // Call this when you are ready for a running shared ticker.\n   * ticker.start();\n   * @example\n   * import { autoDetectRenderer, Container } from 'pixi.js';\n   *\n   * // You may use the shared ticker to render...\n   * const renderer = autoDetectRenderer();\n   * const stage = new Container();\n   * document.body.appendChild(renderer.view);\n   * ticker.add((time) => renderer.render(stage));\n   *\n   * // Or you can just update it manually.\n   * ticker.autoStart = false;\n   * ticker.stop();\n   * const animate = (time) => {\n   *     ticker.update(time);\n   *     renderer.render(stage);\n   *     requestAnimationFrame(animate);\n   * };\n   * animate(performance.now());\n   * @member {ticker.Ticker}\n   * @readonly\n   * @static\n   */\n  static get shared() {\n    if (!_Ticker._shared) {\n      const shared = _Ticker._shared = new _Ticker();\n      shared.autoStart = true;\n      shared._protected = true;\n    }\n    return _Ticker._shared;\n  }\n  /**\n   * The system ticker instance used by {@link BasePrepare} for core timing\n   * functionality that shouldn't usually need to be paused, unlike the `shared`\n   * ticker which drives visual animations and rendering which may want to be paused.\n   *\n   * The property {@link ticker.Ticker#autoStart|autoStart} is set to `true` for this instance.\n   * @member {ticker.Ticker}\n   * @readonly\n   * @static\n   */\n  static get system() {\n    if (!_Ticker._system) {\n      const system = _Ticker._system = new _Ticker();\n      system.autoStart = true;\n      system._protected = true;\n    }\n    return _Ticker._system;\n  }\n};\n/**\n * Target frames per millisecond.\n * @static\n */\n_Ticker.targetFPMS = 0.06;\nlet Ticker = _Ticker;\n\nexports.Ticker = Ticker;\n//# sourceMappingURL=Ticker.js.map\n\n};"],
"names":["shadow$provide","global","require","module","exports","_const","TickerListener","constructor","autoStart","deltaTime","lastTime","speed","started","_requestId","_maxElapsedMS","_minElapsedMS","_protected","_lastFrame","_head","Infinity","deltaMS","_Ticker","targetFPMS","elapsedMS","_tick","time","this._tick","update","next","requestAnimationFrame","_requestIfNeeded","performance","now","_cancelIfNeeded","cancelAnimationFrame","_startIfPossible","start","add","fn","context","priority","UPDATE_PRIORITY","NORMAL","_addListener","addOnce","listener","current","previous","connect","remove","match","destroy","count","stop","currentTime","delta","head","emit","fps","Math","min","minFPMS","max","minFPS","maxFPS","round","_shared","shared","_system","system","Ticker"]
}
