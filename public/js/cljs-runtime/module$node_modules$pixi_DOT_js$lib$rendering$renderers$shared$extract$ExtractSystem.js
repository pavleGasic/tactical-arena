shadow$provide.module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$extract$ExtractSystem = function(global, require, module, exports) {
  global = require("module$node_modules$pixi_DOT_js$lib$extensions$Extensions");
  var Container = require("module$node_modules$pixi_DOT_js$lib$scene$container$Container"), Texture = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$texture$Texture");
  "use strict";
  const imageTypes = {png:"image/png", jpg:"image/jpeg", webp:"image/webp"}, node_modules$pixi_DOT_js$lib$rendering$renderers$shared$extract$ExtractSystem$classdecl$var26 = class {
    constructor(renderer) {
      this._renderer = renderer;
    }
    _normalizeOptions(options, defaults = {}) {
      return options instanceof Container.Container || options instanceof Texture.Texture ? {target:options, ...defaults} : {...defaults, ...options};
    }
    async image(options) {
      const image = new Image();
      image.src = await this.base64(options);
      return image;
    }
    async base64(options) {
      options = this._normalizeOptions(options, node_modules$pixi_DOT_js$lib$rendering$renderers$shared$extract$ExtractSystem$classdecl$var26.defaultImageOptions);
      const {format, quality} = options, canvas = this.canvas(options);
      if (void 0 !== canvas.toBlob) {
        return new Promise((resolve, reject) => {
          canvas.toBlob(blob => {
            if (blob) {
              var reader = new FileReader();
              reader.onload = () => resolve(reader.result);
              reader.onerror = reject;
              reader.readAsDataURL(blob);
            } else {
              reject(Error("ICanvas.toBlob failed!"));
            }
          }, imageTypes[format], quality);
        });
      }
      if (void 0 !== canvas.toDataURL) {
        return canvas.toDataURL(imageTypes[format], quality);
      }
      if (void 0 !== canvas.convertToBlob) {
        const blob = await canvas.convertToBlob({type:imageTypes[format], quality});
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = () => resolve(reader.result);
          reader.onerror = reject;
          reader.readAsDataURL(blob);
        });
      }
      throw Error("Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented");
    }
    canvas(options) {
      options = this._normalizeOptions(options);
      const target = options.target;
      var renderer = this._renderer;
      if (target instanceof Texture.Texture) {
        return renderer.texture.generateCanvas(target);
      }
      options = renderer.textureGenerator.generateTexture(options);
      renderer = renderer.texture.generateCanvas(options);
      options.destroy(!0);
      return renderer;
    }
    pixels(options) {
      options = this._normalizeOptions(options);
      const target = options.target;
      var renderer = this._renderer;
      options = target instanceof Texture.Texture ? target : renderer.textureGenerator.generateTexture(options);
      renderer = renderer.texture.getPixels(options);
      target instanceof Container.Container && options.destroy(!0);
      return renderer;
    }
    texture(options) {
      options = this._normalizeOptions(options);
      return options.target instanceof Texture.Texture ? options.target : this._renderer.textureGenerator.generateTexture(options);
    }
    download(options) {
      options = this._normalizeOptions(options);
      const canvas = this.canvas(options), link = document.createElement("a");
      link.download = options.filename ?? "image.png";
      link.href = canvas.toDataURL("image/png");
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }
    log(options) {
      var width = options.width ?? 200;
      options = this._normalizeOptions(options);
      options = this.canvas(options);
      const base64 = options.toDataURL();
      console.log(`[Pixi Texture] ${options.width}px ${options.height}px`);
      width = ["font-size: 1px;", `padding: ${width}px ${300}px;`, `background: url(${base64}) no-repeat;`, "background-size: contain;"].join(" ");
      console.log("%c ", width);
    }
    destroy() {
      this._renderer = null;
    }
  };
  require = node_modules$pixi_DOT_js$lib$rendering$renderers$shared$extract$ExtractSystem$classdecl$var26;
  require.extension = {type:[global.ExtensionType.WebGLSystem, global.ExtensionType.WebGPUSystem], name:"extract"};
  require.defaultImageOptions = {format:"png", quality:1};
  exports.ExtractSystem = require;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$extract$ExtractSystem.js.map
