shadow$provide.module$node_modules$$pixi$mesh$lib$Mesh = function(global, require, module, exports) {
  var core = require("module$node_modules$$pixi$core$lib$index"), display = require("module$node_modules$$pixi$display$lib$index"), MeshBatchUvs = require("module$node_modules$$pixi$mesh$lib$MeshBatchUvs");
  const tempPoint = new core.Point(), tempPolygon = new core.Polygon();
  global = (() => {
    const node_modules$$pixi$mesh$lib$Mesh$classdecl$var19 = class extends display.Container {
      constructor(geometry, shader, state, drawMode = core.DRAW_MODES.TRIANGLES) {
        super();
        this.geometry = geometry;
        this.shader = shader;
        this.state = state || core.State.for2d();
        this.drawMode = drawMode;
        this.size = this.start = 0;
        this.indices = this.uvs = null;
        this.vertexData = new Float32Array(1);
        this._transformID = this.vertexDirty = -1;
        this._roundPixels = core.settings.ROUND_PIXELS;
        this.batchUvs = null;
      }
      get geometry() {
        return this._geometry;
      }
      set geometry(value) {
        this._geometry !== value && (this._geometry && (this._geometry.refCount--, 0 === this._geometry.refCount && this._geometry.dispose()), this._geometry = value, this._geometry && this._geometry.refCount++, this.vertexDirty = -1);
      }
      get uvBuffer() {
        return this.geometry.buffers[1];
      }
      get verticesBuffer() {
        return this.geometry.buffers[0];
      }
      set material(value) {
        this.shader = value;
      }
      get material() {
        return this.shader;
      }
      set blendMode(value) {
        this.state.blendMode = value;
      }
      get blendMode() {
        return this.state.blendMode;
      }
      set roundPixels(value) {
        this._roundPixels !== value && (this._transformID = -1);
        this._roundPixels = value;
      }
      get roundPixels() {
        return this._roundPixels;
      }
      get tint() {
        return "tint" in this.shader ? this.shader.tint : null;
      }
      set tint(value) {
        this.shader.tint = value;
      }
      get tintValue() {
        return this.shader.tintValue;
      }
      get texture() {
        return "texture" in this.shader ? this.shader.texture : null;
      }
      set texture(value) {
        this.shader.texture = value;
      }
      _render(renderer) {
        const vertices = this.geometry.buffers[0].data;
        this.shader.batchable && this.drawMode === core.DRAW_MODES.TRIANGLES && vertices.length < 2 * node_modules$$pixi$mesh$lib$Mesh$classdecl$var19.BATCHABLE_SIZE ? this._renderToBatch(renderer) : this._renderDefault(renderer);
      }
      _renderDefault(renderer) {
        const shader = this.shader;
        shader.alpha = this.worldAlpha;
        shader.update && shader.update();
        renderer.batch.flush();
        shader.uniforms.translationMatrix = this.transform.worldTransform.toArray(!0);
        renderer.shader.bind(shader);
        renderer.state.set(this.state);
        renderer.geometry.bind(this.geometry, shader);
        renderer.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount);
      }
      _renderToBatch(renderer) {
        var geometry = this.geometry;
        const shader = this.shader;
        shader.uvMatrix && (shader.uvMatrix.update(), this.calculateUvs());
        this.calculateVertices();
        this.indices = geometry.indexBuffer.data;
        this._tintRGB = shader._tintRGB;
        this._texture = shader.texture;
        geometry = this.material.pluginName;
        renderer.batch.setObjectRenderer(renderer.plugins[geometry]);
        renderer.plugins[geometry].render(this);
      }
      calculateVertices() {
        var verticesBuffer = this.geometry.buffers[0], vertices = verticesBuffer.data;
        verticesBuffer = verticesBuffer._updateID;
        if (verticesBuffer !== this.vertexDirty || this._transformID !== this.transform._worldID) {
          this._transformID = this.transform._worldID;
          this.vertexData.length !== vertices.length && (this.vertexData = new Float32Array(vertices.length));
          var wt = this.transform.worldTransform, a = wt.a, b = wt.b, c = wt.c, d = wt.d, tx = wt.tx, ty = wt.ty;
          wt = this.vertexData;
          for (let i = 0; i < wt.length / 2; i++) {
            const x = vertices[2 * i], y = vertices[2 * i + 1];
            wt[2 * i] = a * x + c * y + tx;
            wt[2 * i + 1] = b * x + d * y + ty;
          }
          if (this._roundPixels) {
            for (vertices = core.settings.RESOLUTION, a = 0; a < wt.length; ++a) {
              wt[a] = Math.round(wt[a] * vertices) / vertices;
            }
          }
          this.vertexDirty = verticesBuffer;
        }
      }
      calculateUvs() {
        const geomUvs = this.geometry.buffers[1], shader = this.shader;
        shader.uvMatrix.isSimple ? this.uvs = geomUvs.data : (this.batchUvs || (this.batchUvs = new MeshBatchUvs.MeshBatchUvs(geomUvs, shader.uvMatrix)), this.batchUvs.update(), this.uvs = this.batchUvs.data);
      }
      _calculateBounds() {
        this.calculateVertices();
        this._bounds.addVertexData(this.vertexData, 0, this.vertexData.length);
      }
      containsPoint(point) {
        if (!this.getBounds().contains(point.x, point.y)) {
          return !1;
        }
        this.worldTransform.applyInverse(point, tempPoint);
        point = this.geometry.getBuffer("aVertexPosition").data;
        const points = tempPolygon.points, indices = this.geometry.getIndex().data, len = indices.length, step = 4 === this.drawMode ? 3 : 1;
        for (let i = 0; i + 2 < len; i += step) {
          const ind0 = 2 * indices[i], ind1 = 2 * indices[i + 1], ind2 = 2 * indices[i + 2];
          if (points[0] = point[ind0], points[1] = point[ind0 + 1], points[2] = point[ind1], points[3] = point[ind1 + 1], points[4] = point[ind2], points[5] = point[ind2 + 1], tempPolygon.contains(tempPoint.x, tempPoint.y)) {
            return !0;
          }
        }
        return !1;
      }
      destroy(options) {
        super.destroy(options);
        this._cachedTexture && (this._cachedTexture.destroy(), this._cachedTexture = null);
        this.vertexData = this.indices = this.uvs = this.state = this.shader = this.geometry = null;
      }
    };
    return node_modules$$pixi$mesh$lib$Mesh$classdecl$var19;
  })();
  global.BATCHABLE_SIZE = 100;
  exports.Mesh = global;
};

//# sourceMappingURL=module$node_modules$$pixi$mesh$lib$Mesh.js.map
