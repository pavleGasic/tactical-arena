shadow$provide.module$node_modules$pixi_DOT_js$lib$scene$graphics$shared$path$GraphicsPath = function(global, require, module, exports) {
  function adjustTransform(currentMatrix, transform) {
    return currentMatrix ? currentMatrix.prepend(transform) : transform.clone();
  }
  var Point = require("module$node_modules$pixi_DOT_js$lib$maths$point$Point"), uid = require("module$node_modules$pixi_DOT_js$lib$utils$data$uid"), warn = require("module$node_modules$pixi_DOT_js$lib$utils$logging$warn"), parseSVGPath = require("module$node_modules$pixi_DOT_js$lib$scene$graphics$shared$svg$parseSVGPath"), ShapePath = require("module$node_modules$pixi_DOT_js$lib$scene$graphics$shared$path$ShapePath");
  "use strict";
  class GraphicsPath {
    constructor(instructions, signed = !1) {
      this.instructions = [];
      this.uid = uid.uid("graphicsPath");
      this._dirty = !0;
      this.checkForHoles = signed;
      "string" === typeof instructions ? parseSVGPath.parseSVGPath(instructions, this) : this.instructions = instructions?.slice() ?? [];
    }
    get shapePath() {
      this._shapePath || (this._shapePath = new ShapePath.ShapePath(this));
      this._dirty && (this._dirty = !1, this._shapePath.buildPath());
      return this._shapePath;
    }
    addPath(path, transform) {
      path = path.clone();
      this.instructions.push({action:"addPath", data:[path, transform]});
      this._dirty = !0;
      return this;
    }
    arc(...args) {
      this.instructions.push({action:"arc", data:args});
      this._dirty = !0;
      return this;
    }
    arcTo(...args) {
      this.instructions.push({action:"arcTo", data:args});
      this._dirty = !0;
      return this;
    }
    arcToSvg(...args) {
      this.instructions.push({action:"arcToSvg", data:args});
      this._dirty = !0;
      return this;
    }
    bezierCurveTo(...args) {
      this.instructions.push({action:"bezierCurveTo", data:args});
      this._dirty = !0;
      return this;
    }
    bezierCurveToShort(cp2x, cp2y, x, y, smoothness) {
      var last = this.instructions[this.instructions.length - 1], lastPoint = this.getLastPoint(Point.Point.shared);
      let cp1x;
      if (last && "bezierCurveTo" === last.action) {
        cp1x = last.data[2];
        last = last.data[3];
        const currentX = lastPoint.x;
        lastPoint = lastPoint.y;
        cp1x = currentX + (currentX - cp1x);
        last = lastPoint + (lastPoint - last);
      } else {
        cp1x = lastPoint.x, last = lastPoint.y;
      }
      this.instructions.push({action:"bezierCurveTo", data:[cp1x, last, cp2x, cp2y, x, y, smoothness]});
      this._dirty = !0;
      return this;
    }
    closePath() {
      this.instructions.push({action:"closePath", data:[]});
      this._dirty = !0;
      return this;
    }
    ellipse(...args) {
      this.instructions.push({action:"ellipse", data:args});
      this._dirty = !0;
      return this;
    }
    lineTo(...args) {
      this.instructions.push({action:"lineTo", data:args});
      this._dirty = !0;
      return this;
    }
    moveTo(...args) {
      this.instructions.push({action:"moveTo", data:args});
      return this;
    }
    quadraticCurveTo(...args) {
      this.instructions.push({action:"quadraticCurveTo", data:args});
      this._dirty = !0;
      return this;
    }
    quadraticCurveToShort(x, y, smoothness) {
      var last = this.instructions[this.instructions.length - 1], lastPoint = this.getLastPoint(Point.Point.shared);
      let cpx1;
      if (last && "quadraticCurveTo" === last.action) {
        cpx1 = last.data[0];
        last = last.data[1];
        const currentX = lastPoint.x;
        lastPoint = lastPoint.y;
        cpx1 = currentX + (currentX - cpx1);
        last = lastPoint + (lastPoint - last);
      } else {
        cpx1 = lastPoint.x, last = lastPoint.y;
      }
      this.instructions.push({action:"quadraticCurveTo", data:[cpx1, last, x, y, smoothness]});
      this._dirty = !0;
      return this;
    }
    rect(x, y, w, h, transform) {
      this.instructions.push({action:"rect", data:[x, y, w, h, transform]});
      this._dirty = !0;
      return this;
    }
    circle(x, y, radius, transform) {
      this.instructions.push({action:"circle", data:[x, y, radius, transform]});
      this._dirty = !0;
      return this;
    }
    roundRect(...args) {
      this.instructions.push({action:"roundRect", data:args});
      this._dirty = !0;
      return this;
    }
    poly(...args) {
      this.instructions.push({action:"poly", data:args});
      this._dirty = !0;
      return this;
    }
    regularPoly(...args) {
      this.instructions.push({action:"regularPoly", data:args});
      this._dirty = !0;
      return this;
    }
    roundPoly(...args) {
      this.instructions.push({action:"roundPoly", data:args});
      this._dirty = !0;
      return this;
    }
    roundShape(...args) {
      this.instructions.push({action:"roundShape", data:args});
      this._dirty = !0;
      return this;
    }
    filletRect(...args) {
      this.instructions.push({action:"filletRect", data:args});
      this._dirty = !0;
      return this;
    }
    chamferRect(...args) {
      this.instructions.push({action:"chamferRect", data:args});
      this._dirty = !0;
      return this;
    }
    star(x, y, points, radius, innerRadius, rotation, transform) {
      innerRadius || (innerRadius = radius / 2);
      rotation = -1 * Math.PI / 2 + rotation;
      points *= 2;
      const delta = 2 * Math.PI / points, polygon = [];
      for (let i = 0; i < points; i++) {
        const r = i % 2 ? innerRadius : radius, angle = i * delta + rotation;
        polygon.push(x + r * Math.cos(angle), y + r * Math.sin(angle));
      }
      this.poly(polygon, !0, transform);
      return this;
    }
    clone(deep = !1) {
      const newGraphicsPath2D = new GraphicsPath();
      newGraphicsPath2D.checkForHoles = this.checkForHoles;
      if (deep) {
        for (deep = 0; deep < this.instructions.length; deep++) {
          const instruction = this.instructions[deep];
          newGraphicsPath2D.instructions.push({action:instruction.action, data:instruction.data.slice()});
        }
      } else {
        newGraphicsPath2D.instructions = this.instructions.slice();
      }
      return newGraphicsPath2D;
    }
    clear() {
      this.instructions.length = 0;
      this._dirty = !0;
      return this;
    }
    transform(matrix) {
      if (matrix.isIdentity()) {
        return this;
      }
      const a = matrix.a, b = matrix.b, c = matrix.c, d = matrix.d, tx = matrix.tx, ty = matrix.ty;
      let y;
      let cpx2, cpy2;
      for (let i = 0; i < this.instructions.length; i++) {
        var x = this.instructions[i];
        const data = x.data;
        switch(x.action) {
          case "moveTo":
          case "lineTo":
            x = data[0];
            y = data[1];
            data[0] = a * x + c * y + tx;
            data[1] = b * x + d * y + ty;
            break;
          case "bezierCurveTo":
            var cpx1 = data[0];
            var cpy1 = data[1];
            cpx2 = data[2];
            cpy2 = data[3];
            x = data[4];
            y = data[5];
            data[0] = a * cpx1 + c * cpy1 + tx;
            data[1] = b * cpx1 + d * cpy1 + ty;
            data[2] = a * cpx2 + c * cpy2 + tx;
            data[3] = b * cpx2 + d * cpy2 + ty;
            data[4] = a * x + c * y + tx;
            data[5] = b * x + d * y + ty;
            break;
          case "quadraticCurveTo":
            cpx1 = data[0];
            cpy1 = data[1];
            x = data[2];
            y = data[3];
            data[0] = a * cpx1 + c * cpy1 + tx;
            data[1] = b * cpx1 + d * cpy1 + ty;
            data[2] = a * x + c * y + tx;
            data[3] = b * x + d * y + ty;
            break;
          case "arcToSvg":
            x = data[5];
            y = data[6];
            cpx1 = data[0];
            cpy1 = data[1];
            data[0] = a * cpx1 + c * cpy1;
            data[1] = b * cpx1 + d * cpy1;
            data[5] = a * x + c * y + tx;
            data[6] = b * x + d * y + ty;
            break;
          case "circle":
            data[4] = adjustTransform(data[3], matrix);
            break;
          case "rect":
            data[4] = adjustTransform(data[4], matrix);
            break;
          case "ellipse":
            data[8] = adjustTransform(data[8], matrix);
            break;
          case "roundRect":
            data[5] = adjustTransform(data[5], matrix);
            break;
          case "addPath":
            data[0].transform(matrix);
            break;
          case "poly":
            data[2] = adjustTransform(data[2], matrix);
            break;
          default:
            warn.warn("unknown transform action", x.action);
        }
      }
      this._dirty = !0;
      return this;
    }
    get bounds() {
      return this.shapePath.bounds;
    }
    getLastPoint(out) {
      let index = this.instructions.length - 1, lastInstruction = this.instructions[index];
      if (!lastInstruction) {
        return out.x = 0, out.y = 0, out;
      }
      for (; "closePath" === lastInstruction.action;) {
        index--;
        if (0 > index) {
          return out.x = 0, out.y = 0, out;
        }
        lastInstruction = this.instructions[index];
      }
      switch(lastInstruction.action) {
        case "moveTo":
        case "lineTo":
          out.x = lastInstruction.data[0];
          out.y = lastInstruction.data[1];
          break;
        case "quadraticCurveTo":
          out.x = lastInstruction.data[2];
          out.y = lastInstruction.data[3];
          break;
        case "bezierCurveTo":
          out.x = lastInstruction.data[4];
          out.y = lastInstruction.data[5];
          break;
        case "arc":
        case "arcToSvg":
          out.x = lastInstruction.data[5];
          out.y = lastInstruction.data[6];
          break;
        case "addPath":
          lastInstruction.data[0].getLastPoint(out);
      }
      return out;
    }
  }
  exports.GraphicsPath = GraphicsPath;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$scene$graphics$shared$path$GraphicsPath.js.map
