shadow$provide.module$node_modules$pixi_DOT_js$lib$rendering$renderers$gpu$texture$uploaders$gpuUploadCompressedTextureResource = function(global, require, module, exports) {
  const blockDataMap = {"bc1-rgba-unorm":{blockBytes:8, blockWidth:4, blockHeight:4}, "bc2-rgba-unorm":{blockBytes:16, blockWidth:4, blockHeight:4}, "bc3-rgba-unorm":{blockBytes:16, blockWidth:4, blockHeight:4}, "bc7-rgba-unorm":{blockBytes:16, blockWidth:4, blockHeight:4}, "etc1-rgb-unorm":{blockBytes:8, blockWidth:4, blockHeight:4}, "etc2-rgba8unorm":{blockBytes:16, blockWidth:4, blockHeight:4}, "astc-4x4-unorm":{blockBytes:16, blockWidth:4, blockHeight:4}}, defaultBlockData = {blockBytes:4, blockWidth:1, 
  blockHeight:1};
  exports.blockDataMap = blockDataMap;
  exports.gpuUploadCompressedTextureResource = {type:"compressed", upload(source, gpuTexture, gpu) {
    let mipWidth = source.pixelWidth, mipHeight = source.pixelHeight;
    const blockData = blockDataMap[source.format] || defaultBlockData;
    for (let i = 0; i < source.resource.length; i++) {
      gpu.device.queue.writeTexture({texture:gpuTexture, mipLevel:i}, source.resource[i], {offset:0, bytesPerRow:Math.ceil(mipWidth / blockData.blockWidth) * blockData.blockBytes}, {width:Math.ceil(mipWidth / blockData.blockWidth) * blockData.blockWidth, height:Math.ceil(mipHeight / blockData.blockHeight) * blockData.blockHeight, depthOrArrayLayers:1}), mipWidth = Math.max(mipWidth >> 1, 1), mipHeight = Math.max(mipHeight >> 1, 1);
    }
  }};
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$rendering$renderers$gpu$texture$uploaders$gpuUploadCompressedTextureResource.js.map
