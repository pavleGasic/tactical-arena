shadow$provide.module$node_modules$$pixi$core$lib$textures$TextureMatrix = function(global, require, module, exports) {
  var math = require("module$node_modules$$pixi$math$lib$index");
  const tempMat = new math.Matrix();
  class TextureMatrix {
    constructor(texture, clampMargin) {
      this._texture = texture;
      this.mapCoord = new math.Matrix();
      this.uClampFrame = new Float32Array(4);
      this.uClampOffset = new Float32Array(2);
      this._textureID = -1;
      this.clampOffset = this._updateID = 0;
      this.clampMargin = "u" < typeof clampMargin ? 0.5 : clampMargin;
      this.isSimple = !1;
    }
    get texture() {
      return this._texture;
    }
    set texture(value) {
      this._texture = value;
      this._textureID = -1;
    }
    multiplyUvs(uvs, out) {
      void 0 === out && (out = uvs);
      const mat = this.mapCoord;
      for (let i = 0; i < uvs.length; i += 2) {
        const x = uvs[i], y = uvs[i + 1];
        out[i] = x * mat.a + y * mat.c + mat.tx;
        out[i + 1] = x * mat.b + y * mat.d + mat.ty;
      }
      return out;
    }
    update(forceUpdate) {
      const tex = this._texture;
      if (!tex || !tex.valid || !forceUpdate && this._textureID === tex._updateID) {
        return !1;
      }
      this._textureID = tex._updateID;
      this._updateID++;
      forceUpdate = tex._uvs;
      this.mapCoord.set(forceUpdate.x1 - forceUpdate.x0, forceUpdate.y1 - forceUpdate.y0, forceUpdate.x3 - forceUpdate.x0, forceUpdate.y3 - forceUpdate.y0, forceUpdate.x0, forceUpdate.y0);
      forceUpdate = tex.orig;
      var trim = tex.trim;
      trim && (tempMat.set(forceUpdate.width / trim.width, 0, 0, forceUpdate.height / trim.height, -trim.x / trim.width, -trim.y / trim.height), this.mapCoord.append(tempMat));
      forceUpdate = tex.baseTexture;
      trim = this.uClampFrame;
      const margin = this.clampMargin / forceUpdate.resolution, offset = this.clampOffset;
      return trim[0] = (tex._frame.x + margin + offset) / forceUpdate.width, trim[1] = (tex._frame.y + margin + offset) / forceUpdate.height, trim[2] = (tex._frame.x + tex._frame.width - margin + offset) / forceUpdate.width, trim[3] = (tex._frame.y + tex._frame.height - margin + offset) / forceUpdate.height, this.uClampOffset[0] = offset / forceUpdate.realWidth, this.uClampOffset[1] = offset / forceUpdate.realHeight, this.isSimple = tex._frame.width === forceUpdate.width && tex._frame.height === 
      forceUpdate.height && 0 === tex.rotate, !0;
    }
  }
  exports.TextureMatrix = TextureMatrix;
};

//# sourceMappingURL=module$node_modules$$pixi$core$lib$textures$TextureMatrix.js.map
