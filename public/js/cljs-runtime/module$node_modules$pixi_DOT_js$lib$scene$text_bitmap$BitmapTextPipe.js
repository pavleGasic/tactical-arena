shadow$provide.module$node_modules$pixi_DOT_js$lib$scene$text_bitmap$BitmapTextPipe = function(global, require, module, exports) {
  function syncWithProxy(container, proxy) {
    proxy.groupTransform = container.groupTransform;
    proxy.groupColorAlpha = container.groupColorAlpha;
    proxy.groupColor = container.groupColor;
    proxy.groupBlendMode = container.groupBlendMode;
    proxy.globalDisplayStatus = container.globalDisplayStatus;
    proxy.groupTransform = container.groupTransform;
    proxy.localDisplayStatus = container.localDisplayStatus;
    proxy.groupAlpha = container.groupAlpha;
    proxy._roundPixels = container._roundPixels;
  }
  var Cache = require("module$node_modules$pixi_DOT_js$lib$assets$cache$Cache");
  global = require("module$node_modules$pixi_DOT_js$lib$extensions$Extensions");
  var PoolGroup = require("module$node_modules$pixi_DOT_js$lib$utils$pool$PoolGroup"), Graphics = require("module$node_modules$pixi_DOT_js$lib$scene$graphics$shared$Graphics"), SdfShader = require("module$node_modules$pixi_DOT_js$lib$scene$text$sdfShader$SdfShader"), BitmapFontManager = require("module$node_modules$pixi_DOT_js$lib$scene$text_bitmap$BitmapFontManager"), getBitmapTextLayout = require("module$node_modules$pixi_DOT_js$lib$scene$text_bitmap$utils$getBitmapTextLayout");
  "use strict";
  class BitmapTextPipe {
    constructor(renderer) {
      this._gpuBitmapText = {};
      this._destroyRenderableBound = this.destroyRenderable.bind(this);
      this._renderer = renderer;
      this._renderer.renderableGC.addManagedHash(this, "_gpuBitmapText");
    }
    validateRenderable(bitmapText) {
      const graphicsRenderable = this._getGpuBitmapText(bitmapText);
      bitmapText._didTextUpdate && (bitmapText._didTextUpdate = !1, this._updateContext(bitmapText, graphicsRenderable));
      return this._renderer.renderPipes.graphics.validateRenderable(graphicsRenderable);
    }
    addRenderable(bitmapText, instructionSet) {
      const graphicsRenderable = this._getGpuBitmapText(bitmapText);
      syncWithProxy(bitmapText, graphicsRenderable);
      bitmapText._didTextUpdate && (bitmapText._didTextUpdate = !1, this._updateContext(bitmapText, graphicsRenderable));
      this._renderer.renderPipes.graphics.addRenderable(graphicsRenderable, instructionSet);
      graphicsRenderable.context.customShader && this._updateDistanceField(bitmapText);
    }
    destroyRenderable(bitmapText) {
      bitmapText.off("destroyed", this._destroyRenderableBound);
      this._destroyRenderableByUid(bitmapText.uid);
    }
    _destroyRenderableByUid(renderableUid) {
      const context = this._gpuBitmapText[renderableUid].context;
      context.customShader && (PoolGroup.BigPool.return(context.customShader), context.customShader = null);
      PoolGroup.BigPool.return(this._gpuBitmapText[renderableUid]);
      this._gpuBitmapText[renderableUid] = null;
    }
    updateRenderable(bitmapText) {
      const graphicsRenderable = this._getGpuBitmapText(bitmapText);
      syncWithProxy(bitmapText, graphicsRenderable);
      this._renderer.renderPipes.graphics.updateRenderable(graphicsRenderable);
      graphicsRenderable.context.customShader && this._updateDistanceField(bitmapText);
    }
    _updateContext(bitmapText, proxyGraphics) {
      ({context:proxyGraphics} = proxyGraphics);
      const bitmapFont = BitmapFontManager.BitmapFontManager.getFont(bitmapText.text, bitmapText._style);
      proxyGraphics.clear();
      "none" === bitmapFont.distanceField.type || proxyGraphics.customShader || (proxyGraphics.customShader = PoolGroup.BigPool.get(SdfShader.SdfShader));
      const chars = Array.from(bitmapText.text);
      var style = bitmapText._style;
      let currentY = bitmapFont.baseLineOffset;
      const bitmapTextLayout = getBitmapTextLayout.getBitmapTextLayout(chars, style, bitmapFont, !0);
      let index = 0;
      var padding = style.padding, scale = bitmapTextLayout.scale, tx = bitmapTextLayout.width;
      let ty = bitmapTextLayout.height + bitmapTextLayout.offsetY;
      style._stroke && (tx += style._stroke.width / scale, ty += style._stroke.width / scale);
      proxyGraphics.translate(-bitmapText._anchor._x * tx - padding, -bitmapText._anchor._y * ty - padding).scale(scale, scale);
      bitmapText = bitmapFont.applyFillAsTint ? style._fill.color : 16777215;
      for (style = 0; style < bitmapTextLayout.lines.length; style++) {
        padding = bitmapTextLayout.lines[style];
        for (scale = 0; scale < padding.charPositions.length; scale++) {
          tx = chars[index++], tx = bitmapFont.chars[tx], tx?.texture && proxyGraphics.texture(tx.texture, bitmapText ? bitmapText : "black", Math.round(padding.charPositions[scale] + tx.xOffset), Math.round(currentY + tx.yOffset));
        }
        currentY += bitmapFont.lineHeight;
      }
    }
    _getGpuBitmapText(bitmapText) {
      return this._gpuBitmapText[bitmapText.uid] || this.initGpuText(bitmapText);
    }
    initGpuText(bitmapText) {
      const proxyRenderable = PoolGroup.BigPool.get(Graphics.Graphics);
      this._gpuBitmapText[bitmapText.uid] = proxyRenderable;
      this._updateContext(bitmapText, proxyRenderable);
      bitmapText.on("destroyed", this._destroyRenderableBound);
      return this._gpuBitmapText[bitmapText.uid];
    }
    _updateDistanceField(bitmapText) {
      const context = this._getGpuBitmapText(bitmapText).context, dynamicFont = Cache.Cache.get(`${bitmapText._style.fontFamily}-bitmap`), {a, b, c, d} = bitmapText.groupTransform;
      context.customShader.resources.localUniforms.uniforms.uDistance = (Math.abs(Math.sqrt(a * a + b * b)) + Math.abs(Math.sqrt(c * c + d * d))) / 2 * dynamicFont.distanceField.range * (1 / (dynamicFont.baseRenderedFontSize / bitmapText._style.fontSize));
    }
    destroy() {
      for (const uid in this._gpuBitmapText) {
        this._destroyRenderableByUid(uid);
      }
      this._renderer = this._gpuBitmapText = null;
    }
  }
  BitmapTextPipe.extension = {type:[global.ExtensionType.WebGLPipes, global.ExtensionType.WebGPUPipes, global.ExtensionType.CanvasPipes], name:"bitmapText"};
  exports.BitmapTextPipe = BitmapTextPipe;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$scene$text_bitmap$BitmapTextPipe.js.map
