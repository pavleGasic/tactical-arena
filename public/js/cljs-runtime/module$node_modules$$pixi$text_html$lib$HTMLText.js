shadow$provide.module$node_modules$$pixi$text_html$lib$HTMLText = function(global, require, module, exports) {
  var core = require("module$node_modules$$pixi$core$lib$index");
  global = require("module$node_modules$$pixi$sprite$lib$index");
  var text = require("module$node_modules$$pixi$text$lib$index"), HTMLTextStyle = require("module$node_modules$$pixi$text_html$lib$HTMLTextStyle");
  const node_modules$$pixi$text_html$lib$HTMLText$classdecl$var28 = class extends global.Sprite {
    constructor(text2 = "", style = {}) {
      super(core.Texture.EMPTY);
      this._style = this._text = null;
      this._autoResolution = !0;
      this.localStyleID = -1;
      this.dirty = !1;
      this._updateID = 0;
      this.ownsStyle = !1;
      const image = new Image();
      var texture = core.Texture.from(image, {scaleMode:core.settings.SCALE_MODE, resourceOptions:{autoLoad:!1}});
      texture.orig = new core.Rectangle();
      texture.trim = new core.Rectangle();
      this.texture = texture;
      texture = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      const foreignObject = document.createElementNS("http://www.w3.org/2000/svg", "foreignObject"), domElement = document.createElementNS("http://www.w3.org/1999/xhtml", "div"), styleElement = document.createElementNS("http://www.w3.org/1999/xhtml", "style");
      foreignObject.setAttribute("width", "10000");
      foreignObject.setAttribute("height", "10000");
      foreignObject.style.overflow = "hidden";
      texture.appendChild(foreignObject);
      this.maxWidth = node_modules$$pixi$text_html$lib$HTMLText$classdecl$var28.defaultMaxWidth;
      this.maxHeight = node_modules$$pixi$text_html$lib$HTMLText$classdecl$var28.defaultMaxHeight;
      this._domElement = domElement;
      this._styleElement = styleElement;
      this._svgRoot = texture;
      this._foreignObject = foreignObject;
      this._foreignObject.appendChild(styleElement);
      this._foreignObject.appendChild(domElement);
      this._image = image;
      this._loadImage = new Image();
      this._autoResolution = node_modules$$pixi$text_html$lib$HTMLText$classdecl$var28.defaultAutoResolution;
      this._resolution = node_modules$$pixi$text_html$lib$HTMLText$classdecl$var28.defaultResolution ?? core.settings.RESOLUTION;
      this.text = text2;
      this.style = style;
    }
    measureText(overrides) {
      const {text:text2, style, resolution} = Object.assign({text:this._text, style:this._style, resolution:this._resolution}, overrides);
      Object.assign(this._domElement, {innerHTML:text2, style:style.toCSS(resolution)});
      this._styleElement.textContent = style.toGlobalCSS();
      document.body.appendChild(this._svgRoot);
      overrides = this._domElement.getBoundingClientRect();
      this._svgRoot.remove();
      const {width, height} = overrides;
      (width > this.maxWidth || height > this.maxHeight) && console.warn("[HTMLText] Large expanse of text, increase HTMLText.maxWidth or HTMLText.maxHeight property.");
      overrides = Math.min(this.maxWidth, Math.ceil(width));
      const contentHeight = Math.min(this.maxHeight, Math.ceil(height));
      return this._svgRoot.setAttribute("width", overrides.toString()), this._svgRoot.setAttribute("height", contentHeight.toString()), text2 !== this._text && (this._domElement.innerHTML = this._text), style !== this._style && (Object.assign(this._domElement, {style:this._style?.toCSS(resolution)}), this._styleElement.textContent = this._style?.toGlobalCSS()), {width:overrides + 2 * style.padding, height:contentHeight + 2 * style.padding};
    }
    async updateText(respectDirty = !0) {
      const {style, _image:image, _loadImage:loadImage} = this;
      if (this.localStyleID !== style.styleID && (this.dirty = !0, this.localStyleID = style.styleID), this.dirty || !respectDirty) {
        var {width, height} = this.measureText();
        image.width = loadImage.width = Math.ceil(Math.max(1, width));
        image.height = loadImage.height = Math.ceil(Math.max(1, height));
        this._updateID++;
        var updateID = this._updateID;
        await new Promise(resolve => {
          loadImage.onload = async() => {
            updateID < this._updateID || (await style.onBeforeDraw(), image.src = loadImage.src, loadImage.onload = null, loadImage.src = "", this.updateTexture());
            resolve();
          };
          const svgURL = (new XMLSerializer()).serializeToString(this._svgRoot);
          loadImage.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(svgURL)}`;
        });
      }
    }
    get source() {
      return this._image;
    }
    updateTexture() {
      const {style, texture, _image:image, resolution} = this, {padding} = style, {baseTexture} = texture;
      texture.trim.width = texture._frame.width = image.width / resolution;
      texture.trim.height = texture._frame.height = image.height / resolution;
      texture.trim.x = -padding;
      texture.trim.y = -padding;
      texture.orig.width = texture._frame.width - 2 * padding;
      texture.orig.height = texture._frame.height - 2 * padding;
      this._onTextureUpdate();
      baseTexture.setRealSize(image.width, image.height, resolution);
      this.dirty = !1;
    }
    _render(renderer) {
      this._autoResolution && this._resolution !== renderer.resolution && (this._resolution = renderer.resolution, this.dirty = !0);
      this.updateText(!0);
      super._render(renderer);
    }
    _renderCanvas(renderer) {
      this._autoResolution && this._resolution !== renderer.resolution && (this._resolution = renderer.resolution, this.dirty = !0);
      this.updateText(!0);
      super._renderCanvas(renderer);
    }
    getLocalBounds(rect) {
      return this.updateText(!0), super.getLocalBounds(rect);
    }
    _calculateBounds() {
      this.updateText(!0);
      this.calculateVertices();
      this._bounds.addQuad(this.vertexData);
    }
    _onStyleChange() {
      this.dirty = !0;
    }
    destroy(options) {
      "boolean" == typeof options && (options = {children:options});
      options = Object.assign({}, node_modules$$pixi$text_html$lib$HTMLText$classdecl$var28.defaultDestroyOptions, options);
      super.destroy(options);
      this.ownsStyle && this._style?.cleanFonts();
      this._style = null;
      this._svgRoot?.remove();
      this._svgRoot = null;
      this._domElement?.remove();
      this._domElement = null;
      this._foreignObject?.remove();
      this._foreignObject = null;
      this._styleElement?.remove();
      this._styleElement = null;
      this._loadImage.src = "";
      this._loadImage = this._loadImage.onload = null;
      this._image.src = "";
      this._image = null;
    }
    get width() {
      return this.updateText(!0), Math.abs(this.scale.x) * this._image.width / this.resolution;
    }
    set width(value) {
      this.updateText(!0);
      const s = core.utils.sign(this.scale.x) || 1;
      this.scale.x = s * value / this._image.width / this.resolution;
      this._width = value;
    }
    get height() {
      return this.updateText(!0), Math.abs(this.scale.y) * this._image.height / this.resolution;
    }
    set height(value) {
      this.updateText(!0);
      const s = core.utils.sign(this.scale.y) || 1;
      this.scale.y = s * value / this._image.height / this.resolution;
      this._height = value;
    }
    get style() {
      return this._style;
    }
    set style(style) {
      this._style !== style && (style = style || {}, style instanceof HTMLTextStyle.HTMLTextStyle ? (this.ownsStyle = !1, this._style = style) : style instanceof text.TextStyle ? (console.warn("[HTMLText] Cloning TextStyle, if this is not what you want, use HTMLTextStyle"), this.ownsStyle = !0, this._style = HTMLTextStyle.HTMLTextStyle.from(style)) : (this.ownsStyle = !0, this._style = new HTMLTextStyle.HTMLTextStyle(style)), this.localStyleID = -1, this.dirty = !0);
    }
    get text() {
      return this._text;
    }
    set text(text2) {
      text2 = String("" === text2 || null === text2 || void 0 === text2 ? " " : text2);
      text2 = this.sanitiseText(text2);
      this._text !== text2 && (this._text = text2, this.dirty = !0);
    }
    get resolution() {
      return this._resolution;
    }
    set resolution(value) {
      this._autoResolution = !1;
      this._resolution !== value && (this._resolution = value, this.dirty = !0);
    }
    sanitiseText(text2) {
      return text2.replace(/<br>/gi, "\x3cbr/\x3e").replace(/<hr>/gi, "\x3chr/\x3e").replace(/&nbsp;/gi, "\x26#160;");
    }
  };
  require = node_modules$$pixi$text_html$lib$HTMLText$classdecl$var28;
  require.defaultDestroyOptions = {texture:!0, children:!1, baseTexture:!0};
  require.defaultMaxWidth = 2024;
  require.defaultMaxHeight = 2024;
  require.defaultAutoResolution = !0;
  exports.HTMLText = require;
};

//# sourceMappingURL=module$node_modules$$pixi$text_html$lib$HTMLText.js.map
