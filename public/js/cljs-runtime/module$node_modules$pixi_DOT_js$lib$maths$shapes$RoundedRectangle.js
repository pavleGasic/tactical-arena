shadow$provide.module$node_modules$pixi_DOT_js$lib$maths$shapes$RoundedRectangle = function(global, require, module, exports) {
  var Rectangle = require("module$node_modules$pixi_DOT_js$lib$maths$shapes$Rectangle");
  "use strict";
  const isCornerWithinStroke = (pX, pY, cornerX, cornerY, radius, strokeWidthInner, strokeWidthOuter) => {
    pX -= cornerX;
    pY -= cornerY;
    pY = Math.sqrt(pX * pX + pY * pY);
    return pY >= radius - strokeWidthInner && pY <= radius + strokeWidthOuter;
  };
  class RoundedRectangle {
    constructor(x = 0, y = 0, width = 0, height = 0, radius = 20) {
      this.type = "roundedRectangle";
      this.x = x;
      this.y = y;
      this.width = width;
      this.height = height;
      this.radius = radius;
    }
    getBounds(out) {
      out || (out = new Rectangle.Rectangle());
      out.x = this.x;
      out.y = this.y;
      out.width = this.width;
      out.height = this.height;
      return out;
    }
    clone() {
      return new RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);
    }
    copyFrom(rectangle) {
      this.x = rectangle.x;
      this.y = rectangle.y;
      this.width = rectangle.width;
      this.height = rectangle.height;
      return this;
    }
    copyTo(rectangle) {
      rectangle.copyFrom(this);
      return rectangle;
    }
    contains(x, y) {
      if (0 >= this.width || 0 >= this.height) {
        return !1;
      }
      if (x >= this.x && x <= this.x + this.width && y >= this.y && y <= this.y + this.height) {
        const radius = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
        if (y >= this.y + radius && y <= this.y + this.height - radius || x >= this.x + radius && x <= this.x + this.width - radius) {
          return !0;
        }
        let dx = x - (this.x + radius), dy = y - (this.y + radius);
        const radius2 = radius * radius;
        if (dx * dx + dy * dy <= radius2) {
          return !0;
        }
        dx = x - (this.x + this.width - radius);
        if (dx * dx + dy * dy <= radius2) {
          return !0;
        }
        dy = y - (this.y + this.height - radius);
        if (dx * dx + dy * dy <= radius2) {
          return !0;
        }
        dx = x - (this.x + radius);
        if (dx * dx + dy * dy <= radius2) {
          return !0;
        }
      }
      return !1;
    }
    strokeContains(pX, pY, strokeWidth, alignment = 0.5) {
      const {x, y, width, height, radius} = this;
      alignment = strokeWidth * (1 - alignment);
      strokeWidth -= alignment;
      const innerX = x + radius, innerY = y + radius, rightBound = x + width, bottomBound = y + height;
      return (pX >= x - alignment && pX <= x + strokeWidth || pX >= rightBound - strokeWidth && pX <= rightBound + alignment) && pY >= innerY && pY <= innerY + (height - 2 * radius) || (pY >= y - alignment && pY <= y + strokeWidth || pY >= bottomBound - strokeWidth && pY <= bottomBound + alignment) && pX >= innerX && pX <= innerX + (width - 2 * radius) ? !0 : pX < innerX && pY < innerY && isCornerWithinStroke(pX, pY, innerX, innerY, radius, strokeWidth, alignment) || pX > rightBound - radius && pY < 
      innerY && isCornerWithinStroke(pX, pY, rightBound - radius, innerY, radius, strokeWidth, alignment) || pX > rightBound - radius && pY > bottomBound - radius && isCornerWithinStroke(pX, pY, rightBound - radius, bottomBound - radius, radius, strokeWidth, alignment) || pX < innerX && pY > bottomBound - radius && isCornerWithinStroke(pX, pY, innerX, bottomBound - radius, radius, strokeWidth, alignment);
    }
    toString() {
      return `[pixi.js/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`;
    }
  }
  exports.RoundedRectangle = RoundedRectangle;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$maths$shapes$RoundedRectangle.js.map
