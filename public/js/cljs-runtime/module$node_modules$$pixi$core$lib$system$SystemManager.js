shadow$provide.module$node_modules$$pixi$core$lib$system$SystemManager = function(global, require, module, exports) {
  var runner = require("module$node_modules$$pixi$runner$lib$index");
  global = require("module$node_modules$$pixi$utils$lib$index");
  class SystemManager extends global.EventEmitter {
    constructor() {
      super(...arguments);
      this.runners = {};
      this._systemsHash = {};
    }
    setup(config) {
      this.addRunners(...config.runners);
      const priority = (config.priority ?? []).filter(key => config.systems[key]), orderByPriority = [...priority, ...Object.keys(config.systems).filter(key => !priority.includes(key))];
      for (const i of orderByPriority) {
        this.addSystem(config.systems[i], i);
      }
    }
    addRunners(...runnerIds) {
      runnerIds.forEach(runnerId => {
        this.runners[runnerId] = new runner.Runner(runnerId);
      });
    }
    addSystem(ClassRef, name) {
      ClassRef = new ClassRef(this);
      if (this[name]) {
        throw Error(`Whoops! The name "${name}" is already in use`);
      }
      this[name] = ClassRef;
      this._systemsHash[name] = ClassRef;
      for (const i in this.runners) {
        this.runners[i].add(ClassRef);
      }
      return this;
    }
    emitWithCustomOptions(runner2, options) {
      const systemHashKeys = Object.keys(this._systemsHash);
      runner2.items.forEach(system => {
        const systemName = systemHashKeys.find(systemId => this._systemsHash[systemId] === system);
        system[runner2.name](options[systemName]);
      });
    }
    destroy() {
      Object.values(this.runners).forEach(runner2 => {
        runner2.destroy();
      });
      this._systemsHash = {};
    }
  }
  exports.SystemManager = SystemManager;
};

//# sourceMappingURL=module$node_modules$$pixi$core$lib$system$SystemManager.js.map
