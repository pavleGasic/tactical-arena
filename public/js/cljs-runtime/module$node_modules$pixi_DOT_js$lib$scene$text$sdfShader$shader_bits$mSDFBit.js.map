{
"version":3,
"file":"module$node_modules$pixi_DOT_js$lib$scene$text$sdfShader$shader_bits$mSDFBit.js",
"lineCount":5,
"mappings":"AAAAA,cAAA,CAAA,4EAAA,GAAiG,QAAQ,CAACC,MAAD,EAAQC,OAAR,EAAgBC,MAAhB,EAAuBC,OAAvB,CAAgC;AA6EzIA,SAAQC,CAAAA,OAAR,GAzEgBA,CACdC,KAAM,UADQD,EAEdE,SAAU,CACRC,OAEG,ipCAHK,CAFIH,CAyEhB;AACAD,SAAQK,CAAAA,SAAR,GAtCkBA,CAChBH,KAAM,UADUG,EAEhBF,SAAU,CACRC,OAEG,6pCAHK,CAFMC,CAsClB;AA9EyI,CAAzI;;",
"sources":["node_modules/pixi_DOT_js/lib/scene/text/sdfShader/shader-bits/mSDFBit.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$pixi_DOT_js$lib$scene$text$sdfShader$shader_bits$mSDFBit\"] = function(global,require,module,exports) {\n'use strict';\n\n\"use strict\";\nconst mSDFBit = {\n  name: \"msdf-bit\",\n  fragment: {\n    header: (\n      /* wgsl */\n      `\n            fn calculateMSDFAlpha(msdfColor:vec4<f32>, shapeColor:vec4<f32>, distance:f32) -> f32 {\n                \n                // MSDF\n                var median = msdfColor.r + msdfColor.g + msdfColor.b -\n                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n            \n                // SDF\n                median = min(median, msdfColor.a);\n\n                var screenPxDistance = distance * (median - 0.5);\n                var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                // Gamma correction for coverage-like alpha\n                var luma: f32 = dot(shapeColor.rgb, vec3<f32>(0.299, 0.587, 0.114));\n                var gamma: f32 = mix(1.0, 1.0 / 2.2, luma);\n                var coverage: f32 = pow(shapeColor.a * alpha, gamma);\n\n                return coverage;\n             \n            }\n        `\n    )\n  }\n};\nconst mSDFBitGl = {\n  name: \"msdf-bit\",\n  fragment: {\n    header: (\n      /* glsl */\n      `\n            float calculateMSDFAlpha(vec4 msdfColor, vec4 shapeColor, float distance) {\n                \n                // MSDF\n                float median = msdfColor.r + msdfColor.g + msdfColor.b -\n                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n               \n                // SDF\n                median = min(median, msdfColor.a);\n            \n                float screenPxDistance = distance * (median - 0.5);\n                float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n           \n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                // Gamma correction for coverage-like alpha\n                float luma = dot(shapeColor.rgb, vec3(0.299, 0.587, 0.114));\n                float gamma = mix(1.0, 1.0 / 2.2, luma);\n                float coverage = pow(shapeColor.a * alpha, gamma);  \n              \n                return coverage;\n            }\n        `\n    )\n  }\n};\n\nexports.mSDFBit = mSDFBit;\nexports.mSDFBitGl = mSDFBitGl;\n//# sourceMappingURL=mSDFBit.js.map\n\n};"],
"names":["shadow$provide","global","require","module","exports","mSDFBit","name","fragment","header","mSDFBitGl"]
}
