shadow$provide.module$node_modules$$pixi$core$lib$shader$utils$generateProgram = function(global, require, module, exports) {
  var GLProgram = require("module$node_modules$$pixi$core$lib$shader$GLProgram"), compileShader = require("module$node_modules$$pixi$core$lib$shader$utils$compileShader"), defaultValue = require("module$node_modules$$pixi$core$lib$shader$utils$defaultValue"), getAttributeData = require("module$node_modules$$pixi$core$lib$shader$utils$getAttributeData"), getUniformData = require("module$node_modules$$pixi$core$lib$shader$utils$getUniformData"), logProgramError = require("module$node_modules$$pixi$core$lib$shader$utils$logProgramError");
  exports.generateProgram = function(gl, program) {
    var glVertShader = compileShader.compileShader(gl, gl.VERTEX_SHADER, program.vertexSrc), glFragShader = compileShader.compileShader(gl, gl.FRAGMENT_SHADER, program.fragmentSrc);
    const webGLProgram = gl.createProgram();
    gl.attachShader(webGLProgram, glVertShader);
    gl.attachShader(webGLProgram, glFragShader);
    var transformFeedbackVaryings = program.extra?.transformFeedbackVaryings;
    if (transformFeedbackVaryings && ("function" != typeof gl.transformFeedbackVaryings ? console.warn("TransformFeedback is not supported but TransformFeedbackVaryings are given.") : gl.transformFeedbackVaryings(webGLProgram, transformFeedbackVaryings.names, "separate" === transformFeedbackVaryings.bufferMode ? gl.SEPARATE_ATTRIBS : gl.INTERLEAVED_ATTRIBS)), gl.linkProgram(webGLProgram), gl.getProgramParameter(webGLProgram, gl.LINK_STATUS) || logProgramError.logProgramError(gl, webGLProgram, glVertShader, 
    glFragShader), program.attributeData = getAttributeData.getAttributeData(webGLProgram, gl), program.uniformData = getUniformData.getUniformData(webGLProgram, gl), !/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(program.vertexSrc)) {
      transformFeedbackVaryings = Object.keys(program.attributeData);
      transformFeedbackVaryings.sort((a, b) => a > b ? 1 : -1);
      for (let i = 0; i < transformFeedbackVaryings.length; i++) {
        program.attributeData[transformFeedbackVaryings[i]].location = i, gl.bindAttribLocation(webGLProgram, i, transformFeedbackVaryings[i]);
      }
      gl.linkProgram(webGLProgram);
    }
    gl.deleteShader(glVertShader);
    gl.deleteShader(glFragShader);
    glVertShader = {};
    for (const i in program.uniformData) {
      glFragShader = program.uniformData[i], glVertShader[i] = {location:gl.getUniformLocation(webGLProgram, i), value:defaultValue.defaultValue(glFragShader.type, glFragShader.size)};
    }
    return new GLProgram.GLProgram(webGLProgram, glVertShader);
  };
};

//# sourceMappingURL=module$node_modules$$pixi$core$lib$shader$utils$generateProgram.js.map
