shadow$provide.module$node_modules$pixi_DOT_js$lib$scene$sprite_animated$AnimatedSprite = function(global, require, module, exports) {
  var Texture = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$texture$Texture"), _const = require("module$node_modules$pixi_DOT_js$lib$ticker$const"), Ticker = require("module$node_modules$pixi_DOT_js$lib$ticker$Ticker");
  global = require("module$node_modules$pixi_DOT_js$lib$scene$sprite$Sprite");
  "use strict";
  class AnimatedSprite extends global.Sprite {
    constructor(...args) {
      let options = args[0];
      Array.isArray(args[0]) && (options = {textures:args[0], autoUpdate:args[1]});
      const {animationSpeed = 1, autoPlay = !1, autoUpdate = !0, loop = !0, onComplete = null, onFrameChange = null, onLoop = null, textures, updateAnchor = !1, ...rest} = options;
      [args] = textures;
      super({...rest, texture:args instanceof Texture.Texture ? args : args.texture});
      this._durations = this._textures = null;
      this._autoUpdate = autoUpdate;
      this._isConnectedToTicker = !1;
      this.animationSpeed = animationSpeed;
      this.loop = loop;
      this.updateAnchor = updateAnchor;
      this.onComplete = onComplete;
      this.onFrameChange = onFrameChange;
      this.onLoop = onLoop;
      this._currentTime = 0;
      this._playing = !1;
      this._previousFrame = null;
      this.textures = textures;
      autoPlay && this.play();
    }
    stop() {
      this._playing && (this._playing = !1, this._autoUpdate && this._isConnectedToTicker && (Ticker.Ticker.shared.remove(this.update, this), this._isConnectedToTicker = !1));
    }
    play() {
      this._playing || (this._playing = !0, this._autoUpdate && !this._isConnectedToTicker && (Ticker.Ticker.shared.add(this.update, this, _const.UPDATE_PRIORITY.HIGH), this._isConnectedToTicker = !0));
    }
    gotoAndStop(frameNumber) {
      this.stop();
      this.currentFrame = frameNumber;
    }
    gotoAndPlay(frameNumber) {
      this.currentFrame = frameNumber;
      this.play();
    }
    update(ticker) {
      if (this._playing) {
        var deltaTime = ticker.deltaTime, elapsed = this.animationSpeed * deltaTime;
        ticker = this.currentFrame;
        if (null !== this._durations) {
          let lag = this._currentTime % 1 * this._durations[this.currentFrame];
          for (lag += elapsed / 60 * 1e3; 0 > lag;) {
            this._currentTime--, lag += this._durations[this.currentFrame];
          }
          deltaTime = Math.sign(this.animationSpeed * deltaTime);
          for (this._currentTime = Math.floor(this._currentTime); lag >= this._durations[this.currentFrame];) {
            lag -= this._durations[this.currentFrame] * deltaTime, this._currentTime += deltaTime;
          }
          this._currentTime += lag / this._durations[this.currentFrame];
        } else {
          this._currentTime += elapsed;
        }
        if (0 > this._currentTime && !this.loop) {
          if (this.gotoAndStop(0), this.onComplete) {
            this.onComplete();
          }
        } else if (this._currentTime >= this._textures.length && !this.loop) {
          if (this.gotoAndStop(this._textures.length - 1), this.onComplete) {
            this.onComplete();
          }
        } else if (ticker !== this.currentFrame) {
          if (this.loop && this.onLoop && (0 < this.animationSpeed && this.currentFrame < ticker || 0 > this.animationSpeed && this.currentFrame > ticker)) {
            this.onLoop();
          }
          this._updateTexture();
        }
      }
    }
    _updateTexture() {
      const currentFrame = this.currentFrame;
      if (this._previousFrame !== currentFrame && (this._previousFrame = currentFrame, this.texture = this._textures[currentFrame], this.updateAnchor && this.texture.defaultAnchor && this.anchor.copyFrom(this.texture.defaultAnchor), this.onFrameChange)) {
        this.onFrameChange(this.currentFrame);
      }
    }
    destroy() {
      this.stop();
      super.destroy();
      this.onLoop = this.onFrameChange = this.onComplete = null;
    }
    static fromFrames(frames) {
      const textures = [];
      for (let i = 0; i < frames.length; ++i) {
        textures.push(Texture.Texture.from(frames[i]));
      }
      return new AnimatedSprite(textures);
    }
    static fromImages(images) {
      const textures = [];
      for (let i = 0; i < images.length; ++i) {
        textures.push(Texture.Texture.from(images[i]));
      }
      return new AnimatedSprite(textures);
    }
    get totalFrames() {
      return this._textures.length;
    }
    get textures() {
      return this._textures;
    }
    set textures(value) {
      if (value[0] instanceof Texture.Texture) {
        this._textures = value, this._durations = null;
      } else {
        this._textures = [];
        this._durations = [];
        for (let i = 0; i < value.length; i++) {
          this._textures.push(value[i].texture), this._durations.push(value[i].time);
        }
      }
      this._previousFrame = null;
      this.gotoAndStop(0);
      this._updateTexture();
    }
    get currentFrame() {
      let currentFrame = Math.floor(this._currentTime) % this._textures.length;
      0 > currentFrame && (currentFrame += this._textures.length);
      return currentFrame;
    }
    set currentFrame(value) {
      if (0 > value || value > this.totalFrames - 1) {
        throw Error(`[AnimatedSprite]: Invalid frame index value ${value}, expected to be between 0 and totalFrames ${this.totalFrames}.`);
      }
      const previousFrame = this.currentFrame;
      this._currentTime = value;
      previousFrame !== this.currentFrame && this._updateTexture();
    }
    get playing() {
      return this._playing;
    }
    get autoUpdate() {
      return this._autoUpdate;
    }
    set autoUpdate(value) {
      value !== this._autoUpdate && (this._autoUpdate = value, !this._autoUpdate && this._isConnectedToTicker ? (Ticker.Ticker.shared.remove(this.update, this), this._isConnectedToTicker = !1) : this._autoUpdate && !this._isConnectedToTicker && this._playing && (Ticker.Ticker.shared.add(this.update, this), this._isConnectedToTicker = !0));
    }
  }
  exports.AnimatedSprite = AnimatedSprite;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$scene$sprite_animated$AnimatedSprite.js.map
