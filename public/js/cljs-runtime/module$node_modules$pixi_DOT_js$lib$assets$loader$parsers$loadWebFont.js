shadow$provide.module$node_modules$pixi_DOT_js$lib$assets$loader$parsers$loadWebFont = function(global, require, module, exports) {
  function getFontFamilyName(url) {
    var ext = path.path.extname(url);
    ext = path.path.basename(url, ext).replace(/(-|_)/g, " ").toLowerCase().split(" ").map(word => word.charAt(0).toUpperCase() + word.slice(1));
    url = 0 < ext.length;
    for (var token of ext) {
      if (!token.match(CSS_IDENT_TOKEN_REGEX)) {
        url = !1;
        break;
      }
    }
    token = ext.join(" ");
    url || (token = `"${token.replace(/[\\"]/g, "\\$\x26")}"`);
    return token;
  }
  function encodeURIWhenNeeded(uri) {
    return validURICharactersRegex.test(uri) ? uri : encodeURI(uri);
  }
  var adapter = require("module$node_modules$pixi_DOT_js$lib$environment$adapter");
  global = require("module$node_modules$pixi_DOT_js$lib$extensions$Extensions");
  var warn = require("module$node_modules$pixi_DOT_js$lib$utils$logging$warn"), path = require("module$node_modules$pixi_DOT_js$lib$utils$path"), Cache = require("module$node_modules$pixi_DOT_js$lib$assets$cache$Cache"), checkDataUrl = require("module$node_modules$pixi_DOT_js$lib$assets$utils$checkDataUrl"), checkExtension = require("module$node_modules$pixi_DOT_js$lib$assets$utils$checkExtension");
  require = require("module$node_modules$pixi_DOT_js$lib$assets$loader$parsers$LoaderParser");
  "use strict";
  const validWeights = "normal bold 100 200 300 400 500 600 700 800 900".split(" "), validFontExtensions = [".ttf", ".otf", ".woff", ".woff2"], validFontMIMEs = ["font/ttf", "font/otf", "font/woff", "font/woff2"], CSS_IDENT_TOKEN_REGEX = /^(--|-?[A-Z_])[0-9A-Z_-]*$/i, validURICharactersRegex = /^[0-9A-Za-z%:/?#\[\]@!\$&'()\*\+,;=\-._~]*$/;
  require = {extension:{type:global.ExtensionType.LoadParser, priority:require.LoaderParserPriority.Low}, name:"loadWebFont", test(url) {
    return checkDataUrl.checkDataUrl(url, validFontMIMEs) || checkExtension.checkExtension(url, validFontExtensions);
  }, async load(url, options) {
    const fonts = adapter.DOMAdapter.get().getFontFaceSet();
    if (fonts) {
      const fontFaces = [], name = options.data?.family ?? getFontFamilyName(url), weights = options.data?.weights?.filter(weight => validWeights.includes(weight)) ?? ["normal"];
      options = options.data ?? {};
      for (let i = 0; i < weights.length; i++) {
        var weight = weights[i];
        weight = new FontFace(name, `url(${encodeURIWhenNeeded(url)})`, {...options, weight});
        await weight.load();
        fonts.add(weight);
        fontFaces.push(weight);
      }
      Cache.Cache.set(`${name}-and-url`, {url, fontFaces});
      return 1 === fontFaces.length ? fontFaces[0] : fontFaces;
    }
    warn.warn("[loadWebFont] FontFace API is not supported. Skipping loading font");
    return null;
  }, unload(font) {
    (Array.isArray(font) ? font : [font]).forEach(t => {
      Cache.Cache.remove(`${t.family}-and-url`);
      adapter.DOMAdapter.get().getFontFaceSet().delete(t);
    });
  }};
  exports.getFontFamilyName = getFontFamilyName;
  exports.loadWebFont = require;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$assets$loader$parsers$loadWebFont.js.map
