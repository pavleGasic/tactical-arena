shadow$provide.module$node_modules$$pixi$events$lib$FederatedEventTarget = function(global, require, module, exports) {
  function convertEventModeToInteractiveMode(mode) {
    return "dynamic" === mode || "static" === mode;
  }
  var core = require("module$node_modules$$pixi$core$lib$index");
  global = require("module$node_modules$$pixi$display$lib$index");
  var EventSystem = require("module$node_modules$$pixi$events$lib$EventSystem"), FederatedEvent = require("module$node_modules$$pixi$events$lib$FederatedEvent");
  require = {onclick:null, onmousedown:null, onmouseenter:null, onmouseleave:null, onmousemove:null, onglobalmousemove:null, onmouseout:null, onmouseover:null, onmouseup:null, onmouseupoutside:null, onpointercancel:null, onpointerdown:null, onpointerenter:null, onpointerleave:null, onpointermove:null, onglobalpointermove:null, onpointerout:null, onpointerover:null, onpointertap:null, onpointerup:null, onpointerupoutside:null, onrightclick:null, onrightdown:null, onrightup:null, onrightupoutside:null, 
  ontap:null, ontouchcancel:null, ontouchend:null, ontouchendoutside:null, ontouchmove:null, onglobaltouchmove:null, ontouchstart:null, onwheel:null, _internalInteractive:void 0, get interactive() {
    return this._internalInteractive ?? convertEventModeToInteractiveMode(EventSystem.EventSystem.defaultEventMode);
  }, set interactive(value) {
    core.utils.deprecation("7.2.0", "Setting interactive is deprecated, use eventMode \x3d 'none'/'passive'/'auto'/'static'/'dynamic' instead.");
    this.eventMode = (this._internalInteractive = value) ? "static" : "auto";
  }, _internalEventMode:void 0, get eventMode() {
    return this._internalEventMode ?? EventSystem.EventSystem.defaultEventMode;
  }, set eventMode(value) {
    this._internalInteractive = convertEventModeToInteractiveMode(value);
    this._internalEventMode = value;
  }, isInteractive() {
    return "static" === this.eventMode || "dynamic" === this.eventMode;
  }, interactiveChildren:!0, hitArea:null, addEventListener(type, listener, options) {
    const signal = "object" == typeof options ? options.signal : void 0, once = "object" == typeof options ? !0 === options.once : !1, context = "function" == typeof listener ? void 0 : listener;
    type = "boolean" == typeof options && options || "object" == typeof options && options.capture ? `${type}capture` : type;
    const listenerFn = "function" == typeof listener ? listener : listener.handleEvent, emitter = this;
    signal && signal.addEventListener("abort", () => {
      emitter.off(type, listenerFn, context);
    });
    once ? emitter.once(type, listenerFn, context) : emitter.on(type, listenerFn, context);
  }, removeEventListener(type, listener, options) {
    const context = "function" == typeof listener ? void 0 : listener;
    type = "boolean" == typeof options && options || "object" == typeof options && options.capture ? `${type}capture` : type;
    listener = "function" == typeof listener ? listener : listener.handleEvent;
    this.off(type, listener, context);
  }, dispatchEvent(e) {
    if (!(e instanceof FederatedEvent.FederatedEvent)) {
      throw Error("DisplayObject cannot propagate events outside of the Federated Events API");
    }
    return e.defaultPrevented = !1, e.path = null, e.target = this, e.manager.dispatchEvent(e), !e.defaultPrevented;
  }};
  global.DisplayObject.mixin(require);
  exports.FederatedDisplayObject = require;
};

//# sourceMappingURL=module$node_modules$$pixi$events$lib$FederatedEventTarget.js.map
