shadow$provide.module$node_modules$pixi_DOT_js$lib$scene$text_bitmap$asset$bitmapFontTextParser = function(global, require, module, exports) {
  exports.bitmapFontTextParser = {test(data) {
    return "string" === typeof data && data.startsWith("info face\x3d");
  }, parse(txt) {
    var items = txt.match(/^[a-z]+\s+.+$/gm);
    txt = {info:[], common:[], page:[], char:[], chars:[], kerning:[], kernings:[], distanceField:[]};
    for (var i in items) {
      var name = items[i].match(/^[a-z]+/gm)[0], attributeList = items[i].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm), itemData = {};
      for (var i2 in attributeList) {
        var split = attributeList[i2].split("\x3d"), key = split[0];
        split = split[1].replace(/"/gm, "");
        const floatValue = parseFloat(split);
        split = isNaN(floatValue) ? split : floatValue;
        itemData[key] = split;
      }
      txt[name].push(itemData);
    }
    i = {chars:{}, pages:[], lineHeight:0, fontSize:0, fontFamily:"", distanceField:null, baseLineOffset:0};
    [i2] = txt.info;
    [items] = txt.common;
    [name] = txt.distanceField ?? [];
    name && (i.distanceField = {range:parseInt(name.distanceRange, 10), type:name.fieldType});
    i.fontSize = parseInt(i2.size, 10);
    i.fontFamily = i2.face;
    i.lineHeight = parseInt(items.lineHeight, 10);
    i2 = txt.page;
    for (name = 0; name < i2.length; name++) {
      i.pages.push({id:parseInt(i2[name].id, 10) || 0, file:i2[name].file});
    }
    i2 = {};
    i.baseLineOffset = i.lineHeight - parseInt(items.base, 10);
    items = txt.char;
    for (name = 0; name < items.length; name++) {
      attributeList = items[name], itemData = parseInt(attributeList.id, 10), key = attributeList.letter ?? attributeList.char ?? String.fromCharCode(itemData), "space" === key && (key = " "), i2[itemData] = key, i.chars[key] = {id:itemData, page:parseInt(attributeList.page, 10) || 0, x:parseInt(attributeList.x, 10), y:parseInt(attributeList.y, 10), width:parseInt(attributeList.width, 10), height:parseInt(attributeList.height, 10), xOffset:parseInt(attributeList.xoffset, 10), yOffset:parseInt(attributeList.yoffset, 
      10), xAdvance:parseInt(attributeList.xadvance, 10), kerning:{}};
    }
    txt = txt.kerning || [];
    for (items = 0; items < txt.length; items++) {
      name = parseInt(txt[items].first, 10), attributeList = parseInt(txt[items].second, 10), itemData = parseInt(txt[items].amount, 10), i.chars[i2[attributeList]].kerning[i2[name]] = itemData;
    }
    return i;
  }};
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$scene$text_bitmap$asset$bitmapFontTextParser.js.map
