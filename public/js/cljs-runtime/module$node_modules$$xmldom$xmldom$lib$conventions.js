shadow$provide.module$node_modules$$xmldom$xmldom$lib$conventions = function(global, require, module, exports) {
  function freeze(object, oc) {
    void 0 === oc && (oc = Object);
    return oc && "function" === typeof oc.freeze ? oc.freeze(object) : object;
  }
  var MIME_TYPE = freeze({HTML:"text/html", isHTML:function(value) {
    return value === MIME_TYPE.HTML;
  }, XML_APPLICATION:"application/xml", XML_TEXT:"text/xml", XML_XHTML_APPLICATION:"application/xhtml+xml", XML_SVG_IMAGE:"image/svg+xml"}), NAMESPACE = freeze({HTML:"http://www.w3.org/1999/xhtml", isHTML:function(uri) {
    return uri === NAMESPACE.HTML;
  }, SVG:"http://www.w3.org/2000/svg", XML:"http://www.w3.org/XML/1998/namespace", XMLNS:"http://www.w3.org/2000/xmlns/"});
  exports.assign = function(target, source) {
    if (null === target || "object" !== typeof target) {
      throw new TypeError("target is not an object");
    }
    for (var key in source) {
      Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
    }
    return target;
  };
  exports.find = function(list, predicate, ac) {
    void 0 === ac && (ac = Array.prototype);
    if (list && "function" === typeof ac.find) {
      return ac.find.call(list, predicate);
    }
    for (ac = 0; ac < list.length; ac++) {
      if (Object.prototype.hasOwnProperty.call(list, ac)) {
        var item = list[ac];
        if (predicate.call(void 0, item, ac, list)) {
          return item;
        }
      }
    }
  };
  exports.freeze = freeze;
  exports.MIME_TYPE = MIME_TYPE;
  exports.NAMESPACE = NAMESPACE;
};

//# sourceMappingURL=module$node_modules$$xmldom$xmldom$lib$conventions.js.map
