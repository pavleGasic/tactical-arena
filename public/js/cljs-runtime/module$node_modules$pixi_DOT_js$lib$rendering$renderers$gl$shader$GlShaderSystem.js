shadow$provide.module$node_modules$pixi_DOT_js$lib$rendering$renderers$gl$shader$GlShaderSystem = function(global, require, module, exports) {
  global = require("module$node_modules$pixi_DOT_js$lib$extensions$Extensions");
  var maxRecommendedTextures = require("module$node_modules$pixi_DOT_js$lib$rendering$batcher$gl$utils$maxRecommendedTextures"), GenerateShaderSyncCode = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$gl$shader$GenerateShaderSyncCode"), generateProgram = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$gl$shader$program$generateProgram");
  "use strict";
  const defaultSyncData = {textureCount:0, blockIndex:0};
  class GlShaderSystem {
    constructor(renderer) {
      this._activeProgram = null;
      this._programDataHash = Object.create(null);
      this._shaderSyncFunctions = Object.create(null);
      this._renderer = renderer;
      this._renderer.renderableGC.addManagedHash(this, "_programDataHash");
    }
    contextChange(gl) {
      this._gl = gl;
      this._programDataHash = Object.create(null);
      this._shaderSyncFunctions = Object.create(null);
      this._activeProgram = null;
      this.maxTextures = maxRecommendedTextures.getMaxTexturesPerBatch();
    }
    bind(shader, skipSync) {
      this._setProgram(shader.glProgram);
      skipSync || (defaultSyncData.textureCount = 0, defaultSyncData.blockIndex = 0, (skipSync = this._shaderSyncFunctions[shader.glProgram._key]) || (skipSync = this._shaderSyncFunctions[shader.glProgram._key] = this._generateShaderSync(shader, this)), this._renderer.buffer.nextBindBase(!!shader.glProgram.transformFeedbackVaryings), skipSync(this._renderer, shader, defaultSyncData));
    }
    updateUniformGroup(uniformGroup) {
      this._renderer.uniformGroup.updateUniformGroup(uniformGroup, this._activeProgram, defaultSyncData);
    }
    bindUniformBlock(uniformGroup, name, index = 0) {
      const bufferSystem = this._renderer.buffer, programData = this._getProgramData(this._activeProgram), isBufferResource = uniformGroup._bufferResource;
      isBufferResource || this._renderer.ubo.updateUniformGroup(uniformGroup);
      const buffer = uniformGroup.buffer, glBuffer = bufferSystem.updateBuffer(buffer), boundLocation = bufferSystem.freeLocationForBufferBase(glBuffer);
      if (isBufferResource) {
        const {offset, size} = uniformGroup;
        0 === offset && size === buffer.data.byteLength ? bufferSystem.bindBufferBase(glBuffer, boundLocation) : bufferSystem.bindBufferRange(glBuffer, boundLocation, offset);
      } else {
        bufferSystem.getLastBindBaseLocation(glBuffer) !== boundLocation && bufferSystem.bindBufferBase(glBuffer, boundLocation);
      }
      uniformGroup = this._activeProgram._uniformBlockData[name].index;
      programData.uniformBlockBindings[index] !== boundLocation && (programData.uniformBlockBindings[index] = boundLocation, this._renderer.gl.uniformBlockBinding(programData.program, uniformGroup, boundLocation));
    }
    _setProgram(program) {
      this._activeProgram !== program && (this._activeProgram = program, program = this._getProgramData(program), this._gl.useProgram(program.program));
    }
    _getProgramData(program) {
      return this._programDataHash[program._key] || this._createProgramData(program);
    }
    _createProgramData(program) {
      const key = program._key;
      this._programDataHash[key] = generateProgram.generateProgram(this._gl, program);
      return this._programDataHash[key];
    }
    destroy() {
      for (const key of Object.keys(this._programDataHash)) {
        this._programDataHash[key].destroy(), this._programDataHash[key] = null;
      }
      this._programDataHash = null;
    }
    _generateShaderSync(shader, shaderSystem) {
      return GenerateShaderSyncCode.generateShaderSyncCode(shader, shaderSystem);
    }
    resetState() {
      this._activeProgram = null;
    }
  }
  GlShaderSystem.extension = {type:[global.ExtensionType.WebGLSystem], name:"shader"};
  exports.GlShaderSystem = GlShaderSystem;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$rendering$renderers$gl$shader$GlShaderSystem.js.map
