shadow$provide.module$node_modules$$pixi$core$lib$utils$QuadUv = function(global, require, module, exports) {
  var Buffer = require("module$node_modules$$pixi$core$lib$geometry$Buffer");
  global = require("module$node_modules$$pixi$core$lib$geometry$Geometry");
  class QuadUv extends global.Geometry {
    constructor() {
      super();
      this.vertices = new Float32Array([-1, -1, 1, -1, 1, 1, -1, 1]);
      this.uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);
      this.vertexBuffer = new Buffer.Buffer(this.vertices);
      this.uvBuffer = new Buffer.Buffer(this.uvs);
      this.addAttribute("aVertexPosition", this.vertexBuffer).addAttribute("aTextureCoord", this.uvBuffer).addIndex([0, 1, 2, 0, 2, 3]);
    }
    map(targetTextureFrame, destinationFrame) {
      let x = 0, y = 0;
      return this.uvs[0] = x, this.uvs[1] = y, this.uvs[2] = x + destinationFrame.width / targetTextureFrame.width, this.uvs[3] = y, this.uvs[4] = x + destinationFrame.width / targetTextureFrame.width, this.uvs[5] = y + destinationFrame.height / targetTextureFrame.height, this.uvs[6] = x, this.uvs[7] = y + destinationFrame.height / targetTextureFrame.height, x = destinationFrame.x, y = destinationFrame.y, this.vertices[0] = x, this.vertices[1] = y, this.vertices[2] = x + destinationFrame.width, this.vertices[3] = 
      y, this.vertices[4] = x + destinationFrame.width, this.vertices[5] = y + destinationFrame.height, this.vertices[6] = x, this.vertices[7] = y + destinationFrame.height, this.invalidate(), this;
    }
    invalidate() {
      return this.vertexBuffer._updateID++, this.uvBuffer._updateID++, this;
    }
  }
  exports.QuadUv = QuadUv;
};

//# sourceMappingURL=module$node_modules$$pixi$core$lib$utils$QuadUv.js.map
