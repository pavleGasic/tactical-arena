shadow$provide.module$node_modules$pixi_DOT_js$lib$scene$text$AbstractText = function(global, require, module, exports) {
  var ObservablePoint = require("module$node_modules$pixi_DOT_js$lib$maths$point$ObservablePoint"), deprecation = require("module$node_modules$pixi_DOT_js$lib$utils$logging$deprecation");
  global = require("module$node_modules$pixi_DOT_js$lib$scene$view$ViewContainer");
  "use strict";
  class AbstractText extends global.ViewContainer {
    constructor(options, styleClass) {
      const {text, resolution, style, anchor, width, height, roundPixels, ...rest} = options;
      super({...rest});
      this.batched = !0;
      this._resolution = null;
      this._didTextUpdate = this._autoResolution = !0;
      this._styleClass = styleClass;
      this.text = text ?? "";
      this.style = style;
      this.resolution = resolution ?? null;
      this.allowChildren = !1;
      this._anchor = new ObservablePoint.ObservablePoint({_onUpdate:() => {
        this.onViewUpdate();
      }});
      anchor && (this.anchor = anchor);
      this.roundPixels = roundPixels ?? !1;
      void 0 !== width && (this.width = width);
      void 0 !== height && (this.height = height);
    }
    get anchor() {
      return this._anchor;
    }
    set anchor(value) {
      "number" === typeof value ? this._anchor.set(value) : this._anchor.copyFrom(value);
    }
    set text(value) {
      value = value.toString();
      this._text !== value && (this._text = value, this.onViewUpdate());
    }
    get text() {
      return this._text;
    }
    set resolution(value) {
      this._autoResolution = null === value;
      this._resolution = value;
      this.onViewUpdate();
    }
    get resolution() {
      return this._resolution;
    }
    get style() {
      return this._style;
    }
    set style(style) {
      style || (style = {});
      this._style?.off("update", this.onViewUpdate, this);
      this._style = style instanceof this._styleClass ? style : new this._styleClass(style);
      this._style.on("update", this.onViewUpdate, this);
      this.onViewUpdate();
    }
    get width() {
      return Math.abs(this.scale.x) * this.bounds.width;
    }
    set width(value) {
      this._setWidth(value, this.bounds.width);
    }
    get height() {
      return Math.abs(this.scale.y) * this.bounds.height;
    }
    set height(value) {
      this._setHeight(value, this.bounds.height);
    }
    getSize(out) {
      out || (out = {});
      out.width = Math.abs(this.scale.x) * this.bounds.width;
      out.height = Math.abs(this.scale.y) * this.bounds.height;
      return out;
    }
    setSize(value, height) {
      "object" === typeof value ? (height = value.height ?? value.width, value = value.width) : height ?? (height = value);
      void 0 !== value && this._setWidth(value, this.bounds.width);
      void 0 !== height && this._setHeight(height, this.bounds.height);
    }
    containsPoint(point) {
      var width = this.bounds.width;
      const height = this.bounds.height, x1 = -width * this.anchor.x;
      return point.x >= x1 && point.x <= x1 + width && (width = -height * this.anchor.y, point.y >= width && point.y <= width + height) ? !0 : !1;
    }
    onViewUpdate() {
      this.didViewUpdate || (this._didTextUpdate = !0);
      super.onViewUpdate();
    }
    _getKey() {
      return `${this.text}:${this._style.styleKey}:${this._resolution}`;
    }
    destroy(options = !1) {
      super.destroy(options);
      this._anchor = this._bounds = this.owner = null;
      ("boolean" === typeof options ? options : options?.style) && this._style.destroy(options);
      this._text = this._style = null;
    }
  }
  exports.AbstractText = AbstractText;
  exports.ensureTextOptions = function(args, name) {
    let options = args[0] ?? {};
    if ("string" === typeof options || args[1]) {
      deprecation.deprecation(deprecation.v8_0_0, `use new ${name}({ text: "hi!", style }) instead`), options = {text:options, style:args[1]};
    }
    return options;
  };
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$scene$text$AbstractText.js.map
