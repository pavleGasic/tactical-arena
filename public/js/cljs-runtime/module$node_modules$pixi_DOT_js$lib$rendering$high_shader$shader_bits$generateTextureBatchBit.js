shadow$provide.module$node_modules$pixi_DOT_js$lib$rendering$high_shader$shader_bits$generateTextureBatchBit = function(global, require, module, exports) {
  const textureBatchBitGpuCache = {}, textureBatchBitGlCache = {};
  exports.generateTextureBatchBit = function(maxTextures) {
    if (!textureBatchBitGpuCache[maxTextures]) {
      var src = [];
      if (1 === maxTextures) {
        src.push("@group(1) @binding(0) var textureSource1: texture_2d\x3cf32\x3e;"), src.push("@group(1) @binding(1) var textureSampler1: sampler;");
      } else {
        var bindingIndex = 0;
        for (var i = 0; i < maxTextures; i++) {
          src.push(`@group(1) @binding(${bindingIndex++}) var textureSource${i + 1}: texture_2d<f32>;`), src.push(`@group(1) @binding(${bindingIndex++}) var textureSampler${i + 1}: sampler;`);
        }
      }
      src = `
                @in @interpolate(flat) vTextureId: u32;

                ${src.join("\n")}
            `;
      bindingIndex = [];
      if (1 === maxTextures) {
        bindingIndex.push("outColor \x3d textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);");
      } else {
        bindingIndex.push("switch vTextureId {");
        for (i = 0; i < maxTextures; i++) {
          i === maxTextures - 1 ? bindingIndex.push("  default:{") : bindingIndex.push(`  case ${i}:{`), bindingIndex.push(`      outColor = textureSampleGrad(textureSource${i + 1}, textureSampler${i + 1}, vUV, uvDx, uvDy);`), bindingIndex.push("      break;}");
        }
        bindingIndex.push("}");
      }
      bindingIndex = bindingIndex.join("\n");
      textureBatchBitGpuCache[maxTextures] = {name:"texture-batch-bit", vertex:{header:"\n                @in aTextureIdAndRound: vec2\x3cu32\x3e;\n                @out @interpolate(flat) vTextureId : u32;\n            ", main:"\n                vTextureId \x3d aTextureIdAndRound.y;\n            ", end:"\n                if(aTextureIdAndRound.x \x3d\x3d 1)\n                {\n                    vPosition \x3d vec4\x3cf32\x3e(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n                }\n            "}, 
      fragment:{header:src, main:`
                var uvDx = dpdx(vUV);
                var uvDy = dpdy(vUV);

                ${bindingIndex}
            `}};
    }
    return textureBatchBitGpuCache[maxTextures];
  };
  exports.generateTextureBatchBitGl = function(maxTextures) {
    if (!textureBatchBitGlCache[maxTextures]) {
      var JSCompiler_inline_result = [];
      for (let i = 0; i < maxTextures; i++) {
        0 < i && JSCompiler_inline_result.push("else"), i < maxTextures - 1 && JSCompiler_inline_result.push(`if(vTextureId < ${i}.5)`), JSCompiler_inline_result.push("{"), JSCompiler_inline_result.push(`	outColor = texture(uTextures[${i}], vUV);`), JSCompiler_inline_result.push("}");
      }
      JSCompiler_inline_result = JSCompiler_inline_result.join("\n");
      textureBatchBitGlCache[maxTextures] = {name:"texture-batch-bit", vertex:{header:"\n                in vec2 aTextureIdAndRound;\n                out float vTextureId;\n\n            ", main:"\n                vTextureId \x3d aTextureIdAndRound.y;\n            ", end:"\n                if(aTextureIdAndRound.x \x3d\x3d 1.)\n                {\n                    gl_Position.xy \x3d roundPixels(gl_Position.xy, uResolution);\n                }\n            "}, fragment:{header:`
                in float vTextureId;

                uniform sampler2D uTextures[${maxTextures}];

            `, main:`

                ${JSCompiler_inline_result}
            `}};
    }
    return textureBatchBitGlCache[maxTextures];
  };
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$rendering$high_shader$shader_bits$generateTextureBatchBit.js.map
