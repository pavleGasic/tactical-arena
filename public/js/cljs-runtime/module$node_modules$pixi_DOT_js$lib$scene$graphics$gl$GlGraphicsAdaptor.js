shadow$provide.module$node_modules$pixi_DOT_js$lib$scene$graphics$gl$GlGraphicsAdaptor = function(global, require, module, exports) {
  global = require("module$node_modules$pixi_DOT_js$lib$extensions$Extensions");
  var Matrix = require("module$node_modules$pixi_DOT_js$lib$maths$matrix$Matrix"), maxRecommendedTextures = require("module$node_modules$pixi_DOT_js$lib$rendering$batcher$gl$utils$maxRecommendedTextures"), compileHighShaderToProgram = require("module$node_modules$pixi_DOT_js$lib$rendering$high_shader$compileHighShaderToProgram"), colorBit = require("module$node_modules$pixi_DOT_js$lib$rendering$high_shader$shader_bits$colorBit"), generateTextureBatchBit = require("module$node_modules$pixi_DOT_js$lib$rendering$high_shader$shader_bits$generateTextureBatchBit"), 
  localUniformBit = require("module$node_modules$pixi_DOT_js$lib$rendering$high_shader$shader_bits$localUniformBit"), roundPixelsBit = require("module$node_modules$pixi_DOT_js$lib$rendering$high_shader$shader_bits$roundPixelsBit"), getBatchSamplersUniformGroup = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$gl$shader$getBatchSamplersUniformGroup"), Shader = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$shader$Shader"), UniformGroup = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$shader$UniformGroup");
  "use strict";
  class GlGraphicsAdaptor {
    init() {
      const uniforms = new UniformGroup.UniformGroup({uColor:{value:new Float32Array([1, 1, 1, 1]), type:"vec4\x3cf32\x3e"}, uTransformMatrix:{value:new Matrix.Matrix(), type:"mat3x3\x3cf32\x3e"}, uRound:{value:0, type:"f32"}}), maxTextures = maxRecommendedTextures.getMaxTexturesPerBatch(), glProgram = compileHighShaderToProgram.compileHighShaderGlProgram({name:"graphics", bits:[colorBit.colorBitGl, generateTextureBatchBit.generateTextureBatchBitGl(maxTextures), localUniformBit.localUniformBitGl, 
      roundPixelsBit.roundPixelsBitGl]});
      this.shader = new Shader.Shader({glProgram, resources:{localUniforms:uniforms, batchSamplers:getBatchSamplersUniformGroup.getBatchSamplersUniformGroup(maxTextures)}});
    }
    execute(graphicsPipe, renderable) {
      var context = renderable.context, shader = context.customShader || this.shader;
      renderable = graphicsPipe.renderer;
      const {batcher, instructions} = renderable.graphicsContext.getContextRenderData(context);
      shader.groups[0] = renderable.globalUniforms.bindGroup;
      renderable.state.set(graphicsPipe.state);
      renderable.shader.bind(shader);
      renderable.geometry.bind(batcher.geometry, shader.glProgram);
      graphicsPipe = instructions.instructions;
      for (context = 0; context < instructions.instructionSize; context++) {
        if (shader = graphicsPipe[context], shader.size) {
          for (let j = 0; j < shader.textures.count; j++) {
            renderable.texture.bind(shader.textures.textures[j], j);
          }
          renderable.geometry.draw(shader.topology, shader.size, shader.start);
        }
      }
    }
    destroy() {
      this.shader.destroy(!0);
      this.shader = null;
    }
  }
  GlGraphicsAdaptor.extension = {type:[global.ExtensionType.WebGLPipesAdaptor], name:"graphics"};
  exports.GlGraphicsAdaptor = GlGraphicsAdaptor;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$scene$graphics$gl$GlGraphicsAdaptor.js.map
