shadow$provide.module$node_modules$qs$lib$stringify = function(global, require, module, exports) {
  var getSideChannel = require("module$node_modules$side_channel$index"), utils = require("module$node_modules$qs$lib$utils"), formats = require("module$node_modules$qs$lib$formats"), has = Object.prototype.hasOwnProperty, arrayPrefixGenerators = {brackets:function(prefix) {
    return prefix + "[]";
  }, comma:"comma", indices:function(prefix, key) {
    return prefix + "[" + key + "]";
  }, repeat:function(prefix) {
    return prefix;
  }}, isArray = Array.isArray, push = Array.prototype.push, pushToArray = function(arr, valueOrArray) {
    push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
  }, toISO = Date.prototype.toISOString;
  global = formats["default"];
  var defaults = {addQueryPrefix:!1, allowDots:!1, allowEmptyArrays:!1, arrayFormat:"indices", charset:"utf-8", charsetSentinel:!1, commaRoundTrip:!1, delimiter:"\x26", encode:!0, encodeDotInKeys:!1, encoder:utils.encode, encodeValuesOnly:!1, filter:void 0, format:global, formatter:formats.formatters[global], indices:!1, serializeDate:function(date) {
    return toISO.call(date);
  }, skipNulls:!1, strictNullHandling:!1}, sentinel = {}, stringify = function stringify(object, prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, sideChannel) {
    for (var obj = object, tmpSc = sideChannel, step = 0, findFlag = !1; void 0 !== (tmpSc = tmpSc.get(sentinel)) && !findFlag;) {
      var pos = tmpSc.get(object);
      step += 1;
      if ("undefined" !== typeof pos) {
        if (pos === step) {
          throw new RangeError("Cyclic object value");
        }
        findFlag = !0;
      }
      "undefined" === typeof tmpSc.get(sentinel) && (step = 0);
    }
    "function" === typeof filter ? obj = filter(prefix, obj) : obj instanceof Date ? obj = serializeDate(obj) : "comma" === generateArrayPrefix && isArray(obj) && (obj = utils.maybeMap(obj, function(value) {
      return value instanceof Date ? serializeDate(value) : value;
    }));
    if (null === obj) {
      if (strictNullHandling) {
        return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, "key", format) : prefix;
      }
      obj = "";
    }
    if ("string" === typeof obj || "number" === typeof obj || "boolean" === typeof obj || "symbol" === typeof obj || "bigint" === typeof obj || utils.isBuffer(obj)) {
      return encoder ? (object = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, "key", format), [formatter(object) + "\x3d" + formatter(encoder(obj, defaults.encoder, charset, "value", format))]) : [formatter(prefix) + "\x3d" + formatter(String(obj))];
    }
    tmpSc = [];
    if ("undefined" === typeof obj) {
      return tmpSc;
    }
    "comma" === generateArrayPrefix && isArray(obj) ? (encodeValuesOnly && encoder && (obj = utils.maybeMap(obj, encoder)), findFlag = [{value:0 < obj.length ? obj.join(",") || null : void 0}]) : isArray(filter) ? findFlag = filter : (findFlag = Object.keys(obj), findFlag = sort ? findFlag.sort(sort) : findFlag);
    prefix = encodeDotInKeys ? String(prefix).replace(/\./g, "%2E") : String(prefix);
    prefix = commaRoundTrip && isArray(obj) && 1 === obj.length ? prefix + "[]" : prefix;
    if (allowEmptyArrays && isArray(obj) && 0 === obj.length) {
      return prefix + "[]";
    }
    for (pos = 0; pos < findFlag.length; ++pos) {
      var key = findFlag[pos], value = "object" === typeof key && key && "undefined" !== typeof key.value ? key.value : obj[key];
      if (!skipNulls || null !== value) {
        key = allowDots && encodeDotInKeys ? String(key).replace(/\./g, "%2E") : String(key);
        key = isArray(obj) ? "function" === typeof generateArrayPrefix ? generateArrayPrefix(prefix, key) : prefix : prefix + (allowDots ? "." + key : "[" + key + "]");
        sideChannel.set(object, step);
        var valueSideChannel = getSideChannel();
        valueSideChannel.set(sentinel, sideChannel);
        pushToArray(tmpSc, stringify(value, key, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, "comma" === generateArrayPrefix && encodeValuesOnly && isArray(obj) ? null : encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, valueSideChannel));
      }
    }
    return tmpSc;
  };
  module.exports = function(object, opts) {
    if (opts) {
      if ("undefined" !== typeof opts.allowEmptyArrays && "boolean" !== typeof opts.allowEmptyArrays) {
        throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
      }
      if ("undefined" !== typeof opts.encodeDotInKeys && "boolean" !== typeof opts.encodeDotInKeys) {
        throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
      }
      if (null !== opts.encoder && "undefined" !== typeof opts.encoder && "function" !== typeof opts.encoder) {
        throw new TypeError("Encoder has to be a function.");
      }
      var charset = opts.charset || defaults.charset;
      if ("undefined" !== typeof opts.charset && "utf-8" !== opts.charset && "iso-8859-1" !== opts.charset) {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      var format = formats["default"];
      if ("undefined" !== typeof opts.format) {
        if (!has.call(formats.formatters, opts.format)) {
          throw new TypeError("Unknown format option provided.");
        }
        format = opts.format;
      }
      var formatter = formats.formatters[format], filter = defaults.filter;
      if ("function" === typeof opts.filter || isArray(opts.filter)) {
        filter = opts.filter;
      }
      var arrayFormat = opts.arrayFormat in arrayPrefixGenerators ? opts.arrayFormat : "indices" in opts ? opts.indices ? "indices" : "repeat" : defaults.arrayFormat;
      if ("commaRoundTrip" in opts && "boolean" !== typeof opts.commaRoundTrip) {
        throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
      }
      opts = {addQueryPrefix:"boolean" === typeof opts.addQueryPrefix ? opts.addQueryPrefix : defaults.addQueryPrefix, allowDots:"undefined" === typeof opts.allowDots ? !0 === opts.encodeDotInKeys ? !0 : defaults.allowDots : !!opts.allowDots, allowEmptyArrays:"boolean" === typeof opts.allowEmptyArrays ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays, arrayFormat, charset, charsetSentinel:"boolean" === typeof opts.charsetSentinel ? opts.charsetSentinel : defaults.charsetSentinel, commaRoundTrip:!!opts.commaRoundTrip, 
      delimiter:"undefined" === typeof opts.delimiter ? defaults.delimiter : opts.delimiter, encode:"boolean" === typeof opts.encode ? opts.encode : defaults.encode, encodeDotInKeys:"boolean" === typeof opts.encodeDotInKeys ? opts.encodeDotInKeys : defaults.encodeDotInKeys, encoder:"function" === typeof opts.encoder ? opts.encoder : defaults.encoder, encodeValuesOnly:"boolean" === typeof opts.encodeValuesOnly ? opts.encodeValuesOnly : defaults.encodeValuesOnly, filter, format, formatter, serializeDate:"function" === 
      typeof opts.serializeDate ? opts.serializeDate : defaults.serializeDate, skipNulls:"boolean" === typeof opts.skipNulls ? opts.skipNulls : defaults.skipNulls, sort:"function" === typeof opts.sort ? opts.sort : null, strictNullHandling:"boolean" === typeof opts.strictNullHandling ? opts.strictNullHandling : defaults.strictNullHandling};
    } else {
      opts = defaults;
    }
    if ("function" === typeof opts.filter) {
      charset = opts.filter, object = charset("", object);
    } else if (isArray(opts.filter)) {
      var objKeys = charset = opts.filter;
    }
    charset = [];
    if ("object" !== typeof object || null === object) {
      return "";
    }
    format = arrayPrefixGenerators[opts.arrayFormat];
    formatter = "comma" === format && opts.commaRoundTrip;
    objKeys || (objKeys = Object.keys(object));
    opts.sort && objKeys.sort(opts.sort);
    filter = getSideChannel();
    for (arrayFormat = 0; arrayFormat < objKeys.length; ++arrayFormat) {
      var key = objKeys[arrayFormat], value = object[key];
      opts.skipNulls && null === value || pushToArray(charset, stringify(value, key, format, formatter, opts.allowEmptyArrays, opts.strictNullHandling, opts.skipNulls, opts.encodeDotInKeys, opts.encode ? opts.encoder : null, opts.filter, opts.sort, opts.allowDots, opts.serializeDate, opts.format, opts.formatter, opts.encodeValuesOnly, opts.charset, filter));
    }
    objKeys = charset.join(opts.delimiter);
    object = !0 === opts.addQueryPrefix ? "?" : "";
    opts.charsetSentinel && (object = "iso-8859-1" === opts.charset ? object + "utf8\x3d%26%2310003%3B\x26" : object + "utf8\x3d%E2%9C%93\x26");
    return 0 < objKeys.length ? object + objKeys : "";
  };
};

//# sourceMappingURL=module$node_modules$qs$lib$stringify.js.map
