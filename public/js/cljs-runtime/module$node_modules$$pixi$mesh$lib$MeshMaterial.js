shadow$provide.module$node_modules$$pixi$mesh$lib$MeshMaterial = function(global, require, module, exports) {
  var core = require("module$node_modules$$pixi$core$lib$index"), mesh$1 = require("module$node_modules$$pixi$mesh$lib$shader$mesh_frag"), mesh = require("module$node_modules$$pixi$mesh$lib$shader$mesh_vert");
  class MeshMaterial extends core.Shader {
    constructor(uSampler, options) {
      const uniforms = {uSampler, alpha:1, uTextureMatrix:core.Matrix.IDENTITY, uColor:new Float32Array([1, 1, 1, 1])};
      options = Object.assign({tint:16777215, alpha:1, pluginName:"batch"}, options);
      options.uniforms && Object.assign(uniforms, options.uniforms);
      super(options.program || core.Program.from(mesh.default, mesh$1.default), uniforms);
      this._colorDirty = !1;
      this.uvMatrix = new core.TextureMatrix(uSampler);
      this.batchable = void 0 === options.program;
      this.pluginName = options.pluginName;
      this._tintColor = new core.Color(options.tint);
      this._tintRGB = this._tintColor.toLittleEndianNumber();
      this._colorDirty = !0;
      this.alpha = options.alpha;
    }
    get texture() {
      return this.uniforms.uSampler;
    }
    set texture(value) {
      this.uniforms.uSampler !== value && (!this.uniforms.uSampler.baseTexture.alphaMode != !value.baseTexture.alphaMode && (this._colorDirty = !0), this.uniforms.uSampler = value, this.uvMatrix.texture = value);
    }
    set alpha(value) {
      value !== this._alpha && (this._alpha = value, this._colorDirty = !0);
    }
    get alpha() {
      return this._alpha;
    }
    set tint(value) {
      value !== this.tint && (this._tintColor.setValue(value), this._tintRGB = this._tintColor.toLittleEndianNumber(), this._colorDirty = !0);
    }
    get tint() {
      return this._tintColor.value;
    }
    get tintValue() {
      return this._tintColor.toNumber();
    }
    update() {
      if (this._colorDirty) {
        this._colorDirty = !1;
        const applyToChannels = this.texture.baseTexture.alphaMode;
        core.Color.shared.setValue(this._tintColor).premultiply(this._alpha, applyToChannels).toArray(this.uniforms.uColor);
      }
      this.uvMatrix.update() && (this.uniforms.uTextureMatrix = this.uvMatrix.mapCoord);
    }
  }
  exports.MeshMaterial = MeshMaterial;
};

//# sourceMappingURL=module$node_modules$$pixi$mesh$lib$MeshMaterial.js.map
