shadow$provide.module$node_modules$$pixi$core$lib$projection$ProjectionSystem = function(global, require, module, exports) {
  global = require("module$node_modules$$pixi$extensions$lib$index");
  var math = require("module$node_modules$$pixi$math$lib$index");
  class ProjectionSystem {
    constructor(renderer) {
      this.renderer = renderer;
      this.defaultFrame = this.sourceFrame = this.destinationFrame = null;
      this.projectionMatrix = new math.Matrix();
      this.transform = null;
    }
    update(destinationFrame, sourceFrame, resolution, root) {
      this.destinationFrame = destinationFrame || this.destinationFrame || this.defaultFrame;
      this.sourceFrame = sourceFrame || this.sourceFrame || destinationFrame;
      this.calculateProjection(this.destinationFrame, this.sourceFrame, resolution, root);
      this.transform && this.projectionMatrix.append(this.transform);
      destinationFrame = this.renderer;
      destinationFrame.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix;
      destinationFrame.globalUniforms.update();
      destinationFrame.shader.shader && destinationFrame.shader.syncUniformGroup(destinationFrame.shader.shader.uniforms.globals);
    }
    calculateProjection(_destinationFrame, sourceFrame, _resolution, root) {
      _destinationFrame = this.projectionMatrix;
      root = root ? -1 : 1;
      _destinationFrame.identity();
      _destinationFrame.a = 1 / sourceFrame.width * 2;
      _destinationFrame.d = 1 / sourceFrame.height * root * 2;
      _destinationFrame.tx = -1 - sourceFrame.x * _destinationFrame.a;
      _destinationFrame.ty = -root - sourceFrame.y * _destinationFrame.d;
    }
    setTransform(_matrix) {
    }
    destroy() {
      this.renderer = null;
    }
  }
  ProjectionSystem.extension = {type:global.ExtensionType.RendererSystem, name:"projection"};
  global.extensions.add(ProjectionSystem);
  exports.ProjectionSystem = ProjectionSystem;
};

//# sourceMappingURL=module$node_modules$$pixi$core$lib$projection$ProjectionSystem.js.map
