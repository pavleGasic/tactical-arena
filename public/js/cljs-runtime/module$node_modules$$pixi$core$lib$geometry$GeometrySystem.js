shadow$provide.module$node_modules$$pixi$core$lib$geometry$GeometrySystem = function(global, require, module, exports) {
  var constants = require("module$node_modules$$pixi$constants$lib$index");
  global = require("module$node_modules$$pixi$extensions$lib$index");
  var settings = require("module$node_modules$$pixi$settings$lib$index");
  const byteSizeMap = {5126:4, 5123:2, 5121:1};
  class GeometrySystem {
    constructor(renderer) {
      this.renderer = renderer;
      this._activeVao = this._activeGeometry = null;
      this.hasInstance = this.hasVao = !0;
      this.canUseUInt32ElementIndex = !1;
      this.managedGeometries = {};
    }
    contextChange() {
      this.disposeAll(!0);
      const gl = this.gl = this.renderer.gl, context = this.renderer.context;
      if (this.CONTEXT_UID = this.renderer.CONTEXT_UID, 2 !== context.webGLVersion) {
        let nativeVaoExtension = this.renderer.context.extensions.vertexArrayObject;
        settings.settings.PREFER_ENV === constants.ENV.WEBGL_LEGACY && (nativeVaoExtension = null);
        nativeVaoExtension ? (gl.createVertexArray = () => nativeVaoExtension.createVertexArrayOES(), gl.bindVertexArray = vao => nativeVaoExtension.bindVertexArrayOES(vao), gl.deleteVertexArray = vao => nativeVaoExtension.deleteVertexArrayOES(vao)) : (this.hasVao = !1, gl.createVertexArray = () => null, gl.bindVertexArray = () => null, gl.deleteVertexArray = () => null);
      }
      if (2 !== context.webGLVersion) {
        const instanceExt = gl.getExtension("ANGLE_instanced_arrays");
        instanceExt ? (gl.vertexAttribDivisor = (a, b) => instanceExt.vertexAttribDivisorANGLE(a, b), gl.drawElementsInstanced = (a, b, c, d, e) => instanceExt.drawElementsInstancedANGLE(a, b, c, d, e), gl.drawArraysInstanced = (a, b, c, d) => instanceExt.drawArraysInstancedANGLE(a, b, c, d)) : this.hasInstance = !1;
      }
      this.canUseUInt32ElementIndex = 2 === context.webGLVersion || !!context.extensions.uint32ElementIndex;
    }
    bind(geometry, shader) {
      shader = shader || this.renderer.shader.shader;
      const {gl} = this;
      var vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID];
      let incRefCount = !1;
      vaos || (this.managedGeometries[geometry.id] = geometry, geometry.disposeRunner.add(this), geometry.glVertexArrayObjects[this.CONTEXT_UID] = vaos = {}, incRefCount = !0);
      vaos = vaos[shader.program.id] || this.initGeometryVao(geometry, shader, incRefCount);
      this._activeGeometry = geometry;
      this._activeVao !== vaos && (this._activeVao = vaos, this.hasVao ? gl.bindVertexArray(vaos) : this.activateVao(geometry, shader.program));
      this.updateBuffers();
    }
    reset() {
      this.unbind();
    }
    updateBuffers() {
      const geometry = this._activeGeometry, bufferSystem = this.renderer.buffer;
      for (let i = 0; i < geometry.buffers.length; i++) {
        bufferSystem.update(geometry.buffers[i]);
      }
    }
    checkCompatibility(geometry, program) {
      geometry = geometry.attributes;
      program = program.attributeData;
      for (const j in program) {
        if (!geometry[j]) {
          throw Error(`shader and geometry incompatible, geometry missing the "${j}" attribute`);
        }
      }
    }
    getSignature(geometry, program) {
      const attribs = geometry.attributes;
      program = program.attributeData;
      geometry = ["g", geometry.id];
      for (const i in attribs) {
        program[i] && geometry.push(i, program[i].location);
      }
      return geometry.join("-");
    }
    initGeometryVao(geometry, shader, incRefCount = !0) {
      const gl = this.gl, CONTEXT_UID = this.CONTEXT_UID, bufferSystem = this.renderer.buffer, program = shader.program;
      program.glPrograms[CONTEXT_UID] || this.renderer.shader.generateProgram(shader);
      this.checkCompatibility(geometry, program);
      shader = this.getSignature(geometry, program);
      const vaoObjectHash = geometry.glVertexArrayObjects[this.CONTEXT_UID];
      var vao = vaoObjectHash[shader];
      if (vao) {
        return vaoObjectHash[program.id] = vao, vao;
      }
      const buffers = geometry.buffers;
      vao = geometry.attributes;
      var tempStride = {};
      const tempStart = {};
      for (var j in buffers) {
        tempStride[j] = 0, tempStart[j] = 0;
      }
      for (var j$jscomp$0 in vao) {
        !vao[j$jscomp$0].size && program.attributeData[j$jscomp$0] ? vao[j$jscomp$0].size = program.attributeData[j$jscomp$0].size : vao[j$jscomp$0].size || console.warn(`PIXI Geometry attribute '${j$jscomp$0}' size cannot be determined (likely the bound shader does not have the attribute)`), tempStride[vao[j$jscomp$0].buffer] += vao[j$jscomp$0].size * byteSizeMap[vao[j$jscomp$0].type];
      }
      for (var j$jscomp$1 in vao) {
        j = vao[j$jscomp$1], j$jscomp$0 = j.size, void 0 === j.stride && (tempStride[j.buffer] === j$jscomp$0 * byteSizeMap[j.type] ? j.stride = 0 : j.stride = tempStride[j.buffer]), void 0 === j.start && (j.start = tempStart[j.buffer], tempStart[j.buffer] += j$jscomp$0 * byteSizeMap[j.type]);
      }
      vao = gl.createVertexArray();
      gl.bindVertexArray(vao);
      for (j$jscomp$1 = 0; j$jscomp$1 < buffers.length; j$jscomp$1++) {
        tempStride = buffers[j$jscomp$1], bufferSystem.bind(tempStride), incRefCount && tempStride._glBuffers[CONTEXT_UID].refCount++;
      }
      return this.activateVao(geometry, program), vaoObjectHash[program.id] = vao, vaoObjectHash[shader] = vao, gl.bindVertexArray(null), bufferSystem.unbind(constants.BUFFER_TYPE.ARRAY_BUFFER), vao;
    }
    disposeGeometry(geometry, contextLost) {
      if (this.managedGeometries[geometry.id]) {
        delete this.managedGeometries[geometry.id];
        var vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID], gl = this.gl, buffers = geometry.buffers, bufferSystem = this.renderer?.buffer;
        if (geometry.disposeRunner.remove(this), vaos) {
          if (bufferSystem) {
            for (let i = 0; i < buffers.length; i++) {
              const buf = buffers[i]._glBuffers[this.CONTEXT_UID];
              buf && (buf.refCount--, 0 === buf.refCount && !contextLost && bufferSystem.dispose(buffers[i], contextLost));
            }
          }
          if (!contextLost) {
            for (const vaoId in vaos) {
              "g" === vaoId[0] && (contextLost = vaos[vaoId], this._activeVao === contextLost && this.unbind(), gl.deleteVertexArray(contextLost));
            }
          }
          delete geometry.glVertexArrayObjects[this.CONTEXT_UID];
        }
      }
    }
    disposeAll(contextLost) {
      const all = Object.keys(this.managedGeometries);
      for (let i = 0; i < all.length; i++) {
        this.disposeGeometry(this.managedGeometries[all[i]], contextLost);
      }
    }
    activateVao(geometry, program) {
      const gl = this.gl, CONTEXT_UID = this.CONTEXT_UID, bufferSystem = this.renderer.buffer, buffers = geometry.buffers, attributes = geometry.attributes;
      geometry.indexBuffer && bufferSystem.bind(geometry.indexBuffer);
      geometry = null;
      for (const j in attributes) {
        const attribute = attributes[j];
        var buffer = buffers[attribute.buffer];
        const glBuffer = buffer._glBuffers[CONTEXT_UID];
        if (program.attributeData[j] && (geometry !== glBuffer && (bufferSystem.bind(buffer), geometry = glBuffer), buffer = program.attributeData[j].location, gl.enableVertexAttribArray(buffer), gl.vertexAttribPointer(buffer, attribute.size, attribute.type || gl.FLOAT, attribute.normalized, attribute.stride, attribute.start), attribute.instance)) {
          if (this.hasInstance) {
            gl.vertexAttribDivisor(buffer, attribute.divisor);
          } else {
            throw Error("geometry error, GPU Instancing is not supported on this device");
          }
        }
      }
    }
    draw(type, size, start, instanceCount) {
      const {gl} = this, geometry = this._activeGeometry;
      if (geometry.indexBuffer) {
        const byteSize = geometry.indexBuffer.data.BYTES_PER_ELEMENT, glType = 2 === byteSize ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;
        2 === byteSize || 4 === byteSize && this.canUseUInt32ElementIndex ? geometry.instanced ? gl.drawElementsInstanced(type, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize, instanceCount || 1) : gl.drawElements(type, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize) : console.warn("unsupported index buffer type: uint32");
      } else {
        geometry.instanced ? gl.drawArraysInstanced(type, start, size || geometry.getSize(), instanceCount || 1) : gl.drawArrays(type, start, size || geometry.getSize());
      }
      return this;
    }
    unbind() {
      this.gl.bindVertexArray(null);
      this._activeGeometry = this._activeVao = null;
    }
    destroy() {
      this.renderer = null;
    }
  }
  GeometrySystem.extension = {type:global.ExtensionType.RendererSystem, name:"geometry"};
  global.extensions.add(GeometrySystem);
  exports.GeometrySystem = GeometrySystem;
};

//# sourceMappingURL=module$node_modules$$pixi$core$lib$geometry$GeometrySystem.js.map
