shadow$provide.module$node_modules$pixi_DOT_js$lib$scene$graphics$shared$path$ShapePath = function(global, require, module, exports) {
  var Circle = require("module$node_modules$pixi_DOT_js$lib$maths$shapes$Circle"), Ellipse = require("module$node_modules$pixi_DOT_js$lib$maths$shapes$Ellipse"), Polygon = require("module$node_modules$pixi_DOT_js$lib$maths$shapes$Polygon"), Rectangle = require("module$node_modules$pixi_DOT_js$lib$maths$shapes$Rectangle"), RoundedRectangle = require("module$node_modules$pixi_DOT_js$lib$maths$shapes$RoundedRectangle"), Bounds = require("module$node_modules$pixi_DOT_js$lib$scene$container$bounds$Bounds"), 
  buildAdaptiveBezier = require("module$node_modules$pixi_DOT_js$lib$scene$graphics$shared$buildCommands$buildAdaptiveBezier"), buildAdaptiveQuadratic = require("module$node_modules$pixi_DOT_js$lib$scene$graphics$shared$buildCommands$buildAdaptiveQuadratic"), buildArc = require("module$node_modules$pixi_DOT_js$lib$scene$graphics$shared$buildCommands$buildArc"), buildArcTo = require("module$node_modules$pixi_DOT_js$lib$scene$graphics$shared$buildCommands$buildArcTo"), buildArcToSvg = require("module$node_modules$pixi_DOT_js$lib$scene$graphics$shared$buildCommands$buildArcToSvg"), 
  roundShape = require("module$node_modules$pixi_DOT_js$lib$scene$graphics$shared$path$roundShape");
  "use strict";
  const tempRectangle = new Rectangle.Rectangle();
  class ShapePath {
    constructor(graphicsPath2D) {
      this.shapePrimitives = [];
      this._currentPoly = null;
      this._bounds = new Bounds.Bounds();
      this._graphicsPath2D = graphicsPath2D;
      this.signed = graphicsPath2D.checkForHoles;
    }
    moveTo(x, y) {
      this.startPoly(x, y);
      return this;
    }
    lineTo(x, y) {
      this._ensurePoly();
      const points = this._currentPoly.points, fromY = points[points.length - 1];
      points[points.length - 2] === x && fromY === y || points.push(x, y);
      return this;
    }
    arc(x, y, radius, startAngle, endAngle, counterclockwise) {
      this._ensurePoly(!1);
      buildArc.buildArc(this._currentPoly.points, x, y, radius, startAngle, endAngle, counterclockwise);
      return this;
    }
    arcTo(x1, y1, x2, y2, radius) {
      this._ensurePoly();
      buildArcTo.buildArcTo(this._currentPoly.points, x1, y1, x2, y2, radius);
      return this;
    }
    arcToSvg(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y) {
      buildArcToSvg.buildArcToSvg(this._currentPoly.points, this._currentPoly.lastX, this._currentPoly.lastY, x, y, rx, ry, xAxisRotation, largeArcFlag, sweepFlag);
      return this;
    }
    bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y, smoothness) {
      this._ensurePoly();
      const currentPoly = this._currentPoly;
      buildAdaptiveBezier.buildAdaptiveBezier(this._currentPoly.points, currentPoly.lastX, currentPoly.lastY, cp1x, cp1y, cp2x, cp2y, x, y, smoothness);
      return this;
    }
    quadraticCurveTo(cp1x, cp1y, x, y, smoothing) {
      this._ensurePoly();
      const currentPoly = this._currentPoly;
      buildAdaptiveQuadratic.buildAdaptiveQuadratic(this._currentPoly.points, currentPoly.lastX, currentPoly.lastY, cp1x, cp1y, x, y, smoothing);
      return this;
    }
    closePath() {
      this.endPoly(!0);
      return this;
    }
    addPath(path, transform) {
      this.endPoly();
      transform && !transform.isIdentity() && (path = path.clone(!0), path.transform(transform));
      transform = this.shapePrimitives;
      var start = transform.length;
      for (var i = 0; i < path.instructions.length; i++) {
        var instruction = path.instructions[i];
        this[instruction.action](...instruction.data);
      }
      if (path.checkForHoles && 1 < transform.length - start) {
        for (path = null; start < transform.length; start++) {
          if (i = transform[start], "polygon" === i.shape.type) {
            instruction = i.shape;
            const mainPolygon = path?.shape;
            mainPolygon && mainPolygon.containsPolygon(instruction) ? (path.holes || (path.holes = []), path.holes.push(i), transform.copyWithin(start, start + 1), transform.length--, start--) : path = i;
          }
        }
      }
      return this;
    }
    finish(closePath = !1) {
      this.endPoly(closePath);
    }
    rect(x, y, w, h, transform) {
      this.drawShape(new Rectangle.Rectangle(x, y, w, h), transform);
      return this;
    }
    circle(x, y, radius, transform) {
      this.drawShape(new Circle.Circle(x, y, radius), transform);
      return this;
    }
    poly(points, close, transform) {
      points = new Polygon.Polygon(points);
      points.closePath = close;
      this.drawShape(points, transform);
      return this;
    }
    regularPoly(x, y, radius, sides, rotation = 0, transform) {
      sides = Math.max(sides | 0, 3);
      rotation = -1 * Math.PI / 2 + rotation;
      const delta = 2 * Math.PI / sides, polygon = [];
      for (let i = 0; i < sides; i++) {
        const angle = rotation - i * delta;
        polygon.push(x + radius * Math.cos(angle), y + radius * Math.sin(angle));
      }
      this.poly(polygon, !0, transform);
      return this;
    }
    roundPoly(x, y, radius, sides, corner, rotation = 0, smoothness) {
      sides = Math.max(sides | 0, 3);
      if (0 >= corner) {
        return this.regularPoly(x, y, radius, sides, rotation);
      }
      corner = Math.min(corner, radius * Math.sin(Math.PI / sides) - 1e-3);
      rotation = -1 * Math.PI / 2 + rotation;
      const delta = 2 * Math.PI / sides, internalAngle = (sides - 2) * Math.PI / sides / 2;
      for (let i = 0; i < sides; i++) {
        var angle = i * delta + rotation;
        const x0 = x + radius * Math.cos(angle), y0 = y + radius * Math.sin(angle);
        var a1 = angle + Math.PI + internalAngle, a2 = angle - Math.PI - internalAngle;
        angle = x0 + corner * Math.cos(a1);
        a1 = y0 + corner * Math.sin(a1);
        const x3 = x0 + corner * Math.cos(a2);
        a2 = y0 + corner * Math.sin(a2);
        0 === i ? this.moveTo(angle, a1) : this.lineTo(angle, a1);
        this.quadraticCurveTo(x0, y0, x3, a2, smoothness);
      }
      return this.closePath();
    }
    roundShape(points, radius, useQuadratic = !1, smoothness) {
      if (3 > points.length) {
        return this;
      }
      useQuadratic ? roundShape.roundedShapeQuadraticCurve(this, points, radius, smoothness) : roundShape.roundedShapeArc(this, points, radius);
      return this.closePath();
    }
    filletRect(x, y, width, height, fillet) {
      if (0 === fillet) {
        return this.rect(x, y, width, height);
      }
      var maxFillet = Math.min(width, height) / 2;
      maxFillet = Math.min(maxFillet, Math.max(-maxFillet, fillet));
      fillet = x + width;
      height = y + height;
      const dir = 0 > maxFillet ? -maxFillet : 0;
      maxFillet = Math.abs(maxFillet);
      return this.moveTo(x, y + maxFillet).arcTo(x + dir, y + dir, x + maxFillet, y, maxFillet).lineTo(fillet - maxFillet, y).arcTo(fillet - dir, y + dir, fillet, y + maxFillet, maxFillet).lineTo(fillet, height - maxFillet).arcTo(fillet - dir, height - dir, x + width - maxFillet, height, maxFillet).lineTo(x + maxFillet, height).arcTo(x + dir, height - dir, x, height - maxFillet, maxFillet).closePath();
    }
    chamferRect(x, y, width, height, chamfer, transform) {
      if (0 >= chamfer) {
        return this.rect(x, y, width, height);
      }
      chamfer = Math.min(chamfer, Math.min(width, height) / 2);
      width = x + width;
      height = y + height;
      x = [x + chamfer, y, width - chamfer, y, width, y + chamfer, width, height - chamfer, width - chamfer, height, x + chamfer, height, x, height - chamfer, x, y + chamfer];
      for (y = x.length - 1; 2 <= y; y -= 2) {
        x[y] === x[y - 2] && x[y - 1] === x[y - 3] && x.splice(y - 1, 2);
      }
      return this.poly(x, !0, transform);
    }
    ellipse(x, y, radiusX, radiusY, transform) {
      this.drawShape(new Ellipse.Ellipse(x, y, radiusX, radiusY), transform);
      return this;
    }
    roundRect(x, y, w, h, radius, transform) {
      this.drawShape(new RoundedRectangle.RoundedRectangle(x, y, w, h, radius), transform);
      return this;
    }
    drawShape(shape, matrix) {
      this.endPoly();
      this.shapePrimitives.push({shape, transform:matrix});
      return this;
    }
    startPoly(x, y) {
      let currentPoly = this._currentPoly;
      currentPoly && this.endPoly();
      currentPoly = new Polygon.Polygon();
      currentPoly.points.push(x, y);
      this._currentPoly = currentPoly;
      return this;
    }
    endPoly(closePath = !1) {
      const shape = this._currentPoly;
      shape && 2 < shape.points.length && (shape.closePath = closePath, this.shapePrimitives.push({shape}));
      this._currentPoly = null;
      return this;
    }
    _ensurePoly(start = !0) {
      if (!this._currentPoly && (this._currentPoly = new Polygon.Polygon(), start)) {
        var lastShape = this.shapePrimitives[this.shapePrimitives.length - 1];
        if (lastShape) {
          start = lastShape.shape.x;
          let ly = lastShape.shape.y;
          if (lastShape.transform && !lastShape.transform.isIdentity()) {
            lastShape = lastShape.transform;
            const tempX = start;
            start = lastShape.a * start + lastShape.c * ly + lastShape.tx;
            ly = lastShape.b * tempX + lastShape.d * ly + lastShape.ty;
          }
          this._currentPoly.points.push(start, ly);
        } else {
          this._currentPoly.points.push(0, 0);
        }
      }
    }
    buildPath() {
      const path = this._graphicsPath2D;
      this.shapePrimitives.length = 0;
      this._currentPoly = null;
      for (let i = 0; i < path.instructions.length; i++) {
        const instruction = path.instructions[i];
        this[instruction.action](...instruction.data);
      }
      this.finish();
    }
    get bounds() {
      const bounds = this._bounds;
      bounds.clear();
      const shapePrimitives = this.shapePrimitives;
      for (let i = 0; i < shapePrimitives.length; i++) {
        const shapePrimitive = shapePrimitives[i], boundsRect = shapePrimitive.shape.getBounds(tempRectangle);
        shapePrimitive.transform ? bounds.addRect(boundsRect, shapePrimitive.transform) : bounds.addRect(boundsRect);
      }
      return bounds;
    }
  }
  exports.ShapePath = ShapePath;
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$scene$graphics$shared$path$ShapePath.js.map
