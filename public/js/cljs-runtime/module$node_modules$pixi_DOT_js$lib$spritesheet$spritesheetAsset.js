shadow$provide.module$node_modules$pixi_DOT_js$lib$spritesheet$spritesheetAsset = function(global, require, module, exports) {
  function getCacheableAssets(keys, asset, ignoreMultiPack) {
    const out = {};
    keys.forEach(key => {
      out[key] = asset;
    });
    Object.keys(asset.textures).forEach(key => {
      out[key] = asset.textures[key];
    });
    if (!ignoreMultiPack) {
      const basePath = path.path.dirname(keys[0]);
      asset.linkedSheets.forEach((item, i) => {
        item = getCacheableAssets([`${basePath}/${asset.data.meta.related_multi_packs[i]}`], item, !0);
        Object.assign(out, item);
      });
    }
    return out;
  }
  global = require("module$node_modules$pixi_DOT_js$lib$assets$loader$parsers$LoaderParser");
  var Resolver = require("module$node_modules$pixi_DOT_js$lib$assets$resolver$Resolver"), copySearchParams = require("module$node_modules$pixi_DOT_js$lib$assets$utils$copySearchParams");
  module = require("module$node_modules$pixi_DOT_js$lib$extensions$Extensions");
  var Texture = require("module$node_modules$pixi_DOT_js$lib$rendering$renderers$shared$texture$Texture"), path = require("module$node_modules$pixi_DOT_js$lib$utils$path"), Spritesheet = require("module$node_modules$pixi_DOT_js$lib$spritesheet$Spritesheet");
  "use strict";
  const validImages = "jpg png jpeg avif webp basis etc2 bc7 bc6h bc5 bc4 bc3 bc2 bc1 eac astc".split(" ");
  exports.spritesheetAsset = {extension:module.ExtensionType.Asset, cache:{test:asset => asset instanceof Spritesheet.Spritesheet, getCacheableAssets:(keys, asset) => getCacheableAssets(keys, asset, !1)}, resolver:{extension:{type:module.ExtensionType.ResolveParser, name:"resolveSpritesheet"}, test:value => {
    var split = value.split("?")[0].split(".");
    value = split.pop();
    split = split.pop();
    return "json" === value && validImages.includes(split);
  }, parse:value => {
    const split = value.split(".");
    return {resolution:parseFloat(Resolver.Resolver.RETINA_PREFIX.exec(value)?.[1] ?? "1"), format:split[split.length - 2], src:value};
  }}, loader:{name:"spritesheetLoader", extension:{type:module.ExtensionType.LoadParser, priority:global.LoaderParserPriority.Normal, name:"spritesheetLoader"}, async testParse(asset, options) {
    return ".json" === path.path.extname(options.src).toLowerCase() && !!asset.frames;
  }, async parse(asset, options, loader) {
    const {texture:imageTexture, imageFilename, textureOptions} = options?.data ?? {};
    let basePath = path.path.dirname(options.src);
    basePath && basePath.lastIndexOf("/") !== basePath.length - 1 && (basePath += "/");
    if (imageTexture instanceof Texture.Texture) {
      var texture = imageTexture;
    } else {
      texture = copySearchParams.copySearchParams(basePath + (imageFilename ?? asset.meta.image), options.src), texture = (await loader.load([{src:texture, data:textureOptions}]))[texture];
    }
    const spritesheet = new Spritesheet.Spritesheet(texture.source, asset);
    await spritesheet.parse();
    texture = asset?.meta?.related_multi_packs;
    if (Array.isArray(texture)) {
      asset = [];
      for (const item of texture) {
        "string" === typeof item && (texture = basePath + item, options.data?.ignoreMultiPack || (texture = copySearchParams.copySearchParams(texture, options.src), asset.push(loader.load({src:texture, data:{textureOptions, ignoreMultiPack:!0}}))));
      }
      options = await Promise.all(asset);
      spritesheet.linkedSheets = options;
      options.forEach(item => {
        item.linkedSheets = [spritesheet].concat(spritesheet.linkedSheets.filter(sp => sp !== item));
      });
    }
    return spritesheet;
  }, async unload(spritesheet, _resolvedAsset, loader) {
    await loader.unload(spritesheet.textureSource._sourceOrigin);
    spritesheet.destroy(!1);
  }}};
};

//# sourceMappingURL=module$node_modules$pixi_DOT_js$lib$spritesheet$spritesheetAsset.js.map
